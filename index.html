<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¦¬ë³¼ë²„ ë“€ì–¼</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #0f0f1e;
            color: #fff;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #0f0f1e;
        }


        #augmentModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #e94560;
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        #augmentModal h2 {
            color: #e94560;
            margin-bottom: 20px;
        }

        #augmentViewModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        #augmentViewModal h2 {
            color: #4a9eff;
            margin-bottom: 20px;
        }

        .augment-option {
            background: rgba(233, 69, 96, 0.2);
            border: 2px solid #e94560;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .augment-option:hover {
            background: rgba(233, 69, 96, 0.4);
            transform: scale(1.05);
        }

        .augment-option h4 {
            color: #ffc107;
            margin-bottom: 5px;
        }

        #gameOverModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #ffc107;
            border-radius: 15px;
            padding: 40px;
            z-index: 1001;
            text-align: center;
        }

        #gameOverModal h2 {
            color: #ffc107;
            font-size: 32px;
            margin-bottom: 20px;
        }

        #collectionModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 3000;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
            pointer-events: auto;
        }

        #collectionModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        #roomModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 50px;
            padding-bottom: 100px;
            z-index: 3002;
            max-width: 625px;
            width: 90%;
            text-align: center;
            pointer-events: auto;
        }

        #roomModal h2 {
            color: #4a9eff;
            font-size: 40px;
            margin-bottom: 38px;
        }

        #controlsModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 3001;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        #controlsModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        #controlsModal .control-item {
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        #controlsModal .control-item h3 {
            color: #4a9eff;
            font-size: 20px;
            margin-bottom: 10px;
        }

        #controlsModal .control-item p {
            color: #ffffff;
            font-size: 16px;
            line-height: 1.6;
            margin: 5px 0;
        }

        #controlsModal .key {
            display: inline-block;
            padding: 5px 10px;
            background: rgba(74, 158, 255, 0.3);
            border: 1px solid #4a9eff;
            border-radius: 5px;
            font-weight: bold;
            margin: 0 5px;
        }

        .collection-item {
            background: rgba(74, 158, 255, 0.1);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            transition: all 0.3s;
            position: relative; /* ì„ íƒ íšŸìˆ˜ ìœ„ì¹˜ ì§€ì •ì„ ìœ„í•´ */
        }
        
        .collection-item .select-count {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(74, 158, 255, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .collection-item.locked {
            background: rgba(100, 100, 100, 0.1);
            border-color: #666;
            filter: grayscale(100%);
            opacity: 0.5;
        }

        .collection-item h4 {
            color: #4a9eff;
            margin-bottom: 8px;
            font-size: 20px;
        }

        .collection-item.locked h4 {
            color: #666;
        }

        .collection-item p {
            color: #ccc;
            margin: 0;
            font-size: 16px;
        }

        .collection-item.locked p {
            color: #888;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s;
        }

        button:hover {
            background: #c7364d;
        }

        /* ì œí™” í‘œì‹œ ë„¤ì˜¨ ë§ˆë¦„ëª¨ ìŠ¤íƒ€ì¼ - ë§ˆë¦„ëª¨ (ì •ì‚¬ê°í˜• 45ë„ íšŒì „) */
        .neon-diamond {
            width: 16.875px;
            height: 16.875px;
            position: relative;
            /* ë¾°ì¡±í•œ ë¶€ë¶„ì´ ìœ„ë¡œ ê°€ë„ë¡ 45ë„ íšŒì „ */
            transform: rotate(45deg);
            border: 3px solid #fff;
            background: transparent;
            box-shadow: 
                0 0 10px rgba(255, 255, 255, 0.5),
                0 0 20px rgba(255, 255, 255, 0.4),
                0 0 30px rgba(255, 255, 255, 0.3);
        }
        
        .kill-number {
            font-size: 24px;
            color: #fff;
            text-shadow: 
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 20px rgba(255, 255, 255, 0.6);
            font-weight: bold;
        }

        #killCountInfo {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
            line-height: 1.4;
            white-space: normal;
            max-width: 200px;
            transition: opacity 0.3s;
        }

        .achievement-icon:hover::after {
            opacity: 1;
        }

        /* í™”ë©´ ì „í™˜ ìŠ¤íƒ€ì¼ */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 30, 0.95);
            display: none;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 40px;
            padding-top: 60px;
            z-index: 2000;
        }

        .screen.active {
            display: flex;
        }


        .screen h1 {
            font-size: 100px;
            color: #e94560;
            margin-bottom: 25px;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }

        .screen h2 {
            font-size: 48px;
            color: #4a9eff;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(74, 158, 255, 0.5);
        }

        .back-button {
            font-size: 32px;
            color: #fff;
            cursor: pointer;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            transition: all 0.3s;
        }

        .back-button:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
            transform: scale(1.05);
        }

        #mainMenu h1 {
            font-size: 100px;
            color: #e94560;
            margin-bottom: 25px;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            animation: neonFlicker 1.67s ease-in-out;
            animation-fill-mode: forwards;
            opacity: 0;
        }

        @keyframes neonFlicker {
            0% {
                opacity: 0;
                text-shadow: 0 0 5px rgba(233, 69, 96, 0.2);
            }
            20% {
                opacity: 0.3;
                text-shadow: 0 0 10px rgba(233, 69, 96, 0.4);
            }
            40% {
                opacity: 0.1;
                text-shadow: 0 0 5px rgba(233, 69, 96, 0.2);
            }
            60% {
                opacity: 0.6;
                text-shadow: 0 0 18px rgba(233, 69, 96, 0.6);
            }
            80% {
                opacity: 0.3;
                text-shadow: 0 0 10px rgba(233, 69, 96, 0.4);
            }
            100% {
                opacity: 1;
                text-shadow: 0 0 20px rgba(233, 69, 96, 0.5),
                            0 0 40px rgba(233, 69, 96, 0.5),
                            0 0 60px rgba(233, 69, 96, 0.3);
            }
        }

        @keyframes neonFlickerLocked {
            0% {
                opacity: 0;
                text-shadow: 0 0 5px rgba(136, 136, 136, 0.1);
            }
            20% {
                opacity: 0.2;
                text-shadow: 0 0 8px rgba(136, 136, 136, 0.2);
            }
            40% {
                opacity: 0.1;
                text-shadow: 0 0 5px rgba(136, 136, 136, 0.1);
            }
            60% {
                opacity: 0.4;
                text-shadow: 0 0 12px rgba(136, 136, 136, 0.3);
            }
            80% {
                opacity: 0.2;
                text-shadow: 0 0 8px rgba(136, 136, 136, 0.2);
            }
            100% {
                opacity: 0.6;
                text-shadow: 0 0 10px rgba(136, 136, 136, 0.3),
                            0 0 20px rgba(136, 136, 136, 0.2),
                            0 0 30px rgba(136, 136, 136, 0.1);
            }
        }

        #soloPlayText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            margin-left: 12px;
            display: block;
            margin-top: 15px;
        }

        #soloPlayText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #multiPlayText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        #multiPlayText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #multiModeSelection {
            max-height: 0;
            opacity: 0;
            overflow: visible;
            margin-top: 0;
            margin-left: 12px;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
            pointer-events: none;
        }

        #multiModeSelection.expanded {
            max-height: 200px;
            opacity: 1;
            margin-top: 10px;
            pointer-events: auto;
        }

        #settingsText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        #settingsText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #storageText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        #storageText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #achievementText {
            font-size: 42px;
            color: #666;
            cursor: not-allowed;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(136, 136, 136, 0.3),
                        0 0 20px rgba(136, 136, 136, 0.2),
                        0 0 30px rgba(136, 136, 136, 0.1),
                        0 0 40px rgba(136, 136, 136, 0.05);
            transition: all 0.3s;
            opacity: 0.5;
            filter: grayscale(100%);
        }

        #achievementText:hover {
            color: #666;
            text-shadow: 0 0 10px rgba(136, 136, 136, 0.3),
                        0 0 20px rgba(136, 136, 136, 0.2),
                        0 0 30px rgba(136, 136, 136, 0.1),
                        0 0 40px rgba(136, 136, 136, 0.05);
            transform: none;
        }

        #shopModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #ffc107;
            border-radius: 15px;
            padding: 30px;
            z-index: 3001;
            max-width: 1100px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        #shopModal h2 {
            color: #ffc107;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        .shop-item {
            background: rgba(255, 193, 7, 0.1);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 22px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            min-height: 225px; /* ê°€ë¡œ,ì„¸ë¡œ 10% ê°ì†Œ */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .shop-item:hover {
            transform: scale(1.02);
        }
        
        .shop-item.rarity-common {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #ffffff;
        }
        
        .shop-item.rarity-rare {
            background: rgba(74, 158, 255, 0.1);
            border: 2px solid #4a9eff;
        }
        
        .shop-item.rarity-epic {
            background: rgba(136, 0, 255, 0.1);
            border: 2px solid #8800ff;
        }
        
        .rarity-icon {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 20px;
            height: 20px;
            z-index: 10;
        }
        
        .rarity-icon.triangle {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 17px solid;
            background: transparent;
        }
        
        .rarity-icon.triangle.common {
            border-bottom-color: #ffffff;
        }
        
        .rarity-icon.square {
            width: 17px;
            height: 17px;
            background: #4a9eff;
        }
        
        .rarity-icon.pentagon {
            width: 17px;
            height: 17px;
            background: #8800ff;
            clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
        }


        .shop-item h4 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 22px;
        }
        
        .shop-item.rarity-common h4 {
            color: #ffffff;
        }
        
        .shop-item.rarity-rare h4 {
            color: #ffffff;
        }
        
        .shop-item.rarity-epic h4 {
            color: #ffffff;
        }

        .shop-item p {
            color: #ffffff;
            font-size: 15px;
            margin: 5px 0;
            font-size: 14px;
        }
        
        .shop-item.rarity-common p {
            color: #ffffff;
        }
        
        .shop-item.rarity-rare p {
            color: #ffffff;
        }
        
        .shop-item.rarity-epic p {
            color: #ffffff;
        }

        .shop-item-price {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            margin-top: 10px;
        }

        .shop-item.owned {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #storageModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 3001;
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        #storageModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        .storage-item {
            background: rgba(74, 158, 255, 0.1);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        
        .storage-item.rarity-common {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #ffffff;
        }
        
        .storage-item.rarity-rare {
            background: rgba(74, 158, 255, 0.1);
            border: 2px solid #4a9eff;
        }
        
        .storage-item.rarity-epic {
            background: rgba(136, 0, 255, 0.1);
            border: 2px solid #8800ff;
        }
        
        
        .storage-item .selected-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ffc107;
            color: #000;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            display: none;
        }
        
        .storage-item.selected .selected-badge {
            display: block;
        }

        .storage-item h4 {
            color: #4a9eff;
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        .storage-item.rarity-common h4 {
            color: #ffffff;
        }
        
        .storage-item.rarity-rare h4 {
            color: #ffffff;
        }
        
        .storage-item.rarity-epic h4 {
            color: #ffffff;
        }

        .storage-item p {
            color: #ffffff;
            margin: 5px 0;
            font-size: 14px;
        }

        .menu-text {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            margin-left: 12px;
            display: block;
            margin-top: 15px;
        }

        .menu-text:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        .menu-button {
            background: rgba(233, 69, 96, 0.3);
            border: 3px solid #e94560;
            color: #fff;
            padding: 20px 50px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            margin: 15px;
            transition: all 0.3s;
            min-width: 250px;
        }

        .menu-button:hover {
            background: rgba(233, 69, 96, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.7);
        }

        .menu-button:active {
            transform: scale(1.05);
        }

        #controlsInfo {
            margin-top: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            text-align: center;
            max-width: 600px;
        }

        #controlsInfo h3 {
            color: #4a9eff;
            margin-bottom: 15px;
        }

        #controlsInfo p {
            margin: 8px 0;
            color: #ccc;
        }

        #modeSelection {
            max-height: 0;
            opacity: 0;
            overflow: visible;
            margin-top: 0;
            margin-left: 12px;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
            pointer-events: none;
        }

        #modeSelection.expanded {
            max-height: 200px;
            opacity: 1;
            margin-top: 10px;
            pointer-events: auto;
        }

        .mode-option {
            font-size: 32px;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2),
                        0 0 20px rgba(255, 255, 255, 0.15),
                        0 0 30px rgba(255, 255, 255, 0.1),
                        0 0 40px rgba(255, 255, 255, 0.05);
            margin-top: 8px;
            margin-left: 0;
            display: block;
        }

        .mode-option:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        .menu-text.moved-down {
            margin-top: 120px;
        }

        #multiPlayText.moved-down {
            margin-top: 20px;
            transition: margin-top 0.3s ease;
        }

        #collectionText.moved-down {
            margin-top: 20px;
            transition: margin-top 0.3s ease;
        }

        #settingsText.moved-down {
            margin-top: 120px;
        }

        #randomModeDisplay {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 28px;
            z-index: 100;
            cursor: pointer;
            transition: all 0.3s;
            max-width: 200px;
        }

        #randomModeDisplay::before,
        #randomModeDisplay::after {
            display: none;
        }

        #randomModeDisplay:hover {
            background: transparent;
        }

        #randomModeName {
            display: block;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        #randomModeTooltip {
            position: absolute;
            bottom: 100%;
            right: 0;
            margin-bottom: 10px;
            background: rgba(15, 15, 30, 0.95);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 10px 15px;
            color: #fff;
            font-size: 14px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #randomModeDisplay:hover #randomModeTooltip {
            opacity: 1;
        }


    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="augmentModal">
            <h2>ì¦ê°• ì„ íƒ</h2>
            <p style="margin-bottom: 20px;">íŒ¨ë°°í•˜ì…¨ìŠµë‹ˆë‹¤. ì¦ê°•ì„ ì„ íƒí•˜ì„¸ìš”:</p>
            <div id="enemySelection" style="margin-bottom: 20px; padding: 10px; background: rgba(233, 69, 96, 0.2); border-radius: 5px; display: none;">
                <p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>
            </div>
            <div id="augmentOptions"></div>
        </div>

        <div id="augmentViewModal">
            <h2>ì¦ê°• í™•ì¸</h2>
            <p style="margin-bottom: 20px;">ìŠ¹ë¦¬í•˜ì…¨ìŠµë‹ˆë‹¤! ìƒëŒ€ì˜ ì¦ê°• ì„ íƒì„ í™•ì¸í•˜ì„¸ìš”:</p>
            <div id="opponentSelection" style="margin-bottom: 20px; padding: 10px; background: rgba(233, 69, 96, 0.2); border-radius: 5px;">
                <p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>
            </div>
            <button onclick="closeAugmentViewModal()" style="margin-top: 20px;">í™•ì¸</button>
        </div>

        <div id="gameOverModal">
            <h2 id="gameOverTitle">ê²Œì„ ì¢…ë£Œ</h2>
            <p id="gameOverMessage" style="font-size: 20px; margin-bottom: 20px;"></p>
            <button onclick="restartGame()">ë©”ì¸ë©”ë‰´ë¡œ</button>
        </div>


        <div id="roomModal">
            <h2 id="roomModalTitle">ë°© ìƒì„±</h2>
            
            <!-- ë°© ì½”ë“œ í‘œì‹œ (í˜¸ìŠ¤íŠ¸ìš©, ì—°ê²° ì „) -->
            <div id="roomCodeSection" style="display: none;">
                <p style="margin-bottom: 13px;">ë°© ì½”ë“œ:</p>
                <div id="roomCode" style="font-size: 60px; color: #ffc107; text-shadow: 0 0 20px rgba(255, 193, 7, 0.5); letter-spacing: 13px; margin: 25px 0;"></div>
                <p style="color: #aaa; font-size: 18px;">ìƒëŒ€ë°©ì—ê²Œ ì´ ì½”ë“œë¥¼ ì•Œë ¤ì£¼ì„¸ìš”</p>
                <p id="waitingMessage" style="color: #4a9eff; margin-top: 25px;">ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</p>
            </div>
            
            <!-- ë°© ì½”ë“œ ì…ë ¥ (ê²ŒìŠ¤íŠ¸ìš©, ì—°ê²° ì „) -->
            <div id="roomJoinInput" style="display: none;">
                <p style="margin-bottom: 13px;">ë°© ì½”ë“œ ì…ë ¥:</p>
                <input type="text" id="joinCodeInput" maxlength="5" placeholder="12345" style="
                    font-size: 45px;
                    text-align: center;
                    letter-spacing: 10px;
                    width: 250px;
                    padding: 19px;
                    border: 2px solid #4a9eff;
                    border-radius: 10px;
                    background: rgba(0, 0, 0, 0.3);
                    color: #fff;
                    outline: none;
                ">
                <p id="joinErrorMessage" style="color: #e94560; margin-top: 13px; display: none;">ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</p>
                <button id="joinRoomBtn" onclick="joinRoom()" style="margin-top: 25px; background: #4a9eff;">ì…ì¥</button>
            </div>
            
            <!-- íŒ€ ì„ íƒ UI (ì—°ê²° í›„) -->
            <div id="teamSelectUI" style="display: none;">
                <p style="margin-bottom: 25px; color: #aaa;">íŒ€ì„ ì„ íƒí•˜ì„¸ìš”</p>
                <div style="display: flex; justify-content: center; gap: 38px; margin: 25px 0;">
                    <!-- íŒŒë€íŒ€ -->
                    <div id="blueTeamBox" onclick="selectTeam('blue')" style="
                        width: 225px;
                        height: 150px;
                        background: rgba(74, 158, 255, 0.1);
                        border: 2px solid rgba(74, 158, 255, 0.4);
                        border-radius: 15px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: flex-start;
                        padding-top: 19px;
                        cursor: pointer;
                        transition: all 0.3s;
                    ">
                        <p style="color: #4a9eff; font-size: 23px; margin-bottom: 10px;">íŒŒë€íŒ€</p>
                        <p id="blueTeamPlayer" style="color: #fff; font-size: 20px; font-weight: bold;"></p>
                    </div>
                    <!-- ë¹¨ê°„íŒ€ -->
                    <div id="redTeamBox" onclick="selectTeam('red')" style="
                        width: 225px;
                        height: 150px;
                        background: rgba(233, 69, 96, 0.1);
                        border: 2px solid rgba(233, 69, 96, 0.4);
                        border-radius: 15px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: flex-start;
                        padding-top: 19px;
                        cursor: pointer;
                        transition: all 0.3s;
                    ">
                        <p style="color: #e94560; font-size: 23px; margin-bottom: 10px;">ë¹¨ê°„íŒ€</p>
                        <p id="redTeamPlayer" style="color: #fff; font-size: 20px; font-weight: bold;"></p>
                    </div>
                </div>
                <p id="teamSelectStatus" style="color: #aaa; margin-top: 13px;"></p>
                <p id="guestWaitingMessage" style="display: none; color: #4a9eff; margin-top: 19px;">í˜¸ìŠ¤íŠ¸ê°€ ê²Œì„ì„ ì‹œì‘í•˜ë©´ ì‹œì‘ë©ë‹ˆë‹¤...</p>
            </div>
            
            <!-- í•˜ë‹¨ ë²„íŠ¼ ì˜ì—­ -->
            <div style="position: absolute; bottom: 25px; left: 25px; right: 25px; display: flex; justify-content: space-between;">
                <button onclick="closeRoomModal()" style="background: #e94560; padding: 15px 38px; font-size: 20px;">ë‚˜ê°€ê¸°</button>
                <button id="startGameBtn" onclick="sendStartGame()" style="display: none; background: #00cc66; font-size: 23px; padding: 15px 38px;">ê²Œì„ ì‹œì‘</button>
            </div>
        </div>
        
        <div id="disconnectModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(15, 15, 30, 1); border: 3px solid #e94560; border-radius: 15px; padding: 40px; z-index: 4000; text-align: center;">
            <h2 style="color: #e94560; margin-bottom: 20px;">ì—°ê²° ëŠê¹€</h2>
            <p style="color: #fff; margin-bottom: 30px;">ìƒëŒ€ë°©ê³¼ì˜ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.</p>
            <button onclick="confirmDisconnect()" style="background: #4a9eff; padding: 15px 40px;">í™•ì¸</button>
        </div>
        
        <div id="nicknameModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(15, 15, 30, 1); border: 3px solid #ffc107; border-radius: 15px; padding: 50px; z-index: 5000; text-align: center; min-width: 400px;">
            <h2 style="color: #ffc107; margin-bottom: 15px; font-size: 28px;">ë¦¬ë³¼ë²„ ë“€ì–¼ì— ì˜¤ì‹ ê±¸ í™˜ì˜í•©ë‹ˆë‹¤</h2>
            <p style="color: #fff; margin-bottom: 30px; font-size: 18px;">í”Œë ˆì´ì–´ë‹˜ì˜ ë‹‰ë„¤ì„ì„ ì§€ì–´ì£¼ì„¸ìš”</p>
            <input type="text" id="nicknameInput" maxlength="12" placeholder="ë‹‰ë„¤ì„ ì…ë ¥" style="
                font-size: 24px;
                text-align: center;
                width: 280px;
                padding: 15px;
                border: 2px solid #ffc107;
                border-radius: 10px;
                background: rgba(0, 0, 0, 0.3);
                color: #fff;
                outline: none;
                margin-bottom: 20px;
            ">
            <br>
            <button onclick="saveNickname()" style="background: #ffc107; color: #000; padding: 15px 50px; font-size: 18px; font-weight: bold;">í™•ì¸</button>
        </div>
        


        <div id="mainMenu" class="screen active">
            <div id="nicknameDisplay" style="display: none; position: fixed; top: 25px; right: 30px; color: #fff; font-size: 24px; opacity: 0.7; z-index: 3000; flex-direction: column; align-items: flex-end;">
                <div id="killCountContainer" style="display: flex; align-items: center; gap: 15px;">
                    <div id="killCountDisplay" class="neon-diamond"></div>
                    <div class="kill-number" id="killCountNumber" style="min-width: fit-content;">0</div>
                    <span id="playerNickname" style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); white-space: nowrap;"></span>
                </div>
                <div id="killCountInfo" style="display: none; margin-top: 8px; font-size: 12px; color: rgba(255, 255, 255, 0.6); line-height: 1.4; white-space: normal; max-width: 250px; text-align: right;">
                    ì†”ë¡œ: ì´ê¸´ ë¼ìš´ë“œ ìˆ˜ (ìŠ¹ë¦¬ ì‹œ 2ë°°)<br>ë©€í‹°: ìŠ¹ë¦¬ 2ê°œ, íŒ¨ë°° 1ê°œ
                </div>
            </div>
            <h1>ë¦¬ë³¼ë²„ ë“€ì–¼</h1>
            <span id="soloPlayText" onclick="showModeSelection()">ì†”ë¡œ í”Œë ˆì´</span>
            <div id="modeSelection">
                <span class="mode-option" onclick="startSoloGame('classic')">- í´ë˜ì‹ ëª¨ë“œ</span>
                <span class="mode-option" onclick="startSoloGame('random')">- ëœë¤ ëª¨ë“œ</span>
            </div>
            <span id="multiPlayText" onclick="showMultiModeSelection()">ë©€í‹° í”Œë ˆì´</span>
            <div id="multiModeSelection">
                <span class="mode-option" onclick="createRoom()">- ë°© ìƒì„±</span>
                <span class="mode-option" onclick="showJoinRoom()">- ë°© ì…ì¥</span>
            </div>
            <span class="menu-text" id="collectionText" onclick="showScreen('collection')">ë„ê°</span>
            <span class="menu-text" id="settingsText" onclick="showScreen('shop')">ìƒì </span>
            <span class="menu-text" id="storageText" onclick="showScreen('storage')">ë³´ê´€ì†Œ</span>
            <span class="menu-text" id="achievementText">ğŸ”’ ì—…ì </span>
        </div>

        <!-- ë„ê° í™”ë©´ -->
        <div id="collectionScreen" class="screen">
            <div class="back-button" onclick="showScreen('main')">â† ë©”ì¸ ë©”ë‰´</div>
            <h2>ë„ê°</h2>
            <div id="collectionContent" style="max-height: 70vh; overflow-y: auto; padding: 10px; width: 100%;"></div>
        </div>

        <!-- ìƒì  í™”ë©´ -->
        <div id="shopScreen" class="screen">
            <div class="back-button" onclick="showScreen('main')">â† ë©”ì¸ ë©”ë‰´</div>
            <h2>ìƒì </h2>
            <div id="shopRefreshInfo" style="margin-bottom: 20px; color: #888; font-size: 14px;">
                <p>í• ì¸ìƒí’ˆì€ 6ì‹œê°„ë§ˆë‹¤ ìƒˆë¡œê³ ì¹¨ë©ë‹ˆë‹¤.</p>
                <p id="shopRefreshTime" style="margin-top: 5px; font-size: 18px; color: #ffc107; font-weight: bold; font-family: 'Courier New', monospace;">00:00:00</p>
            </div>
            <div id="shopItems" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; width: 100%; max-height: 70vh; overflow-y: auto; padding: 10px;">
                <!-- ìƒí’ˆì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
            </div>
        </div>

        <!-- ë³´ê´€ì†Œ í™”ë©´ -->
        <div id="storageScreen" class="screen">
            <div class="back-button" onclick="showScreen('main')">â† ë©”ì¸ ë©”ë‰´</div>
            <h2>ë³´ê´€ì†Œ</h2>
            <div id="storageItems" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-height: 70vh; overflow-y: auto; width: 100%;">
                <!-- ë³´ê´€ëœ ì•„ì´í…œì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
            </div>
        </div>

        <!-- ì—…ì  í™”ë©´ -->
        <div id="achievementScreen" class="screen">
            <div class="back-button" onclick="showScreen('main')">â† ë©”ì¸ ë©”ë‰´</div>
            <h2>ì—…ì </h2>
            <div id="achievementContent" style="max-height: 70vh; overflow-y: auto; padding: 10px; width: 100%;">
                <!-- ì—…ì ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
            </div>
        </div>

        <!-- ê²Œì„ í™”ë©´ (ê²Œì„ ì¤‘ì—ëŠ” ëª¨ë“  í™”ë©´ ìˆ¨ê¹€) -->
        <div id="gameScreen" class="screen" style="display: none !important;">
        </div>

        <div id="randomModeDisplay" style="display: none;">
            <div id="randomModeTooltip"></div>
            <span id="randomModeName"></span>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ í™”ë©´ ì „ì²´ë¡œ ì„¤ì •
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ë©”ì¸ ë©”ë‰´ ì™¸ë¶€ í´ë¦­ ì‹œ ëª¨ë“œ ì„ íƒ ì ‘ê¸°
        document.addEventListener('click', (e) => {
            const mainMenu = document.getElementById('mainMenu');
            const modeSelection = document.getElementById('modeSelection');
            const multiModeSelection = document.getElementById('multiModeSelection');
            const soloPlayText = document.getElementById('soloPlayText');
            const multiPlayText = document.getElementById('multiPlayText');
            
            // ë©”ì¸ ë©”ë‰´ê°€ í‘œì‹œë˜ì–´ ìˆì„ ë•Œ
            if (mainMenu && mainMenu.classList.contains('active')) {
                // ì†”ë¡œí”Œë ˆì´ ëª¨ë“œ ì„ íƒì´ í¼ì³ì ¸ ìˆì„ ë•Œ
                if (modeSelection && modeSelection.classList.contains('expanded')) {
                    // í´ë¦­í•œ ìš”ì†Œê°€ ëª¨ë“œ ì„ íƒ ì˜ì—­ì´ë‚˜ ì†”ë¡œ í”Œë ˆì´ í…ìŠ¤íŠ¸ê°€ ì•„ë‹ ë•Œ
                    if (!modeSelection.contains(e.target) && !soloPlayText.contains(e.target)) {
                        collapseModeSelection();
                    }
                }
                // ë©€í‹°í”Œë ˆì´ ëª¨ë“œ ì„ íƒì´ í¼ì³ì ¸ ìˆì„ ë•Œ
                if (multiModeSelection && multiModeSelection.classList.contains('expanded')) {
                    // í´ë¦­í•œ ìš”ì†Œê°€ ë©€í‹° ëª¨ë“œ ì„ íƒ ì˜ì—­ì´ë‚˜ ë©€í‹° í”Œë ˆì´ í…ìŠ¤íŠ¸ê°€ ì•„ë‹ ë•Œ
                    if (!multiModeSelection.contains(e.target) && !multiPlayText.contains(e.target)) {
                        collapseMultiModeSelection();
                    }
                }
            }
        });

        // í™”ë©´ ì „í™˜ í•¨ìˆ˜
        function showScreen(screenName) {
            // ëª¨ë“  í™”ë©´ ìˆ¨ê¸°ê¸°
            const screens = document.querySelectorAll('.screen');
            screens.forEach(screen => {
                screen.classList.remove('active');
                screen.style.display = 'none';
            });
            
            // ì„ íƒí•œ í™”ë©´ í‘œì‹œ
            let targetScreen;
            if (screenName === 'main') {
                // ë©”ì¸ ë©”ë‰´ëŠ” idê°€ mainMenu
                targetScreen = document.getElementById('mainMenu');
            } else if (screenName === 'game') {
                // ê²Œì„ í™”ë©´ì€ ëª¨ë“  í™”ë©´ ìˆ¨ê¹€
                gameState.isMenu = false;
                hideNicknameDisplay(); // ì¸ê²Œì„ì—ì„œëŠ” ë‹‰ë„¤ì„ ìˆ¨ê¹€
                return;
            } else {
                // ë‹¤ë¥¸ í™”ë©´ë“¤ì€ screenName + 'Screen' í˜•ì‹
                targetScreen = document.getElementById(screenName + 'Screen') || document.getElementById(screenName);
            }
            
            if (targetScreen) {
                targetScreen.classList.add('active');
                targetScreen.style.display = 'flex';
                
                // ì¸ê²Œì„ì´ ì•„ë‹Œ ê²½ìš° ë‹‰ë„¤ì„ê³¼ ì œí™” í‘œì‹œ
                if (screenName !== 'game') {
                    showNicknameDisplay();
                }
                
                // ê° í™”ë©´ë³„ ì´ˆê¸°í™”
                if (screenName === 'collection') {
                    loadCollectionContent();
                    stopShopRefreshTimer(); // ìƒì  íƒ€ì´ë¨¸ ì¤‘ì§€
                } else if (screenName === 'shop') {
                    openShopModal();
                } else if (screenName === 'storage') {
                    openStorageModal();
                    stopShopRefreshTimer(); // ìƒì  íƒ€ì´ë¨¸ ì¤‘ì§€
                } else if (screenName === 'achievement') {
                    stopShopRefreshTimer(); // ìƒì  íƒ€ì´ë¨¸ ì¤‘ì§€
                } else if (screenName === 'main') {
                    // ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°ˆ ë•Œ
                    gameState.isMenu = true;
                    stopShopRefreshTimer(); // ìƒì  íƒ€ì´ë¨¸ ì¤‘ì§€
                    
                    // ë©€í‹°í”Œë ˆì´ì–´ ì—°ê²°ì´ ë‚¨ì•„ìˆìœ¼ë©´ ì •ë¦¬ (ì•ˆì „ì¥ì¹˜)
                    if (multiplayerPeer || multiplayerConnection) {
                        console.log('ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°: ë‚¨ì•„ìˆëŠ” ë©€í‹°í”Œë ˆì´ì–´ ì—°ê²° ì •ë¦¬');
                        cleanupMultiplayerConnection();
                    }
                } else if (screenName === 'game') {
                    stopShopRefreshTimer(); // ìƒì  íƒ€ì´ë¨¸ ì¤‘ì§€
                }
            }
        }

        // ê²Œì„ ìƒíƒœ
        let gameState = {
            round: 1,
            playerWins: 0,
            enemyWins: 0,
            winsNeeded: 5, // 5ë¼ìš´ë“œ ì„ ìŠ¹ì œ
            gameTime: 180, // 3ë¶„ = 180ì´ˆ
            isGameOver: false,
            isPaused: false,
            isMenu: true, // ë©”ë‰´ í™”ë©´ í‘œì‹œ ì—¬ë¶€
            isNextRoundProcessing: false, // ë‹¤ìŒ ë¼ìš´ë“œ ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ (ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€)
            roundWins: [], // ê° ë¼ìš´ë“œì˜ ìŠ¹ì ê¸°ë¡ ('player' ë˜ëŠ” 'enemy')
            countdown: 3, // ë¼ìš´ë“œ ì‹œì‘ ì¹´ìš´íŠ¸ë‹¤ìš´
            augmentCountdown: 0, // ì¦ê°• ì„ íƒ ì¹´ìš´íŠ¸ë‹¤ìš´ (0ì´ë©´ í‘œì‹œ ì•ˆí•¨)
            showOpponentSelecting: false, // ìƒëŒ€ ì„ íƒ ì¤‘ ë©”ì‹œì§€ í‘œì‹œ ì—¬ë¶€
            shake: {
                intensity: 0,
                duration: 0
            },
            // ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ
            isSlotMachine: false,
            slotMachineStartTime: 0,
            slotMachineCurrentIndex: 0,
            slotMachineSelectedMode: null,
            // ë§µ í¬ê¸° (ê¸°ë³¸ê°’ì€ ì „ì²´ ìº”ë²„ìŠ¤)
            mapBounds: {
                minX: 0,
                minY: 0,
                maxX: 0, // initGameì—ì„œ ì„¤ì •
                maxY: 0  // initGameì—ì„œ ì„¤ì •
            },
            // ë©€í‹°í”Œë ˆì´ ìƒíƒœ
            isMultiplayer: false,
            multiplayerReady: false, // ì–‘ìª½ ëª¨ë‘ ì¤€ë¹„ë¨
            lastSyncTime: 0, // ë§ˆì§€ë§‰ ë™ê¸°í™” ì‹œê°„
            explosions: [], // í­ë°œ ì´í™íŠ¸ ë°°ì—´
            obstacles: [], // ë©€í‹°í”Œë ˆì´ì–´ ì¥ì• ë¬¼ ë°°ì—´ {x, y, width, height, angle}
            roundStartTime: 0, // ë¼ìš´ë“œ ì‹œì‘ ì‹œê°„
            lastObstacleRemoveTime: 0 // ë§ˆì§€ë§‰ ì¥ì• ë¬¼ ì œê±° ì‹œê°„
        };

        // íŠœí† ë¦¬ì–¼ ìƒíƒœ

        // í”Œë ˆì´ì–´
        const player = {
            x: canvas.width * 0.2,
            y: canvas.height * 0.5,
            radius: 30, // 1.5ë°° ì¦ê°€ (20 -> 30)
            speed: 3,
            health: 5,
            displayHealth: 5, // í‘œì‹œë˜ëŠ” ì²´ë ¥ (ì• ë‹ˆë©”ì´ì…˜ìš©)
            maxHealth: 5,
            ammo: 6,
            maxAmmo: 6,
            reloadTime: 3000, // 3ì´ˆ
            isReloading: false,
            reloadStartTime: 0, // ì¬ì¥ì „ ì‹œì‘ ì‹œê°„
            angle: 0,
            color: '#4a9eff',
            bullets: [],
            lastShot: 0,
            shootCooldown: 1000, // 1ì´ˆë¡œ ê³ ì •
            damage: 1, // ê¸°ë³¸ ë°ë¯¸ì§€
            augmentations: [],
            // ì¦ê°• ê´€ë ¨ ìƒíƒœ
            bulletSpeedMultiplier: 1,
            bulletSizeMultiplier: 1, // íƒ„í™˜ í¬ê¸° ë°°ìœ¨
            hasCritical: false,
            hasDoubleShot: false,
            hasDodge: false,
            hasRevive: false,
            hasRevived: 0, // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜
            hasDeepWound: false,
            hasOneShotOneKill: false,
            hasPoisonBullet: false,
            hasReloadHeal: false,
            hasSurvivalInstinct: false, // ìƒì¡´ë³¸ëŠ¥
            hasLastBullet: false, // ë¹„ì¥ì˜ í•œë°œ
            hasRecoveryContract: false, // íšŒë³µê³„ì•½
            hasRecoveryContractUsed: false, // íšŒë³µê³„ì•½ ì‚¬ìš© ì—¬ë¶€ (ë¼ìš´ë“œë‹¹ í•œë²ˆ)
            hasFocusedFire: false, // ì§‘ì¤‘ ì‚¬ê²©
            hasShotgun: false, // ìƒ·ê±´
            hasRagged: false, // ë‹¤ë‹¤ìµì„ 
            hasGhost: false, // ìœ ë ¹
            hasFortify: false, // ê±°ì í™•ë³´
            isFortified: false, // ê±°ì  í™•ë³´ ìƒíƒœ
            fortifyStartTime: 0, // ê±°ì  í™•ë³´ ì‹œì‘ ì‹œê°„
            lastPosition: { x: 0, y: 0 }, // ë§ˆì§€ë§‰ ìœ„ì¹˜
            stationaryTime: 0, // ì •ì§€í•œ ì‹œê°„
            hasOverheat: false, // ê³¼ì—´
            overheatHitCount: 0, // ì—°ì† íˆíŠ¸ ì¹´ìš´íŠ¸
            lastHitTime: 0, // ë§ˆì§€ë§‰ íˆíŠ¸ ì‹œê°„
            hasGamble: false, // ë„ë°•
            hasWeaken: false, // ì•½í™”
            isWeakened: false, // ì•½í™” ìƒíƒœ
            weakenEndTime: 0, // ì•½í™” ì¢…ë£Œ ì‹œê°„
            hasDamageBoost: false, // ë°ë¯¸ì§€ 1.2ë°°
            hasLightning: false, // ë²ˆê°œ
            isStunned: false, // ê¸°ì ˆ ìƒíƒœ
            stunEndTime: 0, // ê¸°ì ˆ ì¢…ë£Œ ì‹œê°„
            hasShield: false, // ë°©ì–´ë§‰
            shieldReady: false, // ë°©ì–´ë§‰ ì¤€ë¹„ë¨
            shieldCooldown: 0, // ë°©ì–´ë§‰ ì¿¨íƒ€ì„
            hasRegeneration: false, // ì¬ìƒ
            lastRegenTime: 0, // ë§ˆì§€ë§‰ íšŒë³µ ì‹œê°„
            isVulnerable: false, // ì·¨ì•½ ìƒíƒœ
            vulnerabilityUsed: false, // ì·¨ì•½ ì‚¬ìš© ì—¬ë¶€
            poisonEffects: [], // ë… íš¨ê³¼ ë°°ì—´ {target, startTime, duration, damagePerSecond}
            isDodging: false,
            dodgeStartTime: 0, // êµ¬ë¥´ê¸° ì‹œì‘ ì‹œê°„
            dodgeEndTime: 0,
            dodgeStartX: 0,
            dodgeStartY: 0,
            dodgeTargetX: 0,
            dodgeTargetY: 0,
            dodgeTrail: [], // êµ¬ë¥´ê¸° ì”ìƒ ìœ„ì¹˜ ë°°ì—´
            lastDodgeTime: 0, // ë§ˆì§€ë§‰ êµ¬ë¥´ê¸° ì‹œê°„ (ì¿¨íƒ€ì„ìš©)
            isReviving: false,
            reviveTime: 0,
            isInvincible: false,
            invincibleEndTime: 0,
            slowEndTime: 0,
            damageNumbers: [], // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œìš©
            hitEffectParticles: [] // í”¼ê²© ì´í™íŠ¸ íŒŒí‹°í´ ë°°ì—´
        };

        // ì  (AI)
        const enemy = {
            x: canvas.width * 0.8,
            y: canvas.height * 0.5,
            radius: 30, // 1.5ë°° ì¦ê°€ (20 -> 30)
            speed: 2.5,
            health: 5,
            displayHealth: 5, // í‘œì‹œë˜ëŠ” ì²´ë ¥ (ì• ë‹ˆë©”ì´ì…˜ìš©)
            maxHealth: 5,
            ammo: 6,
            maxAmmo: 6,
            reloadTime: 3000, // 3ì´ˆ
            isReloading: false,
            reloadStartTime: 0, // ì¬ì¥ì „ ì‹œì‘ ì‹œê°„
            angle: Math.PI,
            color: '#e94560',
            bullets: [],
            lastShot: 0,
            shootCooldown: 1000, // 1ì´ˆë¡œ ê³ ì •
            damage: 1, // ê¸°ë³¸ ë°ë¯¸ì§€
            augmentations: [],
            // ì¦ê°• ê´€ë ¨ ìƒíƒœ
            bulletSpeedMultiplier: 1,
            bulletSizeMultiplier: 1, // íƒ„í™˜ í¬ê¸° ë°°ìœ¨
            hasCritical: false,
            hasDoubleShot: false,
            hasDodge: false,
            hasRevive: false,
            hasRevived: 0, // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜
            hasDeepWound: false,
            hasOneShotOneKill: false,
            hasPoisonBullet: false,
            hasReloadHeal: false,
            hasSurvivalInstinct: false, // ìƒì¡´ë³¸ëŠ¥
            hasLastBullet: false, // ë¹„ì¥ì˜ í•œë°œ
            hasRecoveryContract: false, // íšŒë³µê³„ì•½
            hasRecoveryContractUsed: false, // íšŒë³µê³„ì•½ ì‚¬ìš© ì—¬ë¶€ (ë¼ìš´ë“œë‹¹ í•œë²ˆ)
            hasFocusedFire: false, // ì§‘ì¤‘ ì‚¬ê²©
            hasShotgun: false, // ìƒ·ê±´
            hasRagged: false, // ë‹¤ë‹¤ìµì„ 
            hasGhost: false, // ìœ ë ¹
            hasFortify: false, // ê±°ì í™•ë³´
            isFortified: false, // ê±°ì  í™•ë³´ ìƒíƒœ
            fortifyStartTime: 0, // ê±°ì  í™•ë³´ ì‹œì‘ ì‹œê°„
            lastPosition: { x: 0, y: 0 }, // ë§ˆì§€ë§‰ ìœ„ì¹˜
            stationaryTime: 0, // ì •ì§€í•œ ì‹œê°„
            hasOverheat: false, // ê³¼ì—´
            overheatHitCount: 0, // ì—°ì† íˆíŠ¸ ì¹´ìš´íŠ¸
            lastHitTime: 0, // ë§ˆì§€ë§‰ íˆíŠ¸ ì‹œê°„
            hasGamble: false, // ë„ë°•
            hasWeaken: false, // ì•½í™”
            isWeakened: false, // ì•½í™” ìƒíƒœ
            weakenEndTime: 0, // ì•½í™” ì¢…ë£Œ ì‹œê°„
            hasDamageBoost: false, // ë°ë¯¸ì§€ 1.2ë°°
            hasLightning: false, // ë²ˆê°œ
            isStunned: false, // ê¸°ì ˆ ìƒíƒœ
            stunEndTime: 0, // ê¸°ì ˆ ì¢…ë£Œ ì‹œê°„
            hasShield: false, // ë°©ì–´ë§‰
            shieldReady: false, // ë°©ì–´ë§‰ ì¤€ë¹„ë¨
            shieldCooldown: 0, // ë°©ì–´ë§‰ ì¿¨íƒ€ì„
            hasRegeneration: false, // ì¬ìƒ
            lastRegenTime: 0, // ë§ˆì§€ë§‰ íšŒë³µ ì‹œê°„
            hasEvasiveManeuver: false, // íšŒí”¼ê¸°ë™
            hasCombatExperience: false, // ì „íˆ¬ ê²½í—˜
            combatExperienceRounds: 0, // ì „íˆ¬ ê²½í—˜ ë¼ìš´ë“œ ìˆ˜
            hasHallucination: false, // í™˜ê°
            hasTasteOfBlood: false, // í”¼ì˜ ë§›
            hasCannon: false, // ëŒ€í¬
            hasTimeBarrier: false, // ì‹œê°„ì¥ë§‰
            timeBarrierRadius: 150, // ì‹œê°„ì¥ë§‰ ë°˜ì§€ë¦„
            hasBouncyBullet: false, // í†µí†µíƒ„
            hasGamble2: false, // ìŠ¤ë„¤ì´í¬
            hasReflect: false, // ë°˜ì‚¬
            reflectActive: false, // ë°˜ì‚¬ ë³´í˜¸ë§‰ í™œì„±í™” ì—¬ë¶€
            reflectCooldown: 0, // ë°˜ì‚¬ ì¿¨íƒ€ì„
            reflectEndTime: 0, // ë°˜ì‚¬ ì¢…ë£Œ ì‹œê°„
            hasExplosiveBullet: false, // í­ë°œíƒ„
            hasReaper: false, // ì‚¬ì‹ 
            isInvisible: false, // ì€ì‹  ìƒíƒœ
            invisibilityEndTime: 0, // ì€ì‹  ì¢…ë£Œ ì‹œê°„
            hasOvercharge: false, // ê³¼ì¶©ì „
            overchargeActive: false, // ê³¼ì¶©ì „ í™œì„±í™” ì—¬ë¶€
            overchargeCooldown: 0, // ê³¼ì¶©ì „ ì¿¨íƒ€ì„
            overchargeEndTime: 0, // ê³¼ì¶©ì „ ì¢…ë£Œ ì‹œê°„
            overchargeTrail: [], // ê³¼ì¶©ì „ ì”ìƒ ìœ„ì¹˜ ë°°ì—´
            hasVictor: false, // ìŠ¹ë¦¬ì
            hasTimeStop: false, // ì‹œê°„ì •ì§€
            timeStopCooldown: 0, // ì‹œê°„ì •ì§€ ì¿¨íƒ€ì„
            timeStopActive: false, // ì‹œê°„ì •ì§€ í™œì„±í™” ì—¬ë¶€
            timeStopEndTime: 0, // ì‹œê°„ì •ì§€ ì¢…ë£Œ ì‹œê°„
            hasScatter: false, // ë¹„ì‚°íƒ„
            hasRocket: false, // ë¡œì¼“íƒ„
            hasTrinity: false, // ì‚¼ìœ„ì¼ì²´
            hasJudgment: false, // ì„ ê³ 
            isJudgmentPushing: false, // ì„ ê³  ë°€ë ¤ë‚˜ëŠ” ì¤‘
            judgmentPushStartX: 0,
            judgmentPushStartY: 0,
            judgmentPushTargetX: 0,
            judgmentPushTargetY: 0,
            judgmentPushStartTime: 0,
            judgmentPushDuration: 0,
            hasBoomerang: false, // ë¶€ë§¤ë‘
            hasTide: false, // í•´ë¥˜
            tidePhase: true, // í•´ë¥˜ í˜ì´ì¦ˆ (true: +50%, false: -25%)
            tideStartTime: 0, // í•´ë¥˜ ì‹œì‘ ì‹œê°„
            hasOblivion: false, // ë§ê°
            oblivionStartTime: 0, // ë§ê° ì‹œì‘ ì‹œê°„ (ë¼ìš´ë“œ ì‹œì‘ ì‹œê°„)
            oblivionActivated: false, // ë§ê° í™œì„±í™” ì—¬ë¶€
            hasMechanization: false, // ê¸°ê³„í™”
            hasPlunder: false, // ê°•íƒˆ
            isVulnerable: false, // ì·¨ì•½ ìƒíƒœ
            vulnerabilityUsed: false, // ì·¨ì•½ ì‚¬ìš© ì—¬ë¶€
            poisonEffects: [], // ë… íš¨ê³¼ ë°°ì—´ {target, startTime, duration, damagePerSecond}
            isDodging: false,
            dodgeStartTime: 0, // êµ¬ë¥´ê¸° ì‹œì‘ ì‹œê°„
            dodgeEndTime: 0,
            dodgeStartX: 0,
            dodgeStartY: 0,
            dodgeTargetX: 0,
            dodgeTargetY: 0,
            dodgeTrail: [], // êµ¬ë¥´ê¸° ì”ìƒ ìœ„ì¹˜ ë°°ì—´
            lastDodgeTime: 0, // ë§ˆì§€ë§‰ êµ¬ë¥´ê¸° ì‹œê°„ (ì¿¨íƒ€ì„ìš©)
            isReviving: false,
            reviveTime: 0,
            isInvincible: false,
            invincibleEndTime: 0,
            slowEndTime: 0,
            aiTimer: 0,
            aiDirection: Math.random() * Math.PI * 2,
            usePrediction: false, // ë°œì‚¬ íŒ¨í„´: false=í˜„ì¬ ìœ„ì¹˜, true=ì˜ˆì¸¡ ìœ„ì¹˜
            lastPlayerX: 0, // í”Œë ˆì´ì–´ ì´ì „ ìœ„ì¹˜ (ì´ë™ ë°©í–¥ ê³„ì‚°ìš©)
            lastPlayerY: 0,
            playerVelocity: { x: 0, y: 0 }, // í”Œë ˆì´ì–´ ì´ë™ ì†ë„
            lastPlayerBulletCount: 0, // í”Œë ˆì´ì–´ ì´ì•Œ ê°œìˆ˜ ì¶”ì  (ë°œì‚¬ ê°ì§€ìš©)
            bulletDodgeTargetY: 0, // ì´ì•Œ íšŒí”¼ ëª©í‘œ Y ìœ„ì¹˜
            isDodgingBullet: false, // ì´ì•Œ íšŒí”¼ ì¤‘ì¸ì§€
            damageNumbers: [], // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œìš©
            hitEffectParticles: [] // í”¼ê²© ì´í™íŠ¸ íŒŒí‹°í´ ë°°ì—´
        };

        // ì¦ê°• ëª©ë¡
        // ì¦ê°• ì¤‘ì²© íšŸìˆ˜ ê³„ì‚° í—¬í¼ í•¨ìˆ˜
        function getAugmentCount(character, augmentId) {
            return character.augmentations.filter(aug => aug.id === augmentId).length;
        }

        const augmentations = [
            { 
                id: 'health', 
                name: 'ìµœëŒ€ì²´ë ¥ +1.5', 
                description: 'ìµœëŒ€ ì²´ë ¥ +1.5', 
                effect: (character) => { 
                    // ì¤‘ì²© ê°€ëŠ¥: íšŸìˆ˜ë§Œí¼ ì¶”ê°€
                    const count = character.augmentations.filter(aug => aug.id === 'health').length + 1;
                    character.maxHealth += 1.5;
                    character.health += 1.5;
                } 
            },
            { 
                id: 'speed', 
                name: 'ì´ë™ì†ë„ +25%', 
                description: 'ì´ë™ ì†ë„ +25%', 
                effect: (character) => { 
                    character.speed *= 1.25; 
                } 
            },
            { 
                id: 'bulletSpeed', 
                name: 'ì´ì•Œ ì†ë„ +25%', 
                description: 'ì´ì•Œ ì†ë„ +25%', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 1.25; 
                } 
            },
            { 
                id: 'ammo', 
                name: 'íƒ„ì•½ +1', 
                description: 'ìµœëŒ€ íƒ„ì•½ +1', 
                effect: (character) => { 
                    character.maxAmmo += 1; 
                    character.ammo += 1; 
                } 
            },
            { 
                id: 'fireRate', 
                name: 'ë°œì‚¬ì†ë„ -25%', 
                description: 'ë°œì‚¬ì†ë„ -25%', 
                effect: (character) => { 
                    character.shootCooldown *= 0.75; 
                } 
            },
            { 
                id: 'reload', 
                name: 'ì¬ì¥ì „ ì†ë„ -1.5ì´ˆ', 
                description: 'ì¬ì¥ì „ ì‹œê°„ -1.5ì´ˆ', 
                effect: (character) => { 
                    character.reloadSpeedCount = (character.reloadSpeedCount || 0) + 1;
                    // ì¤‘ì²© ì ìš©: ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ì—ì„œ ì¤‘ì²© íšŸìˆ˜ * 1.5ì´ˆë¥¼ ëºŒ
                    const baseReloadTime = character.baseReloadTime || 3000;
                    character.reloadTime = Math.max(1000, baseReloadTime - (1500 * character.reloadSpeedCount));
                } 
            },
            { 
                id: 'critical', 
                name: 'í¬ë¦¬í‹°ì»¬', 
                description: 'í”¼ê²© ì‹œ 25% í™•ë¥ ë¡œ ë°ë¯¸ì§€ 2ë°°', 
                effect: (character) => { 
                    character.hasCritical = true; 
                    character.criticalCount = (character.criticalCount || 0) + 1; 
                } 
            },
            { 
                id: 'doubleShot', 
                name: 'ë”ë¸”ìƒ·', 
                description: 'ë°œì‚¬ ì‹œ 25% í™•ë¥ ë¡œ ì¶”ê°€ ë°œì‚¬', 
                effect: (character) => { 
                    character.hasDoubleShot = true; 
                    character.doubleShotCount = (character.doubleShotCount || 0) + 1; 
                } 
            },
            { 
                id: 'dodge', 
                name: 'êµ¬ë¥´ê¸°', 
                description: 'ìš°í´ë¦­ìœ¼ë¡œ êµ¬ë¥´ê¸° (êµ¬ë¥´ëŠ” ë™ì•ˆ ë¬´ì )', 
                effect: (character) => { 
                    character.hasDodge = true; 
                } 
            },
            { 
                id: 'revive', 
                name: 'ë¶€í™œ', 
                description: 'ì£½ì—ˆì„ ë•Œ 2ì´ˆ í›„ ì²´ë ¥ 1ë¡œ ë¶€í™œ', 
                effect: (character) => { 
                    character.hasRevive = true; 
                    character.reviveCount = (character.reviveCount || 0) + 1; 
                } 
            },
            { 
                id: 'deepWound', 
                name: 'ê¹Šì€ ìƒì²˜', 
                description: 'í”¼ê²© ì‹œ ìƒëŒ€ ì´ë™ì†ë„ -25%', 
                effect: (character) => { 
                    character.hasDeepWound = true; 
                    character.deepWoundCount = (character.deepWoundCount || 0) + 1; 
                } 
            },
            { 
                id: 'giant', 
                name: 'ê±°ëŒ€í™”', 
                description: 'ì²´ë ¥ +3, ì´ë™ì†ë„ -25%', 
                effect: (character) => { 
                    character.maxHealth += 3; 
                    character.health += 3; 
                    character.speed *= 0.75; 
                } 
            },
            { 
                id: 'sniper', 
                name: 'ì €ê²©ìˆ˜', 
                description: 'ì´ì•Œ ì†ë„ +75%, ìµœëŒ€ íƒ„ì•½ -3', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 1.75; 
                    character.maxAmmo = Math.max(1, character.maxAmmo - 3); 
                    character.ammo = Math.min(character.ammo, character.maxAmmo); 
                } 
            },
            { 
                id: 'oneShotOneKill', 
                name: 'ì›ìƒ·ì›í‚¬', 
                description: 'ìµœëŒ€ íƒ„ì•½ 1ê°œë¡œ ê³ ì •, ì´ì•Œ ë°ë¯¸ì§€ *3', 
                effect: (character) => { 
                    character.maxAmmo = 1; 
                    character.ammo = Math.min(character.ammo, 1); 
                    character.damage = (character.damage || 1) * 3; // ì´ì•Œ ë°ë¯¸ì§€ *3
                    character.hasOneShotOneKill = true; 
                } 
            },
            { 
                id: 'poisonBullet', 
                name: 'ë… íƒ„í™˜', 
                description: 'ì  í”¼ê²©ì‹œ 0.2ë°ë¯¸ì§€ë¥¼ 1ì´ˆê°„ê²©ìœ¼ë¡œ 2ë²ˆ ì¶”ê°€í”¼í•´', 
                effect: (character) => { 
                    character.hasPoisonBullet = true; 
                    character.poisonBulletCount = (character.poisonBulletCount || 0) + 1; 
                } 
            },
            { 
                id: 'reloadHeal', 
                name: 'ì¬ì¥ì „ íšŒë³µ', 
                description: 'ì¬ì¥ì „ ì‹œ ì²´ë ¥ 1íšŒë³µ', 
                effect: (character) => { 
                    character.hasReloadHeal = true; 
                    character.reloadHealCount = (character.reloadHealCount || 0) + 1; 
                } 
            },
            { 
                id: 'bigBullet', 
                name: 'í° íƒ„í™˜', 
                description: 'íƒ„í™˜ í¬ê¸° +50%', 
                effect: (character) => { 
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 1.5; 
                } 
            },
            { 
                id: 'survivalInstinct', 
                name: 'ìƒì¡´ë³¸ëŠ¥', 
                description: 'ì²´ë ¥ì´ 1ì¼ ë•Œ ì´ë™ì†ë„ +50%', 
                effect: (character) => { 
                    character.hasSurvivalInstinct = true; 
                    character.survivalInstinctCount = (character.survivalInstinctCount || 0) + 1; 
                } 
            },
            { 
                id: 'lastBullet', 
                name: 'ë¹„ì¥ì˜ í•œë°œ', 
                description: 'ë§ˆì§€ë§‰ íƒ„í™˜ì˜ ë°ë¯¸ì§€ +1.5', 
                effect: (character) => { 
                    character.hasLastBullet = true; 
                    character.lastBulletCount = (character.lastBulletCount || 0) + 1; 
                } 
            },
            { 
                id: 'recoveryContract', 
                name: 'íšŒë³µê³„ì•½', 
                description: 'ì²´ë ¥ì´ 1ì¼ ë•Œ ì²´ë ¥ 2íšŒë³µ', 
                effect: (character) => { 
                    character.hasRecoveryContract = true; 
                    character.recoveryContractCount = (character.recoveryContractCount || 0) + 1; 
                } 
            },
            { 
                id: 'focusedFire', 
                name: 'ì§‘ì¤‘ ì‚¬ê²©', 
                description: 'í”¼ê²©ì‹œ 50% í™•ë¥ ë¡œ ìƒëŒ€ì—ê²Œ ì·¨ì•½ ë¶€ì—¬ (ë‹¤ìŒ ë°ë¯¸ì§€ *1.5ë°°)', 
                effect: (character) => { 
                    character.hasFocusedFire = true; 
                } 
            },
            { 
                id: 'shotgun', 
                name: 'ìƒ·ê±´', 
                description: 'ëª¨ë“  íƒ„ì•½ì„ Â±25ë„ ë²”ìœ„ì—ì„œ í•œë²ˆì— ë°œì‚¬', 
                effect: (character) => { 
                    character.hasShotgun = true; 
                } 
            },
            { 
                id: 'ragged', 
                name: 'ë‹¤ë‹¤ìµì„ ', 
                description: 'ìµœëŒ€ íƒ„ì•½ +3, ë°œì‚¬ì†ë„ -50%, ì´ì•Œ ë°ë¯¸ì§€ *0.5', 
                effect: (character) => { 
                    character.maxAmmo += 3; 
                    character.ammo += 3; 
                    character.shootCooldown *= 0.5; // ë°œì‚¬ì†ë„ -50% (ì¿¨íƒ€ì„ ì ˆë°˜)
                    character.damage = (character.damage || 1) * 0.5; // ì´ì•Œ ë°ë¯¸ì§€ *0.5
                    character.hasRagged = true; 
                } 
            },
            { 
                id: 'ghost', 
                name: 'ìœ ë ¹', 
                description: 'ìƒëŒ€ì˜ ê³µê²©ì„ 25% í™•ë¥ ë¡œ ë¬´ì‹œ', 
                effect: (character) => { 
                    character.hasGhost = true; 
                    character.ghostCount = (character.ghostCount || 0) + 1; 
                } 
            },
            { 
                id: 'fortify', 
                name: 'ê±°ì í™•ë³´', 
                description: '3ì´ˆë™ì•ˆ ê°€ë§Œíˆ ì„œìˆì„ ê²½ìš° ë‹¤ì‹œ ì›€ì§ì¼ë•Œê¹Œì§€ ë°›ëŠ” ë°ë¯¸ì§€ *0.5', 
                effect: (character) => { 
                    character.hasFortify = true; 
                    character.fortifyStartTime = 0; // ê±°ì  í™•ë³´ ì‹œì‘ ì‹œê°„
                    character.isFortified = false; // ê±°ì  í™•ë³´ ìƒíƒœ
                    character.lastPosition = { x: character.x, y: character.y }; // ë§ˆì§€ë§‰ ìœ„ì¹˜
                    character.stationaryTime = 0; // ì •ì§€í•œ ì‹œê°„
                } 
            },
            { 
                id: 'overheat', 
                name: 'ê³¼ì—´', 
                description: 'ìƒëŒ€ì—ê²Œ ì´ì•Œì„ ì—°ì†ìœ¼ë¡œ ë§ì¶œ ì‹œ ë§ì¶œë•Œë§ˆë‹¤ ë°ë¯¸ì§€ 0.5ë°°ì”© ìƒìŠ¹', 
                effect: (character) => { 
                    character.hasOverheat = true; 
                    character.overheatHitCount = 0; // ì—°ì† íˆíŠ¸ ì¹´ìš´íŠ¸
                    character.lastHitTime = 0; // ë§ˆì§€ë§‰ íˆíŠ¸ ì‹œê°„
                } 
            },
            { 
                id: 'gamble', 
                name: 'ë„ë°•', 
                description: 'ì´ì•Œì´ Â±10ë„ ë²”ìœ„ì—ì„œ ëœë¤í•˜ê²Œ ë‚˜ê°€ì§€ë§Œ ë°ë¯¸ì§€ëŠ” 1~2ë°° ì‚¬ì´ë¡œ ëœë¤', 
                effect: (character) => { 
                    character.hasGamble = true; 
                } 
            },
            { 
                id: 'weaken', 
                name: 'ì•½í™”', 
                description: 'ìƒëŒ€ì—ê²Œ ì´ì•Œì„ ë§ì¶œ ì‹œ 3ì´ˆë™ì•ˆ ìƒëŒ€ ë°ë¯¸ì§€ -0.25', 
                effect: (character) => { 
                    character.hasWeaken = true; 
                    character.weakenCount = (character.weakenCount || 0) + 1; 
                } 
            },
            { 
                id: 'damageBoost', 
                name: 'ë°ë¯¸ì§€ 1.2ë°°', 
                description: 'ì´ì•Œ ë°ë¯¸ì§€ *1.2', 
                effect: (character) => { 
                    character.damage = (character.damage || 1) * 1.2; 
                    character.hasDamageBoost = true; 
                } 
            },
            { 
                id: 'lightning', 
                name: 'ë²ˆê°œ', 
                description: 'ì ì—ê²Œ ì´ì•Œì„ ë§ì¶œ ì‹œ 25% í™•ë¥ ë¡œ ì  0.75ì´ˆ ê¸°ì ˆ', 
                effect: (character) => { 
                    character.hasLightning = true; 
                    character.lightningCount = (character.lightningCount || 0) + 1; 
                } 
            },
            { 
                id: 'shield', 
                name: 'ë°©ì–´ë§‰', 
                description: 'ë°›ëŠ” ë°ë¯¸ì§€ 1íšŒ ë¬´ì‹œ (ì¿¨íƒ€ì„ 7.5ì´ˆ)', 
                effect: (character) => { 
                    character.hasShield = true; 
                    character.shieldReady = true; // ë°©ì–´ë§‰ ì¤€ë¹„ë¨
                    character.shieldCooldown = 0; // ì¿¨íƒ€ì„
                } 
            },
            { 
                id: 'regeneration', 
                name: 'ì¬ìƒ', 
                description: '1ì´ˆë§ˆë‹¤ ì²´ë ¥ 0.1 íšŒë³µ', 
                effect: (character) => { 
                    character.hasRegeneration = true; 
                    character.lastRegenTime = 0; // ë§ˆì§€ë§‰ íšŒë³µ ì‹œê°„
                    character.regenerationCount = (character.regenerationCount || 0) + 1; 
                } 
            },
            { 
                id: 'evasiveManeuver', 
                name: 'íšŒí”¼ê¸°ë™', 
                description: 'ì¬ì¥ì „ ì¤‘ ì´ë™ì†ë„ +75%', 
                effect: (character) => { 
                    character.hasEvasiveManeuver = true; 
                    character.evasiveManeuverCount = (character.evasiveManeuverCount || 0) + 1; 
                } 
            },
            { 
                id: 'combatExperience', 
                name: 'ì „íˆ¬ ê²½í—˜', 
                description: 'ì§„ ë¼ìš´ë“œ ìˆ˜ë§ˆë‹¤ ìµœëŒ€ì²´ë ¥ 0.5, ë°ë¯¸ì§€ 0.1 ì¦ê°€', 
                effect: (character) => { 
                    character.hasCombatExperience = true; 
                    character.combatExperienceRounds = 0; // í˜„ì¬ ë¼ìš´ë“œ ìˆ˜
                    character.combatExperienceCount = (character.combatExperienceCount || 0) + 1; 
                } 
            },
            { 
                id: 'hallucination', 
                name: 'í™˜ê°', 
                description: 'ì´ì•Œì´ ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.1ì´ˆë§ˆë‹¤ ì†ë„ê°€ 0.75ë°°~2ë°° ì‚¬ì´ë¡œ ëœë¤ìœ¼ë¡œ ì¡°ì •ë¨', 
                effect: (character) => { 
                    character.hasHallucination = true; 
                } 
            },
            { 
                id: 'tasteOfBlood', 
                name: 'í”¼ì˜ ë§›', 
                description: 'ì ì—ê²Œ ì…íŒ í”¼í•´ì˜ 20%ë§Œí¼ íšŒë³µ', 
                effect: (character) => { 
                    character.hasTasteOfBlood = true; 
                    character.tasteOfBloodCount = (character.tasteOfBloodCount || 0) + 1; 
                } 
            },
            { 
                id: 'cannon', 
                name: 'ëŒ€í¬', 
                description: 'ì´ì•Œì˜ ì†ë„ -50% ëŒ€ì‹  ì´ì•Œì˜ í¬ê¸° +200%', 
                effect: (character) => { 
                    // ì†ë„ëŠ” 0.5ë°°ì”© ê³±í•˜ê¸° (ì¤‘ì²©)
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 0.5; 
                    // í¬ê¸°ëŠ” 200%ì”© ì¤‘ì²© (3ë°°ì”© ê³±í•˜ê¸°)
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 3; // +200% = 3ë°°
                    character.hasCannon = true; 
                } 
            },
            { 
                id: 'timeBarrier', 
                name: 'ì‹œê°„ì¥ë§‰', 
                description: 'ìì‹  ì£¼ìœ„ì˜ ë°˜ì§€ë¦„ 150pxì§œë¦¬ ì› ìƒì„±, ì´ ì› ì•ˆì— ë“¤ì–´ì˜¤ëŠ” ì ì˜ ì´ì•Œ 35% ë‘”í™”', 
                effect: (character) => { 
                    character.hasTimeBarrier = true; 
                    character.timeBarrierRadius = 150; 
                } 
            },
            { 
                id: 'bouncyBullet', 
                name: 'í†µí†µíƒ„', 
                description: 'ì´ì•Œì´ ë²½ì— ë§ìœ¼ë©´ 1íšŒ íŠ•ê¹€', 
                effect: (character) => { 
                    character.hasBouncyBullet = true; 
                    character.bouncyBulletCount = (character.bouncyBulletCount || 0) + 1; 
                } 
            },
            { 
                id: 'gamble2', 
                name: 'ìŠ¤ë„¤ì´í¬', 
                description: 'ì´ì•Œì´ ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.2ì´ˆë§ˆë‹¤ Â±20ë„ë§Œí¼ ëœë¤ìœ¼ë¡œ ë°©í–¥ ì „í™˜ + ì´ì•Œì†ë„ -50% + ë°œì‚¬ì†ë„ -50%', 
                effect: (character) => { 
                    character.hasGamble2 = true; 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 0.5;
                    character.shootCooldown *= 0.5; // ë°œì‚¬ì†ë„ -50% (ì¿¨íƒ€ì„ ì ˆë°˜)
                } 
            },
            { 
                id: 'reflect', 
                name: 'ë°˜ì‚¬', 
                description: '5ì´ˆë§ˆë‹¤ ìš°í´ë¦­ìœ¼ë¡œ 0.1ì´ˆë™ì•ˆ ë°˜ì‚¬ë¥¼ í•  ìˆ˜ ìˆëŠ” ë³´í˜¸ë§‰ì„ ì–»ì„ ìˆ˜ ìˆìŒ. ë³´í˜¸ë§‰ì´ ìˆëŠ”ë™ì•ˆ ì ì˜ ì´ì•Œì— ë§ìœ¼ë©´ ìƒëŒ€ê°€ ìˆëŠ” ìª½ìœ¼ë¡œ ë‚ ì•„ê°', 
                effect: (character) => { 
                    character.hasReflect = true;
                    character.reflectCooldown = 0;
                } 
            },
            { 
                id: 'timeStop', 
                name: 'ì‹œê°„ì •ì§€', 
                description: '10ì´ˆë§ˆë‹¤ ìš°í´ë¦­ìœ¼ë¡œ 1ì´ˆë™ì•ˆ ì‹œê°„ì„ ì •ì§€ì‹œì¼œ ìƒëŒ€ì˜ ì´ì•Œì€ ê·¸ ìƒíƒœì—ì„œ ë©ˆì¶”ê³ , ìƒëŒ€ëŠ” ì›€ì§ì´ì§€ ëª»í•˜ê²Œ í•  ìˆ˜ ìˆìŒ', 
                effect: (character) => { 
                    character.hasTimeStop = true;
                    character.timeStopCooldown = 0;
                } 
            },
            { 
                id: 'scatter', 
                name: 'ë¹„ì‚°íƒ„', 
                description: 'ì´ì•Œ í¬ê¸° -25%, ì´ì•Œì´ Â±4ë„ ì‚¬ì´ì—ì„œ 2ë„ ê°„ê²©ìœ¼ë¡œ 4ê°œë¡œ ë‚˜ëˆ” + í•œë°œë‹¹ ë°ë¯¸ì§€ 0.25ë°°', 
                effect: (character) => { 
                    character.hasScatter = true;
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 0.75; // ì´ì•Œ í¬ê¸° -25%
                } 
            },
            { 
                id: 'rocket', 
                name: 'ë¡œì¼“íƒ„', 
                description: 'ì´ì•Œ ì†ë„ê°€ ì´ˆê¸° ì†ë„ì˜ 0.1ë°°ë¶€í„° ì‹œì‘í•´ 0.2ì´ˆë§ˆë‹¤ 2ë°°ì”© ì¦ê°€ (ìµœëŒ€ 6.4ë°°)', 
                effect: (character) => { 
                    character.hasRocket = true; 
                } 
            },
            { 
                id: 'trinity', 
                name: 'ì‚¼ìœ„ì¼ì²´', 
                description: 'ì´ë™ì†ë„ +10%, ë°œì‚¬ì†ë„ +10%, ìµœëŒ€ì²´ë ¥ +0.5', 
                effect: (character) => { 
                    character.speed *= 1.1;
                    character.shootCooldown *= 0.9; // ë°œì‚¬ì†ë„ +10% (ì¿¨íƒ€ì„ 10% ê°ì†Œ)
                    character.maxHealth += 0.5;
                    character.health += 0.5;
                    character.hasTrinity = true;
                } 
            },
            { 
                id: 'judgment', 
                name: 'ì„ ê³ ', 
                description: 'ì ì„ ë§ì¶œ ì‹œ ì ì´ ë§ì€ ë°©í–¥ìœ¼ë¡œ 75px ë°€ë ¤ë‚©ë‹ˆë‹¤', 
                effect: (character) => { 
                    character.hasJudgment = true;
                } 
            },
            { 
                id: 'boomerang', 
                name: 'ë¶€ë§¤ë‘', 
                description: 'ì´ì•Œ ë°ë¯¸ì§€ -0.25, ì´ì•Œì˜ ìµœëŒ€ ì‚¬ê±°ë¦¬ 850pxë¡œ ì œí•œ ëŒ€ì‹  ì´ì•Œì´ ìµœëŒ€ ì‚¬ê±°ë¦¬ê¹Œì§€ ê°”ë‹¤ê°€ ë‹¤ì‹œ ë˜ëŒì•„ì˜µë‹ˆë‹¤', 
                effect: (character) => { 
                    character.hasBoomerang = true;
                } 
            },
            { 
                id: 'tide', 
                name: 'í•´ë¥˜', 
                description: 'ë‹¹ì‹ ì˜ ì´ë™ì†ë„ê°€ -25%ì™€ +50%ë¡œ 3ì´ˆë§ˆë‹¤ ë²ˆê°ˆì•„ ë°˜ë³µë©ë‹ˆë‹¤', 
                effect: (character) => { 
                    character.hasTide = true;
                    character.tidePhase = true; // ì‹œì‘ì€ +50% í˜ì´ì¦ˆ
                    character.tideStartTime = Date.now();
                } 
            },
            { 
                id: 'oblivion', 
                name: 'ë§ê°', 
                description: 'ì´ë™ì†ë„ -25%, ì´ì•Œì†ë„ -25%, ì´ì•Œ ë°ë¯¸ì§€ -25%', 
                effect: (character) => { 
                    character.hasOblivion = true;
                    character.oblivionStartTime = Date.now();
                    character.oblivionActivated = false;
                    // ì¦‰ì‹œ í˜ë„í‹° ì ìš©
                    character.speed *= 0.75; // ì´ë™ì†ë„ -25%
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 0.75; // ì´ì•Œì†ë„ -25%
                    character.damage = (character.damage || 1) * 0.75; // ì´ì•Œ ë°ë¯¸ì§€ -25%
                } 
            },
            { 
                id: 'mechanization', 
                name: 'ê¸°ê³„í™”', 
                description: 'ì´ì•Œ ë°œì‚¬ ì†ë„ +25%, ì¬ì¥ì „ì‹œê°„ -1ì´ˆ ëŒ€ì‹  ìƒ,í•˜,ì¢Œ,ìš°ë¡œë§Œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤', 
                effect: (character) => { 
                    character.hasMechanization = true;
                    character.shootCooldown *= 0.75; // ë°œì‚¬ì†ë„ +25% (ì¿¨íƒ€ì„ 25% ê°ì†Œ)
                    character.reloadSpeedCount = (character.reloadSpeedCount || 0) + 1;
                    const baseReloadTime = character.baseReloadTime || 3000;
                    character.reloadTime = Math.max(1000, baseReloadTime - (1000 * character.reloadSpeedCount));
                } 
            },
            { 
                id: 'plunder', 
                name: 'ê°•íƒˆ', 
                description: 'ì´ì•Œì„ ìƒëŒ€ì—ê²Œ ë§ì¶œ ë•Œ ë§ˆë‹¤ ìƒëŒ€ì˜ íƒ„í™˜ 1ê°œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤', 
                effect: (character) => { 
                    character.hasPlunder = true;
                } 
            },
            { 
                id: 'explosiveBullet', 
                name: 'í­ë°œíƒ„', 
                description: 'ì´ì•Œì´ ë²½ì— ë‹¿ì•˜ì„ ë•Œ 125px ë°˜ê²½ì— 0.5 ë°ë¯¸ì§€', 
                effect: (character) => { 
                    character.hasExplosiveBullet = true;
                } 
            },
            { 
                id: 'reaper', 
                name: 'ì‚¬ì‹ ', 
                description: 'ì ì—ê²Œ ì´ì•Œì„ ë§ì¶œ ì‹œ 0.4ì´ˆê°„ ì€ì‹  + ì´ë™ì†ë„ 15%', 
                effect: (character) => { 
                    character.hasReaper = true;
                } 
            },
            { 
                id: 'overcharge', 
                name: 'ê³¼ì¶©ì „', 
                description: '10ì´ˆë§ˆë‹¤ ìš°í´ë¦­ìœ¼ë¡œ 1.5ì´ˆë™ì•ˆ ì´ë™ì†ë„ 33% + ì´ì•Œì†ë„ +33%', 
                effect: (character) => { 
                    character.hasOvercharge = true;
                    character.overchargeCooldown = 0;
                } 
            },
            { 
                id: 'victor', 
                name: 'ìŠ¹ë¦¬ì', 
                description: 'ë¼ìš´ë“œê°€ ì‹œì‘í•  ë•Œ 10% í™•ë¥ ë¡œ ê·¸ ë¼ìš´ë“œ ì¦‰ì‹œ ìŠ¹ë¦¬', 
                effect: (character) => { 
                    character.hasVictor = true;
                } 
            },
        ];

        // í‚¤ ì…ë ¥ ìƒíƒœ
        const keys = {};
        let mouse = { x: 0, y: 0 };
        let hoveredAugment = null; // ë§ˆìš°ìŠ¤ í˜¸ë²„ëœ ì¦ê°• ì •ë³´

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        canvas.addEventListener('click', (e) => {
            if (!gameState.isPaused && !gameState.isGameOver && !player.isDodging) {
                shoot(player);
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // ìš°í´ë¦­ ë©”ë‰´ ë°©ì§€
            
            if (gameState.isPaused || gameState.isGameOver) return;
            
            // í”Œë ˆì´ì–´ êµ¬ë¥´ê¸° (ìš°í´ë¦­)
            if (player.hasDodge && !player.isDodging) {
                    dodge(player);
            }
            
            // ë°˜ì‚¬ ë³´í˜¸ë§‰ í™œì„±í™” (ìš°í´ë¦­)
            if (player.hasReflect && !player.reflectActive && player.reflectCooldown === 0) {
                player.reflectActive = true;
                player.reflectEndTime = Date.now() + 100; // 0.1ì´ˆ
            }
            
            // ì‹œê°„ì •ì§€ í™œì„±í™” (ìš°í´ë¦­)
            if (player.hasTimeStop && !player.timeStopActive && player.timeStopCooldown === 0) {
                player.timeStopActive = true;
                player.timeStopEndTime = Date.now() + 1000; // 1ì´ˆ
            }
            
            // ê³¼ì¶©ì „ í™œì„±í™” (ìš°í´ë¦­)
            if (player.hasOvercharge && !player.overchargeActive && player.overchargeCooldown === 0) {
                const now = Date.now();
                player.overchargeActive = true;
                player.overchargeEndTime = now + 1500; // 1.5ì´ˆ
                player.overchargeCooldown = now + 10000; // 10ì´ˆ ì¿¨íƒ€ì„
            }
        });

        // ì´ì•Œ í´ë˜ìŠ¤
        class Bullet {
            constructor(x, y, angle, owner, isFreeShot = false) {
                this.x = x;
                this.y = y;
                this.startX = x; // ì‹œì‘ ìœ„ì¹˜ ì €ì¥ (ê·¼ì ‘ì „ëª¨ë“œìš©)
                this.startY = y;
                this.angle = angle;
                this.createTime = Date.now(); // ìƒì„± ì‹œê°„ ì €ì¥ (10ì´ˆ í›„ ì‚­ì œìš©)
                const baseSpeed = 20;
                let speedMultiplier = owner.bulletSpeedMultiplier || 1;
                // ê³¼ì¶©ì „: í™œì„±í™” ì¤‘ ì´ì•Œ ì†ë„ +33%
                if (owner.overchargeActive && Date.now() < owner.overchargeEndTime) {
                    speedMultiplier *= 1.33;
                }
                this.speed = baseSpeed * speedMultiplier;
                this.baseSpeed = this.speed; // ì›ë˜ ì†ë„ ì €ì¥ (ì‹œê°„ì¥ë§‰ìš©)
                // í™˜ê°: ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.1ì´ˆë§ˆë‹¤ ì†ë„ ë³€ê²½ì„ ìœ„í•œ ë³€ìˆ˜
                if (owner.hasHallucination) {
                    this.hallucinationLastChange = Date.now(); // ë§ˆì§€ë§‰ ì†ë„ ë³€ê²½ ì‹œê°„
                    // ì´ˆê¸° ì†ë„ë„ ëœë¤ìœ¼ë¡œ ì„¤ì • (0.75ë°°~2ë°°)
                    const randomMultiplier = 0.75 + Math.random() * 1.25; // 0.75 ~ 2.0
                    this.hallucinationSpeed = this.baseSpeed * randomMultiplier;
                    this.speed = this.hallucinationSpeed; // ì´ˆê¸° ì†ë„ëŠ” í™˜ê° ì†ë„ë¡œ
                }
                this.isInTimeBarrier = false; // ì‹œê°„ì¥ë§‰ ì•ˆì— ìˆëŠ”ì§€ ì—¬ë¶€
                const sizeMultiplier = owner.bulletSizeMultiplier || 1;
                this.radius = 9 * sizeMultiplier;
                this.owner = owner;
                this.damage = owner.damage || 1;
                // ë¶€ë§¤ë‘: ì´ì•Œ ë°ë¯¸ì§€ -0.25
                if (owner.hasBoomerang) {
                    this.damage = Math.max(0.25, this.damage - 0.25);
                }
                // ë¹„ì¥ì˜ í•œë°œ: ë§ˆì§€ë§‰ íƒ„í™˜ì˜ ë°ë¯¸ì§€ +1.5 (ì¤‘ì²©)
                if (owner.hasLastBullet && owner.ammo === 1) {
                    const lastBulletCount = owner.lastBulletCount || 1;
                    this.damage += 1.5 * lastBulletCount;
                }
                // ì•½í™” ìƒíƒœ: ëª¨ë“  ê³µê²© ë°ë¯¸ì§€ -0.25 (ì¤‘ì²©)
                if (owner.isWeakened) {
                    const weakenCount = owner.weakenCount || 1;
                    this.damage = Math.max(0.25, this.damage - (0.25 * weakenCount));
                }
                this.isFreeShot = isFreeShot; // íƒ„ì•½ ì†Œëª¨ ì—†ëŠ” ì´ì•Œ (ë”ë¸”ìƒ·ìš©)
                this.hasPoison = owner.hasPoisonBullet || false; // ë… íƒ„í™˜ ì—¬ë¶€
                this.hasBouncy = owner.hasBouncyBullet || false; // í†µí†µíƒ„ ì—¬ë¶€
                this.bounceCount = 0; // íŠ•ê¹€ íšŸìˆ˜
                this.maxBounces = owner.hasBouncyBullet ? (owner.bouncyBulletCount || 1) : 0; // ìµœëŒ€ íŠ•ê¹€ íšŸìˆ˜
                this.lastX = x; // ì´ì „ ìœ„ì¹˜ (ë²½ ì¶©ëŒ ê°ì§€ìš©)
                this.lastY = y;
                // ë„ë°•íƒ„_2: 0.2ì´ˆë§ˆë‹¤ Â±10ë„ ëœë¤ ë°©í–¥ ì „í™˜
                if (owner.hasGamble2) {
                    this.gamble2LastChange = Date.now();
                }
                // ë¡œì¼“íƒ„: 0.1ë°°ë¶€í„° ì‹œì‘, 0.2ì´ˆë§ˆë‹¤ 2ë°°ì”© ì¦ê°€
                if (owner.hasRocket) {
                    this.rocketSpeed = this.baseSpeed * 0.1; // 0.1ë°°
                    this.rocketLastChange = Date.now();
                    this.speed = this.rocketSpeed;
                }
                // ê·¼ì ‘ì „ëª¨ë“œ: ë©ˆì¶¤ ìƒíƒœ
                this.isStopped = false; // ë©ˆì¶¤ ì—¬ë¶€
                this.stopTime = 0; // ë©ˆì¶˜ ì‹œê°„
                this.fadeStartTime = 0; // í˜ì´ë“œ ì•„ì›ƒ ì‹œì‘ ì‹œê°„
                
                // ë¶€ë§¤ë‘: ì´ì•Œì´ ë˜ëŒì•„ì˜´
                this.hasBoomerang = owner.hasBoomerang || false;
                this.isReturning = false; // ë˜ëŒì•„ê°€ëŠ” ì¤‘ì¸ì§€
                this.maxDistance = owner.hasBoomerang ? 850 : Infinity; // ìµœëŒ€ ì‚¬ê±°ë¦¬
            }

            update(deltaTime = 16.67) {
                // deltaTimeì„ 60fps ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™” (ê¸°ë³¸ê°’ 16.67ms = 60fps)
                const normalizedDelta = deltaTime / 16.67;
                
                // ë¡œì¼“íƒ„: 0.2ì´ˆë§ˆë‹¤ ì†ë„ 2ë°°ì”© ì¦ê°€ (ìµœëŒ€ 6.4ë°°)
                if (this.owner && this.owner.hasRocket && this.rocketSpeed !== undefined) {
                    const now = Date.now();
                    if (now - this.rocketLastChange >= 200) { // 0.2ì´ˆ = 200ms
                        if (this.rocketSpeed < this.baseSpeed * 6.4) {
                            this.rocketSpeed *= 2;
                            if (this.rocketSpeed > this.baseSpeed * 6.4) {
                                this.rocketSpeed = this.baseSpeed * 6.4;
                            }
                        }
                        this.rocketLastChange = now;
                    }
                    // ì‹œê°„ì¥ë§‰ì´ ì—†ê±°ë‚˜ ë°–ì— ìˆì„ ë•Œë§Œ ë¡œì¼“ ì†ë„ ì ìš©
                    if (!this.isInTimeBarrier) {
                        this.speed = this.rocketSpeed;
                    }
                }
                
                // ìŠ¤ë„¤ì´í¬: 0.2ì´ˆë§ˆë‹¤ Â±20ë„ ëœë¤ ë°©í–¥ ì „í™˜
                if (this.owner && this.owner.hasGamble2 && this.gamble2LastChange !== undefined) {
                    const now = Date.now();
                    if (now - this.gamble2LastChange >= 200) { // 0.2ì´ˆ = 200ms
                        const randomOffset = (Math.random() - 0.5) * 40 * Math.PI / 180; // Â±20ë„
                        this.angle += randomOffset;
                        this.gamble2LastChange = now;
                    }
                }
                
                // í™˜ê°: ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.1ì´ˆë§ˆë‹¤ ì´ì•Œ ì†ë„ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³€ê²½
                if (this.owner && this.owner.hasHallucination && this.hallucinationLastChange !== undefined) {
                    const now = Date.now();
                    if (now - this.hallucinationLastChange >= 100) { // 0.1ì´ˆ = 100ms
                        // 0.75ë°°~2ë°° ì‚¬ì´ë¡œ ëœë¤ ì¡°ì •
                        const randomMultiplier = 0.75 + Math.random() * 1.25; // 0.75 ~ 2.0
                        this.hallucinationSpeed = this.baseSpeed * randomMultiplier;
                        this.hallucinationLastChange = now;
                    }
                    // í™˜ê° ì†ë„ ì‚¬ìš© (ì‹œê°„ì¥ë§‰ì´ ì ìš©ë˜ë©´ ê·¸ê²Œ ìš°ì„ ì´ë¯€ë¡œ ì‹œê°„ì¥ë§‰ ë¡œì§ì—ì„œ ì²˜ë¦¬)
                    // ì‹œê°„ì¥ë§‰ì´ ì—†ê±°ë‚˜ ë°–ì— ìˆì„ ë•Œë§Œ í™˜ê° ì†ë„ ì ìš©
                    if (!this.isInTimeBarrier && !this.owner.hasRocket) { // ë¡œì¼“íƒ„ì´ ìˆìœ¼ë©´ ë¡œì¼“ ì†ë„ ìš°ì„ 
                        this.speed = this.hallucinationSpeed;
                    }
                }
                
                // ë¶€ë§¤ë‘: ì´ì•Œì´ ìµœëŒ€ ì‚¬ê±°ë¦¬ê¹Œì§€ ê°€ê±°ë‚˜ ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ë˜ëŒì•„ì˜´
                if (this.hasBoomerang && !this.isReturning) {
                    const distance = Math.sqrt(
                        Math.pow(this.x - this.startX, 2) + 
                        Math.pow(this.y - this.startY, 2)
                    );
                    
                    // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°”ê±°ë‚˜ ìµœëŒ€ ì‚¬ê±°ë¦¬ì— ë„ë‹¬í•˜ë©´ ë˜ëŒì•„ê°€ê¸° ì‹œì‘
                    if (this.isOutOfBounds() || distance >= this.maxDistance) {
                        // ë˜ëŒì•„ê°€ê¸° ì‹œì‘
                        this.isReturning = true;
                        // ì†ë„ê°€ ë§¤ìš° ì¤„ì–´ë“¦
                        this.speed = this.baseSpeed * 0.1;
                    }
                }
                
                // ë¶€ë§¤ë‘: ë˜ëŒì•„ê°€ëŠ” ì¤‘
                if (this.hasBoomerang && this.isReturning) {
                    // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ì´ë™
                    const dxToOwner = this.owner.x - this.x;
                    const dyToOwner = this.owner.y - this.y;
                    const distanceToOwner = Math.sqrt(dxToOwner * dxToOwner + dyToOwner * dyToOwner);
                    
                    if (distanceToOwner > 0) {
                        this.angle = Math.atan2(dyToOwner, dxToOwner);
                        // ì†ë„ ì ì§„ì ìœ¼ë¡œ ì¦ê°€
                        this.speed = Math.min(this.baseSpeed * 1.5, this.speed * 1.05);
                    }
                }
                
                // ì´ë™ ì „ ìœ„ì¹˜ ì €ì¥
                const prevX = this.x;
                const prevY = this.y;
                
                // í†µí†µíƒ„: ë²½ì— ë§ìœ¼ë©´ íŠ•ê¹€ (ì¤‘ì²© íšŸìˆ˜ë§Œí¼)
                if (this.hasBouncy && this.bounceCount < this.maxBounces) {
                    const nextX = this.x + Math.cos(this.angle) * this.speed * normalizedDelta;
                    const nextY = this.y + Math.sin(this.angle) * this.speed * normalizedDelta;
                    
                    // ë²½ ì¶©ëŒ ê°ì§€
                    let hitWall = false;
                    let newAngle = this.angle;
                    
                    // ì™¼ìª½ ë²½ ë˜ëŠ” ì˜¤ë¥¸ìª½ ë²½ì— ì¶©ëŒ
                    if (nextX - this.radius < 0 || nextX + this.radius > canvas.width) {
                        hitWall = true;
                        // ë°˜ëŒ€ë°©í–¥ì—ì„œ Â±25ë„ (ìˆ˜í‰ ë°˜ì‚¬)
                        const reflectAngle = Math.PI - this.angle; // ë°˜ì‚¬ê°
                        const randomOffset = (Math.random() - 0.5) * 50 * Math.PI / 180; // Â±25ë„
                        newAngle = reflectAngle + randomOffset;
                    }
                    // ìœ„ìª½ ë²½ ë˜ëŠ” ì•„ë˜ìª½ ë²½ì— ì¶©ëŒ
                    if (nextY - this.radius < 0 || nextY + this.radius > canvas.height) {
                        hitWall = true;
                        // ë°˜ëŒ€ë°©í–¥ì—ì„œ Â±25ë„ (ìˆ˜ì§ ë°˜ì‚¬)
                        const reflectAngle = -this.angle; // ë°˜ì‚¬ê°
                        const randomOffset = (Math.random() - 0.5) * 50 * Math.PI / 180; // Â±25ë„
                        newAngle = reflectAngle + randomOffset;
                    }
                    
                    if (hitWall) {
                        this.bounceCount++;
                        this.angle = newAngle;
                        // ë²½ ê²½ê³„ë¡œ ìœ„ì¹˜ ì¡°ì • (ë§µ ê²½ê³„ ì‚¬ìš©)
                        this.x = Math.max(gameState.mapBounds.minX + this.radius, Math.min(gameState.mapBounds.maxX - this.radius, this.x));
                        this.y = Math.max(gameState.mapBounds.minY + this.radius, Math.min(gameState.mapBounds.maxY - this.radius, this.y));
                    } else {
                        this.x = nextX;
                        this.y = nextY;
                    }
                } else {
                    this.x += Math.cos(this.angle) * this.speed * normalizedDelta;
                    this.y += Math.sin(this.angle) * this.speed * normalizedDelta;
                }
                
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // í˜ì´ë“œ ì•„ì›ƒ íš¨ê³¼ (ê·¼ì ‘ì „ëª¨ë“œì—ì„œ ë©ˆì¶˜ ì´ì•Œ)
                let alpha = 1.0;
                if (this.isStopped && this.fadeStartTime > 0) {
                    const fadeElapsed = Date.now() - this.fadeStartTime;
                    const fadeDuration = 300; // 0.3ì´ˆ
                    alpha = Math.max(0, 1 - (fadeElapsed / fadeDuration));
                }
                ctx.globalAlpha = alpha;
                
                // ì§ì‚¬ê°í˜• ì´ì•Œ ê·¸ë¦¬ê¸° (ë„¤ì˜¨ íš¨ê³¼ ì¶”ê°€)
                // ë… íƒ„í™˜ì´ë©´ ì–´ë‘ìš´ ì´ˆë¡ìƒ‰, ì•„ë‹ˆë©´ í•˜ì–€ìƒ‰
                const bulletColor = this.hasPoison ? '#006600' : '#ffffff';
                ctx.fillStyle = bulletColor;
                ctx.shadowBlur = 10;
                ctx.shadowColor = bulletColor;
                const sizeMultiplier = this.owner.bulletSizeMultiplier || 1;
                const bulletWidth = 24 * sizeMultiplier; // ì´ì•Œ ë„ˆë¹„
                const bulletHeight = 9 * sizeMultiplier; // ì´ì•Œ ë†’ì´
                ctx.fillRect(-bulletWidth / 2, -bulletHeight / 2, bulletWidth, bulletHeight);
                
                ctx.globalAlpha = 1.0; // ë³µì›
                ctx.restore();
            }

            isOutOfBounds() {
                // ë§µ ê²½ê³„ ì²´í¬
                return this.x < gameState.mapBounds.minX || this.x > gameState.mapBounds.maxX || 
                       this.y < gameState.mapBounds.minY || this.y > gameState.mapBounds.maxY;
            }
        }

        // ì†Œìˆ˜ì  ë°˜ì˜¬ë¦¼ í—¬í¼ í•¨ìˆ˜: 1~2ìë¦¬ëŠ” ìœ ì§€, 3ìë¦¬ ì´ìƒì€ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
        function roundToMaxTwoDecimals(value) {
            const strValue = value.toString();
            const decimalIndex = strValue.indexOf('.');
            if (decimalIndex === -1) {
                return value; // ì •ìˆ˜ë©´ ê·¸ëŒ€ë¡œ
            }
            const decimalPart = strValue.substring(decimalIndex + 1);
            if (decimalPart.length <= 2) {
                return value; // 2ìë¦¬ ì´í•˜ë©´ ê·¸ëŒ€ë¡œ
            }
            // 3ìë¦¬ ì´ìƒì´ë©´ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
            return Math.round(value * 100) / 100;
        }

        // í™”ë©´ í”ë“¤ë¦¼ í•¨ìˆ˜
        function addScreenShake(intensity, duration) {
            gameState.shake.intensity = intensity;
            gameState.shake.duration = duration;
        }

        // ë°œì‚¬ í•¨ìˆ˜
        function shoot(character) {
            const now = Date.now();
            // ê¸°ì ˆ ìƒíƒœë©´ ë°œì‚¬ ë¶ˆê°€
            if (character.isStunned) return;
            if (character.ammo > 0 && !character.isReloading && 
                now - character.lastShot > character.shootCooldown) {
                
                // ë¹„ì‚°íƒ„ ì¦ê°•ì´ ìˆì„ ë•Œì˜ ë°œì‚¬ ì²˜ë¦¬
                if (character.hasScatter) {
                    // ë¹„ì‚°íƒ„: Â±4ë„ ë²”ìœ„ì—ì„œ 2ë„ ê°„ê²©ìœ¼ë¡œ 4ê°œë¡œ ë‚˜ëˆ” + ë°ë¯¸ì§€ 0.25ë°°
                    const scatterAngles = [-4, -2, 0, 2];
                    
                    // ë„ë°• ì¦ê°•: ê° ë°œì‚¬ë§ˆë‹¤ ëœë¤ ë°°ìœ¨ ì ìš©
                    let scatterGambleMultiplier = 1;
                    let scatterBaseAngle = character.angle;
                    if (character.hasGamble) {
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„
                        scatterBaseAngle = character.angle + randomAngle;
                        scatterGambleMultiplier = 1 + Math.random(); // 1~2ë°°
                    }
                    
                    if (character.hasShotgun) {
                        // ìƒ·ê±´ + ë¹„ì‚°íƒ„: ëª¨ë“  íƒ„ì•½ì„ ìƒ·ê±´ìœ¼ë¡œ ë°œì‚¬í•˜ë˜, ê° ì´ì•Œì„ ë¹„ì‚°íƒ„ìœ¼ë¡œ ë¶„ì‚°
                        const currentAmmo = character.ammo;
                        for (let i = 0; i < currentAmmo; i++) {
                            // Â±25ë„ ë²”ìœ„ ë‚´ ëœë¤ ê°ë„
                            const randomAngle = (Math.random() - 0.5) * (Math.PI * 50 / 180); // -25ë„ ~ +25ë„
                            const baseAngle = scatterBaseAngle + randomAngle;
                            
                            // ê° ì´ì•Œì„ ë¹„ì‚°íƒ„ìœ¼ë¡œ ë¶„ì‚°
                            scatterAngles.forEach(angleDeg => {
                                const angle = baseAngle + (angleDeg * Math.PI / 180);
                                const bullet = new Bullet(
                                    character.x + Math.cos(character.angle) * character.radius,
                                    character.y + Math.sin(character.angle) * character.radius,
                                    angle,
                                    character,
                                    false
                                );
                                // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                                if (character.hasGamble) {
                                    bullet.damage = Math.round(bullet.damage * scatterGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                                }
                                bullet.damage = bullet.damage * 0.25; // ë°ë¯¸ì§€ 0.25ë°°
                                character.bullets.push(bullet);
                            });
                        }
                        character.ammo = 0; // ëª¨ë“  íƒ„ì•½ ì†Œëª¨
                        character.lastShot = now;
                    } else {
                        // ë¹„ì‚°íƒ„ë§Œ: í•œ ë°œì”© ë°œì‚¬í•  ë•Œ Â±4ë„ ë²”ìœ„ì—ì„œ 2ë„ ê°„ê²©ìœ¼ë¡œ 4ê°œë¡œ ë‚˜ëˆ”
                        scatterAngles.forEach(angleDeg => {
                            const angle = scatterBaseAngle + (angleDeg * Math.PI / 180);
                            const bullet = new Bullet(
                                character.x + Math.cos(character.angle) * character.radius,
                                character.y + Math.sin(character.angle) * character.radius,
                                angle,
                                character,
                                false
                            );
                            // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                            if (character.hasGamble) {
                                bullet.damage = Math.round(bullet.damage * scatterGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                            }
                            bullet.damage = bullet.damage * 0.25; // ë°ë¯¸ì§€ 0.25ë°°
                            character.bullets.push(bullet);
                        });
                        character.ammo--; // í•œ ë°œë§Œ ì†Œëª¨
                        character.lastShot = now;
                    }
                } else if (character.hasShotgun) {
                // ìƒ·ê±´ ì¦ê°•: ëª¨ë“  íƒ„ì•½ì„ Â±25ë„ ë²”ìœ„ì—ì„œ í•œë²ˆì— ë°œì‚¬
                    // ë„ë°• ì¦ê°•: ê° ë°œì‚¬ë§ˆë‹¤ ëœë¤ ë°°ìœ¨ ì ìš©
                    let shotgunGambleMultiplier = 1;
                    if (character.hasGamble) {
                        shotgunGambleMultiplier = 1 + Math.random(); // 1~2ë°°
                    }
                    
                    const currentAmmo = character.ammo;
                    for (let i = 0; i < currentAmmo; i++) {
                        // Â±25ë„ ë²”ìœ„ ë‚´ ëœë¤ ê°ë„
                        let randomAngle = (Math.random() - 0.5) * (Math.PI * 50 / 180); // -25ë„ ~ +25ë„
                        // ë„ë°• ì¦ê°•: ê°ë„ì—ë„ Â±10ë„ ì¶”ê°€
                        if (character.hasGamble) {
                            randomAngle += (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„ ì¶”ê°€
                        }
                const bullet = new Bullet(
                    character.x + Math.cos(character.angle) * character.radius,
                    character.y + Math.sin(character.angle) * character.radius,
                            character.angle + randomAngle,
                    character,
                    false
                );
                        // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                        if (character.hasGamble) {
                            bullet.damage = Math.round(bullet.damage * shotgunGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                        }
                        character.bullets.push(bullet);
                    }
                    character.ammo = 0; // ëª¨ë“  íƒ„ì•½ ì†Œëª¨
                    character.lastShot = now;
                } else {
                    // ì¼ë°˜ ë°œì‚¬
                    let bulletAngle = character.angle;
                    let bulletDamage = character.damage || 1;
                    
                    // ë„ë°• ì¦ê°•: Â±10ë„ ëœë¤ ê°ë„, ë°ë¯¸ì§€ 1~2ë°° ëœë¤
                    let gambleMultiplier = 1;
                    if (character.hasGamble) {
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„
                        bulletAngle = character.angle + randomAngle;
                        gambleMultiplier = 1 + Math.random(); // 1~2ë°°
                    }
                    
                    // ë¹„ì‚°íƒ„ì´ ìˆìœ¼ë©´ ì¼ë°˜ ë°œì‚¬ë„ ë¹„ì‚°íƒ„ìœ¼ë¡œ ë¶„ì‚°
                    if (character.hasScatter) {
                        const scatterAngles = [-4, -2, 0, 2];
                        scatterAngles.forEach(angleDeg => {
                            const scatterAngle = bulletAngle + (angleDeg * Math.PI / 180);
                            const bullet = new Bullet(
                                character.x + Math.cos(character.angle) * character.radius,
                                character.y + Math.sin(character.angle) * character.radius,
                                scatterAngle,
                                character,
                                false
                            );
                            // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                            if (character.hasGamble) {
                                bullet.damage = Math.round(bullet.damage * gambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                            }
                            bullet.damage = bullet.damage * 0.25; // ë°ë¯¸ì§€ 0.25ë°°
                            character.bullets.push(bullet);
                        });
                    } else {
                        const bullet = new Bullet(
                            character.x + Math.cos(character.angle) * character.radius,
                            character.y + Math.sin(character.angle) * character.radius,
                            bulletAngle,
                            character,
                            false
                        );
                        // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                        if (character.hasGamble) {
                            bullet.damage = Math.round(bullet.damage * gambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                        }
                        character.bullets.push(bullet);
                    }
                    character.ammo--;
                    character.lastShot = now;

                // ë”ë¸”ìƒ· (í™•ë¥  ì¤‘ì²©: 25% * count)
                const doubleShotCount = character.doubleShotCount || 1;
                if (character.hasDoubleShot && Math.random() < (0.25 * doubleShotCount)) {
                    // Â±15ë„ ì‚¬ì´ì˜ ëœë¤ ê°ë„
                    const randomAngle = (Math.random() - 0.5) * (Math.PI * 30 / 180); // -15ë„ ~ +15ë„
                    let doubleBulletAngle = character.angle + randomAngle;
                    
                    // ë”ë¸”ìƒ·ì—ë„ ë„ë°• ì¦ê°• ì ìš© (ê°ë„ë§Œ, ë°ë¯¸ì§€ëŠ” ì´ì•Œ ìƒì„± í›„ ì ìš©)
                    let doubleGambleMultiplier = 1;
                    if (character.hasGamble) {
                        const doubleRandomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„
                        doubleBulletAngle = character.angle + doubleRandomAngle;
                        doubleGambleMultiplier = 1 + Math.random(); // 1~2ë°°
                    }
                    
                    // ë”ë¸”ìƒ·ì—ë„ ë¹„ì‚°íƒ„ ì ìš©
                    if (character.hasScatter) {
                        const scatterAngles = [-4, -2, 0, 2];
                        scatterAngles.forEach(angleDeg => {
                            const angle = doubleBulletAngle + (angleDeg * Math.PI / 180);
                            const doubleBullet = new Bullet(
                                character.x + Math.cos(character.angle) * character.radius,
                                character.y + Math.sin(character.angle) * character.radius,
                                angle,
                                character,
                                true // íƒ„ì•½ ì†Œëª¨ ì—†ìŒ
                            );
                            // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                            if (character.hasGamble) {
                                doubleBullet.damage = Math.round(doubleBullet.damage * doubleGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                            }
                            doubleBullet.damage = doubleBullet.damage * 0.25; // ë°ë¯¸ì§€ 0.25ë°°
                            character.bullets.push(doubleBullet);
                        });
                    } else {
                        const doubleBullet = new Bullet(
                            character.x + Math.cos(character.angle) * character.radius,
                            character.y + Math.sin(character.angle) * character.radius,
                            doubleBulletAngle,
                            character,
                            true // íƒ„ì•½ ì†Œëª¨ ì—†ìŒ
                        );
                        // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                        if (character.hasGamble) {
                            doubleBullet.damage = Math.round(doubleBullet.damage * doubleGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                        }
                        character.bullets.push(doubleBullet);
                    }
                    }
                }

                // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼ (í”Œë ˆì´ì–´ ë°œì‚¬ ì‹œì—ë§Œ)
                if (character === player) {
                    addScreenShake(18, 200);
                }

                // ìë™ ì¬ì¥ì „
                if (character.ammo === 0 && !character.isReloading) {
                    reload(character);
                }
                
                // ë©€í‹°í”Œë ˆì´ì–´: í”Œë ˆì´ì–´ê°€ ìœ ì´ì•Œ ì •ë³´ ì „ì†¡
                if (gameState.isMultiplayer && character === player && character.bullets.length > 0) {
                    // ë°©ê¸ˆ ì¶”ê°€ëœ ì´ì•Œë“¤ë§Œ ì „ì†¡ (ë§ˆì§€ë§‰ì— ì¶”ê°€ëœ ì´ì•Œ)
                    const newBullets = character.bullets.slice(-10); // ìµœëŒ€ 10ê°œ (ìƒ·ê±´/ë¹„ì‚°íƒ„ ëŒ€ë¹„)
                    sendShootData(newBullets);
                }
            }
        }

        // ì¬ì¥ì „ í•¨ìˆ˜
        function reload(character) {
            if (character.ammo < character.maxAmmo && !character.isReloading) {
                character.isReloading = true;
                character.reloadStartTime = Date.now();
                
                setTimeout(() => {
                    character.ammo = character.maxAmmo;
                    character.isReloading = false;
                    character.reloadStartTime = 0;
                    
                    // ì¬ì¥ì „ íšŒë³µ ì¦ê°• (íšŒë³µëŸ‰ ì¤‘ì²©)
                    if (character.hasReloadHeal) {
                        const reloadHealCount = character.reloadHealCount || 1;
                        character.health = Math.min(character.health + (1 * reloadHealCount), character.maxHealth);
                    }
                }, character.reloadTime);
            }
        }

        // ì¶©ëŒ ê°ì§€
        function checkCollision(bullet, target) {
            const dx = bullet.x - target.x;
            const dy = bullet.y - target.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < bullet.radius + target.radius;
        }
        
        // ì´ì•Œê³¼ ì§ì‚¬ê°í˜• ì¥ì• ë¬¼ ì¶©ëŒ ê°ì§€
        function checkBulletObstacleCollision(bullet, obstacle) {
            if (!gameState.isMultiplayer || !gameState.obstacles) return false;
            
            // íšŒì „ëœ ì§ì‚¬ê°í˜•ì˜ ëª¨ì„œë¦¬ ì¢Œí‘œ ê³„ì‚°
            const cos = Math.cos(obstacle.angle);
            const sin = Math.sin(obstacle.angle);
            const hw = obstacle.width / 2;
            const hh = obstacle.height / 2;
            
            // ì§ì‚¬ê°í˜•ì˜ 4ê°œ ëª¨ì„œë¦¬ (ë¡œì»¬ ì¢Œí‘œ)
            const corners = [
                { x: -hw, y: -hh },
                { x: hw, y: -hh },
                { x: hw, y: hh },
                { x: -hw, y: hh }
            ];
            
            // ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜
            const worldCorners = corners.map(c => ({
                x: obstacle.x + c.x * cos - c.y * sin,
                y: obstacle.y + c.x * sin + c.y * cos
            }));
            
            // ì´ì•Œ ìœ„ì¹˜ë¥¼ ì§ì‚¬ê°í˜•ì˜ ë¡œì»¬ ì¢Œí‘œë¡œ ë³€í™˜
            const dx = bullet.x - obstacle.x;
            const dy = bullet.y - obstacle.y;
            const localX = dx * cos + dy * sin;
            const localY = -dx * sin + dy * cos;
            
            // AABB ì¶©ëŒ ê°ì§€ (ë¡œì»¬ ì¢Œí‘œì—ì„œ)
            if (Math.abs(localX) < hw + bullet.radius && Math.abs(localY) < hh + bullet.radius) {
                // ë” ì •í™•í•œ ì¶©ëŒ ê°ì§€ë¥¼ ìœ„í•´ ê°€ì¥ ê°€ê¹Œìš´ ëª¨ì„œë¦¬ê¹Œì§€ì˜ ê±°ë¦¬ í™•ì¸
                let minDist = Infinity;
                for (let i = 0; i < worldCorners.length; i++) {
                    const next = worldCorners[(i + 1) % worldCorners.length];
                    const dist = pointToLineSegmentDistance(bullet.x, bullet.y, 
                                                           worldCorners[i].x, worldCorners[i].y,
                                                           next.x, next.y);
                    minDist = Math.min(minDist, dist);
                }
                return minDist < bullet.radius;
            }
            
            return false;
        }
        
        // í”Œë ˆì´ì–´/ì ê³¼ ì§ì‚¬ê°í˜• ì¥ì• ë¬¼ ì¶©ëŒ ê°ì§€
        function checkCharacterObstacleCollision(character, obstacle) {
            if (!gameState.isMultiplayer || !gameState.obstacles) return false;
            
            // íšŒì „ëœ ì§ì‚¬ê°í˜•ì˜ ë¡œì»¬ ì¢Œí‘œë¡œ ë³€í™˜
            const cos = Math.cos(obstacle.angle);
            const sin = Math.sin(obstacle.angle);
            const dx = character.x - obstacle.x;
            const dy = character.y - obstacle.y;
            const localX = dx * cos + dy * sin;
            const localY = -dx * sin + dy * cos;
            
            // AABB ì¶©ëŒ ê°ì§€ (ë¡œì»¬ ì¢Œí‘œì—ì„œ)
            const hw = obstacle.width / 2;
            const hh = obstacle.height / 2;
            
            // ìºë¦­í„° ë°˜ì§€ë¦„ì„ ê³ ë ¤í•œ ì¶©ëŒ ì²´í¬
            if (Math.abs(localX) < hw + character.radius && Math.abs(localY) < hh + character.radius) {
                return true;
            }
            
            return false;
        }
        
        // ì ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬ ê³„ì‚°
        function pointToLineSegmentDistance(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSq = dx * dx + dy * dy;
            
            if (lengthSq === 0) {
                // ì„ ë¶„ì´ ì ì¸ ê²½ìš°
                const dx2 = px - x1;
                const dy2 = py - y1;
                return Math.sqrt(dx2 * dx2 + dy2 * dy2);
            }
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            const dx2 = px - projX;
            const dy2 = py - projY;
            return Math.sqrt(dx2 * dx2 + dy2 * dy2);
        }

        // êµ¬ë¥´ê¸° í•¨ìˆ˜
        function dodge(character) {
            const now = Date.now();
            // ê¸°ì ˆ ìƒíƒœë©´ êµ¬ë¥´ê¸° ë¶ˆê°€
            if (character.isStunned) return;
            // ì¿¨íƒ€ì„ ì²´í¬ (3ì´ˆ)
            if (character.isDodging || now - character.lastDodgeTime < 3000) return;
            
            character.isDodging = true;
            const dodgeDistance = character.radius * 6.4; // í”Œë ˆì´ì–´ í¬ê¸°ì˜ 3.2ë°° (20% ê°ì†Œ: 8 -> 6.4)
            const dodgeDuration = 300; // 0.3ì´ˆ
            character.dodgeStartTime = now; // êµ¬ë¥´ê¸° ì‹œì‘ ì‹œê°„
            character.dodgeEndTime = now + dodgeDuration;
            character.lastDodgeTime = now; // ì¿¨íƒ€ì„ ì‹œì‘
            character.dodgeTrail = []; // ì”ìƒ ì´ˆê¸°í™”
            
            // êµ¬ë¥´ê¸° ì‹œì‘ ìœ„ì¹˜ ì €ì¥
            character.dodgeStartX = character.x;
            character.dodgeStartY = character.y;
            character.dodgeTrail.push({ x: character.x, y: character.y, alpha: 0.5 });
            
            // êµ¬ë¥´ê¸° ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            const targetX = character.x + Math.cos(character.angle) * dodgeDistance;
            const targetY = character.y + Math.sin(character.angle) * dodgeDistance;
            
            // ê²½ê³„ ì²´í¬
            character.dodgeTargetX = Math.max(character.radius, Math.min(canvas.width - character.radius, targetX));
            character.dodgeTargetY = Math.max(character.radius, Math.min(canvas.height - character.radius, targetY));
        }

        // í”Œë ˆì´ì–´ ì´ë™
        function updatePlayer(deltaTime = 16.67) {
            const now = Date.now();
            // deltaTimeì„ 60fps ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™” (ê¸°ë³¸ê°’ 16.67ms = 60fps)
            const normalizedDelta = deltaTime / 16.67;
            
            // ì‹œê°„ì •ì§€ ìƒíƒœ ì²´í¬ (ìƒëŒ€ê°€ ì‹œê°„ì •ì§€ ì¤‘ì´ë©´ ì˜í–¥ ì—†ìŒ)
            // ì‹œê°„ì •ì§€ê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì•„ë¬´ê²ƒë„ í•  ìˆ˜ ì—†ìŒ
            
            // êµ¬ë¥´ê¸° ìƒíƒœ ì²´í¬
            if (player.isDodging) {
                if (now >= player.dodgeEndTime) {
                    // êµ¬ë¥´ê¸° ì™„ë£Œ
                    player.x = player.dodgeTargetX;
                    player.y = player.dodgeTargetY;
                    player.isDodging = false;
                    player.dodgeTrail = [];
                } else {
                    // êµ¬ë¥´ëŠ” ë™ì•ˆ ë¹ ë¥¸ ì†ë„ë¡œ ì´ë™
                    const elapsed = now - player.dodgeStartTime; // ì‹œì‘ ì‹œê°„ìœ¼ë¡œë¶€í„°ì˜ ê²½ê³¼ ì‹œê°„
                    const progress = Math.min(elapsed / 300, 1); // 0~1 (300ms = 0.3ì´ˆ)
                    
                    // ì‹œì‘ ìœ„ì¹˜ì—ì„œ ëª©í‘œ ìœ„ì¹˜ë¡œ ì„ í˜• ë³´ê°„
                    player.x = player.dodgeStartX + (player.dodgeTargetX - player.dodgeStartX) * progress;
                    player.y = player.dodgeStartY + (player.dodgeTargetY - player.dodgeStartY) * progress;
                    
                    // ì”ìƒ ì—…ë°ì´íŠ¸ (ë§¤ í”„ë ˆì„ë§ˆë‹¤)
                    if (!player.dodgeTrail) player.dodgeTrail = [];
                    player.dodgeTrail.push({ x: player.x, y: player.y, alpha: 0.3 });
                    // ì”ìƒì´ ë„ˆë¬´ ë§ì•„ì§€ë©´ ì œê±°
                    if (player.dodgeTrail.length > 5) {
                        player.dodgeTrail.shift();
                    }
                }
                return; // êµ¬ë¥´ëŠ” ì¤‘ì—ëŠ” ì¼ë°˜ ì´ë™ ë¶ˆê°€
            }

            // ë¶€í™œ ì²˜ë¦¬
            if (player.isReviving) {
                if (now >= player.reviveTime) {
                    player.isReviving = false;
                    player.health = 1;
                    // displayHealthëŠ” ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ìë™ ì—…ë°ì´íŠ¸ë¨
                    player.isInvincible = true;
                    player.invincibleEndTime = now + 1000; // 1ì´ˆ ë¬´ì 
                    // ë¶€í™œ íšŸìˆ˜ í™•ì¸ - ì•„ì§ ë” ë¶€í™œí•  ìˆ˜ ìˆìœ¼ë©´ ê³„ì† ì§„í–‰
                    const reviveCount = player.reviveCount || 1;
                    const hasRevivedCount = (typeof player.hasRevived === 'number' ? player.hasRevived : (player.hasRevived ? 1 : 0));
                    if (hasRevivedCount >= reviveCount) {
                        // ë” ì´ìƒ ë¶€í™œ ë¶ˆê°€
                    }
                }
                return; // ë¶€í™œ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            }

            // ë¬´ì  ìƒíƒœ ì²´í¬
            if (player.isInvincible && now >= player.invincibleEndTime) {
                player.isInvincible = false;
            }

            // ì•½í™” ìƒíƒœ ì²´í¬
            if (player.isWeakened && now >= player.weakenEndTime) {
                player.isWeakened = false;
                // ì•½í™”ëŠ” ì´ì•Œ ìƒì„± ì‹œì—ë§Œ ë°ë¯¸ì§€ë¥¼ ê°ì†Œì‹œí‚¤ë¯€ë¡œ, damage ìì²´ëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ
            }
            
            // ì‚¬ì‹  ì¦ê°•: ì€ì‹  ì¢…ë£Œ ì²´í¬
            if (player.isInvisible && now >= player.invisibilityEndTime) {
                player.isInvisible = false;
            }
            
            // ê³¼ì¶©ì „: ì¢…ë£Œ ë° ì¿¨íƒ€ì„ ì²´í¬
            if (player.overchargeActive && now >= player.overchargeEndTime) {
                player.overchargeActive = false;
            }
            if (player.overchargeCooldown > 0 && now >= player.overchargeCooldown) {
                player.overchargeCooldown = 0;
            }

            // ê¸°ì ˆ ìƒíƒœ ì²´í¬
            if (player.isStunned && now >= player.stunEndTime) {
                player.isStunned = false;
            }

            // ë°©ì–´ë§‰ ì¿¨íƒ€ì„ ì²´í¬
            if (player.hasShield && !player.shieldReady && now >= player.shieldCooldown) {
                player.shieldReady = true;
            }
            
            // ë°˜ì‚¬ ì¿¨íƒ€ì„ ì²´í¬
            if (player.hasReflect && !player.reflectActive && now >= player.reflectCooldown) {
                player.reflectCooldown = 0; // ì¿¨íƒ€ì„ ì™„ë£Œ
            }
            
            // ë°˜ì‚¬ ë³´í˜¸ë§‰ ì¢…ë£Œ ì²´í¬
            if (player.reflectActive && now >= player.reflectEndTime) {
                player.reflectActive = false;
                player.reflectCooldown = now + 5000; // 5ì´ˆ ì¿¨íƒ€ì„
            }
            
            // ì‹œê°„ì •ì§€ ì¿¨íƒ€ì„ ì²´í¬
            if (player.hasTimeStop && now >= player.timeStopCooldown) {
                player.timeStopCooldown = 0; // ì¿¨íƒ€ì„ ì™„ë£Œ
            }
            
            // ì‹œê°„ì •ì§€ ì¢…ë£Œ ì²´í¬
            if (player.timeStopActive && now >= player.timeStopEndTime) {
                player.timeStopActive = false;
                player.timeStopCooldown = now + 10000; // 10ì´ˆ ì¿¨íƒ€ì„
            }

            // í”¼ê²© ì´í™íŠ¸ ì—…ë°ì´íŠ¸
            if (player.hitEffectParticles) {
                for (let i = player.hitEffectParticles.length - 1; i >= 0; i--) {
                    const particle = player.hitEffectParticles[i];
                    particle.life -= deltaTime / 1000;
                    
                    // dot, triangle, square, burst íƒ€ì…ì€ ì´ë™ (í¼ì§€ëŠ” íš¨ê³¼)
                    if ((particle.type === 'dot' || particle.type === 'triangle' || particle.type === 'square' || particle.type === 'burst') && particle.vx !== undefined) {
                        particle.x += particle.vx * (deltaTime / 1000);
                        particle.y += particle.vy * (deltaTime / 1000);
                        // ê°ì†
                        particle.vx *= 0.95;
                        particle.vy *= 0.95;
                    }
                    
                    // firework íƒ€ì…ì€ ì§ì‚¬ê°í˜•ì´ í¼ì§€ë©´ì„œ ê¸¸ì–´ì§€ëŠ” íš¨ê³¼ (ê°ì† íš¨ê³¼ í¬í•¨)
                    if (particle.type === 'firework') {
                        // ì†ë„ê°€ ì ì  ì¤„ì–´ë“¤ë©´ì„œ í¼ì§
                        if (!particle.speed) {
                            particle.speed = 1.0;
                        }
                        // ê°ì† íš¨ê³¼ (ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ì†ë„ ê°ì†Œ)
                        const lifeProgress = 1 - (particle.life / particle.maxLife);
                        particle.speed = Math.max(0.1, 1.0 - lifeProgress * 0.9); // ìµœì†Œ 0.1ê¹Œì§€ ê°ì†Œ
                    }
                    
                    // ring íƒ€ì…ì€ í¬ê¸° ì¦ê°€
                    if (particle.type === 'ring' && particle.maxSize !== undefined) {
                        const progress = 1 - (particle.life / particle.maxLife);
                        particle.size = particle.size + (particle.maxSize - particle.size) * progress * 0.1;
                    }
                    
                    if (particle.life <= 0) {
                        player.hitEffectParticles.splice(i, 1);
                    }
                }
            }
            
            // ì¬ìƒ: 1ì´ˆë§ˆë‹¤ ì²´ë ¥ 0.1 íšŒë³µ (íšŒë³µëŸ‰ ì¤‘ì²©)
            if (player.hasRegeneration) {
                if (now - player.lastRegenTime >= 1000) {
                    const regenerationCount = player.regenerationCount || 1;
                    player.health = Math.min(player.health + (0.1 * regenerationCount), player.maxHealth);
                    player.lastRegenTime = now;
                }
            }

            // ê¸°ì ˆ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            if (player.isStunned) {
                return;
            }
            
            // ì„ ê³ : ë°€ë ¤ë‚˜ëŠ” íš¨ê³¼ ì²˜ë¦¬
            if (player.isJudgmentPushing) {
                const elapsed = now - player.judgmentPushStartTime;
                const progress = Math.min(1, elapsed / player.judgmentPushDuration);
                
                // ë¶€ë“œëŸ¬ìš´ ì´ë™ (ease-out)
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                player.x = player.judgmentPushStartX + (player.judgmentPushTargetX - player.judgmentPushStartX) * easeProgress;
                player.y = player.judgmentPushStartY + (player.judgmentPushTargetY - player.judgmentPushStartY) * easeProgress;
                
                // ê²½ê³„ ì²´í¬
                player.x = Math.max(gameState.mapBounds.minX + player.radius, Math.min(gameState.mapBounds.maxX - player.radius, player.x));
                player.y = Math.max(gameState.mapBounds.minY + player.radius, Math.min(gameState.mapBounds.maxY - player.radius, player.y));
                
                if (progress >= 1) {
                    player.isJudgmentPushing = false;
                } else {
                    return; // ë°€ë ¤ë‚˜ëŠ” ì¤‘ì—ëŠ” ë‹¤ë¥¸ ì´ë™ ë¶ˆê°€
                }
            }

            // ì´ë™ì†ë„ ê°ì†Œ ì²˜ë¦¬ (ê¹Šì€ ìƒì²˜)
            let currentSpeed = player.speed;
            if (now < player.slowEndTime) {
                    currentSpeed *= 0.75; // -25%
                }
            
            // ì‚¬ì‹  ì¦ê°•: ì€ì‹  ì¤‘ ì´ë™ì†ë„ +15%
            if (player.isInvisible && now < player.invisibilityEndTime) {
                currentSpeed *= 1.15;
            }
            
            // ê³¼ì¶©ì „: í™œì„±í™” ì¤‘ ì´ë™ì†ë„ +33%
            if (player.overchargeActive && now < player.overchargeEndTime) {
                currentSpeed *= 1.33;
                // ê³¼ì¶©ì „ ì”ìƒ ì¶”ê°€ (íŒŒë€ìƒ‰)
                if (!player.overchargeTrail) player.overchargeTrail = [];
                player.overchargeTrail.push({ x: player.x, y: player.y, alpha: 0.6 });
                // ì”ìƒì´ ë„ˆë¬´ ë§ì•„ì§€ë©´ ì œê±°
                if (player.overchargeTrail.length > 8) {
                    player.overchargeTrail.shift();
                }
            } else {
                // ê³¼ì¶©ì „ ë¹„í™œì„±í™” ì‹œ ì”ìƒ ì´ˆê¸°í™”
                if (player.overchargeTrail) player.overchargeTrail = [];
            }
            
            // íšŒí”¼ê¸°ë™: ì¬ì¥ì „ ì¤‘ ì´ë™ì†ë„ +75% (ì¤‘ì²©)
            if (player.hasEvasiveManeuver && player.isReloading) {
                const evasiveManeuverCount = player.evasiveManeuverCount || 1;
                currentSpeed *= (1 + 0.75 * evasiveManeuverCount);
            }
            
            // ìƒì¡´ë³¸ëŠ¥: ì²´ë ¥ì´ 1ì¼ ë•Œ ì´ë™ì†ë„ +50% (ì¤‘ì²©)
            if (player.hasSurvivalInstinct && player.health === 1) {
                const survivalInstinctCount = player.survivalInstinctCount || 1;
                currentSpeed *= (1 + 0.5 * survivalInstinctCount);
            }
            
            // íšŒë³µê³„ì•½: ì²´ë ¥ì´ 1ì¼ ë•Œ ì²´ë ¥ 2íšŒë³µ (íšŒë³µëŸ‰ ì¤‘ì²©)
            if (player.hasRecoveryContract && !player.hasRecoveryContractUsed && player.health === 1) {
                const recoveryContractCount = player.recoveryContractCount || 1;
                player.health = Math.min(player.health + (2 * recoveryContractCount), player.maxHealth);
                player.hasRecoveryContractUsed = true;
            }
            
            // í•´ë¥˜: ì´ë™ì†ë„ê°€ -25%ì™€ +50%ë¡œ 3ì´ˆë§ˆë‹¤ ë²ˆê°ˆì•„ ë°˜ë³µ
            if (player.hasTide) {
                if (player.tideStartTime === 0) {
                    player.tideStartTime = now;
                }
                const elapsed = now - player.tideStartTime;
                const phase = Math.floor(elapsed / 3000) % 2; // 0 ë˜ëŠ” 1 (3ì´ˆë§ˆë‹¤ ì „í™˜)
                if (phase === 0) {
                    // +50% í˜ì´ì¦ˆ
                    currentSpeed *= 1.5;
                } else {
                    // -25% í˜ì´ì¦ˆ
                    currentSpeed *= 0.75;
                }
            }
            
            // ë§ê°: 30ì´ˆ í›„ ê°•ë ¥í•œ ë²„í”„ í™œì„±í™”
            if (player.hasOblivion && !player.oblivionActivated) {
                if (player.oblivionStartTime === 0) {
                    player.oblivionStartTime = now;
                }
                const elapsed = now - player.oblivionStartTime;
                if (elapsed >= 30000) { // 30ì´ˆ í›„
                    player.oblivionActivated = true;
                    // ì´ì•Œ ì†ë„ 300% ì¦ê°€ (ì›ë˜ ì†ë„ * 4)
                    player.bulletSpeedMultiplier = (player.bulletSpeedMultiplier || 1) * 4;
                    // ì´ì•Œ ë°ë¯¸ì§€ 300% ì¦ê°€ (ì›ë˜ ë°ë¯¸ì§€ * 4)
                    player.damage = (player.damage || 1) * 4;
                    // ìµœëŒ€ ì²´ë ¥ìœ¼ë¡œ íšŒë³µ
                    player.health = player.maxHealth;
                    player.displayHealth = player.maxHealth;
                    // ê¸€ë¦¬ì¹˜ íš¨ê³¼ (ì‹œê°ì  íš¨ê³¼ëŠ” draw í•¨ìˆ˜ì—ì„œ ì²˜ë¦¬)
                }
            }

            let dx = 0;
            let dy = 0;

            // ë¬´ë¹™ì›Œí¬ëª¨ë“œ: 5ì´ˆë§ˆë‹¤ ë°”ë€ŒëŠ” ë°©í–¥ìœ¼ë¡œ ì´ˆë‹¹ 25px ì´ë™ + WASD ì…ë ¥ë„ ê°€ëŠ¥
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'movingWork') {
                // ìœ„, ì•„ë˜, ì¢Œ, ìš° 4ë°©í–¥ ì¤‘ 1ê°œ ì„ íƒ
                if (!gameState.movingWorkDirection) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // ìš°, ì•„ë˜, ì¢Œ, ìœ„
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // 5ì´ˆë§ˆë‹¤ ë°©í–¥ ë³€ê²½
                if (now - gameState.movingWorkLastChange >= 5000) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // ìš°, ì•„ë˜, ì¢Œ, ìœ„
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // ì´ˆë‹¹ 25px ì´ë™ (ë¶€ë“œëŸ½ê²Œ)
                const moveSpeed = 25 / 60; // 60fps ê¸°ì¤€
                let autoDx = Math.cos(gameState.movingWorkDirection) * moveSpeed * normalizedDelta;
                let autoDy = Math.sin(gameState.movingWorkDirection) * moveSpeed * normalizedDelta;
                
                // WASD ì…ë ¥ë„ ë°›ê¸°
                if (keys['w']) dy -= 1;
                if (keys['s']) dy += 1;
                if (keys['a']) dx -= 1;
                if (keys['d']) dx += 1;
                
                // ëŒ€ê°ì„  ì´ë™ ì •ê·œí™”
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                // ìë™ ì´ë™ê³¼ WASD ì…ë ¥ í•©ì‚°
                dx += autoDx;
                dy += autoDy;
            } else {
                // ì¼ë°˜ ì´ë™
                // ê¸°ê³„í™”: ìƒí•˜ì¢Œìš°ë¡œë§Œ ì´ë™ ê°€ëŠ¥
                if (player.hasMechanization) {
                    // ê°€ì¥ ê°€ê¹Œìš´ ë°©í–¥ìœ¼ë¡œ ì •ê·œí™”
                    let inputX = 0;
                    let inputY = 0;
                    if (keys['w']) inputY -= 1;
                    if (keys['s']) inputY += 1;
                    if (keys['a']) inputX -= 1;
                    if (keys['d']) inputX += 1;
                    
                    // ìƒí•˜ì¢Œìš° ì¤‘ ê°€ì¥ ê°•í•œ ë°©í–¥ìœ¼ë¡œë§Œ ì´ë™
                    if (Math.abs(inputX) > Math.abs(inputY)) {
                        dx = inputX > 0 ? 1 : (inputX < 0 ? -1 : 0);
                        dy = 0;
                    } else if (Math.abs(inputY) > Math.abs(inputX)) {
                        dx = 0;
                        dy = inputY > 0 ? 1 : (inputY < 0 ? -1 : 0);
                    } else if (inputX !== 0 || inputY !== 0) {
                        // ê°™ì€ ê°•ë„ë©´ ìš°ì„ ìˆœìœ„: ìœ„ > ì•„ë˜ > ì™¼ìª½ > ì˜¤ë¥¸ìª½
                        if (inputY < 0) { dy = -1; dx = 0; }
                        else if (inputY > 0) { dy = 1; dx = 0; }
                        else if (inputX < 0) { dx = -1; dy = 0; }
                        else if (inputX > 0) { dx = 1; dy = 0; }
                    }
                } else {
                    // ì¼ë°˜ ì´ë™
                    if (keys['w']) dy -= 1;
                    if (keys['s']) dy += 1;
                    if (keys['a']) dx -= 1;
                    if (keys['d']) dx += 1;
                }
                
                // ëŒ€ê°ì„  ì´ë™ ì •ê·œí™”
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
            }

            // ê±°ì í™•ë³´: ìœ„ì¹˜ ë³€í™” ì²´í¬
            if (player.hasFortify) {
                const moved = Math.abs(player.x - (player.lastPosition?.x || player.x)) > 0.1 || 
                             Math.abs(player.y - (player.lastPosition?.y || player.y)) > 0.1;
                
                if (moved) {
                    // ì›€ì§ì„: ê±°ì  í™•ë³´ í•´ì œ
                    player.isFortified = false;
                    player.stationaryTime = 0;
                    if (!player.lastPosition) player.lastPosition = { x: player.x, y: player.y };
                    player.lastPosition.x = player.x;
                    player.lastPosition.y = player.y;
                } else {
                    // ì •ì§€: ì‹œê°„ ëˆ„ì 
                    if (!player.lastPosition) player.lastPosition = { x: player.x, y: player.y };
                    player.stationaryTime += 16; // ì•½ 60fps ê¸°ì¤€
                    
                    // 3ì´ˆ(3000ms) ë™ì•ˆ ì •ì§€í•˜ë©´ ê±°ì  í™•ë³´
                    if (player.stationaryTime >= 3000 && !player.isFortified) {
                        player.isFortified = true;
                        player.fortifyStartTime = now;
                    }
                }
            }

            // ë¹™íŒëª¨ë“œ: ë¯¸ë„ëŸ¬ì§ íš¨ê³¼
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'ice') {
                // ì†ë„ ë²¡í„° ì´ˆê¸°í™”
                if (!player.velocityX) player.velocityX = 0;
                if (!player.velocityY) player.velocityY = 0;
                
                // ì…ë ¥ì´ ìˆìœ¼ë©´ ì†ë„ ë²¡í„° ì—…ë°ì´íŠ¸
                if (dx !== 0 || dy !== 0) {
                    player.velocityX = dx * currentSpeed;
                    player.velocityY = dy * currentSpeed;
                }
                
                // ë§ˆì°° ì ìš© (ì†ë„ ê°ì†Œ) - ë¹™íŒëª¨ë“œì—ì„œëŠ” í›¨ì”¬ ë” ì˜ ë¯¸ë„ëŸ¬ì§
                player.velocityX *= 0.995;
                player.velocityY *= 0.995;
                
                // ì†ë„ê°€ ë§¤ìš° ì‘ìœ¼ë©´ ì •ì§€
                if (Math.abs(player.velocityX) < 0.01) player.velocityX = 0;
                if (Math.abs(player.velocityY) < 0.01) player.velocityY = 0;
                
                // ì†ë„ ë²¡í„°ë¡œ ì´ë™ (deltaTime ì •ê·œí™” ì ìš©)
                let newX = player.x + player.velocityX * normalizedDelta;
                let newY = player.y + player.velocityY * normalizedDelta;
                
                // ê²½ê³„ ì²´í¬ (ë§µ ê²½ê³„ ì‚¬ìš©) - ê²½ê³„ë¥¼ ë„˜ì–´ê°€ë©´ ê°•ì œë¡œ ê²½ê³„ ì•ˆìœ¼ë¡œ ì œí•œ
                newX = Math.max(gameState.mapBounds.minX + player.radius, Math.min(gameState.mapBounds.maxX - player.radius, newX));
                newY = Math.max(gameState.mapBounds.minY + player.radius, Math.min(gameState.mapBounds.maxY - player.radius, newY));
                
                // ê²½ê³„ì— ë‹¿ìœ¼ë©´ ì†ë„ ë°˜ì‚¬
                if (newX !== player.x + player.velocityX) player.velocityX *= -0.5;
                if (newY !== player.y + player.velocityY) player.velocityY *= -0.5;
                
                player.x = newX;
                player.y = newY;
            } else {
                // ì¼ë°˜ ì´ë™ (deltaTime ì •ê·œí™” ì ìš©)
                let newX = player.x + dx * currentSpeed * normalizedDelta;
                let newY = player.y + dy * currentSpeed * normalizedDelta;

                // ê²½ê³„ ì²´í¬ (ë§µ ê²½ê³„ ì‚¬ìš©) - ê²½ê³„ë¥¼ ë„˜ì–´ê°€ë©´ ê°•ì œë¡œ ê²½ê³„ ì•ˆìœ¼ë¡œ ì œí•œ
                newX = Math.max(gameState.mapBounds.minX + player.radius, Math.min(gameState.mapBounds.maxX - player.radius, newX));
                newY = Math.max(gameState.mapBounds.minY + player.radius, Math.min(gameState.mapBounds.maxY - player.radius, newY));
                
                // ë©€í‹°í”Œë ˆì´ì–´ ì¥ì• ë¬¼ ì¶©ëŒ ì²´í¬
                if (gameState.isMultiplayer && gameState.obstacles) {
                    const testPlayer = { x: newX, y: newY, radius: player.radius };
                    for (let i = 0; i < gameState.obstacles.length; i++) {
                        if (checkCharacterObstacleCollision(testPlayer, gameState.obstacles[i])) {
                            // ì¶©ëŒ ë°œìƒ: ì´ì „ ìœ„ì¹˜ ìœ ì§€
                            newX = player.x;
                            newY = player.y;
                            break;
                        }
                    }
                }
                
                player.x = newX;
                player.y = newY;
            }

            // ê°ë„ ê³„ì‚° (ë§ˆìš°ìŠ¤ ë°©í–¥)
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
        }


        // AI ì  ì—…ë°ì´íŠ¸
        function updateEnemy(deltaTime = 16.67) {
            const now = Date.now();
            // deltaTimeì„ 60fps ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™” (ê¸°ë³¸ê°’ 16.67ms = 60fps)
            const normalizedDelta = deltaTime / 16.67;
            
            // ë¶€í™œ ì²˜ë¦¬
            if (enemy.isReviving) {
                if (now >= enemy.reviveTime) {
                    enemy.isReviving = false;
                    enemy.health = 1;
                    // displayHealthëŠ” ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ìë™ ì—…ë°ì´íŠ¸ë¨
                    enemy.isInvincible = true;
                    enemy.invincibleEndTime = now + 1000; // 1ì´ˆ ë¬´ì 
                    // ë¶€í™œ íšŸìˆ˜ í™•ì¸ - ì•„ì§ ë” ë¶€í™œí•  ìˆ˜ ìˆìœ¼ë©´ ê³„ì† ì§„í–‰
                    const reviveCount = enemy.reviveCount || 1;
                    const hasRevivedCount = (typeof enemy.hasRevived === 'number' ? enemy.hasRevived : (enemy.hasRevived ? 1 : 0));
                    if (hasRevivedCount >= reviveCount) {
                        // ë” ì´ìƒ ë¶€í™œ ë¶ˆê°€
                    }
                }
                return; // ë¶€í™œ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            }

            // ë¬´ì  ìƒíƒœ ì²´í¬
            if (enemy.isInvincible && now >= enemy.invincibleEndTime) {
                enemy.isInvincible = false;
            }

            // ì•½í™” ìƒíƒœ ì²´í¬
            if (enemy.isWeakened && now >= enemy.weakenEndTime) {
                enemy.isWeakened = false;
                // ì•½í™”ëŠ” ì´ì•Œ ìƒì„± ì‹œì—ë§Œ ë°ë¯¸ì§€ë¥¼ ê°ì†Œì‹œí‚¤ë¯€ë¡œ, damage ìì²´ëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ
            }
            
            // ì‚¬ì‹  ì¦ê°•: ì€ì‹  ì¢…ë£Œ ì²´í¬
            if (enemy.isInvisible && now >= enemy.invisibilityEndTime) {
                enemy.isInvisible = false;
            }
            
            // ê³¼ì¶©ì „: ì¢…ë£Œ ë° ì¿¨íƒ€ì„ ì²´í¬
            if (enemy.overchargeActive && now >= enemy.overchargeEndTime) {
                enemy.overchargeActive = false;
            }
            if (enemy.overchargeCooldown > 0 && now >= enemy.overchargeCooldown) {
                enemy.overchargeCooldown = 0;
            }

            // ê¸°ì ˆ ìƒíƒœ ì²´í¬
            if (enemy.isStunned && now >= enemy.stunEndTime) {
                enemy.isStunned = false;
            }

            // ë°©ì–´ë§‰ ì¿¨íƒ€ì„ ì²´í¬
            if (enemy.hasShield && !enemy.shieldReady && now >= enemy.shieldCooldown) {
                enemy.shieldReady = true;
            }

            // ì¬ìƒ: 1ì´ˆë§ˆë‹¤ ì²´ë ¥ 0.1 íšŒë³µ (íšŒë³µëŸ‰ ì¤‘ì²©)
            if (enemy.hasRegeneration) {
                if (now - enemy.lastRegenTime >= 1000) {
                    const regenerationCount = enemy.regenerationCount || 1;
                    enemy.health = Math.min(enemy.health + (0.1 * regenerationCount), enemy.maxHealth);
                    enemy.health = roundToMaxTwoDecimals(enemy.health);
                    enemy.lastRegenTime = now;
                }
            }

            // ê¸°ì ˆ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            if (enemy.isStunned) {
                return;
            }
            
            // ì‹œê°„ì •ì§€: ìƒëŒ€ê°€ ì‹œê°„ì •ì§€ë¥¼ ì‚¬ìš© ì¤‘ì´ë©´ ì›€ì§ì´ì§€ ëª»í•¨
            if (player.timeStopActive) {
                return;
            }
            
            // ì„ ê³ : ë°€ë ¤ë‚˜ëŠ” íš¨ê³¼ ì²˜ë¦¬
            if (enemy.isJudgmentPushing) {
                const elapsed = now - enemy.judgmentPushStartTime;
                const progress = Math.min(1, elapsed / enemy.judgmentPushDuration);
                
                // ë¶€ë“œëŸ¬ìš´ ì´ë™ (ease-out)
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                enemy.x = enemy.judgmentPushStartX + (enemy.judgmentPushTargetX - enemy.judgmentPushStartX) * easeProgress;
                enemy.y = enemy.judgmentPushStartY + (enemy.judgmentPushTargetY - enemy.judgmentPushStartY) * easeProgress;
                
                // ê²½ê³„ ì²´í¬
                enemy.x = Math.max(gameState.mapBounds.minX + enemy.radius, Math.min(gameState.mapBounds.maxX - enemy.radius, enemy.x));
                enemy.y = Math.max(gameState.mapBounds.minY + enemy.radius, Math.min(gameState.mapBounds.maxY - enemy.radius, enemy.y));
                
                if (progress >= 1) {
                    enemy.isJudgmentPushing = false;
                } else {
                    return; // ë°€ë ¤ë‚˜ëŠ” ì¤‘ì—ëŠ” ë‹¤ë¥¸ ì´ë™ ë¶ˆê°€
                }
            }

            // ì´ë™ì†ë„ ê°ì†Œ ì²˜ë¦¬ (ê¹Šì€ ìƒì²˜)
            let currentSpeed = enemy.speed;
            if (now < enemy.slowEndTime) {
                    currentSpeed *= 0.75; // -25%
                }
            
            // ì‚¬ì‹  ì¦ê°•: ì€ì‹  ì¤‘ ì´ë™ì†ë„ +15%
            if (enemy.isInvisible && now < enemy.invisibilityEndTime) {
                currentSpeed *= 1.15;
            }
            
            // ê³¼ì¶©ì „: í™œì„±í™” ì¤‘ ì´ë™ì†ë„ +33%
            if (enemy.overchargeActive && now < enemy.overchargeEndTime) {
                currentSpeed *= 1.33;
                // ê³¼ì¶©ì „ ì”ìƒ ì¶”ê°€ (íŒŒë€ìƒ‰)
                if (!enemy.overchargeTrail) enemy.overchargeTrail = [];
                enemy.overchargeTrail.push({ x: enemy.x, y: enemy.y, alpha: 0.6 });
                // ì”ìƒì´ ë„ˆë¬´ ë§ì•„ì§€ë©´ ì œê±°
                if (enemy.overchargeTrail.length > 8) {
                    enemy.overchargeTrail.shift();
                }
            } else {
                // ê³¼ì¶©ì „ ë¹„í™œì„±í™” ì‹œ ì”ìƒ ì´ˆê¸°í™”
                if (enemy.overchargeTrail) enemy.overchargeTrail = [];
            }
            
            // íšŒí”¼ê¸°ë™: ì¬ì¥ì „ ì¤‘ ì´ë™ì†ë„ +75% (ì¤‘ì²©)
            if (enemy.hasEvasiveManeuver && enemy.isReloading) {
                const evasiveManeuverCount = enemy.evasiveManeuverCount || 1;
                currentSpeed *= (1 + 0.75 * evasiveManeuverCount);
            }
            
            // ìƒì¡´ë³¸ëŠ¥: ì²´ë ¥ì´ 1ì¼ ë•Œ ì´ë™ì†ë„ +50% (ì¤‘ì²©)
            if (enemy.hasSurvivalInstinct && enemy.health === 1) {
                const survivalInstinctCount = enemy.survivalInstinctCount || 1;
                currentSpeed *= (1 + 0.5 * survivalInstinctCount);
            }
            
            // íšŒë³µê³„ì•½: ì²´ë ¥ì´ 1ì¼ ë•Œ ì²´ë ¥ 2íšŒë³µ (íšŒë³µëŸ‰ ì¤‘ì²©)
            if (enemy.hasRecoveryContract && !enemy.hasRecoveryContractUsed && enemy.health === 1) {
                const recoveryContractCount = enemy.recoveryContractCount || 1;
                enemy.health = Math.min(enemy.health + (2 * recoveryContractCount), enemy.maxHealth);
                enemy.hasRecoveryContractUsed = true;
            }
            
            // í•´ë¥˜: ì´ë™ì†ë„ê°€ -25%ì™€ +50%ë¡œ 3ì´ˆë§ˆë‹¤ ë²ˆê°ˆì•„ ë°˜ë³µ
            if (enemy.hasTide) {
                if (enemy.tideStartTime === 0) {
                    enemy.tideStartTime = now;
                }
                const elapsed = now - enemy.tideStartTime;
                const phase = Math.floor(elapsed / 3000) % 2; // 0 ë˜ëŠ” 1 (3ì´ˆë§ˆë‹¤ ì „í™˜)
                if (phase === 0) {
                    // +50% í˜ì´ì¦ˆ
                    currentSpeed *= 1.5;
                } else {
                    // -25% í˜ì´ì¦ˆ
                    currentSpeed *= 0.75;
                }
            }
            
            // ë§ê°: 30ì´ˆ í›„ ê°•ë ¥í•œ ë²„í”„ í™œì„±í™”
            if (enemy.hasOblivion && !enemy.oblivionActivated) {
                if (enemy.oblivionStartTime === 0) {
                    enemy.oblivionStartTime = now;
                }
                const elapsed = now - enemy.oblivionStartTime;
                if (elapsed >= 30000) { // 30ì´ˆ í›„
                    enemy.oblivionActivated = true;
                    // ì´ì•Œ ì†ë„ 300% ì¦ê°€ (ì›ë˜ ì†ë„ * 4)
                    enemy.bulletSpeedMultiplier = (enemy.bulletSpeedMultiplier || 1) * 4;
                    // ì´ì•Œ ë°ë¯¸ì§€ 300% ì¦ê°€ (ì›ë˜ ë°ë¯¸ì§€ * 4)
                    enemy.damage = (enemy.damage || 1) * 4;
                    // ìµœëŒ€ ì²´ë ¥ìœ¼ë¡œ íšŒë³µ
                    enemy.health = enemy.maxHealth;
                    enemy.displayHealth = enemy.maxHealth;
                    // ê¸€ë¦¬ì¹˜ íš¨ê³¼ (ì‹œê°ì  íš¨ê³¼ëŠ” draw í•¨ìˆ˜ì—ì„œ ì²˜ë¦¬)
                }
            }

            enemy.aiTimer++;

            // í”Œë ˆì´ì–´ê°€ ì´ì„ ì˜ëŠ”ì§€ ê°ì§€
            const currentPlayerBulletCount = player.bullets.length;
            if (currentPlayerBulletCount > enemy.lastPlayerBulletCount) {
                // í”Œë ˆì´ì–´ê°€ ì´ì„ ìˆìŒ
                const dodgeProbability = 0.85; // 85% í™•ë¥ 
                if (Math.random() < dodgeProbability) {
                    // 85% í™•ë¥ ë¡œ íšŒí”¼
                    enemy.isDodgingBullet = true;
                    // ì´ì•Œ ë°©í–¥ì—ì„œ +90ë„ ë˜ëŠ” -90ë„ë¡œ ì´ë™
                    const bulletAngle = player.angle; // í”Œë ˆì´ì–´ê°€ ìœ ì´ì•Œì˜ ë°©í–¥
                    const dodgeDirection = Math.random() < 0.5 ? 1 : -1; // 1 = +90ë„, -1 = -90ë„
                    const dodgeAngle = bulletAngle + (dodgeDirection * Math.PI / 2); // Â±90ë„
                    const dodgeDistance = 30 + Math.random() * 30; // 30px~60px ëœë¤
                    
                    // Â±90ë„ ë°©í–¥ìœ¼ë¡œ ëœë¤ ê±°ë¦¬ë§Œí¼ ì´ë™í•œ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
                    const targetX = enemy.x + Math.cos(dodgeAngle) * dodgeDistance;
                    const targetY = enemy.y + Math.sin(dodgeAngle) * dodgeDistance;
                    
                    // ê²½ê³„ ì²´í¬
                    enemy.bulletDodgeTargetX = Math.max(
                        enemy.radius,
                        Math.min(canvas.width - enemy.radius, targetX)
                    );
                    enemy.bulletDodgeTargetY = Math.max(
                        enemy.radius,
                        Math.min(canvas.height - enemy.radius, targetY)
                    );
                    // í˜„ì¬ ì›€ì§ì„ ë©ˆì¶”ê¸°
                    enemy.aiTimer = 0;
                }
            }
            enemy.lastPlayerBulletCount = currentPlayerBulletCount;

            // ì´ì•Œ íšŒí”¼ ì¤‘ì´ë©´ ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
            if (enemy.isDodgingBullet) {
                const dxToTarget = enemy.bulletDodgeTargetX - enemy.x;
                const dyToTarget = enemy.bulletDodgeTargetY - enemy.y;
                const distanceToTarget = Math.sqrt(dxToTarget * dxToTarget + dyToTarget * dyToTarget);
                
                if (distanceToTarget > 2) {
                    // ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
                    enemy.aiDirection = Math.atan2(dyToTarget, dxToTarget);
                } else {
                    // ëª©í‘œ ìœ„ì¹˜ì— ë„ë‹¬í–ˆìœ¼ë©´ íšŒí”¼ ì¢…ë£Œ
                    enemy.isDodgingBullet = false;
                    enemy.aiTimer = 0; // ìƒˆë¡œìš´ ë°©í–¥ ì„ íƒ
                }
            }

            // í”Œë ˆì´ì–´ ì´ë™ ë°©í–¥ ì¶”ì  (ì˜ˆì¸¡ ë°œì‚¬ìš©)
            if (enemy.lastPlayerX === 0 && enemy.lastPlayerY === 0) {
                enemy.lastPlayerX = player.x;
                enemy.lastPlayerY = player.y;
            }
            // í”Œë ˆì´ì–´ ì†ë„ ê³„ì‚° (í”„ë ˆì„ë‹¹ ì´ë™ëŸ‰)
            enemy.playerVelocity.x = player.x - enemy.lastPlayerX;
            enemy.playerVelocity.y = player.y - enemy.lastPlayerY;
            enemy.lastPlayerX = player.x;
            enemy.lastPlayerY = player.y;

            // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ê°ë„ ì„¤ì •
            const dxToPlayer = player.x - enemy.x;
            const dyToPlayer = player.y - enemy.y;
            enemy.angle = Math.atan2(dyToPlayer, dxToPlayer);

            // í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ ê³„ì‚°
            const distance = Math.sqrt(dxToPlayer * dxToPlayer + dyToPlayer * dyToPlayer);
            const safeDistance = 500; // ì•ˆì „ ê±°ë¦¬ (500px)

            const aiTimerThreshold = 30; // ì›ë˜ëŒ€ë¡œ ë³µêµ¬ (30í”„ë ˆì„ = ì•½ 0.5ì´ˆ)
            
            // ì  ì´ë™ íŒ¨í„´ ê°œì„  - ìœ„ì•„ë˜ë¡œ ë” ìì£¼ ì›€ì§ì„ (íšŒí”¼ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
            if (!enemy.isDodgingBullet && enemy.aiTimer > aiTimerThreshold) {
                let targetAngle;
                
                // ëœë¤í•˜ê²Œ ë‹¤ì–‘í•œ ì›€ì§ì„ íŒ¨í„´ ì‚¬ìš©
                const movementPattern = Math.random();
                
                if (movementPattern < 0.2) {
                    // 20% í™•ë¥ : í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ì´ë™
                    targetAngle = Math.atan2(dyToPlayer, dxToPlayer);
                } else if (movementPattern < 0.35) {
                    // 15% í™•ë¥ : í”Œë ˆì´ì–´ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì´ë™
                    targetAngle = Math.atan2(-dyToPlayer, -dxToPlayer);
                } else if (movementPattern < 0.45) {
                    // 10% í™•ë¥ : ì¸¡ë©´ ì´ë™ (ì™¼ìª½/ì˜¤ë¥¸ìª½)
                    targetAngle = Math.atan2(dyToPlayer, dxToPlayer) + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                } else if (movementPattern < 0.75) {
                    // 30% í™•ë¥ : ìœ„ì•„ë˜ ì´ë™ (í”Œë ˆì´ì–´ ë°©í–¥ ê¸°ì¤€ ìœ„/ì•„ë˜)
                    const playerAngle = Math.atan2(dyToPlayer, dxToPlayer);
                    targetAngle = playerAngle + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                } else {
                    // 25% í™•ë¥ : ì™„ì „ ëœë¤ ë°©í–¥
                    targetAngle = Math.random() * Math.PI * 2;
                }
                
                // ê±°ë¦¬ ê¸°ë°˜ ì¡°ì • (ì„ íƒì )
                if (distance < safeDistance * 0.7) {
                    // ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë©€ì–´ì§€ëŠ” ê²½í–¥
                    if (movementPattern < 0.5) {
                        targetAngle = Math.atan2(-dyToPlayer, -dxToPlayer);
                    }
                }
                
                // ëœë¤ ê°ë„ ì¶”ê°€ë¡œ ë” ìì—°ìŠ¤ëŸ¬ìš´ ì›€ì§ì„
                const randomAngle = (Math.random() - 0.5) * Math.PI * 0.5; // Â±45ë„ ëœë¤
                enemy.aiDirection = targetAngle + randomAngle;
                enemy.aiTimer = 0;
            }

            // ë²½ì— ë„ˆë¬´ ë¶™ìœ¼ë©´ ë§µ ì¤‘ì•™ìœ¼ë¡œ ì´ë™ (íšŒí”¼ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
            if (!enemy.isDodgingBullet) {
                const mapWidth = gameState.mapBounds.maxX - gameState.mapBounds.minX;
                const mapHeight = gameState.mapBounds.maxY - gameState.mapBounds.minY;
                const wallThreshold = Math.min(mapWidth, mapHeight) * 0.05; // ë§µ í¬ê¸°ì˜ 5% ì´ë‚´
                
                const distToLeftWall = enemy.x - (gameState.mapBounds.minX + enemy.radius);
                const distToRightWall = (gameState.mapBounds.maxX - enemy.radius) - enemy.x;
                const distToTopWall = enemy.y - (gameState.mapBounds.minY + enemy.radius);
                const distToBottomWall = (gameState.mapBounds.maxY - enemy.radius) - enemy.y;
                
                // ë²½ì— ë„ˆë¬´ ë¶™ì—ˆëŠ”ì§€ í™•ì¸
                if (distToLeftWall < wallThreshold || distToRightWall < wallThreshold ||
                    distToTopWall < wallThreshold || distToBottomWall < wallThreshold) {
                    // ë§µ ì¤‘ì•™ìœ¼ë¡œ ì´ë™
                    const centerX = (gameState.mapBounds.minX + gameState.mapBounds.maxX) / 2;
                    const centerY = (gameState.mapBounds.minY + gameState.mapBounds.maxY) / 2;
                    const dxToCenter = centerX - enemy.x;
                    const dyToCenter = centerY - enemy.y;
                    enemy.aiDirection = Math.atan2(dyToCenter, dxToCenter);
                    enemy.aiTimer = 0;
                }
            }
            
            // ê²½ê³„ì— ë‹¿ìœ¼ë©´ ë°©í–¥ ë³€ê²½ (ë§µ ê²½ê³„ ì‚¬ìš©)
            if (enemy.x < gameState.mapBounds.minX + enemy.radius || enemy.x > gameState.mapBounds.maxX - enemy.radius ||
                enemy.y < gameState.mapBounds.minY + enemy.radius || enemy.y > gameState.mapBounds.maxY - enemy.radius) {
                enemy.aiDirection = Math.random() * Math.PI * 2;
                enemy.aiTimer = 0;
            }

            // ì´ë™ ê³„ì‚°
            let dx = Math.cos(enemy.aiDirection) * currentSpeed;
            let dy = Math.sin(enemy.aiDirection) * currentSpeed;
            
            // ê¸°ê³„í™”: ìƒí•˜ì¢Œìš°ë¡œë§Œ ì´ë™ ê°€ëŠ¥
            if (enemy.hasMechanization) {
                // ê°€ì¥ ê°€ê¹Œìš´ ìƒí•˜ì¢Œìš° ë°©í–¥ìœ¼ë¡œ ì •ê·œí™”
                const angle = enemy.aiDirection;
                // 0ë„(ìš°), 90ë„(í•˜), 180ë„(ì¢Œ), 270ë„(ìƒ) ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ ë°©í–¥ ì°¾ê¸°
                const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];
                let closestDir = directions[0];
                let minDiff = Math.abs(angle - directions[0]);
                for (let i = 1; i < directions.length; i++) {
                    const diff = Math.abs(angle - directions[i]);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestDir = directions[i];
                    }
                }
                // ê°€ì¥ ê°€ê¹Œìš´ ë°©í–¥ìœ¼ë¡œ ì´ë™
                dx = Math.cos(closestDir) * currentSpeed;
                dy = Math.sin(closestDir) * currentSpeed;
            }
            
            // ë¬´ë¹™ì›Œí¬ëª¨ë“œ: 5ì´ˆë§ˆë‹¤ ë°”ë€ŒëŠ” ë°©í–¥ìœ¼ë¡œ ì´ˆë‹¹ 25px ì´ë™ ì¶”ê°€ (í”Œë ˆì´ì–´ì™€ ê°™ì€ ë°©í–¥)
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'movingWork') {
                // ìœ„, ì•„ë˜, ì¢Œ, ìš° 4ë°©í–¥ ì¤‘ 1ê°œ ì„ íƒ (í”Œë ˆì´ì–´ì™€ ê°™ì€ ë°©í–¥ ì‚¬ìš©)
                if (!gameState.movingWorkDirection) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // ìš°, ì•„ë˜, ì¢Œ, ìœ„
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // 5ì´ˆë§ˆë‹¤ ë°©í–¥ ë³€ê²½
                if (now - gameState.movingWorkLastChange >= 5000) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // ìš°, ì•„ë˜, ì¢Œ, ìœ„
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // ì´ˆë‹¹ 25px ì´ë™ (ë¶€ë“œëŸ½ê²Œ) - currentSpeedë¥¼ ê³±í•˜ì§€ ì•Šê³  ì§ì ‘ ì¶”ê°€
                const moveSpeed = 25 / 60; // 60fps ê¸°ì¤€
                const moveDx = Math.cos(gameState.movingWorkDirection) * moveSpeed * normalizedDelta;
                const moveDy = Math.sin(gameState.movingWorkDirection) * moveSpeed * normalizedDelta;
                
                // AI ì´ë™ê³¼ ë¬´ë¹™ì›Œí¬ ì´ë™ í•©ì‚°
                dx += moveDx;
                dy += moveDy;
            }

            // ë¹™íŒëª¨ë“œ: ë¯¸ë„ëŸ¬ì§ íš¨ê³¼
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'ice') {
                // ì†ë„ ë²¡í„° ì´ˆê¸°í™”
                if (enemy.velocityX === undefined) enemy.velocityX = 0;
                if (enemy.velocityY === undefined) enemy.velocityY = 0;
                
                // ì…ë ¥ì´ ìˆìœ¼ë©´ ì†ë„ ë²¡í„° ì—…ë°ì´íŠ¸ (í•­ìƒ ì—…ë°ì´íŠ¸)
                enemy.velocityX = dx;
                enemy.velocityY = dy;
                
                // ë§ˆì°° ì ìš© (ì†ë„ ê°ì†Œ) - ë¹™íŒëª¨ë“œì—ì„œëŠ” í›¨ì”¬ ë” ì˜ ë¯¸ë„ëŸ¬ì§
                enemy.velocityX *= 0.995;
                enemy.velocityY *= 0.995;
                
                // ì†ë„ê°€ ë§¤ìš° ì‘ìœ¼ë©´ ì •ì§€
                if (Math.abs(enemy.velocityX) < 0.01) enemy.velocityX = 0;
                if (Math.abs(enemy.velocityY) < 0.01) enemy.velocityY = 0;
                
                // ì†ë„ ë²¡í„°ë¡œ ì´ë™ (deltaTime ì •ê·œí™” ì ìš©)
                let newX = enemy.x + enemy.velocityX * normalizedDelta;
                let newY = enemy.y + enemy.velocityY * normalizedDelta;
                
                // ê²½ê³„ ì²´í¬ (ë§µ ê²½ê³„ ì‚¬ìš©) - ê²½ê³„ë¥¼ ë„˜ì–´ê°€ë©´ ê°•ì œë¡œ ê²½ê³„ ì•ˆìœ¼ë¡œ ì œí•œ
                newX = Math.max(gameState.mapBounds.minX + enemy.radius, Math.min(gameState.mapBounds.maxX - enemy.radius, newX));
                newY = Math.max(gameState.mapBounds.minY + enemy.radius, Math.min(gameState.mapBounds.maxY - enemy.radius, newY));
                
                // ê²½ê³„ì— ë‹¿ìœ¼ë©´ ì†ë„ ë°˜ì‚¬
                if (newX !== enemy.x + enemy.velocityX * normalizedDelta) enemy.velocityX *= -0.5;
                if (newY !== enemy.y + enemy.velocityY * normalizedDelta) enemy.velocityY *= -0.5;
                
                // ë©€í‹°í”Œë ˆì´ì–´ ì¥ì• ë¬¼ ì¶©ëŒ ì²´í¬
                if (gameState.isMultiplayer && gameState.obstacles) {
                    const testEnemy = { x: newX, y: newY, radius: enemy.radius };
                    for (let i = 0; i < gameState.obstacles.length; i++) {
                        if (checkCharacterObstacleCollision(testEnemy, gameState.obstacles[i])) {
                            // ì¶©ëŒ ë°œìƒ: ì´ì „ ìœ„ì¹˜ ìœ ì§€
                            newX = enemy.x;
                            newY = enemy.y;
                            break;
                        }
                    }
                }
                
                enemy.x = newX;
                enemy.y = newY;
            } else {
                // ì¼ë°˜ ì´ë™ (deltaTime ì •ê·œí™” ì ìš©)
                let newX = Math.max(gameState.mapBounds.minX + enemy.radius, Math.min(gameState.mapBounds.maxX - enemy.radius, enemy.x + dx * normalizedDelta));
                let newY = Math.max(gameState.mapBounds.minY + enemy.radius, Math.min(gameState.mapBounds.maxY - enemy.radius, enemy.y + dy * normalizedDelta));
                
                // ë©€í‹°í”Œë ˆì´ì–´ ì¥ì• ë¬¼ ì¶©ëŒ ì²´í¬
                if (gameState.isMultiplayer && gameState.obstacles) {
                    const testEnemy = { x: newX, y: newY, radius: enemy.radius };
                    for (let i = 0; i < gameState.obstacles.length; i++) {
                        if (checkCharacterObstacleCollision(testEnemy, gameState.obstacles[i])) {
                            // ì¶©ëŒ ë°œìƒ: ì´ì „ ìœ„ì¹˜ ìœ ì§€
                            newX = enemy.x;
                            newY = enemy.y;
                            break;
                        }
                    }
                }
                
                enemy.x = newX;
                enemy.y = newY;
                // ë¹™íŒëª¨ë“œê°€ ì•„ë‹ ë•ŒëŠ” ì†ë„ ë²¡í„° ì´ˆê¸°í™”
                enemy.velocityX = 0;
                enemy.velocityY = 0;
            }
            
            // ê°ë„ ê³„ì‚° (í”Œë ˆì´ì–´ ë°©í–¥)
            enemy.angle = Math.atan2(dyToPlayer, dxToPlayer);


            // ê·¼ì ‘ì „ëª¨ë“œ: í”Œë ˆì´ì–´ê°€ 500px ì•ˆì— ë“¤ì–´ì™”ì„ ë•Œë§Œ ë°œì‚¬
            const isMeleeMode = gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'melee';
            const maxDistance = isMeleeMode ? 500 : Math.max(canvas.width, canvas.height) * 0.8; // ê·¼ì ‘ì „ëª¨ë“œë©´ 500px, ì•„ë‹ˆë©´ í™”ë©´ í¬ê¸°ì˜ 80%
            const shootProbability = isMeleeMode ? 0.6 : 0.3; // ê·¼ì ‘ì „ëª¨ë“œë©´ ë” ì ê·¹ì ìœ¼ë¡œ ë°œì‚¬ (60%)
            const nowForShoot = Date.now();
            // ì¿¨íƒ€ì„ ì²´í¬ ì¶”ê°€ (ê·¼ì ‘ì „ëª¨ë“œë©´ ì¿¨íƒ€ì„ ê°ì†Œ)
            const shootCooldown = isMeleeMode ? enemy.shootCooldown * 0.7 : enemy.shootCooldown; // ê·¼ì ‘ì „ëª¨ë“œë©´ ì¿¨íƒ€ì„ 30% ê°ì†Œ
            const canShoot = !enemy.lastShot || (nowForShoot - enemy.lastShot >= shootCooldown);
            if (distance < maxDistance && enemy.ammo > 0 && !enemy.isReloading && canShoot && Math.random() < shootProbability) {
                // í”Œë ˆì´ì–´ê°€ ì›€ì§ì´ê³  ìˆëŠ”ì§€ í™•ì¸
                const playerSpeed = Math.sqrt(enemy.playerVelocity.x * enemy.playerVelocity.x + enemy.playerVelocity.y * enemy.playerVelocity.y);
                const isPlayerMoving = playerSpeed > 0.1; // 0.1px ì´ìƒ ì›€ì§ì´ë©´ ì›€ì§ì´ëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼
                
                const originalAngle = enemy.angle;
                const currentAngle = Math.atan2(dyToPlayer, dxToPlayer);
                
                // í”Œë ˆì´ì–´ê°€ ë©ˆì¶°ìˆìœ¼ë©´ 100% í˜„ì¬ ìœ„ì¹˜ë¡œ ë°œì‚¬
                if (!isPlayerMoving) {
                    // ë©ˆì¶°ìˆì„ ë•Œ: í•­ìƒ ì •í™•íˆ í˜„ì¬ ìœ„ì¹˜
                    enemy.angle = currentAngle;
                } else {
                    // ì›€ì§ì¼ ë•Œ: 80% í™•ë¥ ë¡œ ì´ë™ ë°©í–¥ìœ¼ë¡œ ê±°ë¦¬ì— ë”°ë¼ ì˜ˆì¸¡, 20% í˜„ì¬ ìœ„ì¹˜
                    if (Math.random() < 0.8) {
                        // 80% í™•ë¥ : í”Œë ˆì´ì–´ ì´ë™ ë°©í–¥ìœ¼ë¡œ ê±°ë¦¬ì— ë”°ë¼ ì˜ˆì¸¡ ê±°ë¦¬ ì¡°ì •
                        let predictedDistance;
                        if (distance <= 300) {
                            // 300px ì´ë‚´: 15px~25px ì‚¬ì´ ëœë¤
                            predictedDistance = 15 + Math.random() * (25 - 15);
                        } else if (distance <= 750) {
                            // 750px ì´ë‚´: 50px~75px ì‚¬ì´ ëœë¤
                            predictedDistance = 50 + Math.random() * (75 - 50);
                    } else {
                            // 750px ì´ìƒ: 150px (ê¸°ë³¸ê°’)
                            predictedDistance = 150;
                        }
                        
                        // í”Œë ˆì´ì–´ ì´ë™ ë°©í–¥ ê³„ì‚°
                        const playerMoveAngle = Math.atan2(enemy.playerVelocity.y, enemy.playerVelocity.x);
                        // í”Œë ˆì´ì–´ ìœ„ì¹˜ì—ì„œ ì´ë™ ë°©í–¥ìœ¼ë¡œ ê³„ì‚°ëœ ê±°ë¦¬ë§Œí¼ ì• ì§€ì  ê³„ì‚°
                        const predictedX = player.x + Math.cos(playerMoveAngle) * predictedDistance;
                        const predictedY = player.y + Math.sin(playerMoveAngle) * predictedDistance;
                        // ì˜ˆì¸¡ ì§€ì ìœ¼ë¡œ ê°ë„ ì„¤ì •
                        const dxToPredicted = predictedX - enemy.x;
                        const dyToPredicted = predictedY - enemy.y;
                        enemy.angle = Math.atan2(dyToPredicted, dxToPredicted);
                    } else {
                        // 20% í™•ë¥ : í˜„ì¬ ìœ„ì¹˜ë¡œ ë°œì‚¬
                        enemy.angle = currentAngle;
                    }
                }
                
                shoot(enemy);
                enemy.lastShot = nowForShoot; // ë°œì‚¬ ì‹œê°„ ê¸°ë¡
                // ë°œì‚¬ í›„ ê°ë„ ë³µì› (ì´ë™ ë°©í–¥ ìœ ì§€)
                enemy.angle = originalAngle;
            }

            // ìë™ ì¬ì¥ì „
            if (enemy.ammo === 0 && !enemy.isReloading) {
                reload(enemy);
            }
        }

        // ì´ì•Œ ì—…ë°ì´íŠ¸
        function updateBullets(character, deltaTime = 16.67) {
            for (let i = character.bullets.length - 1; i >= 0; i--) {
                const bullet = character.bullets[i];
                
                // ì‹œê°„ì •ì§€: ìƒëŒ€ì˜ ì´ì•Œì€ ë©ˆì¶¤ (ì‚¬ìš©ìëŠ” ì˜í–¥ ì—†ìŒ)
                const target = character === player ? enemy : player;
                if (target.timeStopActive && character !== target) {
                    continue; // ì´ì•Œ ì—…ë°ì´íŠ¸ ì•ˆ í•¨ (ë©ˆì¶¤)
                }
                
                // ì‹œê°„ì¥ë§‰: ì ì˜ ì´ì•Œì´ í”Œë ˆì´ì–´ì˜ ì‹œê°„ì¥ë§‰ ì•ˆì— ìˆìœ¼ë©´ ì†ë„ 35% ë‘”í™”
                if (character === enemy && player.hasTimeBarrier) {
                    const dx = bullet.x - player.x;
                    const dy = bullet.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= player.timeBarrierRadius) {
                        // ì†ë„ 65%ë¡œ ì„¤ì • (35% ê°ì†Œ) - í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„ ê¸°ì¤€ìœ¼ë¡œ
                        const baseSpeedForBarrier = bullet.hallucinationSpeed !== undefined ? bullet.hallucinationSpeed : (bullet.baseSpeed || bullet.speed);
                        bullet.speed = baseSpeedForBarrier * 0.65;
                        bullet.isInTimeBarrier = true;
                    } else {
                        // ì‹œê°„ì¥ë§‰ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì›ë˜ ì†ë„ë¡œ ë³µì› (í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„)
                        bullet.isInTimeBarrier = false;
                        if (bullet.hallucinationSpeed !== undefined) {
                            bullet.speed = bullet.hallucinationSpeed;
                        } else {
                            bullet.speed = bullet.baseSpeed || bullet.speed;
                        }
                    }
                }
                // ì‹œê°„ì¥ë§‰: í”Œë ˆì´ì–´ì˜ ì´ì•Œì´ ì ì˜ ì‹œê°„ì¥ë§‰ ì•ˆì— ìˆìœ¼ë©´ ì†ë„ 35% ë‘”í™”
                if (character === player && enemy.hasTimeBarrier) {
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= enemy.timeBarrierRadius) {
                        // ì†ë„ 65%ë¡œ ì„¤ì • (35% ê°ì†Œ) - í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„ ê¸°ì¤€ìœ¼ë¡œ
                        const baseSpeedForBarrier = bullet.hallucinationSpeed !== undefined ? bullet.hallucinationSpeed : (bullet.baseSpeed || bullet.speed);
                        bullet.speed = baseSpeedForBarrier * 0.65;
                        bullet.isInTimeBarrier = true;
                    } else {
                        // ì‹œê°„ì¥ë§‰ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì›ë˜ ì†ë„ë¡œ ë³µì› (í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„)
                        bullet.isInTimeBarrier = false;
                        if (bullet.hallucinationSpeed !== undefined) {
                            bullet.speed = bullet.hallucinationSpeed;
                        } else {
                            bullet.speed = bullet.baseSpeed || bullet.speed;
                        }
                    }
                }
                
                // ê·¼ì ‘ì „ëª¨ë“œ: ì´ì•Œì´ 500px ì´ë™í–ˆëŠ”ì§€ ì²´í¬
                if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'melee') {
                    if (!bullet.isStopped) {
                        // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê±°ë¦¬ ê³„ì‚°
                        const currentDistance = Math.sqrt(
                            Math.pow(bullet.x - bullet.startX, 2) + 
                            Math.pow(bullet.y - bullet.startY, 2)
                        );
                        
                        if (currentDistance >= 500) {
                            // ì´ì•Œì´ 500pxë¥¼ ë„˜ì—ˆìœ¼ë©´ ì •í™•íˆ 500px ìœ„ì¹˜ë¡œ ì¡°ì •
                            const angle = Math.atan2(bullet.y - bullet.startY, bullet.x - bullet.startX);
                            bullet.x = bullet.startX + Math.cos(angle) * 500;
                            bullet.y = bullet.startY + Math.sin(angle) * 500;
                            
                            // ì´ì•Œ ë©ˆì¶”ê¸°
                            bullet.isStopped = true;
                            bullet.stopTime = Date.now();
                            bullet.speed = 0; // ì†ë„ 0ìœ¼ë¡œ ì„¤ì •
                        } else {
                            // ì•„ì§ 500px ë¯¸ë§Œì´ë©´ ì—…ë°ì´íŠ¸
                            bullet.update(deltaTime);
                            
                            // update í›„ ë‹¤ì‹œ ì²´í¬ (500pxë¥¼ ë„˜ì—ˆëŠ”ì§€)
                            const newDistance = Math.sqrt(
                                Math.pow(bullet.x - bullet.startX, 2) + 
                                Math.pow(bullet.y - bullet.startY, 2)
                            );
                            if (newDistance >= 500) {
                                // ì •í™•íˆ 500px ìœ„ì¹˜ë¡œ ì¡°ì •
                                const angle = Math.atan2(bullet.y - bullet.startY, bullet.x - bullet.startX);
                                bullet.x = bullet.startX + Math.cos(angle) * 500;
                                bullet.y = bullet.startY + Math.sin(angle) * 500;
                                
                                bullet.isStopped = true;
                                bullet.stopTime = Date.now();
                                bullet.speed = 0;
                            }
                        }
                    } else {
                        // ë©ˆì¶˜ ì´ì•Œ: 0.7ì´ˆ í›„ í˜ì´ë“œ ì•„ì›ƒ ì‹œì‘, 1ì´ˆ í›„ ì œê±°
                        const now = Date.now();
                        const elapsed = now - bullet.stopTime;
                        
                        if (elapsed >= 700 && bullet.fadeStartTime === 0) {
                            // í˜ì´ë“œ ì•„ì›ƒ ì‹œì‘
                            bullet.fadeStartTime = now;
                        }
                        
                        if (elapsed >= 1000) {
                            character.bullets.splice(i, 1);
                            continue;
                        }
                    }
                } else {
                    // ê·¼ì ‘ì „ëª¨ë“œê°€ ì•„ë‹ˆë©´ ì¼ë°˜ ì—…ë°ì´íŠ¸
                    bullet.update(deltaTime);
                }

                // ë¶€ë§¤ë‘: ë˜ëŒì•„ì˜¤ëŠ” ì´ì•Œì´ í”Œë ˆì´ì–´ì—ê²Œ ë‹¿ìœ¼ë©´ ì‚­ì œ
                if (bullet.hasBoomerang && bullet.isReturning && bullet.owner) {
                    if (checkCollision(bullet, bullet.owner)) {
                        character.bullets.splice(i, 1);
                        continue;
                    }
                }
                
                // ë©€í‹°í”Œë ˆì´ì–´ ì¥ì• ë¬¼ ì¶©ëŒ ì²´í¬
                if (gameState.isMultiplayer && gameState.obstacles && !bullet.isStopped) {
                    for (let j = 0; j < gameState.obstacles.length; j++) {
                        const obstacle = gameState.obstacles[j];
                        if (checkBulletObstacleCollision(bullet, obstacle)) {
                            // í­ë°œíƒ„: ì¥ì• ë¬¼ì— ë‹¿ì•˜ì„ ë•Œë„ í­ë°œ
                            if (bullet.owner && bullet.owner.hasExplosiveBullet) {
                                const explosionRadius = 125;
                                const explosionDamage = 0.5;
                                const explosionX = bullet.x;
                                const explosionY = bullet.y;
                                
                                // í­ë°œ ì´í™íŠ¸ ì¶”ê°€
                                if (!gameState.explosions) gameState.explosions = [];
                                gameState.explosions.push({
                                    x: explosionX,
                                    y: explosionY,
                                    radius: explosionRadius,
                                    startTime: Date.now(),
                                    duration: 300
                                });
                                
                                // í­ë°œ ë²”ìœ„ ë‚´ì˜ íƒ€ê²Ÿì—ê²Œ ë°ë¯¸ì§€
                                const target = character === player ? enemy : player;
                                const distToTarget = Math.sqrt(
                                    Math.pow(explosionX - target.x, 2) + 
                                    Math.pow(explosionY - target.y, 2)
                                );
                                if (distToTarget <= explosionRadius) {
                                    target.health -= explosionDamage;
                                    target.health = roundToMaxTwoDecimals(target.health);
                                }
                            }
                            
                            // ì´ì•Œ ì‚­ì œ
                            character.bullets.splice(i, 1);
                            i--;
                            continue;
                        }
                    }
                }
                
                // ê²½ê³„ ì²´í¬ (ë©ˆì¶˜ ì´ì•Œì€ ê²½ê³„ ì²´í¬ ì•ˆ í•¨, ë¶€ë§¤ë‘ ì´ì•Œì€ ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ë„ ë˜ëŒì•„ì˜¤ë¯€ë¡œ ê²½ê³„ ì²´í¬ ì•ˆ í•¨)
                if (!bullet.isStopped && !bullet.hasBoomerang && bullet.isOutOfBounds()) {
                    // í­ë°œíƒ„: ë²½ì— ë‹¿ì•˜ì„ ë•Œ í­ë°œ
                    if (bullet.owner && bullet.owner.hasExplosiveBullet) {
                        const explosionRadius = 125;
                        const explosionDamage = 0.5;
                        const explosionX = bullet.x;
                        const explosionY = bullet.y;
                        
                        // í­ë°œ ì´í™íŠ¸ ì¶”ê°€
                        if (!gameState.explosions) gameState.explosions = [];
                        gameState.explosions.push({
                            x: explosionX,
                            y: explosionY,
                            radius: explosionRadius,
                            startTime: Date.now(),
                            duration: 300
                        });
                        
                        // í­ë°œ ë²”ìœ„ ë‚´ì˜ ì ì—ê²Œ ë°ë¯¸ì§€
                        const target = bullet.owner === player ? enemy : player;
                        const dx = target.x - explosionX;
                        const dy = target.y - explosionY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance <= explosionRadius) {
                            // ë°ë¯¸ì§€ ì ìš©
                            target.health = Math.max(0, target.health - explosionDamage);
                            target.displayHealth = Math.max(0, target.displayHealth - explosionDamage);
                            
                            // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ (ì£¼í™©ìƒ‰)
                            target.damageNumbers.push({
                                x: target.x,
                                y: target.y,
                                damage: explosionDamage,
                                isCritical: false,
                                startTime: Date.now(),
                                duration: 1000,
                                offsetY: 0,
                                color: '#ff8800'
                            });
                            
                            // í”¼ê²© ì´í™íŠ¸
                            addHitEffect(target, explosionX, explosionY);
                        }
                    }
                    
                    character.bullets.splice(i, 1);
                    i--; // ì¸ë±ìŠ¤ ì¡°ì • (ì—­ìˆœ ìˆœíšŒì´ì§€ë§Œ ì¼ê´€ì„±ì„ ìœ„í•´)
                    continue;
                }

                // ì¶©ëŒ ì²´í¬ (targetì€ ìœ„ì—ì„œ ì´ë¯¸ ì„ ì–¸ë¨)
                if (checkCollision(bullet, target)) {
                    // ê²Œì„ì´ ì¼ì‹œì •ì§€ëœ ìƒíƒœë©´ ë°ë¯¸ì§€ ë¬´ì‹œ (ì¦ê°• ì„ íƒ ì‹œê°„ ë™ì•ˆ)
                    if (gameState.isPaused) {
                        character.bullets.splice(i, 1);
                        continue;
                    }
                    // ë°˜ì‚¬ ë³´í˜¸ë§‰: ì ì˜ ì´ì•Œì„ ë°˜ì‚¬
                    if (target.reflectActive && character !== target) {
                        // ì´ì•Œ ë°©í–¥ì„ ë°˜ëŒ€ë¡œ (ìƒëŒ€ ìª½ìœ¼ë¡œ)
                        const dxToTarget = character.x - target.x;
                        const dyToTarget = character.y - target.y;
                        bullet.angle = Math.atan2(dyToTarget, dxToTarget);
                        bullet.owner = target; // ì´ì•Œ ì†Œìœ ìë¥¼ ë³€ê²½
                        // ì´ì•Œì„ targetì˜ bullets ë°°ì—´ë¡œ ì´ë™
                        character.bullets.splice(i, 1);
                        target.bullets.push(bullet);
                        continue; // ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                    }
                    // ë°˜ì‚¬ ë³´í˜¸ë§‰: ì ì˜ ì´ì•Œì„ ë°˜ì‚¬
                    if (target.reflectActive && character !== target) {
                        // ì´ì•Œ ë°©í–¥ì„ ë°˜ëŒ€ë¡œ (ìƒëŒ€ ìª½ìœ¼ë¡œ)
                        const dxToTarget = character.x - target.x;
                        const dyToTarget = character.y - target.y;
                        bullet.angle = Math.atan2(dyToTarget, dxToTarget);
                        bullet.owner = target; // ì´ì•Œ ì†Œìœ ìë¥¼ ë³€ê²½
                        // ì´ì•Œì„ targetì˜ bullets ë°°ì—´ë¡œ ì´ë™
                        character.bullets.splice(i, 1);
                        target.bullets.push(bullet);
                        continue; // ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                    }
                    
                    // êµ¬ë¥´ëŠ” ì¤‘ì´ê±°ë‚˜ ë¬´ì  ìƒíƒœë©´ ë°ë¯¸ì§€ ë¬´ì‹œ
                    if (target.isDodging || target.isInvincible || target.isReviving) {
                        character.bullets.splice(i, 1);
                        continue;
                    }

                    // ë°©ì–´ë§‰: ë°ë¯¸ì§€ 1íšŒ ë¬´ì‹œ (ì¿¨íƒ€ì„ 7.5ì´ˆ)
                    if (target.hasShield && target.shieldReady) {
                        target.shieldReady = false;
                        target.shieldCooldown = Date.now() + 7500; // 7.5ì´ˆ ì¿¨íƒ€ì„
                        character.bullets.splice(i, 1);
                        // "ë¬´ì‹œ" í…ìŠ¤íŠ¸ í‘œì‹œ
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isShield: true, // ë°©ì–´ë§‰ ë¬´ì‹œ ì—¬ë¶€
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: 0
                        });
                        continue; // ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                    }

                    // ìœ ë ¹ ì¦ê°•: í™•ë¥  ì¤‘ì²© (25% * count)
                    const ghostCount = target.ghostCount || 1;
                    if (target.hasGhost && Math.random() < (0.25 * ghostCount)) {
                        // "ë¬´ì‹œ" í…ìŠ¤íŠ¸ í‘œì‹œ
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isGhost: true, // ìœ ë ¹ ë¬´ì‹œ ì—¬ë¶€
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: 0
                        });
                        // ì´ì•Œ ì œê±°í•˜ê³  ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                        character.bullets.splice(i, 1);
                        i--; // ì¸ë±ìŠ¤ ì¡°ì •
                        continue; // ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                    }

                    // í¬ë¦¬í‹°ì»¬ ê³„ì‚° (í™•ë¥  ì¤‘ì²©: 25% * count)
                    let finalDamage = bullet.damage;
                    let isCritical = false;
                    const criticalCount = character.criticalCount || 1;
                    if (character.hasCritical && Math.random() < (0.25 * criticalCount)) {
                        finalDamage *= 2;
                        isCritical = true;
                    }
                    
                    // ì·¨ì•½ ìƒíƒœ: ë‹¤ìŒ ë°ë¯¸ì§€ 1.5ë°°
                    if (target.isVulnerable && !target.vulnerabilityUsed) {
                        finalDamage *= 1.5;
                        target.vulnerabilityUsed = true; // ì·¨ì•½ ì‚¬ìš©ë¨
                        target.isVulnerable = false; // ì·¨ì•½ ìƒíƒœ í•´ì œ
                    }

                    // ê±°ì í™•ë³´: ë°ë¯¸ì§€ *0.5
                    if (target.hasFortify && target.isFortified) {
                        finalDamage *= 0.5;
                    }

                    // ê³¼ì—´: ì—°ì† íˆíŠ¸ ì‹œ ë°ë¯¸ì§€ ë°°ìœ¨ ì ìš©
                    if (character.hasOverheat) {
                        const now = Date.now();
                        // 2ì´ˆ ì´ë‚´ì— íˆíŠ¸í•˜ë©´ ì—°ì† íˆíŠ¸ë¡œ ê°„ì£¼
                        if (now - character.lastHitTime < 2000) {
                            character.overheatHitCount++;
                        } else {
                            // 2ì´ˆ ì´ìƒ ì§€ë‚˜ë©´ ì´ˆê¸°í™”
                            character.overheatHitCount = 0;
                        }
                        // ë°ë¯¸ì§€ ë°°ìœ¨: 1 + hitCount * 0.5 (ì²«ë²ˆì§¸ëŠ” 1ë°°, ë‘ë²ˆì§¸ëŠ” 1.5ë°°, ì„¸ë²ˆì§¸ëŠ” 2ë°°...)
                        finalDamage *= (1 + character.overheatHitCount * 0.5);
                        character.lastHitTime = now;
                    }

                    // ì•½í™”: ìƒëŒ€ì—ê²Œ ì•½í™” ìƒíƒœ ë¶€ì—¬ (3ì´ˆ ë™ì•ˆ ëª¨ë“  ê³µê²© ë°ë¯¸ì§€ -0.25, ì¤‘ì²© ì•ˆë¨)
                    // ì•½í™”: ìƒëŒ€ì—ê²Œ ì´ì•Œì„ ë§ì¶œ ì‹œ 3ì´ˆë™ì•ˆ ìƒëŒ€ ë°ë¯¸ì§€ -0.25 (ì¤‘ì²©)
                    if (character.hasWeaken && !target.isWeakened) {
                        target.isWeakened = true;
                        target.weakenEndTime = Date.now() + 3000;
                    }

                    // í­ë°œíƒ„: ì ì—ê²Œ ë§ì•˜ì„ ë•Œ í­ë°œ ì²˜ë¦¬ (ë°ë¯¸ì§€ ì ìš© ì „)
                    if (bullet.owner && bullet.owner.hasExplosiveBullet) {
                        const explosionRadius = 125;
                        const explosionDamage = 0.5;
                        const explosionX = bullet.x;
                        const explosionY = bullet.y;
                        
                        // í­ë°œ ì´í™íŠ¸ ì¶”ê°€
                        if (!gameState.explosions) gameState.explosions = [];
                        gameState.explosions.push({
                            x: explosionX,
                            y: explosionY,
                            radius: explosionRadius,
                            startTime: Date.now(),
                            duration: 300
                        });
                        
                        // í­ë°œ ë²”ìœ„ ë‚´ì˜ íƒ€ê²Ÿì—ê²Œ ì¶”ê°€ ë°ë¯¸ì§€ (ì§ì ‘ ë§ì€ ë°ë¯¸ì§€ì™€ ë³„ë„)
                        const dx = target.x - explosionX;
                        const dy = target.y - explosionY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance <= explosionRadius) {
                            // í­ë°œ ë°ë¯¸ì§€ ì ìš© (ì§ì ‘ ë§ì€ ë°ë¯¸ì§€ì™€ ë³„ë„)
                            target.health = Math.max(0, target.health - explosionDamage);
                            target.health = roundToMaxTwoDecimals(target.health);
                            
                            // í­ë°œ ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ (ì£¼í™©ìƒ‰)
                            target.damageNumbers.push({
                                x: target.x,
                                y: target.y,
                                damage: explosionDamage,
                                isCritical: false,
                                startTime: Date.now(),
                                duration: 1000,
                                offsetY: 0,
                                color: '#ff8800'
                            });
                        }
                    }
                    
                    // ì†Œìˆ˜ì  3ìë¦¬ ì´ìƒì´ë©´ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼, 1~2ìë¦¬ëŠ” ìœ ì§€
                    finalDamage = roundToMaxTwoDecimals(finalDamage);
                    target.health -= finalDamage;
                    target.health = roundToMaxTwoDecimals(target.health);
                    
                    // ê°•íƒˆ: ì´ì•Œì„ ìƒëŒ€ì—ê²Œ ë§ì¶œ ë•Œë§ˆë‹¤ ìƒëŒ€ì˜ íƒ„í™˜ 1ê°œë¥¼ ê°€ì ¸ì˜´
                    if (character.hasPlunder && !target.isReloading && target.ammo > 0) {
                        // ìƒëŒ€ê°€ ì¬ì¥ì „ ì¤‘ì´ ì•„ë‹ˆê³  íƒ„í™˜ì´ ìˆì„ ë•Œë§Œ
                        target.ammo = Math.max(0, target.ammo - 1);
                        // ìì‹ ì˜ íƒ„í™˜ì„ ì¦ê°€ (ìµœëŒ€ íƒ„ì•½ìˆ˜ ì´ˆê³¼ ë¶ˆê°€)
                        if (character.ammo < character.maxAmmo) {
                            character.ammo = Math.min(character.maxAmmo, character.ammo + 1);
                        }
                    }
                    
                    // ì‚¬ì‹  ì¦ê°•: ì ì—ê²Œ ì´ì•Œì„ ë§ì¶œ ì‹œ 0.4ì´ˆê°„ ì€ì‹  + ì´ë™ì†ë„ 15%
                    if (character.hasReaper && character === player) {
                        const now = Date.now();
                        player.isInvisible = true;
                        player.invisibilityEndTime = now + 400; // 0.4ì´ˆ
                    } else if (character.hasReaper && character === enemy) {
                        const now = Date.now();
                        enemy.isInvisible = true;
                        enemy.invisibilityEndTime = now + 400; // 0.4ì´ˆ
                    }
                    
                    // í”¼ê²© ì´í™íŠ¸ ìƒì„± (í”Œë ˆì´ì–´ê°€ ì ì„ ë§ì·„ì„ ë•Œ)
                    if (character === player) {
                        const selectedHitEffect = localStorage.getItem('selectedHitEffectItem');
                        if (selectedHitEffect) {
                            const parts = selectedHitEffect.split('_');
                            if (parts.length >= 3) {
                                const effectType = parts[1]; // dot, triangle, square, etc.
                                
                                // ê°•í™” ì—¬ë¶€ í™•ì¸ (ì„ íƒëœ ê°•í™” ë‹¨ê³„ ì‚¬ìš©)
                                const levelKey = `hitEffect_level_${selectedHitEffect}`;
                                let currentLevel = parseInt(localStorage.getItem(levelKey) || '0');
                                // ê°•í™”ëŠ” ìµœëŒ€ 2ë‹¨ê³„ê¹Œì§€ë§Œ ê°€ëŠ¥í•˜ë¯€ë¡œ ì œí•œ
                                if (currentLevel > 2) {
                                    currentLevel = 2;
                                    localStorage.setItem(levelKey, '2');
                                }
                                const selectedLevelKey = `selectedHitEffectLevel_${selectedHitEffect}`;
                                let selectedLevel = parseInt(localStorage.getItem(selectedLevelKey) || '0');
                                // ì„ íƒëœ ë‹¨ê³„ê°€ ê°•í™”í•œ ë‹¨ê³„ë¥¼ ì´ˆê³¼í•˜ì§€ ì•Šë„ë¡ ì œí•œ
                                if (selectedLevel > currentLevel) {
                                    selectedLevel = 0;
                                    localStorage.setItem(selectedLevelKey, '0');
                                }
                                
                                // ì„ íƒëœ ê°•í™” ë‹¨ê³„ì— ë”°ë¼ ìƒ‰ìƒ ê²°ì •
                                let color = 'gray';
                                let hasNeon = false;
                                if (selectedLevel > 0) {
                                    // ê°•í™”ëœ ê²½ìš°: ë¹¨ê°•, ì£¼í™©, ë…¸ë‘, ì´ˆë¡, íŒŒë‘, ë³´ë¼ ì¤‘ ëœë¤ ì„ íƒ
                                    const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
                                    color = colors[Math.floor(Math.random() * colors.length)];
                                }
                                if (selectedLevel >= 2) {
                                    // 2ë‹¨ê³„ ê°•í™”: ë„¤ì˜¨ íš¨ê³¼ ì ìš©
                                    hasNeon = true;
                                }
                                
                                const colorMap = {
                                    'red': '#ff6666',
                                    'orange': '#ffaa66',
                                    'yellow': '#ffff88',
                                    'blue': '#66aaff',
                                    'purple': '#aa66ff',
                                    'white': '#ffffff',
                                    'green': '#66ff66',
                                    'pink': '#ff66ff',
                                    'gray': '#888888'
                                };
                                const effectColor = colorMap[color] || '#888888';
                                
                                // ë„¤ì˜¨ íš¨ê³¼ ì—¬ë¶€ë¥¼ íŒŒí‹°í´ì— ì €ì¥
                                const neonEffect = hasNeon;
                                
                                // ì´ì•Œì´ ë§ì€ ìœ„ì¹˜ì—ì„œ ì´í™íŠ¸ ìƒì„±
                                const hitX = bullet.x;
                                const hitY = bullet.y;
                                
                                if (effectType === 'dot') {
                                    // ì  ì´í™íŠ¸: íšŒìƒ‰ ì  3~5ê°œ í©ë¿Œë¦¬ê¸°
                                    const dotCount = 3 + Math.floor(Math.random() * 3); // 3~5ê°œ
                                    for (let i = 0; i < dotCount; i++) {
                                        // ì´ì•Œì´ ë§ì€ ìœ„ì¹˜ì—ì„œ Â±10px ë²”ìœ„ ë‚´ì—ì„œ ëœë¤ ìƒì„±
                                        const offsetX = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const offsetY = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const startX = hitX + offsetX;
                                        const startY = hitY + offsetY;
                                        
                                        // í¼ì§€ëŠ” ë°©í–¥ê³¼ ì†ë„
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 50 + Math.random() * 50; // í¼ì§€ëŠ” ì†ë„ (ë” ë„“ê²Œ)
                                        
                                        player.hitEffectParticles.push({
                                            x: startX,
                                            y: startY,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            type: 'dot',
                                            color: effectColor,
                                            life: neonEffect ? 1.1 : 0.75, // ë„¤ì˜¨ íš¨ê³¼ ì‹œ ë” ê¸¸ê²Œ ì§€ì†
                                            maxLife: neonEffect ? 1.1 : 0.75,
                                            size: 4 + Math.random() * 2, // í¬ê¸° 4~6
                                            hasNeon: neonEffect // ë„¤ì˜¨ íš¨ê³¼ ì—¬ë¶€
                                        });
                                    }
                                } else if (effectType === 'triangle') {
                                    // ì‚¼ê°í˜• ì´í™íŠ¸: íšŒìƒ‰ ì‚¼ê°í˜• 3~5ê°œ í©ë¿Œë¦¬ê¸°
                                    const triangleCount = 3 + Math.floor(Math.random() * 3); // 3~5ê°œ
                                    for (let i = 0; i < triangleCount; i++) {
                                        // ì´ì•Œì´ ë§ì€ ìœ„ì¹˜ì—ì„œ Â±10px ë²”ìœ„ ë‚´ì—ì„œ ëœë¤ ìƒì„±
                                        const offsetX = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const offsetY = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const startX = hitX + offsetX;
                                        const startY = hitY + offsetY;
                                        
                                        // í¼ì§€ëŠ” ë°©í–¥ê³¼ ì†ë„
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 50 + Math.random() * 50; // í¼ì§€ëŠ” ì†ë„ (ë” ë„“ê²Œ)
                                        
                                        player.hitEffectParticles.push({
                                            x: startX,
                                            y: startY,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            type: 'triangle',
                                            color: effectColor,
                                            life: neonEffect ? 1.1 : 0.75, // ë„¤ì˜¨ íš¨ê³¼ ì‹œ ë” ê¸¸ê²Œ ì§€ì†
                                            maxLife: neonEffect ? 1.1 : 0.75,
                                            size: 6 + Math.random() * 2, // í¬ê¸° 6~8
                                            rotation: Math.random() * Math.PI * 2, // ëœë¤ íšŒì „ ê°ë„
                                            hasNeon: neonEffect // ë„¤ì˜¨ íš¨ê³¼ ì—¬ë¶€
                                        });
                                    }
                                } else if (effectType === 'square') {
                                    // ì‚¬ê°í˜• ì´í™íŠ¸: íšŒìƒ‰ ì‚¬ê°í˜• 3~5ê°œ í©ë¿Œë¦¬ê¸°
                                    const squareCount = 3 + Math.floor(Math.random() * 3); // 3~5ê°œ
                                    for (let i = 0; i < squareCount; i++) {
                                        // ì´ì•Œì´ ë§ì€ ìœ„ì¹˜ì—ì„œ Â±10px ë²”ìœ„ ë‚´ì—ì„œ ëœë¤ ìƒì„±
                                        const offsetX = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const offsetY = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const startX = hitX + offsetX;
                                        const startY = hitY + offsetY;
                                        
                                        // í¼ì§€ëŠ” ë°©í–¥ê³¼ ì†ë„
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 50 + Math.random() * 50; // í¼ì§€ëŠ” ì†ë„ (ë” ë„“ê²Œ)
                                        
                                        player.hitEffectParticles.push({
                                            x: startX,
                                            y: startY,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            type: 'square',
                                            color: effectColor,
                                            life: neonEffect ? 1.1 : 0.75, // ë„¤ì˜¨ íš¨ê³¼ ì‹œ ë” ê¸¸ê²Œ ì§€ì†
                                            maxLife: neonEffect ? 1.1 : 0.75,
                                            size: 4 + Math.random() * 2, // í¬ê¸° 4~6
                                            rotation: Math.random() * Math.PI * 2, // ëœë¤ íšŒì „ ê°ë„
                                            hasNeon: neonEffect // ë„¤ì˜¨ íš¨ê³¼ ì—¬ë¶€
                                        });
                                    }
                                } else if (effectType === 'diamond') {
                                    // ë§ˆë¦„ëª¨ ì´í™íŠ¸
                                    for (let i = 0; i < 6; i++) {
                                        const angle = (Math.PI * 2 / 6) * i;
                                        const distance = 12 + Math.random() * 8;
                                        player.hitEffectParticles.push({
                                            x: hitX + Math.cos(angle) * distance,
                                            y: hitY + Math.sin(angle) * distance,
                                            type: 'diamond',
                                            color: effectColor,
                                            life: 0.5,
                                            maxLife: 0.5,
                                            size: 4 + Math.random() * 3
                                        });
                                    }
                                } else if (effectType === 'spark') {
                                    // ìŠ¤íŒŒí¬ ì´í™íŠ¸: ì—¬ëŸ¬ ê°œì˜ ì§§ì€ ì„ 
                                    for (let i = 0; i < 12; i++) {
                                        const angle = Math.random() * Math.PI * 2;
                                        player.hitEffectParticles.push({
                                            x: hitX,
                                            y: hitY,
                                            angle: angle,
                                            type: 'spark',
                                            color: effectColor,
                                            life: neonEffect ? 0.6 : 0.3, // ë„¤ì˜¨ íš¨ê³¼ ì‹œ 2ë°° ì§€ì†
                                            maxLife: neonEffect ? 0.6 : 0.3,
                                            length: 8 + Math.random() * 6,
                                            size: 1.5 + Math.random() * 1,
                                            hasNeon: neonEffect // ë„¤ì˜¨ íš¨ê³¼ ì—¬ë¶€
                                        });
                                    }
                                } else if (effectType === 'firework') {
                                    // í­ì£½ ì´í™íŠ¸: ì´ì•Œ í¬ê¸°ì˜ 75% ì§ì‚¬ê°í˜• 6ê°œê°€ 60ë„ì”© í¼ì§€ëŠ” ë¶ˆê½ƒë†€ì´ ëŠë‚Œ
                                    const rectangleCount = 6;
                                    const angleStep = (Math.PI * 2) / rectangleCount; // 60ë„ì”©
                                    const randomRotation = Math.random() * Math.PI * 2; // ì „ì²´ ëœë¤ íšŒì „
                                    
                                    // ì´ì•Œ ê¸°ë³¸ í¬ê¸° (radius 9, ì§€ë¦„ 18)
                                    const bulletSize = 9 * 2; // ì´ì•Œ ì§€ë¦„
                                    const rectangleSize = bulletSize * 0.75 * 1.25; // ì´ì•Œ í¬ê¸°ì˜ 75% * 1.25ë°° (25% ì¦ê°€)
                                    
                                    for (let i = 0; i < rectangleCount; i++) {
                                        const angle = angleStep * i + randomRotation; // 60ë„ ê°„ê²© + ëœë¤ íšŒì „
                                        
                                        player.hitEffectParticles.push({
                                            x: hitX,
                                            y: hitY,
                                            angle: angle,
                                            type: 'firework',
                                            color: effectColor,
                                            life: neonEffect ? 1.1 : 0.75, // ë„¤ì˜¨ íš¨ê³¼ ì‹œ ë” ê¸¸ê²Œ ì§€ì†
                                            maxLife: neonEffect ? 1.1 : 0.75,
                                            size: rectangleSize, // ì§ì‚¬ê°í˜• í¬ê¸° (ì´ì•Œ í¬ê¸°ì˜ 75% * 1.25ë°°)
                                            speed: 1.0, // ì´ˆê¸° ì†ë„
                                            hasNeon: neonEffect // ë„¤ì˜¨ íš¨ê³¼ ì—¬ë¶€
                                        });
                                    }
                                } else if (effectType === 'ring') {
                                    // ë§ ì´í™íŠ¸: í™•ì¥ë˜ëŠ” ì›
                                    for (let i = 0; i < 3; i++) {
                                        player.hitEffectParticles.push({
                                            x: hitX,
                                            y: hitY,
                                            type: 'ring',
                                            color: effectColor,
                                            life: 0.6,
                                            maxLife: 0.6,
                                            size: 5 + i * 5,
                                            maxSize: 30 + i * 10
                                        });
                                    }
                                } else if (effectType === 'burst') {
                                    // í­ë°œ ì´í™íŠ¸: ì—¬ëŸ¬ ë°©í–¥ìœ¼ë¡œ í¼ì§€ëŠ” íŒŒí‹°í´
                                    for (let i = 0; i < 16; i++) {
                                        const angle = (Math.PI * 2 / 16) * i + Math.random() * 0.3;
                                        const speed = 20 + Math.random() * 30;
                                        player.hitEffectParticles.push({
                                            x: hitX,
                                            y: hitY,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            type: 'burst',
                                            color: effectColor,
                                            life: 0.5,
                                            maxLife: 0.5,
                                            size: 4 + Math.random() * 3
                                        });
                                    }
                                }
                            }
                        }
                    }
                    
                    // í”¼ì˜ ë§›: ì ì—ê²Œ ì…íŒ í”¼í•´ì˜ 20%ë§Œí¼ íšŒë³µ (20%ì”© ì¤‘ì²©)
                    if (character.hasTasteOfBlood) {
                        const tasteOfBloodCount = character.tasteOfBloodCount || 1;
                        let healAmount = finalDamage * (0.2 * tasteOfBloodCount);
                        healAmount = roundToMaxTwoDecimals(healAmount);
                        const oldHealth = character.health;
                        character.health = Math.min(character.health + healAmount, character.maxHealth);
                        character.health = roundToMaxTwoDecimals(character.health);
                        const actualHeal = character.health - oldHealth;
                        if (actualHeal > 0) {
                            // íšŒë³µ ìˆ«ì í‘œì‹œ (ë¹¨ê°„ìƒ‰)
                            character.damageNumbers.push({
                                x: character.x,
                                y: character.y,
                                damage: roundToMaxTwoDecimals(actualHeal),
                                isCritical: false,
                                isHeal: true, // íšŒë³µ ì—¬ë¶€
                                startTime: Date.now(),
                                duration: 1000,
                                offsetY: 0
                            });
                        }
                    }
                    
                    // ì„ ê³ : ì ì„ ë§ì€ ë°©í–¥ìœ¼ë¡œ 75px ë°€ë ¤ë‚¨ (0.1ì´ˆ ì†Œìš”)
                    if (character.hasJudgment) {
                        const bulletAngle = bullet.angle;
                        const pushDistance = 75;
                        const pushDuration = 100; // 0.1ì´ˆ
                        const pushDx = Math.cos(bulletAngle) * pushDistance;
                        const pushDy = Math.sin(bulletAngle) * pushDistance;
                        
                        // ë°€ë ¤ë‚˜ëŠ” ëª©í‘œ ìœ„ì¹˜
                        const targetPushX = Math.max(
                            gameState.mapBounds.minX + target.radius,
                            Math.min(gameState.mapBounds.maxX - target.radius, target.x + pushDx)
                        );
                        const targetPushY = Math.max(
                            gameState.mapBounds.minY + target.radius,
                            Math.min(gameState.mapBounds.maxY - target.radius, target.y + pushDy)
                        );
                        
                        // ë°€ë ¤ë‚˜ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                        target.judgmentPushStartX = target.x;
                        target.judgmentPushStartY = target.y;
                        target.judgmentPushTargetX = targetPushX;
                        target.judgmentPushTargetY = targetPushY;
                        target.judgmentPushStartTime = Date.now();
                        target.judgmentPushDuration = pushDuration;
                        target.isJudgmentPushing = true;
                    }
                    
                    character.bullets.splice(i, 1);

                    // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ ì¶”ê°€
                    target.damageNumbers.push({
                        x: target.x,
                        y: target.y,
                        damage: finalDamage,
                        isCritical: isCritical, // í¬ë¦¬í‹°ì»¬ ì—¬ë¶€
                        startTime: Date.now(),
                        duration: 1000, // 1ì´ˆ ë™ì•ˆ í‘œì‹œ
                        offsetY: 0 // ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì˜¤í”„ì…‹
                    });

                    // ë²ˆê°œ: í™•ë¥  ì¤‘ì²© (25% * count)
                    const lightningCount = character.lightningCount || 1;
                    if (character.hasLightning && Math.random() < (0.25 * lightningCount)) {
                        target.isStunned = true;
                        target.stunEndTime = Date.now() + 750; // 0.75ì´ˆ
                        // ê¸°ì ˆ í…ìŠ¤íŠ¸ í‘œì‹œ (ë°ë¯¸ì§€ ìˆ«ì ìœ„ì— í‘œì‹œ)
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isStunned: true, // ê¸°ì ˆ ì—¬ë¶€
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: -40 // ë°ë¯¸ì§€ ìˆ«ì ìœ„ì— í‘œì‹œ
                        });
                    }

                    // ê¹Šì€ ìƒì²˜ (í”¼ê²© ì‹œ ìƒëŒ€ ì´ë™ì†ë„ -25% (ì‹œê°„ ì¤‘ì²©))
                    if (character.hasDeepWound) {
                        const deepWoundCount = character.deepWoundCount || 1;
                        target.slowEndTime = Date.now() + (500 * deepWoundCount);
                    }
                    
                    // ë… íƒ„í™˜ íš¨ê³¼ (1ì´ˆê°„ê²©ìœ¼ë¡œ 3ë²ˆ, ë°ë¯¸ì§€ ì¤‘ì²©)
                    if (bullet.hasPoison) {
                        const poisonCount = character.poisonBulletCount || 1;
                        character.poisonEffects.push({
                            target: target,
                            startTime: Date.now(),
                            duration: 3000, // 3ì´ˆ (1ì´ˆê°„ê²©ìœ¼ë¡œ 3ë²ˆ)
                            damagePerSecond: 0.2 * poisonCount, // ì¤‘ì²©ëœ ë°ë¯¸ì§€
                            lastDamageTime: Date.now(),
                            hitCount: 0, // íˆíŠ¸ íšŸìˆ˜
                            maxHits: 3 // ìµœëŒ€ íˆíŠ¸ íšŸìˆ˜
                        });
                    }
                    
                    // ì§‘ì¤‘ ì‚¬ê²©: í”¼ê²©ì‹œ 50% í™•ë¥ ë¡œ ìƒëŒ€ì—ê²Œ ì·¨ì•½ ë¶€ì—¬
                    if (target.hasFocusedFire && Math.random() < 0.5) {
                        character.isVulnerable = true;
                        character.vulnerabilityUsed = false;
                    }

                    if (target.health <= 0) {
                        target.health = 0;
                        
                        // ë¶€í™œ ì²´í¬ (íšŸìˆ˜ ì¤‘ì²©)
                        const reviveCount = target.reviveCount || 1;
                        const hasRevivedCount = (typeof target.hasRevived === 'number' ? target.hasRevived : (target.hasRevived ? 1 : 0));
                        if (target.hasRevive && hasRevivedCount < reviveCount && !target.isReviving) {
                            target.hasRevived = hasRevivedCount + 1; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì¦ê°€
                            target.isReviving = true;
                            target.reviveTime = Date.now() + 2000; // 2ì´ˆ
                        } else {
                            endRound(character === player ? 'player' : 'enemy');
                        }
                    }
                    // ì²´ë ¥ì´ ìŒìˆ˜ê°€ ë˜ì§€ ì•Šë„ë¡
                    if (target.health < 0) target.health = 0;
                }
            }
        }

        // ë¼ìš´ë“œ ì¢…ë£Œ
        function endRound(winner) {
            // ëª¨ë“  ì´í™íŠ¸ ì§€ìš°ê¸°
            if (player.hitEffectParticles) {
                player.hitEffectParticles = [];
            }
            if (enemy.hitEffectParticles) {
                enemy.hitEffectParticles = [];
            }
            // ë©€í‹°í”Œë ˆì´ì–´: ê²ŒìŠ¤íŠ¸ëŠ” í˜¸ìŠ¤íŠ¸ë¡œë¶€í„° ê²°ê³¼ë¥¼ ë°›ìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
            if (gameState.isMultiplayer && !isHost) {
                return; // ê²ŒìŠ¤íŠ¸ëŠ” handleRoundEndFromHostì—ì„œ ì²˜ë¦¬
            }
            
            gameState.isPaused = true;

            // ë©€í‹°í”Œë ˆì´ì–´: í˜¸ìŠ¤íŠ¸ê°€ ê²°ê³¼ ì „ì†¡
            if (gameState.isMultiplayer && isHost) {
                sendMultiplayerData({
                    type: 'roundEnd',
                    winner: winner === 'player' ? 'host' : 'guest'
                });
            }

            // ë¼ìš´ë“œ ìŠ¹ë¦¬ ê¸°ë¡ì— ì¶”ê°€ (ìˆœì„œëŒ€ë¡œ)
            gameState.roundWins.push(winner);

            if (winner === 'player') {
                gameState.playerWins++;
            } else {
                gameState.enemyWins++;
            }

            // ìŠ¹ë¦¬ ì²´í¬ (5ë¼ìš´ë“œ ì„ ìŠ¹ì œ)
            if (gameState.playerWins >= gameState.winsNeeded || gameState.enemyWins >= gameState.winsNeeded) {
                const finalWinner = winner === 'player' ? 'player' : 'enemy';
                endGame(finalWinner);
                return;
            }

            // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œ (í˜¸ìŠ¤íŠ¸)
            if (gameState.isMultiplayer) {
                if (winner === 'player') {
                    // ë‚´ê°€ ìŠ¹ë¦¬: ìƒëŒ€ê°€ ì¦ê°• ì„ íƒ ì¤‘ - 15ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ë§Œ í‘œì‹œ
                    gameState.showOpponentSelecting = true;
                    gameState.augmentCountdown = 15;
                    startOpponentWaitCountdown();
                } else {
                    // ë‚´ê°€ íŒ¨ë°°: ì¦ê°• ì„ íƒ
                    showAugmentModal(player);
                }
                return;
            }

            // ì†”ë¡œ ëª¨ë“œ: íŒ¨ë°°ìê°€ ì¦ê°• ì„ íƒ, ìŠ¹ë¦¬ìëŠ” í™•ì¸ë§Œ
            if (winner === 'player') {
                // í”Œë ˆì´ì–´ ìŠ¹ë¦¬: AIê°€ ì„ íƒ
                gameState.showOpponentSelecting = true;
                selectAugmentForEnemy();
            } else {
                // enemy ìŠ¹ë¦¬: í”Œë ˆì´ì–´ëŠ” ì„ íƒ
                showAugmentModal(player);
            }
        }

        // ì ì„ ìœ„í•œ ì¦ê°• ìë™ ì„ íƒ
        function selectAugmentForEnemy() {
            const enemySelectionDiv = document.getElementById('enemySelection');
            const opponentSelectionDiv = document.getElementById('opponentSelection');
            
            if (enemySelectionDiv) {
            enemySelectionDiv.style.display = 'block';
            enemySelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>';
            }
            
            if (opponentSelectionDiv) {
                opponentSelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>';
            }
            
            // 2Xëª¨ë“œ ì²´í¬ - AIë„ 2ê°œ ì„ íƒ
            const isDoubleAugmentMode = gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'doubleAugment';
            const selectCount = isDoubleAugmentMode ? 2 : 1;
            
            // 3ì´ˆ ëŒ€ê¸° í›„ ì„ íƒ
            setTimeout(() => {
                // AIëŠ” êµ¬ë¥´ê¸°, ê±°ì í™•ë³´, ì‹œê°„ì •ì§€ ì¦ê°•ì„ ë½‘ì§€ ì•ŠìŒ
                const availableAugments = augmentations.filter(aug => aug.id !== 'dodge' && aug.id !== 'fortify' && aug.id !== 'timeStop');
                const shuffled = [...availableAugments].sort(() => Math.random() - 0.5);
                
                // selectCountë§Œí¼ ì¦ê°• ì„ íƒ
                const selectedAugments = [];
                for (let i = 0; i < selectCount && i < shuffled.length; i++) {
                    const selectedAugment = shuffled[i];
                    selectedAugment.effect(enemy);
                    enemy.augmentations.push(selectedAugment);
                    incrementAugmentSelectCount(selectedAugment.id); // ì„ íƒ íšŸìˆ˜ ì¦ê°€
                    markAugmentAsSeen(selectedAugment.id); // ë³¸ ì¦ê°• ëª©ë¡ì— ì¶”ê°€
                    selectedAugments.push(selectedAugment);
                }
                
                // ì„ íƒí•œ ì¦ê°• í‘œì‹œ
                const selectedNames = selectedAugments.map(aug => aug.name).join(', ');
                if (enemySelectionDiv) {
                    enemySelectionDiv.innerHTML = `<p style="color: #e94560; margin: 0;">ìƒëŒ€ ì„ íƒ: <strong style="color: #ffc107;">${selectedNames}</strong></p>`;
                }
                if (opponentSelectionDiv) {
                    opponentSelectionDiv.innerHTML = `<p style="color: #e94560; margin: 0;">ìƒëŒ€ ì„ íƒ: <strong style="color: #ffc107;">${selectedNames}</strong></p>`;
                }
                
                // í”Œë ˆì´ì–´ê°€ ìŠ¹ë¦¬í•œ ê²½ìš°: ìƒëŒ€ ì„ íƒ ì™„ë£Œ í›„ ìë™ìœ¼ë¡œ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                if (gameState.showOpponentSelecting) {
                    gameState.showOpponentSelecting = false;
                    // ì•½ê°„ì˜ ë”œë ˆì´ í›„ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                    setTimeout(() => {
                        nextRound();
                    }, 500);
                }
            }, 3000);
        }

        // ì¦ê°• ëª¨ë‹¬ í‘œì‹œ (í”Œë ˆì´ì–´ìš© - ì„ íƒ ê°€ëŠ¥)
        function showAugmentModal(character) {
            const modal = document.getElementById('augmentModal');
            const optionsDiv = document.getElementById('augmentOptions');
            optionsDiv.innerHTML = '';

            // ëœë¤ ì¦ê°• 3ê°œ ì„ íƒ (ì¤‘ë³µ ì„ íƒ ê°€ëŠ¥)
            const shuffled = [...augmentations].sort(() => Math.random() - 0.5);
            const selectedAugments = shuffled.slice(0, 3);

            // ì„ íƒ ê°€ëŠ¥í•œ 3ê°œ ì¦ê°• ëª¨ë‘ ë„ê°ì— ì €ì¥
            selectedAugments.forEach(aug => {
                markAugmentAsSeen(aug.id);
            });

            let timeLeft = 15;
            let isSelected = false;
            let timerInterval;

            // 2Xëª¨ë“œ ì²´í¬
            const isDoubleAugmentMode = gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'doubleAugment';
            
            // 2Xëª¨ë“œì—ì„œ í˜„ì¬ ë¼ìš´ë“œì— ì„ íƒí•œ ì¦ê°• ê°œìˆ˜ ì´ˆê¸°í™” (ì²˜ìŒ í˜¸ì¶œ ì‹œì—ë§Œ)
            if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount === undefined) {
                gameState.doubleAugmentSelectedCount = 0;
            }
            
            const maxSelections = isDoubleAugmentMode ? 2 : 1;
            const currentSelectedCount = isDoubleAugmentMode ? (gameState.doubleAugmentSelectedCount || 0) : 0;

            // ì¦ê°• ì„ íƒ í•¨ìˆ˜
            const selectAugment = (aug) => {
                if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount >= maxSelections) return;
                if (!isDoubleAugmentMode && isSelected) return;
                
                aug.effect(character);
                character.augmentations.push(aug);
                incrementAugmentSelectCount(aug.id); // ì„ íƒ íšŸìˆ˜ ì¦ê°€
                
                // ë©€í‹°í”Œë ˆì´ì–´: ì¦ê°• ì„ íƒ ì •ë³´ ì „ì†¡
                if (gameState.isMultiplayer) {
                    sendMultiplayerData({
                        type: 'augmentSelected',
                        augment: { id: aug.id, name: aug.name }
                    });
                }
                
                if (isDoubleAugmentMode) {
                    gameState.doubleAugmentSelectedCount = (gameState.doubleAugmentSelectedCount || 0) + 1;
                }
                
                // 2Xëª¨ë“œì´ê³  ì²« ë²ˆì§¸ ì„ íƒì´ë©´ ì°½ì„ ë‹«ê³  ìƒˆë¡œìš´ ì°½ ë„ìš°ê¸°
                if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount === 1) {
                    isSelected = true;
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    modal.style.display = 'none';
                    
                    // ì•½ê°„ì˜ ë”œë ˆì´ í›„ ìƒˆë¡œìš´ ì°½ ë„ìš°ê¸°
                    setTimeout(() => {
                        showAugmentModal(character);
                    }, 300);
                    
                    return; // ì•„ì§ ì„ íƒ ì¤‘
                }
                
                // ì„ íƒ ì™„ë£Œ
                if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount >= maxSelections) {
                    isSelected = true;
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    gameState.doubleAugmentSelectedCount = 0; // ë‹¤ìŒ ë¼ìš´ë“œë¥¼ ìœ„í•´ ì´ˆê¸°í™”
                    modal.style.display = 'none';
                    const viewModal = document.getElementById('augmentViewModal');
                    if (viewModal) {
                        viewModal.style.display = 'none';
                    }
                    nextRound();
                } else if (!isDoubleAugmentMode) {
                    isSelected = true;
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    modal.style.display = 'none';
                    const viewModal = document.getElementById('augmentViewModal');
                    if (viewModal) {
                        viewModal.style.display = 'none';
                    }
                    nextRound();
                }
            };

            // ì¦ê°• ì˜µì…˜ ìƒì„±
            selectedAugments.forEach(aug => {
                const option = document.createElement('div');
                option.className = 'augment-option';
                option.innerHTML = `
                    <h4>${aug.name}</h4>
                    <p>${aug.description}</p>
                `;
                option.onclick = () => selectAugment(aug);
                optionsDiv.appendChild(option);
            });

            // ëª¨ë‹¬ í‘œì‹œ
            modal.style.display = 'block';
            const enemySelectionDiv = document.getElementById('enemySelection');
            // í”Œë ˆì´ì–´ê°€ íŒ¨ë°°í•œ ê²½ìš°: ì ì€ ìŠ¹ë¦¬ìì´ë¯€ë¡œ ì¦ê°•ì„ ì„ íƒí•˜ì§€ ì•ŠìŒ, ë©”ì‹œì§€ í‘œì‹œ ì•ˆí•¨
            enemySelectionDiv.style.display = 'none';
            
            // í™”ë©´ ê°€ìš´ë° ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
            gameState.augmentCountdown = 15;
            timerInterval = setInterval(() => {
                timeLeft--;
                gameState.augmentCountdown = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    if (!isSelected) {
                        // ì‹œê°„ ì´ˆê³¼ ì‹œ ëœë¤ ì„ íƒ
                        const randomAug = selectedAugments[Math.floor(Math.random() * selectedAugments.length)];
                        selectAugment(randomAug);
                    }
                }
            }, 1000);
        }

        // ì¦ê°• í™•ì¸ ëª¨ë‹¬ í‘œì‹œ (ìŠ¹ë¦¬ììš© - í™•ì¸ë§Œ ê°€ëŠ¥)
        function showAugmentViewModal(winnerCharacter, loserType) {
            const modal = document.getElementById('augmentViewModal');
            const opponentSelectionDiv = document.getElementById('opponentSelection');
            
            // ëª¨ë‹¬ í‘œì‹œ
            modal.style.display = 'block';
            opponentSelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>';
        }

        // ì¦ê°• í™•ì¸ ëª¨ë‹¬ ë‹«ê¸°
        function closeAugmentViewModal() {
            const modal = document.getElementById('augmentViewModal');
            modal.style.display = 'none';
            
            // ìƒëŒ€ ì„ íƒì´ ì™„ë£Œë˜ì—ˆìœ¼ë©´ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
            if (enemy.augmentations.length > 0) {
                nextRound();
            } else {
                // ì•„ì§ ì ì´ ì„ íƒ ì¤‘ì´ë©´ ëŒ€ê¸°
                const checkEnemySelection = setInterval(() => {
                    if (enemy.augmentations.length > 0) {
                        clearInterval(checkEnemySelection);
                        nextRound();
                    }
                }, 100);
            }
        }

        // ë‹¤ìŒ ë¼ìš´ë“œ
        function nextRound() {
            // ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€ (ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ)
            if (gameState.isMultiplayer && gameState.isNextRoundProcessing) {
                return;
            }
            gameState.isNextRoundProcessing = true;
            
            // ìŠ¹ë¦¬ì ì¦ê°•: ë¼ìš´ë“œ ì‹œì‘ ì‹œ 10% í™•ë¥ ë¡œ ì¦‰ì‹œ ìŠ¹ë¦¬
            if (player.hasVictor && Math.random() < 0.1) {
                gameState.isNextRoundProcessing = false;
                endRound('player');
                return;
            }
            if (enemy.hasVictor && Math.random() < 0.1) {
                gameState.isNextRoundProcessing = false;
                endRound('enemy');
                return;
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´: í˜¸ìŠ¤íŠ¸ê°€ ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘ ì•Œë¦¼
            if (gameState.isMultiplayer && isHost) {
                sendMultiplayerData({ type: 'nextRound' });
            }
            
            resizeCanvas();
            gameState.round++;
            gameState.gameTime = 180;
            gameState.roundStartTime = Date.now(); // ë¼ìš´ë“œ ì‹œì‘ ì‹œê°„ ê¸°ë¡
            gameState.lastObstacleRemoveTime = Date.now(); // ì¥ì• ë¬¼ ì œê±° ì‹œê°„ ì´ˆê¸°í™”
            gameState.showOpponentSelecting = false;
            // 2Xëª¨ë“œ ì„ íƒ ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'doubleAugment') {
                gameState.doubleAugmentSelectedCount = 0;
            }
            
            // ì „íˆ¬ ê²½í—˜: ì§„ ë¼ìš´ë“œ ìˆ˜ë§ˆë‹¤ ìµœëŒ€ì²´ë ¥ 0.5, ë°ë¯¸ì§€ 0.1 ì¦ê°€ (ì¤‘ì²©)
            if (player.hasCombatExperience) {
                player.combatExperienceRounds = gameState.enemyWins; // í”Œë ˆì´ì–´ê°€ ì§„ ë¼ìš´ë“œ ìˆ˜ (ì ì´ ì´ê¸´ ë¼ìš´ë“œ)
                const combatExperienceCount = player.combatExperienceCount || 1;
                player.maxHealth = 5 + player.combatExperienceRounds * (0.5 * combatExperienceCount);
                player.damage = 1 + player.combatExperienceRounds * (0.1 * combatExperienceCount);
            }
            if (enemy.hasCombatExperience) {
                enemy.combatExperienceRounds = gameState.playerWins; // ì ì´ ì§„ ë¼ìš´ë“œ ìˆ˜ (í”Œë ˆì´ì–´ê°€ ì´ê¸´ ë¼ìš´ë“œ)
                const combatExperienceCount = enemy.combatExperienceCount || 1;
                enemy.maxHealth = 5 + enemy.combatExperienceRounds * (0.5 * combatExperienceCount);
                enemy.damage = 1 + enemy.combatExperienceRounds * (0.1 * combatExperienceCount);
            }

            // í”Œë ˆì´ì–´ ìƒíƒœ ì´ˆê¸°í™” - ë©€í‹°í”Œë ˆì´ì–´ì¼ ë•Œ íŒ€ì— ë”°ë¥¸ ìœ„ì¹˜ ì„¤ì •
            const leftX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            const rightX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            const centerY = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            
            if (gameState.isMultiplayer && myTeam) {
                // ë©€í‹°í”Œë ˆì´ì–´: íŒŒë€íŒ€ì€ ì™¼ìª½, ë¹¨ê°„íŒ€ì€ ì˜¤ë¥¸ìª½
                player.x = myTeam === 'blue' ? leftX : rightX;
                enemy.x = myTeam === 'blue' ? rightX : leftX;
            } else {
                // ì†”ë¡œ: í”Œë ˆì´ì–´ ì™¼ìª½, ì  ì˜¤ë¥¸ìª½
                player.x = leftX;
            }
            player.y = centerY;
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” ì²´ë ¥ì„ ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ (ê²Œì„ ì¤‘ì—ëŠ” ì²´ë ¥ ìœ ì§€)
            // ë¼ìš´ë“œ ì‹œì‘ ì‹œì—ë§Œ ì²´ë ¥ ì´ˆê¸°í™”
            if (!gameState.isMultiplayer || gameState.round === 1) {
                player.health = player.maxHealth;
                player.displayHealth = player.maxHealth;
            }
            // í•´ë¥˜/ë§ê° ì‹œì‘ ì‹œê°„ ì´ˆê¸°í™”
            if (player.hasTide) {
                player.tideStartTime = Date.now();
            }
            if (player.hasOblivion) {
                player.oblivionStartTime = Date.now();
                player.oblivionActivated = false;
            }
            player.ammo = player.maxAmmo;
            player.bullets = [];
            player.isReloading = false;
            player.isDodging = false;
            player.dodgeStartTime = 0;
            player.dodgeEndTime = 0;
            player.dodgeStartX = 0;
            player.dodgeStartY = 0;
            player.dodgeTargetX = 0;
            player.dodgeTargetY = 0;
            player.dodgeTrail = [];
            player.lastDodgeTime = 0;
            player.isReviving = false;
            player.reviveTime = 0;
            player.hasRevived = 0; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
            player.isInvincible = false;
            player.invincibleEndTime = 0;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.poisonEffects = [];
            player.hasRecoveryContractUsed = false; // íšŒë³µê³„ì•½ ì´ˆê¸°í™”
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.shieldReady = true; // ë°©ì–´ë§‰ ì¤€ë¹„ ìƒíƒœë¡œ ì´ˆê¸°í™”
            player.shieldCooldown = 0;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.lastRegenTime = Date.now(); // ì¬ìƒ ì‹œì‘ ì‹œê°„
            // ìƒˆë¡œìš´ ì¦ê°• ìƒíƒœ ì´ˆê¸°í™” (ë¼ìš´ë“œ ì´ˆê¸°í™”)
            player.reflectActive = false;
            player.reflectCooldown = 0;
            player.reflectEndTime = 0;
            player.timeStopActive = false;
            player.timeStopCooldown = 0;
            player.timeStopEndTime = 0;

            // ì  ìƒíƒœ ì´ˆê¸°í™” - ë©€í‹°í”Œë ˆì´ì–´ê°€ ì•„ë‹ ë•Œë§Œ ìœ„ì¹˜ ì„¤ì • (ìœ„ì—ì„œ ì´ë¯¸ ì„¤ì •í•¨)
            if (!gameState.isMultiplayer) {
                enemy.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            }
            enemy.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” ì²´ë ¥ì„ ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ (ê²Œì„ ì¤‘ì—ëŠ” ì²´ë ¥ ìœ ì§€)
            // ë¼ìš´ë“œ ì‹œì‘ ì‹œì—ë§Œ ì²´ë ¥ ì´ˆê¸°í™”
            if (!gameState.isMultiplayer || gameState.round === 1) {
                enemy.health = enemy.maxHealth;
                enemy.displayHealth = enemy.maxHealth;
            }
            // í•´ë¥˜/ë§ê° ì‹œì‘ ì‹œê°„ ì´ˆê¸°í™”
            if (enemy.hasTide) {
                enemy.tideStartTime = Date.now();
            }
            if (enemy.hasOblivion) {
                enemy.oblivionStartTime = Date.now();
                enemy.oblivionActivated = false;
            }
            
            // í”Œë˜ê·¸ í•´ì œ (ë‹¤ìŒ ë¼ìš´ë“œ ì¤€ë¹„)
            gameState.isNextRoundProcessing = false;
            enemy.ammo = enemy.maxAmmo;
            enemy.bullets = [];
            enemy.isReloading = false;
            enemy.isDodging = false;
            enemy.dodgeStartTime = 0;
            enemy.dodgeEndTime = 0;
            enemy.dodgeStartX = 0;
            enemy.dodgeStartY = 0;
            enemy.dodgeTargetX = 0;
            enemy.dodgeTargetY = 0;
            enemy.bulletDodgeTargetY = 0;
            enemy.isDodgingBullet = false;
            enemy.lastPlayerBulletCount = 0;
            enemy.dodgeTrail = [];
            enemy.lastDodgeTime = 0;
            enemy.isReviving = false;
            enemy.reviveTime = 0;
            enemy.hasRevived = 0; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
            enemy.isInvincible = false;
            enemy.invincibleEndTime = 0;
            enemy.slowEndTime = 0;
            enemy.damageNumbers = [];
            enemy.usePrediction = false;
            enemy.lastPlayerX = 0;
            enemy.lastPlayerY = 0;
            enemy.playerVelocity = { x: 0, y: 0 };
            enemy.poisonEffects = [];
            enemy.hasRecoveryContractUsed = false; // íšŒë³µê³„ì•½ ì´ˆê¸°í™”
            enemy.isVulnerable = false;
            enemy.vulnerabilityUsed = false;
            enemy.isStunned = false;
            enemy.stunEndTime = 0;
            enemy.shieldReady = true; // ë°©ì–´ë§‰ ì¤€ë¹„ ìƒíƒœë¡œ ì´ˆê¸°í™”
            enemy.shieldCooldown = 0;
            enemy.isWeakened = false;
            enemy.weakenEndTime = 0;
            enemy.lastRegenTime = Date.now(); // ì¬ìƒ ì‹œì‘ ì‹œê°„
            // ìƒˆë¡œìš´ ì¦ê°• ìƒíƒœ ì´ˆê¸°í™” (ë¼ìš´ë“œ ì´ˆê¸°í™”)
            enemy.reflectActive = false;
            enemy.reflectCooldown = 0;
            enemy.reflectEndTime = 0;
            enemy.timeStopActive = false;
            enemy.timeStopCooldown = 0;
            enemy.timeStopEndTime = 0;

            // 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (ê²Œì„ ì™„ì „íˆ ë©ˆì¶¤)
            gameState.countdown = 3;
            gameState.isPaused = true;
            
            // ì¹´ìš´íŠ¸ë‹¤ìš´ ì²˜ë¦¬ - ë©€í‹°í”Œë ˆì´ì–´ ê²ŒìŠ¤íŠ¸ëŠ” í˜¸ìŠ¤íŠ¸ì˜ ì¹´ìš´íŠ¸ë‹¤ìš´ì„ ë”°ë¦„
            if (!gameState.isMultiplayer || isHost) {
                const countdownInterval = setInterval(() => {
                    gameState.countdown--;
                    if (gameState.countdown <= 0) {
                        clearInterval(countdownInterval);
                        gameState.isPaused = false;
                    }
                }, 1000);
            }
        }

        // ê²Œì„ ì¢…ë£Œ
        function endGame(winner) {
            gameState.isGameOver = true;
            const modal = document.getElementById('gameOverModal');
            const title = document.getElementById('gameOverTitle');
            const message = document.getElementById('gameOverMessage');

            // ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ì¢…ë£Œ ì‹œ ì—°ê²° ì •ë¦¬ (ìƒëŒ€ë°©ì—ê²Œ ì•Œë¦¼)
            if (gameState.isMultiplayer) {
                // ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ë£¨í”„ ì •ì§€
                stopMultiplayerGameLoop();
                
                // ìƒëŒ€ë°©ì—ê²Œ ê²Œì„ ì¢…ë£Œ ì•Œë¦¼ (ì—°ê²°ì´ ì—´ë ¤ìˆì„ ë•Œë§Œ)
                if (multiplayerConnection && multiplayerConnection.open) {
                    try {
                        sendMultiplayerData({ type: 'gameEnd', winner: winner });
                    } catch (e) {
                        console.log('ê²Œì„ ì¢…ë£Œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨:', e);
                    }
                }
            }

            // ì œí™” ì§€ê¸‰ (ê²Œì„ ì™„ì „ ì¢…ë£Œ ì‹œ)
            let killReward = 0;
            if (gameState.isMultiplayer) {
                // ë©€í‹°í”Œë ˆì´: ìŠ¹ë¦¬ ì‹œ 2ê°œ, íŒ¨ë°° ì‹œ 1ê°œ
                if (winner === 'player') {
                    killReward = 2;
                } else {
                    killReward = 1;
                }
            } else {
                // ì†”ë¡œí”Œë ˆì´: ì´ê¸´ ë¼ìš´ë“œ ìˆ˜ë§Œí¼ ì œí™” ì§€ê¸‰ (ìµœì¢… ìŠ¹ë¦¬ ì‹œ 2ë°° ì§€ê¸‰)
                killReward = gameState.playerWins || 0;
                if (winner === 'player') {
                    // ìµœì¢… ìŠ¹ë¦¬ ì‹œ 2ë°° ì§€ê¸‰
                    killReward *= 2;
                }
            }
            
            // ì œí™” ì§€ê¸‰
            updateKillCount(gameKillCount + killReward);

            if (winner === 'player') {
                title.textContent = 'ìŠ¹ë¦¬';
                title.style.color = '#4a9eff'; // íŒŒë€ìƒ‰
                message.textContent = 'ìŠ¹ë¦¬';
                message.style.color = '#4a9eff'; // íŒŒë€ìƒ‰
            } else {
                title.textContent = 'íŒ¨ë°°';
                title.style.color = '#e94560'; // ë¹¨ê°„ìƒ‰
                message.textContent = 'íŒ¨ë°°';
                message.style.color = '#e94560'; // ë¹¨ê°„ìƒ‰
            }

            modal.style.display = 'block';
            
            // 10ì´ˆ í›„ ë©”ì¸í™”ë©´ìœ¼ë¡œ ì´ë™
            setTimeout(() => {
                // ìŠ¤í¬ë¡¤ì„ ë§¨ ìœ„ë¡œ ì´ë™
                window.scrollTo(0, 0);
                restartGame();
            }, 10000);
        }

        // ê²Œì„ ì¬ì‹œì‘
        function restartGame() {
            // ìŠ¤í¬ë¡¤ì„ ë§¨ ìœ„ë¡œ ì´ë™
            window.scrollTo(0, 0);
            
            // ë©€í‹°í”Œë ˆì´ì–´ ì—°ê²° ì •ë¦¬ (ê²Œì„ ì¢…ë£Œ ì‹œ í•­ìƒ ì •ë¦¬)
            // ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ì´ì—ˆê±°ë‚˜ Peer ì¸ìŠ¤í„´ìŠ¤ê°€ ë‚¨ì•„ìˆìœ¼ë©´ ì™„ì „íˆ ì •ë¦¬
            if (gameState.isMultiplayer || multiplayerPeer || multiplayerConnection) {
                console.log('ê²Œì„ ì¬ì‹œì‘: ë©€í‹°í”Œë ˆì´ì–´ ì—°ê²° ì •ë¦¬ ì¤‘...');
                cleanupMultiplayerConnection();
                // ì¶”ê°€ ì •ë¦¬: ì•½ê°„ì˜ ì§€ì—° í›„ í•œ ë²ˆ ë” í™•ì¸
                setTimeout(() => {
                    if (multiplayerPeer || multiplayerConnection) {
                        console.log('ì¶”ê°€ ì •ë¦¬: ë‚¨ì•„ìˆëŠ” ì—°ê²° ì •ë¦¬ ì¤‘...');
                        cleanupMultiplayerConnection();
                    }
                }, 100);
            }
            
            // í”Œë ˆì´ì–´ ìƒ‰ìƒ ì´ˆê¸°í™”
            player.color = '#4a9eff';
            enemy.color = '#e94560';
            
            // ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
            gameState.isMenu = true;
            gameState.isGameOver = false;
            document.getElementById('gameOverModal').style.display = 'none';
            showScreen('main');
            
            // ë‹‰ë„¤ì„ í‘œì‹œ
            showNicknameDisplay();
            
            // ëª¨ë“œ ì„ íƒ ì ‘ê¸°
            collapseModeSelection();
            collapseMultiModeSelection();
            
            // ì²« ë¼ìš´ë“œ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
            gameState.isPaused = true;
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.isPaused = false;
                }
            }, 1000);

            player.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            player.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.hasCritical = false;
            player.hasDoubleShot = false;
            player.hasDodge = false;
            player.hasRevive = false;
            player.hasDeepWound = false;
            player.hasOneShotOneKill = false;
            player.hasPoisonBullet = false;
            player.hasReloadHeal = false;
            player.hasSurvivalInstinct = false;
            player.hasLastBullet = false;
            player.hasRecoveryContract = false;
            player.hasRecoveryContractUsed = false;
            player.hasFocusedFire = false;
            player.hasShotgun = false;
            player.hasRagged = false;
            player.hasGhost = false;
            player.hasFortify = false;
            player.isFortified = false;
            player.fortifyStartTime = 0;
            player.lastPosition = { x: player.x, y: player.y };
            player.stationaryTime = 0;
            player.hasOverheat = false;
            player.overheatHitCount = 0;
            player.lastHitTime = 0;
            player.hasGamble = false;
            player.hasWeaken = false;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.hasDamageBoost = false;
            player.hasLightning = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.hasShield = false;
            player.shieldReady = false;
            player.shieldCooldown = 0;
            player.hasRegeneration = false;
            player.lastRegenTime = 0;
            player.hasEvasiveManeuver = false;
            player.hasCombatExperience = false;
            player.combatExperienceRounds = 0;
            player.hasHallucination = false;
            player.hasTasteOfBlood = false;
            player.hasCannon = false;
            player.hasTimeBarrier = false;
            player.timeBarrierRadius = 150;
            player.hasBouncyBullet = false;
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.poisonEffects = [];
            player.isDodging = false;
            player.dodgeStartTime = 0;
            player.dodgeEndTime = 0;
            player.dodgeStartX = 0;
            player.dodgeStartY = 0;
            player.dodgeTargetX = 0;
            player.dodgeTargetY = 0;
            player.dodgeTrail = [];
            player.lastDodgeTime = 0;
            player.isReviving = false;
            player.reviveTime = 0;
            player.hasRevived = 0; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
            player.isInvincible = false;
            player.invincibleEndTime = 0;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.damage = 1;
            player.speed = 3;
            player.reloadTime = 3000;
            player.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
            player.reloadStartTime = 0;
            player.shootCooldown = 1000;

            enemy.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            enemy.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            enemy.health = 5;
            enemy.displayHealth = 5;
            enemy.maxHealth = 5;
            enemy.ammo = 6;
            enemy.maxAmmo = 6;
            enemy.bullets = [];
            enemy.augmentations = [];
            enemy.bulletSpeedMultiplier = 1;
            enemy.bulletSizeMultiplier = 1;
            enemy.hasCritical = false;
            enemy.hasDoubleShot = false;
            enemy.hasDodge = false;
            enemy.hasRevive = false;
            enemy.hasRevived = 0; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
            enemy.hasDeepWound = false;
            enemy.hasOneShotOneKill = false;
            enemy.hasPoisonBullet = false;
            enemy.hasReloadHeal = false;
            enemy.hasSurvivalInstinct = false;
            enemy.hasLastBullet = false;
            enemy.hasRecoveryContract = false;
            enemy.hasRecoveryContractUsed = false;
            enemy.hasFocusedFire = false;
            enemy.hasEvasiveManeuver = false;
            enemy.hasCombatExperience = false;
            enemy.combatExperienceRounds = 0;
            enemy.hasHallucination = false;
            enemy.hasTasteOfBlood = false;
            enemy.hasCannon = false;
            enemy.hasTimeBarrier = false;
            enemy.timeBarrierRadius = 150;
            enemy.hasBouncyBullet = false;
            enemy.hasExplosiveBullet = false;
            enemy.hasReaper = false;
            enemy.isInvisible = false;
            enemy.invisibilityEndTime = 0;
            enemy.hasOvercharge = false;
            enemy.overchargeActive = false;
            enemy.overchargeCooldown = 0;
            enemy.overchargeEndTime = 0;
            enemy.overchargeTrail = [];
            enemy.hasVictor = false;
            enemy.hasReflect = false;
            enemy.reflectActive = false;
            enemy.reflectCooldown = 0;
            enemy.reflectEndTime = 0;
            enemy.hasTimeStop = false;
            enemy.timeStopCooldown = 0;
            enemy.timeStopActive = false;
            enemy.timeStopEndTime = 0;
            enemy.hasScatter = false;
            enemy.hasGamble2 = false;
            enemy.hasRocket = false;
            enemy.hasTrinity = false;
            enemy.hasJudgment = false;
            enemy.isJudgmentPushing = false;
            enemy.judgmentPushStartX = 0;
            enemy.judgmentPushStartY = 0;
            enemy.judgmentPushTargetX = 0;
            enemy.judgmentPushTargetY = 0;
            enemy.judgmentPushStartTime = 0;
            enemy.judgmentPushDuration = 0;
            enemy.hasBoomerang = false;
            enemy.isVulnerable = false;
            enemy.vulnerabilityUsed = false;
            enemy.poisonEffects = [];
            enemy.isDodging = false;
            enemy.dodgeStartTime = 0;
            enemy.dodgeEndTime = 0;
            enemy.dodgeStartX = 0;
            enemy.dodgeStartY = 0;
            enemy.dodgeTargetX = 0;
            enemy.dodgeTargetY = 0;
            enemy.bulletDodgeTargetY = 0;
            enemy.isDodgingBullet = false;
            enemy.lastPlayerBulletCount = 0;
            enemy.dodgeTrail = [];
            enemy.lastDodgeTime = 0;
            enemy.isReviving = false;
            enemy.reviveTime = 0;
            enemy.hasRevived = 0; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
            enemy.isInvincible = false;
            enemy.invincibleEndTime = 0;
            enemy.slowEndTime = 0;
            enemy.damageNumbers = [];
            enemy.usePrediction = false;
            enemy.lastPlayerX = 0;
            enemy.lastPlayerY = 0;
            enemy.playerVelocity = { x: 0, y: 0 };
            enemy.damage = 1;
            enemy.reloadTime = 3000;
            enemy.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
            enemy.reloadStartTime = 0;
            enemy.shootCooldown = 1000;

            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('augmentModal').style.display = 'none';
        }

        // ë‘¥ê·¼ ì‚¬ê°í˜• ê·¸ë¦¬ê¸° í—¬í¼ í•¨ìˆ˜
        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            // ìƒë‹¨ ì™¼ìª½
            ctx.moveTo(x + radius, y);
            // ìƒë‹¨ ì˜¤ë¥¸ìª½
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            // ì˜¤ë¥¸ìª½ ì•„ë˜
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            // ì•„ë˜ ì™¼ìª½
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            // ì™¼ìª½ ìœ„
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
        }

        // ì²´ë ¥ í‘œì‹œ ê·¸ë¦¬ê¸° (ì§ì‚¬ê°í˜• ë°”)
        function drawHealthHearts(character, x, y, isPlayer) {
            const fixedBarWidth = 150; // ê³ ì •ëœ ë°” ê¸¸ì´ (200 -> 150)
            const barHeight = 20;
            const borderRadius = 4;
            // ë©€í‹°í”Œë ˆì´ì–´: ìºë¦­í„°ì˜ ì‹¤ì œ ìƒ‰ìƒ ì‚¬ìš©, ì†”ë¡œ: ê¸°ë³¸ ìƒ‰ìƒ
            const color = character.color || (isPlayer ? '#4a9eff' : '#e94560');
            
            // ë°°ê²½ (ë¹ˆ ë°”)
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
            ctx.fill();
            ctx.restore();
            
            // ì±„ì›Œì§„ ë¶€ë¶„ (ì• ë‹ˆë©”ì´ì…˜) - í•­ìƒ ë„¤ì˜¨ íš¨ê³¼ ì ìš©
            const fillRatio = Math.max(0, Math.min(1, character.displayHealth / character.maxHealth));
            const fillWidth = fixedBarWidth * fillRatio;
            
            if (fillWidth > 0) {
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.fillStyle = color;
                // ë¶€ë¶„ ì±„ìš°ê¸°ë¥¼ ìœ„í•´ í´ë¦¬í•‘ ì‚¬ìš©
                if (fillWidth < fixedBarWidth) {
                    ctx.save();
                    ctx.beginPath();
                    drawRoundedRect(x, y, fillWidth, barHeight, borderRadius);
                    ctx.clip();
                    drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                    ctx.fill();
                    ctx.restore();
                } else {
                    drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                    ctx.fill();
                }
                ctx.restore();
            }
            
            // í…Œë‘ë¦¬ - í•­ìƒ ë„¤ì˜¨ íš¨ê³¼ ì ìš©
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
            ctx.stroke();
            ctx.restore();
        }

        // ì¦ê°• ì•„ì´ì½˜ ê·¸ë¦¬ê¸°
        function drawAugmentIcon(ctx, x, y, size, augId) {
            ctx.save();
            ctx.translate(x, y);
            ctx.shadowBlur = 8; // ê¸°ë³¸ ë„¤ì˜¨ íš¨ê³¼
            
            switch(augId) {
                case 'health':
                    // ì²´ë ¥: í˜„ëŒ€ì ì¸ í•˜íŠ¸ (ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff006e';
                    const healthGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                    healthGradient.addColorStop(0, '#ff3399');
                    healthGradient.addColorStop(1, '#ff006e');
                    ctx.fillStyle = healthGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.35, -size * 0.2, -size * 0.35, -size * 0.35, 0, -size * 0.2);
                    ctx.bezierCurveTo(size * 0.35, -size * 0.35, size * 0.35, -size * 0.2, 0, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'speed':
                    // ì†ë„: í˜„ëŒ€ì ì¸ ì´ì¤‘ í™”ì‚´í‘œ (ìœ„ì•„ë˜)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ff88';
                    ctx.fillStyle = '#00ff88';
                    // ìœ„ìª½ í™”ì‚´í‘œ
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.35);
                    ctx.lineTo(-size * 0.2, -size * 0.1);
                    ctx.lineTo(-size * 0.1, -size * 0.1);
                    ctx.lineTo(-size * 0.1, size * 0.05);
                    ctx.lineTo(size * 0.1, size * 0.05);
                    ctx.lineTo(size * 0.1, -size * 0.1);
                    ctx.lineTo(size * 0.2, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ì•„ë˜ìª½ í™”ì‚´í‘œ
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.35);
                    ctx.lineTo(-size * 0.2, size * 0.1);
                    ctx.lineTo(-size * 0.1, size * 0.1);
                    ctx.lineTo(-size * 0.1, -size * 0.05);
                    ctx.lineTo(size * 0.1, -size * 0.05);
                    ctx.lineTo(size * 0.1, size * 0.1);
                    ctx.lineTo(size * 0.2, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bulletSpeed':
                    // ì´ì•Œ ì†ë„: í˜„ëŒ€ì ì¸ ë²ˆê°œ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffaa00';
                    const bulletSpeedGradient = ctx.createLinearGradient(-size * 0.2, -size * 0.4, size * 0.2, size * 0.4);
                    bulletSpeedGradient.addColorStop(0, '#ffcc44');
                    bulletSpeedGradient.addColorStop(0.5, '#ffaa00');
                    bulletSpeedGradient.addColorStop(1, '#ff8800');
                    ctx.fillStyle = bulletSpeedGradient;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, -size * 0.4);
                    ctx.lineTo(size * 0.08, -size * 0.15);
                    ctx.lineTo(-size * 0.08, -size * 0.1);
                    ctx.lineTo(size * 0.12, size * 0.15);
                    ctx.lineTo(-size * 0.1, size * 0.35);
                    ctx.lineTo(0, size * 0.15);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'ammo':
                    // íƒ„ì•½: í˜„ëŒ€ì ì¸ ì´ì•Œ ì•„ì´ì½˜ (ì› + ì‚¼ê°í˜•)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff';
                    // ì´ì•Œ ë³¸ì²´ (ì›)
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // ì´ì•Œ ë (ì‚¼ê°í˜•)
                    ctx.beginPath();
                    ctx.moveTo(size * 0.3, 0);
                    ctx.lineTo(size * 0.45, -size * 0.15);
                    ctx.lineTo(size * 0.45, size * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'fireRate':
                    // ë°œì‚¬ ì†ë„: í˜„ëŒ€ì ì¸ ë³„ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff00ff';
                    const fireRateGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                    fireRateGradient.addColorStop(0, '#ff66ff');
                    fireRateGradient.addColorStop(1, '#ff00ff');
                    ctx.fillStyle = fireRateGradient;
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.4 : size * 0.18;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'reload':
                    // ì¬ì¥ì „: í˜„ëŒ€ì ì¸ ì‹œê³„ (ì›í˜• + ë°”ëŠ˜)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ffff';
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2.5;
                    ctx.lineCap = 'round';
                    // ì‹œê³„ ì™¸ê³½
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.stroke();
                    // ì‹œê³„ ë°”ëŠ˜ (ë¶„ì¹¨)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -size * 0.28);
                    ctx.stroke();
                    // ì‹œê³„ ë°”ëŠ˜ (ì‹œì¹¨)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.18, size * 0.05);
                    ctx.stroke();
                    // ì¤‘ì•™ ì 
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'critical':
                    // í¬ë¦¬í‹°ì»¬: í˜„ëŒ€ì ì¸ X í‘œì‹œ (ë‘êº¼ìš´ ì„ )
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff0000';
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.32, -size * 0.32);
                    ctx.lineTo(size * 0.32, size * 0.32);
                    ctx.moveTo(size * 0.32, -size * 0.32);
                    ctx.lineTo(-size * 0.32, size * 0.32);
                    ctx.stroke();
                    break;
                case 'doubleShot':
                    // ë”ë¸”ìƒ·: í˜„ëŒ€ì ì¸ ë‘ ê°œì˜ ì´ì•Œ (ì› + ì‚¼ê°í˜•)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffc107';
                    ctx.fillStyle = '#ffc107';
                    // ì™¼ìª½ ì´ì•Œ
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, 0, size * 0.22, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.02, 0);
                    ctx.lineTo(-size * 0.12, -size * 0.12);
                    ctx.lineTo(-size * 0.12, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // ì˜¤ë¥¸ìª½ ì´ì•Œ
                    ctx.beginPath();
                    ctx.arc(size * 0.2, 0, size * 0.22, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(size * 0.02, 0);
                    ctx.lineTo(size * 0.12, -size * 0.12);
                    ctx.lineTo(size * 0.12, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'dodge':
                    // êµ¬ë¥´ê¸°: í˜„ëŒ€ì ì¸ ëŒ€ì‹œì„  (í™”ì‚´í‘œ í¬í•¨)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#8888ff';
                    ctx.strokeStyle = '#8888ff';
                    ctx.fillStyle = '#8888ff';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.35, 0);
                    ctx.lineTo(size * 0.2, 0);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    // í™”ì‚´í‘œ ë¨¸ë¦¬
                    ctx.beginPath();
                    ctx.moveTo(size * 0.2, 0);
                    ctx.lineTo(size * 0.35, -size * 0.12);
                    ctx.lineTo(size * 0.35, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'revive':
                    // ë¶€í™œ: í˜„ëŒ€ì ì¸ ì‹­ìê°€ (ë‘¥ê·¼ ëª¨ì„œë¦¬)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#00ff88';
                    ctx.fillStyle = '#00ff88';
                    // ì„¸ë¡œ ë§‰ëŒ€
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.12, -size * 0.4, size * 0.24, size * 0.8, size * 0.05);
                    ctx.fill();
                    // ê°€ë¡œ ë§‰ëŒ€
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.4, -size * 0.12, size * 0.8, size * 0.24, size * 0.05);
                    ctx.fill();
                    break;
                case 'deepWound':
                    // ê¹Šì€ ìƒì²˜: í˜„ëŒ€ì ì¸ ì¹¼ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#880000';
                    const deepWoundGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.3);
                    deepWoundGradient.addColorStop(0, '#aa0000');
                    deepWoundGradient.addColorStop(1, '#660000');
                    ctx.fillStyle = deepWoundGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.12, size * 0.15);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.12, size * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    // ì¹¼ë‚  ê°•ì¡°ì„ 
                    ctx.strokeStyle = '#cc0000';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(0, size * 0.25);
                    ctx.stroke();
                    break;
                case 'giant':
                    // ê±°ëŒ€í™”: í˜„ëŒ€ì ì¸ í° ì‚¬ê°í˜• (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#8B4513';
                    const giantGradient = ctx.createLinearGradient(-size * 0.4, -size * 0.4, size * 0.4, size * 0.4);
                    giantGradient.addColorStop(0, '#A0522D');
                    giantGradient.addColorStop(1, '#8B4513');
                    ctx.fillStyle = giantGradient;
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.38, -size * 0.38, size * 0.76, size * 0.76, size * 0.08);
                    ctx.fill();
                    // ë‚´ë¶€ ì‘ì€ ì‚¬ê°í˜•
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.24, -size * 0.24, size * 0.48, size * 0.48, size * 0.05);
                    ctx.fill();
                    break;
                case 'sniper':
                    // ì €ê²©ìˆ˜: í˜„ëŒ€ì ì¸ ìŠ¤ì½”í”„ (ì›í˜• + ì‹­ìì„ )
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#333333';
                    ctx.strokeStyle = '#555555';
                    ctx.lineWidth = 2.5;
                    // ì™¸ë¶€ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.stroke();
                    // ë‚´ë¶€ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    // ì‹­ìì„ 
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.38, 0);
                    ctx.lineTo(size * 0.38, 0);
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(0, size * 0.38);
                    ctx.stroke();
                    // ì¤‘ì•™ ì 
                    ctx.fillStyle = '#ff0000';
                    ctx.shadowColor = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'oneShotOneKill':
                    // ì›ìƒ·ì›í‚¬: í˜„ëŒ€ì ì¸ í° ì´ì•Œ (ê·¸ë¼ë°ì´ì…˜ + X)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0000';
                    const oskGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.35);
                    oskGradient.addColorStop(0, '#ff4444');
                    oskGradient.addColorStop(1, '#cc0000');
                    ctx.fillStyle = oskGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.33, 0, Math.PI * 2);
                    ctx.fill();
                    // ì¤‘ì•™ X (ë‘êº¼ìš´ ì„ )
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.22, -size * 0.22);
                    ctx.lineTo(size * 0.22, size * 0.22);
                    ctx.moveTo(size * 0.22, -size * 0.22);
                    ctx.lineTo(-size * 0.22, size * 0.22);
                    ctx.stroke();
                    break;
                case 'poisonBullet':
                    // ë… íƒ„í™˜: í˜„ëŒ€ì ì¸ ë… ë°©ìš¸ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#00aa00';
                    const poisonGradient = ctx.createRadialGradient(0, -size * 0.1, 0, 0, -size * 0.1, size * 0.3);
                    poisonGradient.addColorStop(0, '#00cc00');
                    poisonGradient.addColorStop(1, '#006600');
                    ctx.fillStyle = poisonGradient;
                    // í° ë°©ìš¸
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.1, size * 0.28, 0, Math.PI * 2);
                    ctx.fill();
                    // ì‘ì€ ë°©ìš¸ë“¤
                    ctx.fillStyle = '#00aa00';
                    ctx.beginPath();
                    ctx.arc(-size * 0.18, size * 0.12, size * 0.14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.18, size * 0.12, size * 0.14, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'reloadHeal':
                    // ì¬ì¥ì „ íšŒë³µ: í˜„ëŒ€ì ì¸ í•˜íŠ¸ + í™”ì‚´í‘œ
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff006e';
                    const reloadHealGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
                    reloadHealGradient.addColorStop(0, '#ff3399');
                    reloadHealGradient.addColorStop(1, '#ff006e');
                    ctx.fillStyle = reloadHealGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.12);
                    ctx.bezierCurveTo(-size * 0.28, -size * 0.08, -size * 0.28, -size * 0.25, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.28, -size * 0.25, size * 0.28, -size * 0.08, 0, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // í™”ì‚´í‘œ (ì˜¤ë¥¸ìª½)
                    ctx.shadowColor = '#00ff00';
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(size * 0.25, 0);
                    ctx.lineTo(size * 0.1, -size * 0.18);
                    ctx.lineTo(size * 0.1, size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bigBullet':
                    // í° íƒ„í™˜: í˜„ëŒ€ì ì¸ í° ì´ì•Œ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffffff';
                    const bigBulletGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                    bigBulletGradient.addColorStop(0, '#ffffff');
                    bigBulletGradient.addColorStop(0.7, '#cccccc');
                    bigBulletGradient.addColorStop(1, '#999999');
                    ctx.fillStyle = bigBulletGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.fill();
                    // ë‚´ë¶€ ì‘ì€ ì› (í•˜ì´ë¼ì´íŠ¸)
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, -size * 0.15, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'survivalInstinct':
                    // ìƒì¡´ë³¸ëŠ¥: í˜„ëŒ€ì ì¸ ë²ˆê°œ + í•˜íŠ¸
                    ctx.shadowBlur = 12;
                    // ë²ˆê°œ
                    ctx.shadowColor = '#ffaa00';
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, -size * 0.32);
                    ctx.lineTo(size * 0.08, -size * 0.12);
                    ctx.lineTo(-size * 0.08, -size * 0.08);
                    ctx.lineTo(size * 0.15, size * 0.25);
                    ctx.lineTo(-size * 0.1, size * 0.32);
                    ctx.lineTo(0, size * 0.12);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    // í•˜íŠ¸
                    ctx.shadowColor = '#ff006e';
                    const survivalHeartGradient = ctx.createRadialGradient(0, size * 0.15, 0, 0, size * 0.15, size * 0.25);
                    survivalHeartGradient.addColorStop(0, '#ff3399');
                    survivalHeartGradient.addColorStop(1, '#ff006e');
                    ctx.fillStyle = survivalHeartGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.2);
                    ctx.bezierCurveTo(-size * 0.22, -size * 0.08, -size * 0.22, -size * 0.2, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.22, -size * 0.2, size * 0.22, -size * 0.08, 0, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'lastBullet':
                    // ë¹„ì¥ì˜ í•œë°œ: í˜„ëŒ€ì ì¸ í° ì´ì•Œ + ë³„
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff0000';
                    const lastBulletGradient = ctx.createLinearGradient(-size * 0.3, 0, size * 0.3, 0);
                    lastBulletGradient.addColorStop(0, '#ff4444');
                    lastBulletGradient.addColorStop(1, '#cc0000');
                    ctx.fillStyle = lastBulletGradient;
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.28, -size * 0.14, size * 0.56, size * 0.28, size * 0.05);
                    ctx.fill();
                    // ë³„
                    ctx.shadowColor = '#ffc107';
                    ctx.fillStyle = '#ffc107';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.18 : size * 0.09;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'recoveryContract':
                    // íšŒë³µê³„ì•½: í˜„ëŒ€ì ì¸ í•˜íŠ¸ + í™”ì‚´í‘œ ìœ„
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#00ff00';
                    const recoveryGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
                    recoveryGradient.addColorStop(0, '#44ff44');
                    recoveryGradient.addColorStop(1, '#00aa00');
                    ctx.fillStyle = recoveryGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.12);
                    ctx.bezierCurveTo(-size * 0.28, -size * 0.08, -size * 0.28, -size * 0.25, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.28, -size * 0.25, size * 0.28, -size * 0.08, 0, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // í™”ì‚´í‘œ ìœ„
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.32);
                    ctx.lineTo(-size * 0.18, -size * 0.12);
                    ctx.lineTo(size * 0.18, -size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'focusedFire':
                    // ì§‘ì¤‘ ì‚¬ê²©: í˜„ëŒ€ì ì¸ ëˆˆ ëª¨ì–‘ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffff00';
                    // ì™¼ìª½ ëˆˆ
                    const leftEyeGradient = ctx.createRadialGradient(-size * 0.15, 0, 0, -size * 0.15, 0, size * 0.2);
                    leftEyeGradient.addColorStop(0, '#ffff88');
                    leftEyeGradient.addColorStop(1, '#ffff00');
                    ctx.fillStyle = leftEyeGradient;
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, 0, size * 0.18, 0, Math.PI * 2);
                    ctx.fill();
                    // ì˜¤ë¥¸ìª½ ëˆˆ
                    const rightEyeGradient = ctx.createRadialGradient(size * 0.15, 0, 0, size * 0.15, 0, size * 0.2);
                    rightEyeGradient.addColorStop(0, '#ffff88');
                    rightEyeGradient.addColorStop(1, '#ffff00');
                    ctx.fillStyle = rightEyeGradient;
                    ctx.beginPath();
                    ctx.arc(size * 0.15, 0, size * 0.18, 0, Math.PI * 2);
                    ctx.fill();
                    // ë™ê³µ
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, 0, size * 0.09, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, 0, size * 0.09, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'ghost':
                    // ìœ ë ¹: í˜„ëŒ€ì ì¸ ë°˜íˆ¬ëª… ì› + ì‘ì€ ì›ë“¤ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#cccccc';
                    ctx.globalAlpha = 0.75;
                    const ghostGradient = ctx.createRadialGradient(0, -size * 0.1, 0, 0, -size * 0.1, size * 0.3);
                    ghostGradient.addColorStop(0, '#eeeeee');
                    ghostGradient.addColorStop(1, '#aaaaaa');
                    ctx.fillStyle = ghostGradient;
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.1, size * 0.28, 0, Math.PI * 2);
                    ctx.fill();
                    // ì‘ì€ ì›ë“¤ (ìœ ë ¹ ëŠë‚Œ)
                    ctx.fillStyle = '#cccccc';
                    ctx.beginPath();
                    ctx.arc(-size * 0.16, size * 0.12, size * 0.14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.16, size * 0.12, size * 0.14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    break;
                case 'fortify':
                    // ê±°ì í™•ë³´: í˜„ëŒ€ì ì¸ ë°©íŒ¨ ëª¨ì–‘ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffffff';
                    const fortifyGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.3);
                    fortifyGradient.addColorStop(0, '#ffffff');
                    fortifyGradient.addColorStop(1, '#cccccc');
                    ctx.fillStyle = fortifyGradient;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2.5;
                    // ë°©íŒ¨ ë³¸ì²´
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.28, -size * 0.18);
                    ctx.lineTo(-size * 0.28, size * 0.18);
                    ctx.lineTo(0, size * 0.28);
                    ctx.lineTo(size * 0.28, size * 0.18);
                    ctx.lineTo(size * 0.28, -size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // ì‹­ìê°€
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.2);
                    ctx.lineTo(0, size * 0.1);
                    ctx.moveTo(-size * 0.16, -size * 0.05);
                    ctx.lineTo(size * 0.16, -size * 0.05);
                    ctx.stroke();
                    break;
                case 'overheat':
                    // ê³¼ì—´: í˜„ëŒ€ì ì¸ ë¶ˆê½ƒ ëª¨ì–‘ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff6600';
                    const overheatGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.2);
                    overheatGradient.addColorStop(0, '#ffaa00');
                    overheatGradient.addColorStop(0.5, '#ff6600');
                    overheatGradient.addColorStop(1, '#ff4400');
                    ctx.fillStyle = overheatGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.18, -size * 0.08);
                    ctx.lineTo(-size * 0.14, size * 0.12);
                    ctx.lineTo(0, size * 0.18);
                    ctx.lineTo(size * 0.14, size * 0.12);
                    ctx.lineTo(size * 0.18, -size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    // ì‘ì€ ë¶ˆê½ƒë“¤
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffaa00';
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.18);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.lineTo(0, -size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(size * 0.1, -size * 0.18);
                    ctx.lineTo(size * 0.05, 0);
                    ctx.lineTo(0, -size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'gamble':
                    // ë„ë°•: í˜„ëŒ€ì ì¸ ì£¼ì‚¬ìœ„ (ê·¸ë¼ë°ì´ì…˜ + ê·¸ë¦¼ì)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    const gambleGradient = ctx.createLinearGradient(-size * 0.3, -size * 0.3, size * 0.3, size * 0.3);
                    gambleGradient.addColorStop(0, '#ffffff');
                    gambleGradient.addColorStop(1, '#dddddd');
                    ctx.fillStyle = gambleGradient;
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.28, -size * 0.28, size * 0.56, size * 0.56, size * 0.08);
                    ctx.fill();
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.28, -size * 0.28, size * 0.56, size * 0.56, size * 0.08);
                    ctx.stroke();
                    // ì£¼ì‚¬ìœ„ ëˆˆ (ë” í˜„ëŒ€ì ìœ¼ë¡œ)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-size * 0.16, -size * 0.16, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.16, size * 0.16, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'weaken':
                    // ì•½í™”: í˜„ëŒ€ì ì¸ ì•„ë˜ í™”ì‚´í‘œ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#888888';
                    const weakenGradient = ctx.createLinearGradient(0, -size * 0.3, 0, size * 0.1);
                    weakenGradient.addColorStop(0, '#aaaaaa');
                    weakenGradient.addColorStop(1, '#666666');
                    ctx.fillStyle = weakenGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.28);
                    ctx.lineTo(-size * 0.18, size * 0.08);
                    ctx.lineTo(-size * 0.08, size * 0.08);
                    ctx.lineTo(-size * 0.08, size * 0.15);
                    ctx.lineTo(size * 0.08, size * 0.15);
                    ctx.lineTo(size * 0.08, size * 0.08);
                    ctx.lineTo(size * 0.18, size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    // ê°ì†Œ í‘œì‹œ (ë¹¨ê°„ ì„ )
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.16, size * 0.18);
                    ctx.lineTo(size * 0.16, size * 0.18);
                    ctx.stroke();
                    break;
                case 'damageBoost':
                    // ë°ë¯¸ì§€ 1.2ë°°: í˜„ëŒ€ì ì¸ ìœ„ í™”ì‚´í‘œ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff6600';
                    const damageBoostGradient = ctx.createLinearGradient(0, size * 0.3, 0, -size * 0.1);
                    damageBoostGradient.addColorStop(0, '#ff8800');
                    damageBoostGradient.addColorStop(1, '#ff4400');
                    ctx.fillStyle = damageBoostGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.28);
                    ctx.lineTo(-size * 0.18, -size * 0.08);
                    ctx.lineTo(-size * 0.08, -size * 0.08);
                    ctx.lineTo(-size * 0.08, -size * 0.15);
                    ctx.lineTo(size * 0.08, -size * 0.15);
                    ctx.lineTo(size * 0.08, -size * 0.08);
                    ctx.lineTo(size * 0.18, -size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    // ì¦ê°€ í‘œì‹œ (ì´ˆë¡ ì„ )
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.16, -size * 0.18);
                    ctx.lineTo(size * 0.16, -size * 0.18);
                    ctx.stroke();
                    break;
                case 'lightning':
                    // ë²ˆê°œ: í˜„ëŒ€ì ì¸ ë²ˆê°œ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffff00';
                    const lightningGradient = ctx.createLinearGradient(-size * 0.1, -size * 0.4, size * 0.15, size * 0.3);
                    lightningGradient.addColorStop(0, '#ffff88');
                    lightningGradient.addColorStop(0.5, '#ffff00');
                    lightningGradient.addColorStop(1, '#ffaa00');
                    ctx.fillStyle = lightningGradient;
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.08, -size * 0.38);
                    ctx.lineTo(size * 0.08, -size * 0.18);
                    ctx.lineTo(-size * 0.05, -size * 0.08);
                    ctx.lineTo(size * 0.14, size * 0.18);
                    ctx.lineTo(-size * 0.1, size * 0.28);
                    ctx.lineTo(0, size * 0.12);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'shield':
                    // ë°©ì–´ë§‰: í˜„ëŒ€ì ì¸ ë°©íŒ¨ ëª¨ì–‘ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0066ff';
                    const shieldGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.3);
                    shieldGradient.addColorStop(0, '#3399ff');
                    shieldGradient.addColorStop(1, '#0044cc');
                    ctx.fillStyle = shieldGradient;
                    ctx.strokeStyle = '#0044cc';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.28, -size * 0.18);
                    ctx.lineTo(-size * 0.28, size * 0.12);
                    ctx.lineTo(0, size * 0.28);
                    ctx.lineTo(size * 0.28, size * 0.12);
                    ctx.lineTo(size * 0.28, -size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // í•˜ì´ë¼ì´íŠ¸
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.14, -size * 0.18);
                    ctx.lineTo(0, size * 0.05);
                    ctx.lineTo(size * 0.14, -size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'regeneration':
                    // ì¬ìƒ: í˜„ëŒ€ì ì¸ í•˜íŠ¸ + í”ŒëŸ¬ìŠ¤ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff006e';
                    const regenGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.25);
                    regenGradient.addColorStop(0, '#ff3399');
                    regenGradient.addColorStop(1, '#ff006e');
                    ctx.fillStyle = regenGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.12);
                    ctx.bezierCurveTo(-size * 0.24, -size * 0.08, -size * 0.24, -size * 0.25, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.24, -size * 0.25, size * 0.24, -size * 0.08, 0, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // í”ŒëŸ¬ìŠ¤ í‘œì‹œ (ë‘¥ê·¼ ëª¨ì„œë¦¬)
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.1, -size * 0.05, size * 0.2, size * 0.03, size * 0.01);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.05, -size * 0.1, size * 0.03, size * 0.2, size * 0.01);
                    ctx.fill();
                    break;
                case 'shotgun':
                    // ìƒ·ê±´: í˜„ëŒ€ì ì¸ ì‚°íƒ„ì´ ëª¨ì–‘ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#8B4513';
                    const shotgunGradient = ctx.createLinearGradient(-size * 0.4, 0, size * 0.4, 0);
                    shotgunGradient.addColorStop(0, '#A0522D');
                    shotgunGradient.addColorStop(1, '#654321');
                    ctx.fillStyle = shotgunGradient;
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.38, -size * 0.1, size * 0.76, size * 0.2, size * 0.03);
                    ctx.fill();
                    ctx.fillStyle = '#4a2c1a';
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.34, -size * 0.05, size * 0.68, size * 0.1, size * 0.02);
                    ctx.fill();
                    // ì´êµ¬
                    ctx.fillStyle = '#333333';
                    ctx.beginPath();
                    ctx.arc(size * 0.38, 0, size * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'ragged':
                    // ë‹¤ë‹¤ìµì„ : í˜„ëŒ€ì ì¸ ê¹¨ì§„ ì´ì•Œ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#888888';
                    const raggedGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
                    raggedGradient.addColorStop(0, '#aaaaaa');
                    raggedGradient.addColorStop(1, '#666666');
                    ctx.fillStyle = raggedGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.28, 0, Math.PI * 2);
                    ctx.fill();
                    // ê¹¨ì§„ ì„  (X)
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.22, -size * 0.22);
                    ctx.lineTo(size * 0.22, size * 0.22);
                    ctx.moveTo(size * 0.22, -size * 0.22);
                    ctx.lineTo(-size * 0.22, size * 0.22);
                    ctx.stroke();
                    break;
                case 'evasiveManeuver':
                    // íšŒí”¼ê¸°ë™: í˜„ëŒ€ì ì¸ í™”ì‚´í‘œ + ë²ˆê°œ
                    ctx.shadowBlur = 12;
                    // í™”ì‚´í‘œ
                    ctx.shadowColor = '#4a9eff';
                    const evasiveGradient = ctx.createLinearGradient(0, -size * 0.3, 0, size * 0.1);
                    evasiveGradient.addColorStop(0, '#66b3ff');
                    evasiveGradient.addColorStop(1, '#3399ff');
                    ctx.fillStyle = evasiveGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.28);
                    ctx.lineTo(-size * 0.18, size * 0.08);
                    ctx.lineTo(-size * 0.08, size * 0.08);
                    ctx.lineTo(-size * 0.08, size * 0.15);
                    ctx.lineTo(size * 0.08, size * 0.15);
                    ctx.lineTo(size * 0.08, size * 0.08);
                    ctx.lineTo(size * 0.18, size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    // ë²ˆê°œ (X)
                    ctx.shadowColor = '#ffff00';
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.12, -size * 0.12);
                    ctx.lineTo(size * 0.12, size * 0.12);
                    ctx.moveTo(size * 0.12, -size * 0.12);
                    ctx.lineTo(-size * 0.12, size * 0.12);
                    ctx.stroke();
                    break;
                case 'combatExperience':
                    // ì „íˆ¬ ê²½í—˜: í˜„ëŒ€ì ì¸ ë³„ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffaa00';
                    const combatGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
                    combatGradient.addColorStop(0, '#ffcc44');
                    combatGradient.addColorStop(1, '#ff8800');
                    ctx.fillStyle = combatGradient;
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.32 : size * 0.16;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'hallucination':
                    // í™˜ê°: í˜„ëŒ€ì ì¸ ë¬¼ê²° ëª¨ì–‘ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff00ff';
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    for (let i = -size * 0.38; i <= size * 0.38; i += 4) {
                        const y = Math.sin(i * 0.25) * size * 0.22;
                        if (i === -size * 0.38) ctx.moveTo(i, y);
                        else ctx.lineTo(i, y);
                    }
                    ctx.stroke();
                    // ë‘ ë²ˆì§¸ ë¬¼ê²°
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    for (let i = -size * 0.38; i <= size * 0.38; i += 4) {
                        const y = Math.sin(i * 0.25 + Math.PI) * size * 0.15;
                        if (i === -size * 0.38) ctx.moveTo(i, y);
                        else ctx.lineTo(i, y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    break;
                case 'tasteOfBlood':
                    // í”¼ì˜ ë§›: í˜„ëŒ€ì ì¸ ë¹¨ê°„ í•˜íŠ¸ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0000';
                    const bloodGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.25);
                    bloodGradient.addColorStop(0, '#ff4444');
                    bloodGradient.addColorStop(1, '#cc0000');
                    ctx.fillStyle = bloodGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.12);
                    ctx.bezierCurveTo(-size * 0.24, -size * 0.08, -size * 0.24, -size * 0.25, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.24, -size * 0.25, size * 0.24, -size * 0.08, 0, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // í•˜ì´ë¼ì´íŠ¸
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.08);
                    ctx.bezierCurveTo(-size * 0.12, -size * 0.15, -size * 0.12, -size * 0.2, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.12, -size * 0.2, size * 0.12, -size * 0.15, 0, -size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'cannon':
                    // ëŒ€í¬: í˜„ëŒ€ì ì¸ í° ì› (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#8B4513';
                    const cannonGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                    cannonGradient.addColorStop(0, '#A0522D');
                    cannonGradient.addColorStop(0.7, '#8B4513');
                    cannonGradient.addColorStop(1, '#654321');
                    ctx.fillStyle = cannonGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#4a2c1a';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.stroke();
                    // ë‚´ë¶€ ì› (êµ¬ë©)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'timeBarrier':
                    // ì‹œê°„ì¥ë§‰: í˜„ëŒ€ì ì¸ ì› + ì‹œê³„ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ff00';
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2.5;
                    ctx.globalAlpha = 0.6;
                    // ì™¸ë¶€ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.stroke();
                    // ë‚´ë¶€ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    // ì‹œê³„ ë°”ëŠ˜
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -size * 0.22);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.16, size * 0.08);
                    ctx.stroke();
                    // ì¤‘ì•™ ì 
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'bouncyBullet':
                    // í†µí†µíƒ„: í˜„ëŒ€ì ì¸ íŠ•ê¸°ëŠ” í™”ì‚´í‘œ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffaa00';
                    const bouncyGradient = ctx.createLinearGradient(0, -size * 0.3, 0, size * 0.3);
                    bouncyGradient.addColorStop(0, '#ffcc44');
                    bouncyGradient.addColorStop(0.5, '#ffaa00');
                    bouncyGradient.addColorStop(1, '#ff8800');
                    ctx.fillStyle = bouncyGradient;
                    // ìœ„ìª½ í™”ì‚´í‘œ
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.28);
                    ctx.lineTo(-size * 0.16, -size * 0.12);
                    ctx.lineTo(-size * 0.08, -size * 0.12);
                    ctx.lineTo(-size * 0.08, 0);
                    ctx.lineTo(size * 0.08, 0);
                    ctx.lineTo(size * 0.08, -size * 0.12);
                    ctx.lineTo(size * 0.16, -size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // ì•„ë˜ìª½ í™”ì‚´í‘œ (ë°˜ëŒ€ ë°©í–¥)
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.28);
                    ctx.lineTo(-size * 0.16, size * 0.12);
                    ctx.lineTo(-size * 0.08, size * 0.12);
                    ctx.lineTo(-size * 0.08, 0);
                    ctx.lineTo(size * 0.08, 0);
                    ctx.lineTo(size * 0.08, size * 0.12);
                    ctx.lineTo(size * 0.16, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'gamble2':
                    // ìŠ¤ë„¤ì´í¬: í˜„ëŒ€ì ì¸ êµ¬ë¶ˆêµ¬ë¶ˆí•œ í™”ì‚´í‘œ (ë°©í–¥ ì „í™˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffffff';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3.5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    // êµ¬ë¶ˆêµ¬ë¶ˆí•œ ì„ 
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, -size * 0.1);
                    ctx.quadraticCurveTo(-size * 0.1, 0, 0, size * 0.1);
                    ctx.quadraticCurveTo(size * 0.1, 0, size * 0.3, -size * 0.1);
                    ctx.stroke();
                    // í™”ì‚´í‘œ ë¨¸ë¦¬
                    ctx.beginPath();
                    ctx.moveTo(size * 0.3, -size * 0.1);
                    ctx.lineTo(size * 0.35, -size * 0.18);
                    ctx.lineTo(size * 0.32, -size * 0.12);
                    ctx.lineTo(size * 0.38, -size * 0.12);
                    ctx.lineTo(size * 0.38, -size * 0.05);
                    ctx.lineTo(size * 0.32, -size * 0.05);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'reflect':
                    // ë°˜ì‚¬: í˜„ëŒ€ì ì¸ ë°©íŒ¨ + í™”ì‚´í‘œ ë°˜ì‚¬ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffffff';
                    const reflectGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.3);
                    reflectGradient.addColorStop(0, '#ffffff');
                    reflectGradient.addColorStop(1, '#cccccc');
                    ctx.fillStyle = reflectGradient;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2.5;
                    // ë°©íŒ¨ ë³¸ì²´
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.28, -size * 0.18);
                    ctx.lineTo(-size * 0.28, size * 0.18);
                    ctx.lineTo(0, size * 0.28);
                    ctx.lineTo(size * 0.28, size * 0.18);
                    ctx.lineTo(size * 0.28, -size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // ë°˜ì‚¬ í™”ì‚´í‘œ (ë…¸ë€ìƒ‰)
                    ctx.shadowColor = '#ffff00';
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.22, 0);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.22, 0);
                    ctx.stroke();
                    // í™”ì‚´í‘œ ë¨¸ë¦¬
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.moveTo(size * 0.22, 0);
                    ctx.lineTo(size * 0.32, -size * 0.12);
                    ctx.lineTo(size * 0.32, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'explosiveBullet':
                    // í­ë°œíƒ„: í­ë°œ ì•„ì´ì½˜
                    ctx.fillStyle = '#ff8800';
                    ctx.shadowColor = '#ff8800';
                    // ì¤‘ì‹¬ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    // í­ë°œì„ ë“¤
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI * 2 / 8);
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * size * 0.15, Math.sin(angle) * size * 0.15);
                        ctx.lineTo(Math.cos(angle) * size * 0.35, Math.sin(angle) * size * 0.35);
                        ctx.strokeStyle = '#ff8800';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    break;
                case 'reaper':
                    // ì‚¬ì‹ : ë‚« ëª¨ì–‘
                    ctx.strokeStyle = '#333333';
                    ctx.shadowColor = '#333333';
                    ctx.lineWidth = 3;
                    // ë‚« ì†ì¡ì´
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(0, size * 0.3);
                    ctx.stroke();
                    // ë‚« ë‚ 
                    ctx.beginPath();
                    ctx.arc(size * 0.1, -size * 0.2, size * 0.25, -Math.PI * 0.3, Math.PI * 0.7);
                    ctx.stroke();
                    break;
                case 'overcharge':
                    // ê³¼ì¶©ì „: ë²ˆê°œ + ì›
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    // ë²ˆê°œ
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.3);
                    ctx.lineTo(size * 0.1, -size * 0.1);
                    ctx.lineTo(-size * 0.05, -size * 0.05);
                    ctx.lineTo(size * 0.15, size * 0.2);
                    ctx.lineTo(-size * 0.1, size * 0.3);
                    ctx.lineTo(0, size * 0.1);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    // ì›í˜• í…Œë‘ë¦¬
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'victor':
                    // ìŠ¹ë¦¬ì: ì™•ê´€
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowColor = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, size * 0.2);
                    ctx.lineTo(-size * 0.2, -size * 0.1);
                    ctx.lineTo(0, size * 0.1);
                    ctx.lineTo(size * 0.2, -size * 0.1);
                    ctx.lineTo(size * 0.3, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    // ë³´ì„
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'timeStop':
                    // ì‹œê°„ì •ì§€: í˜„ëŒ€ì ì¸ ë©ˆì¶¤ ì•„ì´ì½˜ (pause icon, ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#888888';
                    const timeStopGradient = ctx.createLinearGradient(-size * 0.15, -size * 0.2, -size * 0.15, size * 0.2);
                    timeStopGradient.addColorStop(0, '#aaaaaa');
                    timeStopGradient.addColorStop(1, '#666666');
                    ctx.fillStyle = timeStopGradient;
                    // ë‘ ê°œì˜ ì„¸ë¡œ ë§‰ëŒ€ (pause icon, ë‘¥ê·¼ ëª¨ì„œë¦¬)
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.15, -size * 0.2, size * 0.1, size * 0.4, size * 0.02);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.roundRect(size * 0.05, -size * 0.2, size * 0.1, size * 0.4, size * 0.02);
                    ctx.fill();
                    break;
                case 'scatter':
                    // ë¹„ì‚°íƒ„: í˜„ëŒ€ì ì¸ 4ë°©í–¥ í™”ì‚´í‘œ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffaa00';
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI * 2 / 4) - Math.PI / 2;
                        const x = Math.cos(angle) * size * 0.25;
                        const y = Math.sin(angle) * size * 0.25;
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle);
                        const scatterGradient = ctx.createLinearGradient(0, -size * 0.15, 0, 0);
                        scatterGradient.addColorStop(0, '#ffcc44');
                        scatterGradient.addColorStop(1, '#ff8800');
                        ctx.fillStyle = scatterGradient;
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.16);
                        ctx.lineTo(-size * 0.08, -size * 0.06);
                        ctx.lineTo(-size * 0.04, -size * 0.06);
                        ctx.lineTo(-size * 0.04, 0);
                        ctx.lineTo(size * 0.04, 0);
                        ctx.lineTo(size * 0.04, -size * 0.06);
                        ctx.lineTo(size * 0.08, -size * 0.06);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    break;
                case 'rocket':
                    // ë¡œì¼“íƒ„: í˜„ëŒ€ì ì¸ ë¡œì¼“ ëª¨ì–‘ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff6600';
                    const rocketGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.3);
                    rocketGradient.addColorStop(0, '#ffaa00');
                    rocketGradient.addColorStop(0.5, '#ff6600');
                    rocketGradient.addColorStop(1, '#ff4400');
                    ctx.fillStyle = rocketGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.18, size * 0.18);
                    ctx.lineTo(0, size * 0.28);
                    ctx.lineTo(size * 0.18, size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    // ë¶ˆê½ƒ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowColor = '#ffff00';
                    const flameGradient = ctx.createLinearGradient(0, size * 0.3, 0, size * 0.4);
                    flameGradient.addColorStop(0, '#ffff00');
                    flameGradient.addColorStop(1, '#ff6600');
                    ctx.fillStyle = flameGradient;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.14, size * 0.28);
                    ctx.lineTo(-size * 0.05, size * 0.38);
                    ctx.lineTo(0, size * 0.33);
                    ctx.lineTo(size * 0.05, size * 0.38);
                    ctx.lineTo(size * 0.14, size * 0.28);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'trinity':
                    // ì‚¼ìœ„ì¼ì²´: í˜„ëŒ€ì ì¸ ì„¸ ê°œì˜ ì›ì´ ì—°ê²°ëœ ëª¨ì–‘ (ì‚¼ê°í˜• ë°°ì¹˜, ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#9b59b6';
                    const trinityGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.2);
                    trinityGradient.addColorStop(0, '#bb77dd');
                    trinityGradient.addColorStop(1, '#7b39a6');
                    ctx.fillStyle = trinityGradient;
                    // ìœ„ìª½ ì›
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.2, size * 0.16, 0, Math.PI * 2);
                    ctx.fill();
                    // ì™¼ìª½ ì•„ë˜ ì›
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, size * 0.2, size * 0.16, 0, Math.PI * 2);
                    ctx.fill();
                    // ì˜¤ë¥¸ìª½ ì•„ë˜ ì›
                    ctx.beginPath();
                    ctx.arc(size * 0.2, size * 0.2, size * 0.16, 0, Math.PI * 2);
                    ctx.fill();
                    // ì—°ê²°ì„  (ë” ë‘ê»ê³  ë¶€ë“œëŸ½ê²Œ)
                    ctx.strokeStyle = '#9b59b6';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.04);
                    ctx.lineTo(-size * 0.2, size * 0.04);
                    ctx.moveTo(0, -size * 0.04);
                    ctx.lineTo(size * 0.2, size * 0.04);
                    ctx.moveTo(-size * 0.2, size * 0.04);
                    ctx.lineTo(size * 0.2, size * 0.04);
                    ctx.stroke();
                    break;
                case 'judgment':
                    // ì„ ê³ : í˜„ëŒ€ì ì¸ ì¶©ê²©íŒŒ ëª¨ì–‘ (ì›í˜• íŒŒë™, ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff4444';
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 3.5;
                    ctx.lineCap = 'round';
                    // ë°”ê¹¥ìª½ ì›
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    // ì¤‘ê°„ ì›
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    // ì•ˆìª½ ì›
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    // ì¤‘ì•™ í™”ì‚´í‘œ (ë°€ì–´ë‚´ëŠ” ë°©í–¥, ê·¸ë¼ë°ì´ì…˜)
                    const judgmentGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.35);
                    judgmentGradient.addColorStop(0, '#ff6666');
                    judgmentGradient.addColorStop(1, '#cc0000');
                    ctx.fillStyle = judgmentGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.22, -size * 0.16);
                    ctx.lineTo(size * 0.16, -size * 0.12);
                    ctx.lineTo(size * 0.26, -size * 0.12);
                    ctx.lineTo(size * 0.26, -size * 0.22);
                    ctx.lineTo(size * 0.36, 0);
                    ctx.lineTo(size * 0.26, size * 0.22);
                    ctx.lineTo(size * 0.26, size * 0.12);
                    ctx.lineTo(size * 0.16, size * 0.12);
                    ctx.lineTo(size * 0.22, size * 0.16);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'tide':
                    // í•´ë¥˜: íŒŒë„ ëª¨ì–‘ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#00aaff';
                    const tideGradient = ctx.createLinearGradient(-size * 0.3, 0, size * 0.3, 0);
                    tideGradient.addColorStop(0, '#66ccff');
                    tideGradient.addColorStop(0.5, '#00aaff');
                    tideGradient.addColorStop(1, '#0088ff');
                    ctx.fillStyle = tideGradient;
                    // íŒŒë„ ëª¨ì–‘ (ìœ„ì•„ë˜ë¡œ íë¥´ëŠ” ëŠë‚Œ)
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.4, size * 0.2);
                    ctx.quadraticCurveTo(-size * 0.2, -size * 0.1, 0, size * 0.1);
                    ctx.quadraticCurveTo(size * 0.2, size * 0.3, size * 0.4, size * 0.1);
                    ctx.quadraticCurveTo(size * 0.2, -size * 0.1, 0, size * 0.05);
                    ctx.quadraticCurveTo(-size * 0.2, size * 0.25, -size * 0.4, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'oblivion':
                    // ë§ê°: ì–´ë‘ìš´ êµ¬ë¦„/ì•ˆê°œ ëª¨ì–‘ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#6600aa';
                    const oblivionGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                    oblivionGradient.addColorStop(0, '#8800ff');
                    oblivionGradient.addColorStop(0.5, '#6600aa');
                    oblivionGradient.addColorStop(1, '#440066');
                    ctx.fillStyle = oblivionGradient;
                    // ì•ˆê°œ/êµ¬ë¦„ ëª¨ì–‘ (ë¶ˆê·œì¹™í•œ ì›)
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, -size * 0.1, size * 0.25, 0, Math.PI * 2);
                    ctx.arc(size * 0.15, -size * 0.05, size * 0.2, 0, Math.PI * 2);
                    ctx.arc(0, size * 0.15, size * 0.22, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'mechanization':
                    // ê¸°ê³„í™”: ê¸°ì–´/í†±ë‹ˆë°”í€´ ëª¨ì–‘
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#888888';
                    ctx.fillStyle = '#aaaaaa';
                    ctx.strokeStyle = '#666666';
                    ctx.lineWidth = 2;
                    // ê¸°ì–´ ì¤‘ì‹¬ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // í†±ë‹ˆ (8ê°œ)
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI * 2 / 8);
                        const x1 = Math.cos(angle) * size * 0.25;
                        const y1 = Math.sin(angle) * size * 0.25;
                        const x2 = Math.cos(angle) * size * 0.35;
                        const y2 = Math.sin(angle) * size * 0.35;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    break;
                case 'plunder':
                    // ê°•íƒˆ: ì† ëª¨ì–‘ (ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffaa00';
                    const plunderGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                    plunderGradient.addColorStop(0, '#ffcc44');
                    plunderGradient.addColorStop(1, '#ff8800');
                    ctx.fillStyle = plunderGradient;
                    // ì† ëª¨ì–‘ (ë‹¨ìˆœí™”)
                    ctx.beginPath();
                    // ì†ë°”ë‹¥
                    ctx.arc(0, size * 0.1, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    // ì†ê°€ë½ë“¤ (4ê°œ)
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, -size * 0.1, size * 0.1, 0, Math.PI * 2);
                    ctx.arc(-size * 0.05, -size * 0.15, size * 0.1, 0, Math.PI * 2);
                    ctx.arc(size * 0.05, -size * 0.15, size * 0.1, 0, Math.PI * 2);
                    ctx.arc(size * 0.15, -size * 0.1, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'boomerang':
                    // ë¶€ë§¤ë‘: í˜„ëŒ€ì ì¸ ë¶€ë©”ë‘ ëª¨ì–‘ (ê³¡ì„  í™”ì‚´í‘œ, ê·¸ë¼ë°ì´ì…˜)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00aaff';
                    ctx.strokeStyle = '#00aaff';
                    ctx.lineWidth = 3.5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    // ë¶€ë©”ë‘ ë³¸ì²´ (ê³¡ì„ , ë” ë‘ê»ê²Œ)
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.32, -Math.PI * 0.3, Math.PI * 1.3);
                    ctx.stroke();
                    // í™”ì‚´í‘œ ë¨¸ë¦¬ (ë˜ëŒì•„ì˜¤ëŠ” ë°©í–¥, ê·¸ë¼ë°ì´ì…˜)
                    const boomerangGradient = ctx.createLinearGradient(size * 0.25, -size * 0.15, size * 0.4, -size * 0.15);
                    boomerangGradient.addColorStop(0, '#33ccff');
                    boomerangGradient.addColorStop(1, '#0088cc');
                    ctx.fillStyle = boomerangGradient;
                    ctx.beginPath();
                    ctx.moveTo(size * 0.26, -size * 0.16);
                    ctx.lineTo(size * 0.36, -size * 0.26);
                    ctx.lineTo(size * 0.32, -size * 0.22);
                    ctx.lineTo(size * 0.42, -size * 0.16);
                    ctx.lineTo(size * 0.32, -size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // ë°˜ëŒ€ ë°©í–¥ í™”ì‚´í‘œ (ëŒì•„ì˜¤ëŠ” ë°©í–¥)
                    const boomerangGradient2 = ctx.createLinearGradient(-size * 0.25, size * 0.15, -size * 0.4, size * 0.15);
                    boomerangGradient2.addColorStop(0, '#33ccff');
                    boomerangGradient2.addColorStop(1, '#0088cc');
                    ctx.fillStyle = boomerangGradient2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.26, size * 0.16);
                    ctx.lineTo(-size * 0.36, size * 0.26);
                    ctx.lineTo(-size * 0.32, size * 0.22);
                    ctx.lineTo(-size * 0.42, size * 0.16);
                    ctx.lineTo(-size * 0.32, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                default:
                    // ê¸°ë³¸: ì‚¬ê°í˜•
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
            }
            
            ctx.restore();
        }

        // ì¦ê°• ì•„ì´ì½˜ ëª©ë¡ ê·¸ë¦¬ê¸°
        function drawAugmentIcons(character, x, y, align = 'left') {
            const iconSize = 32; // 2ë°° ì¦ê°€ (16 -> 32)
            const spacing = 8; // ê°„ê²©ë„ 2ë°° ì¦ê°€
            const bgSize = iconSize + 4; // ë°°ê²½ í¬ê¸°
            
            // ë§ˆìš°ìŠ¤ í˜¸ë²„ ê°ì§€
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseCanvasX = (mouse.x - rect.left) * scaleX;
            const mouseCanvasY = (mouse.y - rect.top) * scaleY;
            
            character.augmentations.forEach((aug, index) => {
                let iconX;
                if (align === 'right') {
                    iconX = x - (character.augmentations.length - index - 1) * (iconSize + spacing) - iconSize / 2;
                } else {
                    iconX = x + index * (iconSize + spacing) + iconSize / 2;
                }
                
                // ë§ˆìš°ìŠ¤ í˜¸ë²„ ì²´í¬
                const iconLeft = iconX - bgSize / 2;
                const iconRight = iconX + bgSize / 2;
                const iconTop = y - bgSize / 2;
                const iconBottom = y + bgSize / 2;
                
                if (mouseCanvasX >= iconLeft && mouseCanvasX <= iconRight &&
                    mouseCanvasY >= iconTop && mouseCanvasY <= iconBottom) {
                    hoveredAugment = {
                        aug: aug,
                        x: iconX,
                        y: y
                    };
                }
                
                // ë°°ê²½ ì‚¬ê°í˜• (í˜¸ë²„ ì‹œ ê°•ì¡°)
                if (hoveredAugment && hoveredAugment.aug === aug) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                }
                ctx.fillRect(iconX - bgSize / 2, y - bgSize / 2, bgSize, bgSize);
                
                // ì•„ì´ì½˜ ê·¸ë¦¬ê¸°
                drawAugmentIcon(ctx, iconX, y, iconSize, aug.id);
            });
        }

        // íƒ„í™˜ìˆ˜ í‘œì‹œ (ì²´ë ¥ ì•„ë˜ - í•˜ì–€ìƒ‰ ì›)
        function drawAmmoCount(character, x, y, align = 'left') {
            const circleSize = 12; // ì²´ë ¥ë°”(30px)ë³´ë‹¤ ë” ì‘ì€ ì›
            const spacing = 4;
            const radius = circleSize / 2;
            const centerY = y + radius; // ì›ì˜ ì¤‘ì‹¬ Y ì¢Œí‘œ
            
            // ì´ íƒ„í™˜ìˆ˜ë§Œí¼ ì› ê·¸ë¦¬ê¸° (ì‚¬ìš©í•œ íƒ„í™˜ì€ ë°˜íˆ¬ëª…)
            for (let i = 0; i < character.maxAmmo; i++) {
                ctx.save();
                if (i < character.ammo) {
                    // ë‚¨ì€ íƒ„í™˜: ë¶ˆíˆ¬ëª… í•˜ì–€ìƒ‰ + ë„¤ì˜¨ íš¨ê³¼
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff'; // íŒŒìŠ¤í…” í™”ì´íŠ¸
                } else {
                    // ì‚¬ìš©í•œ íƒ„í™˜: ë°˜íˆ¬ëª…
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                }
                
                let centerX;
                if (align === 'right') {
                    // ì˜¤ë¥¸ìª½ ì •ë ¬: ì˜¤ë¥¸ìª½ë¶€í„° ì™¼ìª½ìœ¼ë¡œ
                    centerX = x - (character.maxAmmo - i - 1) * (circleSize + spacing) - radius;
                } else {
                    // ì™¼ìª½ ì •ë ¬: ì™¼ìª½ë¶€í„° ì˜¤ë¥¸ìª½ìœ¼ë¡œ
                    centerX = x + i * (circleSize + spacing) + radius;
                }
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ë§ˆë¦„ëª¨ ê·¸ë¦¬ê¸° í•¨ìˆ˜
        function drawDiamond(x, y, size, color) {
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2); // ìœ„
            ctx.lineTo(x + size / 2, y); // ì˜¤ë¥¸ìª½
            ctx.lineTo(x, y + size / 2); // ì•„ë˜
            ctx.lineTo(x - size / 2, y); // ì™¼ìª½
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ (ë§ˆë¦„ëª¨ ì•„ë˜)
        function drawCountdown() {
            const countdownValue = gameState.countdown > 0 ? gameState.countdown : gameState.augmentCountdown;
            if (countdownValue <= 0) return;
            
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const y = 100; // ë§ˆë¦„ëª¨ ì•„ë˜
            
            // ë°˜íˆ¬ëª… ë°°ê²½
            const textWidth = ctx.measureText(countdownValue).width;
            const padding = 30;
            ctx.fillRect(
                canvas.width / 2 - textWidth / 2 - padding,
                y - 50,
                textWidth + padding * 2,
                100
            );
            
            // ìˆ«ì í‘œì‹œ (ë„¤ì˜¨ íš¨ê³¼)
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffffff';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(countdownValue, canvas.width / 2, y);
            ctx.restore();
        }

        // ìŠ¹ë¦¬ í‘œì‹œ ë§ˆë¦„ëª¨ ê·¸ë¦¬ê¸° (í™”ë©´ ìœ„ìª½ ê°€ìš´ë°)
        function drawWinIndicators() {
            const diamondSize = 20;
            const spacing = 5;
            const groupSpacing = 15; // ê·¸ë£¹ ì‚¬ì´ ê°„ê²© (ì–‡ì€ ì„  í¬í•¨)
            const diamondsPerGroup = 5;
            
            // ì²« ë²ˆì§¸ ê·¸ë£¹ ë„ˆë¹„ ê³„ì‚°
            const groupWidth = (diamondsPerGroup * diamondSize) + ((diamondsPerGroup - 1) * spacing);
            // ì „ì²´ ë„ˆë¹„ ê³„ì‚° (ë‘ ê·¸ë£¹ + ê·¸ë£¹ ì‚¬ì´ ê°„ê²©)
            const totalWidth = (groupWidth * 2) + groupSpacing;
            const startX = (canvas.width - totalWidth) / 2;
            const y = 35; // ì‚´ì§ ì•„ë˜ë¡œ ë‚´ë¦¼

            // ë©€í‹°í”Œë ˆì´ì–´: íŒ€ ê¸°ì¤€ìœ¼ë¡œ ìŠ¹ë¦¬ ìˆ˜ ê³„ì‚°
            // ì™¼ìª½ì€ í•­ìƒ íŒŒë€íŒ€, ì˜¤ë¥¸ìª½ì€ í•­ìƒ ë¹¨ê°„íŒ€
            let blueWins, redWins;
            if (gameState.isMultiplayer && myTeam) {
                if (myTeam === 'blue') {
                    blueWins = gameState.playerWins;
                    redWins = gameState.enemyWins;
                } else {
                    blueWins = gameState.enemyWins;
                    redWins = gameState.playerWins;
                }
            } else {
                // ì†”ë¡œ: í”Œë ˆì´ì–´=íŒŒë€, ì =ë¹¨ê°•
                blueWins = gameState.playerWins;
                redWins = gameState.enemyWins;
            }

            // ì™¼ìª½ ê·¸ë£¹: íŒŒë€íŒ€ ìŠ¹ë¦¬ (íŒŒë€ìƒ‰)
            for (let i = 0; i < diamondsPerGroup; i++) {
                let color;
                if (i < blueWins) {
                    // íŒŒë€íŒ€ ìŠ¹ë¦¬: íŒŒë€ìƒ‰
                    color = 'rgba(74, 158, 255, 0.8)';
                } else {
                    // ì•„ì§ ì§„í–‰ë˜ì§€ ì•Šì€ ë¼ìš´ë“œ: ë°˜íˆ¬ëª… íšŒìƒ‰
                    color = 'rgba(255, 255, 255, 0.2)';
                }
                
                const x = startX + i * (diamondSize + spacing) + diamondSize / 2;
                drawDiamond(x, y, diamondSize, color);
            }
            
            // ì˜¤ë¥¸ìª½ ê·¸ë£¹: ë¹¨ê°„íŒ€ ìŠ¹ë¦¬ (ë¹¨ê°„ìƒ‰) - ì˜¤ë¥¸ìª½ë¶€í„° ì±„ì›Œì§
            for (let i = 0; i < diamondsPerGroup; i++) {
                let color;
                // ì˜¤ë¥¸ìª½ë¶€í„° ì±„ìš°ê¸° ìœ„í•´ ì—­ìˆœìœ¼ë¡œ ê³„ì‚°
                if ((diamondsPerGroup - 1 - i) < redWins) {
                    // ë¹¨ê°„íŒ€ ìŠ¹ë¦¬: ë¹¨ê°„ìƒ‰
                    color = 'rgba(233, 69, 96, 0.8)';
                } else {
                    // ì•„ì§ ì§„í–‰ë˜ì§€ ì•Šì€ ë¼ìš´ë“œ: ë°˜íˆ¬ëª… íšŒìƒ‰
                    color = 'rgba(255, 255, 255, 0.2)';
                }
                
                const x = startX + groupWidth + groupSpacing + i * (diamondSize + spacing) + diamondSize / 2;
                drawDiamond(x, y, diamondSize, color);
            }
            
            // ê·¸ë£¹ ì‚¬ì´ ì–‡ì€ ì„  ê·¸ë¦¬ê¸°
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            const lineX = startX + groupWidth + groupSpacing / 2;
            ctx.beginPath();
            ctx.moveTo(lineX, y - diamondSize / 2 - 5);
            ctx.lineTo(lineX, y + diamondSize / 2 + 5);
            ctx.stroke();
            ctx.restore();
        }

        // ì¬ì¥ì „ ì§„í–‰ë¥  ë°” ê·¸ë¦¬ê¸° (ë™ê·¸ë€ ë°”ë¡œ)
        function drawReloadBar(character, x, y) {
            if (!character.isReloading) return;
            
            const now = Date.now();
            const elapsed = now - character.reloadStartTime;
            const progress = Math.min(elapsed / character.reloadTime, 1); // 0~1 ì‚¬ì´ ê°’
            
            const radius = 8; // ì›ì˜ ë°˜ì§€ë¦„ (20% ì¤„ì„: 10 -> 8)
            const lineWidth = 4; // ì„  ë‘ê»˜ (30% ëŠ˜ë¦¼: 3 -> 4)
            
            ctx.save();
            // ë°°ê²½ ì› (íšŒìƒ‰)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ì§„í–‰ë¥  ì› (í•˜ì–€ìƒ‰ + ë„¤ì˜¨ íš¨ê³¼)
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffffff';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(x, y, radius, -Math.PI / 2, -Math.PI / 2 + (progress * Math.PI * 2));
            ctx.stroke();
            ctx.restore();
        }

        // ê·¸ë¦¬ê¸° í•¨ìˆ˜
        // ê²Œì„ ì‹œì‘ í•¨ìˆ˜ë“¤
        // ë³¸ ì¦ê°• ëª©ë¡ ê´€ë¦¬ (localStorage ì‚¬ìš©)
        function getSeenAugments() {
            const seen = localStorage.getItem('seenAugments');
            return seen ? JSON.parse(seen) : [];
        }

        function markAugmentAsSeen(augmentId) {
            const seen = getSeenAugments();
            if (!seen.includes(augmentId)) {
                seen.push(augmentId);
                localStorage.setItem('seenAugments', JSON.stringify(seen));
            }
        }

        // ì¦ê°• ì„ íƒ íšŸìˆ˜ ê´€ë¦¬ (localStorage ì‚¬ìš©)
        function getAugmentSelectCounts() {
            const counts = localStorage.getItem('augmentSelectCounts');
            return counts ? JSON.parse(counts) : {};
        }

        function incrementAugmentSelectCount(augmentId) {
            const counts = getAugmentSelectCounts();
            counts[augmentId] = (counts[augmentId] || 0) + 1;
            localStorage.setItem('augmentSelectCounts', JSON.stringify(counts));
        }

        function getAugmentSelectCount(augmentId) {
            const counts = getAugmentSelectCounts();
            return counts[augmentId] || 0;
        }

        // ë„ê° í™”ë©´ ë‚´ìš© ë¡œë“œ
        function loadCollectionContent() {
            const content = document.getElementById('collectionContent');
            const seenAugments = getSeenAugments();
            
            if (content) {
            content.innerHTML = '';
            
            augmentations.forEach(aug => {
                const isSeen = seenAugments.includes(aug.id);
                const selectCount = getAugmentSelectCount(aug.id);
                const item = document.createElement('div');
                item.className = 'collection-item' + (isSeen ? '' : ' locked');
                item.innerHTML = `
                    ${selectCount > 0 ? `<span class="select-count">${selectCount}íšŒ ì„ íƒ</span>` : ''}
                    <h4>${isSeen ? aug.name : '???'}</h4>
                    <p>${isSeen ? aug.description : '??? (ì•„ì§ ë°œê²¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤)'}</p>
                `;
                content.appendChild(item);
            });
            }
        }

        // ìƒì  ìƒí’ˆ ëª©ë¡
        const shopItemsRaw = [
            { id: 'hitEffect_dot_gray', name: 'ì ', description: 'í”¼ê²© ì‹œ íšŒìƒ‰ ì  ì´í™íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤', price: 40, rarity: 'common' },
            { id: 'hitEffect_triangle_gray', name: 'ì‚¼ê°í˜•', description: 'í”¼ê²© ì‹œ íšŒìƒ‰ ì‚¼ê°í˜• ì´í™íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤', price: 40, rarity: 'common' },
            { id: 'hitEffect_square_gray', name: 'ì‚¬ê°í˜•', description: 'í”¼ê²© ì‹œ íšŒìƒ‰ ì‚¬ê°í˜• ì´í™íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤', price: 40, rarity: 'common' },
            { id: 'hitEffect_firework_gray', name: 'í­ì£½', description: 'í”¼ê²© ì‹œ íšŒìƒ‰ í­ì£½ ì´í™íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤', price: 75, rarity: 'rare' }
        ];
        
        // ë“±ê¸‰ë³„ ê°€ê²© ì„¤ì • (common: 40, rare: 75)
        const shopItems = shopItemsRaw.map(item => {
            if (item.rarity === 'common') {
                return { ...item, price: 40 };
            } else if (item.rarity === 'rare') {
                return { ...item, price: 75 };
            }
            return { ...item };
        });
        
        // ë³´ê´€ì†Œ (êµ¬ë§¤í•œ ì•„ì´í…œ ì €ì¥)
        let storage = JSON.parse(localStorage.getItem('gameStorage') || '[]');
        
        // ìƒì  ìƒˆë¡œê³ ì¹¨ ì‹œê°„ ê´€ë¦¬ (6ì‹œê°„ë§ˆë‹¤)
        const SHOP_REFRESH_INTERVAL = 6 * 60 * 60 * 1000; // 6ì‹œê°„ (ë°€ë¦¬ì´ˆ)
        
        function getShopRefreshTime() {
            const lastRefresh = localStorage.getItem('shopLastRefresh');
            if (!lastRefresh) {
                // ì²˜ìŒì´ë©´ í˜„ì¬ ì‹œê°„ìœ¼ë¡œ ì„¤ì •í•˜ê³  ìƒí’ˆë„ ì´ˆê¸°í™”
                const now = Date.now();
                localStorage.setItem('shopLastRefresh', now.toString());
                // ìƒí’ˆì´ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ì €ì¥
                if (!localStorage.getItem('shopCurrentItems')) {
                    localStorage.setItem('shopCurrentItems', JSON.stringify([]));
                }
                return now;
            }
            return parseInt(lastRefresh);
        }
        
        function shouldRefreshShop() {
            const lastRefresh = getShopRefreshTime();
            const now = Date.now();
            return (now - lastRefresh) >= SHOP_REFRESH_INTERVAL;
        }
        
        function refreshShopItems() {
            // ëª¨ë“  ìƒí’ˆì„ ë°˜í™˜í•˜ë˜, 3ê°œëŠ” í• ì¸ëœ ìƒí’ˆìœ¼ë¡œ í‘œì‹œ
            if (shopItems.length > 0) {
                const shuffled = [...shopItems].sort(() => Math.random() - 0.5);
                const discountedItems = shuffled.slice(0, Math.min(3, shopItems.length));
                
                // í• ì¸ìœ¨ 20%~50% ëœë¤ ì ìš© (5% ë‹¨ìœ„)
                const discountRates = [0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50]; // 5% ë‹¨ìœ„ í• ì¸ìœ¨
                const allItems = shopItems.map((item, index) => {
                    const isDiscounted = discountedItems.some(disc => disc.id === item.id);
                    // í• ì¸ëœ ìƒí’ˆì— ëŒ€í•´ ëœë¤í•˜ê²Œ 5% ë‹¨ìœ„ í• ì¸ìœ¨ ì„ íƒ
                    const discountRate = isDiscounted ? discountRates[Math.floor(Math.random() * discountRates.length)] : 0;
                    return {
                        ...item,
                        originalPrice: item.price,
                        discountRate: discountRate,
                        discountedPrice: Math.floor(item.price * (1 - discountRate))
                    };
                });
                
                localStorage.setItem('shopCurrentItems', JSON.stringify(allItems));
                localStorage.setItem('shopDiscountedItems', JSON.stringify(discountedItems.map(item => item.id)));
                localStorage.setItem('shopLastRefresh', Date.now().toString());
                return allItems;
        }
            return [];
        }
        
        function getCurrentShopItems() {
            // ìƒˆë¡œê³ ì¹¨ì´ í•„ìš”í•œì§€ í™•ì¸í•˜ë˜, ì‹œê°„ ê³„ì‚°ì€ ë³„ë„ë¡œ ì²˜ë¦¬
            const shouldRefresh = shouldRefreshShop();
            if (shouldRefresh) {
                const refreshed = refreshShopItems();
                return refreshed;
            }
            const stored = localStorage.getItem('shopCurrentItems');
            if (stored) {
                const items = JSON.parse(stored);
                // shopItemsì— ìˆëŠ” ëª¨ë“  ì•„ì´í…œì´ ì €ì¥ëœ ì•„ì´í…œì— ìˆëŠ”ì§€ í™•ì¸
                const storedIds = items.map(item => item.id);
                const allShopItemIds = shopItems.map(item => item.id);
                const hasNewItems = allShopItemIds.some(id => !storedIds.includes(id));
                
                // ê¸°ì¡´ ì €ì¥ëœ ì•„ì´í…œì— rarity ì†ì„±ì´ ì—†ê±°ë‚˜, shopItemsì˜ ë“±ê¸‰ê³¼ ë‹¤ë¥´ê±°ë‚˜, ìƒˆë¡œìš´ ì•„ì´í…œì´ ìˆê±°ë‚˜, ê°€ê²©ì´ 0ì´ê±°ë‚˜ ë‹¤ë¥´ë©´ ìƒˆë¡œê³ ì¹¨
                const needsRefresh = hasNewItems || items.some(item => {
                    if (!item.rarity) return true;
                    const originalItem = shopItems.find(shopItem => shopItem.id === item.id);
                    if (originalItem && originalItem.rarity !== item.rarity) return true;
                    // ê°€ê²©ì´ 0ì´ê±°ë‚˜ shopItemsì˜ ê°€ê²©ê³¼ ë‹¤ë¥´ë©´ ìƒˆë¡œê³ ì¹¨
                    if (originalItem && (item.price === 0 || item.originalPrice === 0 || item.price !== originalItem.price)) return true;
                    return false;
                });
                if (needsRefresh) {
                    return refreshShopItems();
                }
                // ê¸°ì¡´ ì €ì¥ëœ ì•„ì´í…œì— rarity ì†ì„±ì´ ì—†ìœ¼ë©´ ì¶”ê°€í•˜ê³ , ê°€ê²©ë„ ì—…ë°ì´íŠ¸
                return items.map(item => {
                    const originalItem = shopItems.find(shopItem => shopItem.id === item.id);
                    if (originalItem) {
                        if (!item.rarity) {
                            item.rarity = originalItem.rarity;
                        }
                        // ê°€ê²©ì´ 0ì´ê±°ë‚˜ ë‹¤ë¥´ë©´ ì—…ë°ì´íŠ¸
                        if (item.price === 0 || item.price !== originalItem.price) {
                            item.price = originalItem.price;
                            item.originalPrice = originalItem.price;
                            // í• ì¸ëœ ê°€ê²©ë„ ë‹¤ì‹œ ê³„ì‚°
                            if (item.discountRate > 0) {
                                item.discountedPrice = Math.floor(item.price * (1 - item.discountRate));
                            }
                        }
                    } else {
                        if (!item.rarity) {
                            item.rarity = 'common'; // ê¸°ë³¸ê°’
                        }
                    }
                    return item;
                });
            }
            // ì €ì¥ëœ ìƒí’ˆì´ ì—†ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨
            return refreshShopItems();
        }
        
        function formatTimeUntilRefresh() {
            const lastRefresh = getShopRefreshTime();
            const now = Date.now();
            const elapsed = now - lastRefresh;
            let remaining = SHOP_REFRESH_INTERVAL - elapsed;
            
            // ë§Œì•½ ì´ë¯¸ ìƒˆë¡œê³ ì¹¨ ì‹œê°„ì´ ì§€ë‚¬ë‹¤ë©´ ë‹¤ìŒ ìƒˆë¡œê³ ì¹¨ê¹Œì§€ì˜ ì‹œê°„ ê³„ì‚°
            if (remaining <= 0) {
                // ì´ë¯¸ ì§€ë‚œ ì‹œê°„ì„ ì£¼ê¸°ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒ ì£¼ê¸°ê¹Œì§€ì˜ ì‹œê°„ ê³„ì‚°
                const elapsedInCycle = elapsed % SHOP_REFRESH_INTERVAL;
                remaining = SHOP_REFRESH_INTERVAL - elapsedInCycle;
            }
            
            // ìŒìˆ˜ê°€ ë˜ì§€ ì•Šë„ë¡ ë³´ì •
            remaining = Math.max(0, remaining);
            
            const totalSeconds = Math.floor(remaining / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            // ë‘ ìë¦¬ ìˆ«ìë¡œ í¬ë§·íŒ…
            const formattedHours = String(hours).padStart(2, '0');
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');
            
            return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
        }
        
        // ìƒì  í™”ë©´ì´ ì—´ë ¤ìˆì„ ë•Œ ì‹¤ì‹œê°„ìœ¼ë¡œ ì‹œê°„ ì—…ë°ì´íŠ¸
        let shopRefreshInterval = null;
        
        function startShopRefreshTimer() {
            // ê¸°ì¡´ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ì œê±°
            if (shopRefreshInterval) {
                clearInterval(shopRefreshInterval);
            }
            
            // 1ì´ˆë§ˆë‹¤ ì‹œê°„ ì—…ë°ì´íŠ¸
            shopRefreshInterval = setInterval(() => {
                const refreshTimeElement = document.getElementById('shopRefreshTime');
                if (refreshTimeElement) {
                    refreshTimeElement.textContent = formatTimeUntilRefresh();
                }
            }, 1000);
        }
        
        function stopShopRefreshTimer() {
            if (shopRefreshInterval) {
                clearInterval(shopRefreshInterval);
                shopRefreshInterval = null;
            }
        }
        
        // ìƒì  í™”ë©´ ì—´ê¸° (ë‚´ë¶€ í•¨ìˆ˜)
        function openShopModal() {
            const itemsContainer = document.getElementById('shopItems');
            const refreshTimeElement = document.getElementById('shopRefreshTime');
            
            // í˜„ì¬ ìƒí’ˆ ê°€ì ¸ì˜¤ê¸° (ì´ í•¨ìˆ˜ê°€ shopLastRefreshë¥¼ ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆìŒ)
            const currentItems = getCurrentShopItems();
            
            // ìƒˆë¡œê³ ì¹¨ ì‹œê°„ í‘œì‹œ (ìƒí’ˆ ë¡œë“œ í›„ì— í‘œì‹œ)
            if (refreshTimeElement) {
                refreshTimeElement.textContent = formatTimeUntilRefresh();
            }
            
            // ì‹¤ì‹œê°„ íƒ€ì´ë¨¸ ì‹œì‘
            startShopRefreshTimer();
            
            // ìƒí’ˆ í‘œì‹œ
            if (itemsContainer) {
                itemsContainer.innerHTML = '';
                if (currentItems.length === 0) {
                    itemsContainer.innerHTML = '<p style="color: #888; text-align: center; grid-column: 1 / -1;">ìƒí’ˆì´ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</p>';
                } else {
                    // í• ì¸ëœ ìƒí’ˆê³¼ ì¼ë°˜ ìƒí’ˆ ë¶„ë¦¬
                    const discountedItems = currentItems.filter(item => item.discountRate > 0);
                    const regularItems = currentItems.filter(item => item.discountRate === 0);
            
                    // í• ì¸ëœ ìƒí’ˆ ì„¹ì…˜ (3ê°œë§Œ í‘œì‹œ)
                    if (discountedItems.length > 0) {
                        const discountSection = document.createElement('div');
                        discountSection.style.cssText = 'grid-column: 1 / -1; margin-bottom: 30px;';
                        discountSection.innerHTML = '<h3 style="color: #ffc107; font-size: 24px; margin-bottom: 20px; text-align: center;">í• ì¸ ìƒí’ˆ</h3>';
                        itemsContainer.appendChild(discountSection);
                        
                        // ì²˜ìŒ 3ê°œë§Œ í‘œì‹œ
                        discountedItems.slice(0, 3).forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'shop-item';
                            // ë“±ê¸‰ì— ë”°ë¥¸ í´ë˜ìŠ¤ ì¶”ê°€
                            if (item.rarity === 'common') {
                                itemDiv.classList.add('rarity-common');
                            } else if (item.rarity === 'rare') {
                                itemDiv.classList.add('rarity-rare');
                            } else if (item.rarity === 'epic') {
                                itemDiv.classList.add('rarity-epic');
                            }
                            
                            const isOwned = storage.includes(item.id);
                            if (isOwned) {
                                itemDiv.classList.add('owned');
                            }
                            
                            const displayPrice = item.discountedPrice || item.price;
                            const discountPercent = Math.round(item.discountRate * 100);
                            
                            // ë“±ê¸‰ ì•„ì´ì½˜ ìƒì„±
                            let rarityIcon = '';
                            if (item.rarity === 'common') {
                                rarityIcon = '<div class="rarity-icon triangle common"></div>';
                            } else if (item.rarity === 'rare') {
                                rarityIcon = '<div class="rarity-icon square"></div>';
                            } else if (item.rarity === 'epic') {
                                rarityIcon = '<div class="rarity-icon pentagon"></div>';
                            }
                            
                            itemDiv.innerHTML = `
                                ${rarityIcon}
                                <div style="position: absolute; top: 10px; right: 10px; background: #e94560; color: white; padding: 5px 10px; border-radius: 5px; font-size: 14px; font-weight: bold; z-index: 10;">-${discountPercent}%</div>
                                <h4>${item.name}</h4>
                                <p>${item.description}</p>
                                <div class="shop-item-price" style="text-decoration: line-through; color: #888; font-size: 14px; margin-top: 10px; display: flex; align-items: center; justify-content: center; gap: 5px;">
                                    ${item.originalPrice}<div class="neon-diamond" style="width: 12px; height: 12px; border: 2px solid #888;"></div>
                                </div>
                                <div class="shop-item-price" style="color: #ffc107; font-size: 20px; font-weight: bold; margin-top: 5px; display: flex; align-items: center; justify-content: center; gap: 5px;">
                                    ${displayPrice}<div class="neon-diamond" style="width: 14px; height: 14px; border: 2px solid #ffc107;"></div>
                                </div>
                                ${isOwned ? '<p style="color: #4a9eff; margin-top: 10px;">ë³´ìœ  ì¤‘</p>' : ''}
                            `;
                            
                            if (!isOwned) {
                                itemDiv.onclick = () => buyShopItem(item, displayPrice);
                            }
                            
                            itemsContainer.appendChild(itemDiv);
                        });
                    }
                    
                    // ì¼ë°˜ ìƒí’ˆ ì„¹ì…˜
                    if (regularItems.length > 0) {
                        const regularSection = document.createElement('div');
                        regularSection.style.cssText = 'grid-column: 1 / -1; margin-top: 30px; margin-bottom: 20px;';
                        regularSection.innerHTML = '<h3 style="color: #ffffff; font-size: 24px; margin-bottom: 20px; text-align: center;">ì¼ë°˜ ìƒí’ˆ</h3>';
                        itemsContainer.appendChild(regularSection);
                        
                        regularItems.forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'shop-item';
                            // ë“±ê¸‰ì— ë”°ë¥¸ í´ë˜ìŠ¤ ì¶”ê°€
                            if (item.rarity === 'common') {
                                itemDiv.classList.add('rarity-common');
                            } else if (item.rarity === 'rare') {
                                itemDiv.classList.add('rarity-rare');
                            } else if (item.rarity === 'epic') {
                                itemDiv.classList.add('rarity-epic');
                            }
                            
                            const isOwned = storage.includes(item.id);
                            if (isOwned) {
                                itemDiv.classList.add('owned');
                            }
                            
                            const displayPrice = item.price;
                            
                            // ë“±ê¸‰ ì•„ì´ì½˜ ìƒì„±
                            let rarityIcon = '';
                            if (item.rarity === 'common') {
                                rarityIcon = '<div class="rarity-icon triangle common"></div>';
                            } else if (item.rarity === 'rare') {
                                rarityIcon = '<div class="rarity-icon square"></div>';
                            } else if (item.rarity === 'epic') {
                                rarityIcon = '<div class="rarity-icon pentagon"></div>';
                            }
                            
                            itemDiv.innerHTML = `
                                ${rarityIcon}
                                <h4>${item.name}</h4>
                                <p>${item.description}</p>
                                <div class="shop-item-price" style="display: flex; align-items: center; justify-content: center; gap: 5px; margin-top: 10px;">
                                    ${displayPrice}<div class="neon-diamond" style="width: 14px; height: 14px; border: 2px solid #fff;"></div>
                                </div>
                                ${isOwned ? '<p style="color: #4a9eff; margin-top: 10px;">ë³´ìœ  ì¤‘</p>' : ''}
                            `;
                            
                            if (!isOwned) {
                                itemDiv.onclick = () => buyShopItem(item, displayPrice);
                            }
                            
                            itemsContainer.appendChild(itemDiv);
                        });
                    }
                }
            }
        }

        // ìƒì  ì•„ì´í…œ êµ¬ë§¤
        function buyShopItem(item, displayPrice) {
            const price = displayPrice !== undefined ? displayPrice : (item.discountedPrice || item.price);
            if (gameKillCount < price) {
                alert('ì œí™”ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!');
                return;
            }
            
            if (storage.includes(item.id)) {
                alert('ì´ë¯¸ ë³´ìœ í•œ ì•„ì´í…œì…ë‹ˆë‹¤!');
                return;
            }
            
            // êµ¬ë§¤ í™•ì¸
            if (confirm(`${item.name}ì„(ë¥¼) ${price} ì œí™”ì— êµ¬ë§¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                gameKillCount -= price;
                updateKillCount(gameKillCount);
                storage.push(item.id);
                localStorage.setItem('gameStorage', JSON.stringify(storage));
                
                // ìƒì  í™”ë©´ ìƒˆë¡œê³ ì¹¨
                openShopModal();
                alert('êµ¬ë§¤ ì™„ë£Œ! ë³´ê´€ì†Œì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            }
        }
        
        // ì„ íƒëœ í”¼ê²© ì´í™íŠ¸ ì•„ì´í…œ ê´€ë¦¬
        let selectedHitEffectItem = localStorage.getItem('selectedHitEffectItem') || null;
        
        // ë³´ê´€ì†Œ í™”ë©´ ì—´ê¸° (ë‚´ë¶€ í•¨ìˆ˜)
        function openStorageModal() {
            const itemsContainer = document.getElementById('storageItems');
            
            // ì„ íƒëœ ì•„ì´í…œ ë‹¤ì‹œ ë¶ˆëŸ¬ì˜¤ê¸°
            selectedHitEffectItem = localStorage.getItem('selectedHitEffectItem') || null;
            
            // ë³´ê´€ëœ ì•„ì´í…œ í‘œì‹œ
            if (itemsContainer) {
                itemsContainer.innerHTML = '';
                if (storage.length === 0) {
                    itemsContainer.innerHTML = '<p style="color: #888; text-align: center; grid-column: 1 / -1;">ë³´ê´€ëœ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                } else {
                    // ë“±ê¸‰ ìˆœì„œ ì •ì˜ (ë†’ì€ ìˆœì„œë¶€í„°)
                    const rarityOrder = { 'epic': 3, 'rare': 2, 'common': 1 };
                    
                    // ì•„ì´í…œì„ ë“±ê¸‰ ìˆœìœ¼ë¡œ ì •ë ¬
                    const sortedItems = storage.map(itemId => {
                        const item = shopItems.find(i => i.id === itemId);
                        return item ? { id: itemId, item: item } : null;
                    }).filter(entry => entry !== null).sort((a, b) => {
                        const orderA = rarityOrder[a.item.rarity] || 0;
                        const orderB = rarityOrder[b.item.rarity] || 0;
                        return orderB - orderA; // ë†’ì€ ë“±ê¸‰ë¶€í„°
                    });
                    
                    sortedItems.forEach(({ item }) => {
                        if (item) {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'storage-item';
                            
                            // ë“±ê¸‰ì— ë”°ë¥¸ í´ë˜ìŠ¤ ì¶”ê°€
                            if (item.rarity === 'common') {
                                itemDiv.classList.add('rarity-common');
                            } else if (item.rarity === 'rare') {
                                itemDiv.classList.add('rarity-rare');
                            } else if (item.rarity === 'epic') {
                                itemDiv.classList.add('rarity-epic');
                            }
                            
                            // ì„ íƒëœ ì•„ì´í…œì¸ì§€ í™•ì¸
                            if (selectedHitEffectItem === item.id) {
                                itemDiv.classList.add('selected');
                            }
                            
                            // ë“±ê¸‰ ì•„ì´ì½˜ ìƒì„±
                            let rarityIcon = '';
                            if (item.rarity === 'common') {
                                rarityIcon = '<div class="rarity-icon triangle common"></div>';
                            } else if (item.rarity === 'rare') {
                                rarityIcon = '<div class="rarity-icon square"></div>';
                            } else if (item.rarity === 'epic') {
                                rarityIcon = '<div class="rarity-icon pentagon"></div>';
                            }
                            
                            // ê°•í™” ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                            const levelKey = `hitEffect_level_${item.id}`;
                            let currentLevel = parseInt(localStorage.getItem(levelKey) || '0');
                            // ê°•í™”ëŠ” ìµœëŒ€ 2ë‹¨ê³„ê¹Œì§€ë§Œ ê°€ëŠ¥í•˜ë¯€ë¡œ ì œí•œ
                            if (currentLevel > 2) {
                                currentLevel = 2;
                                localStorage.setItem(levelKey, '2');
                            }
                            const isEnhanced = currentLevel > 0;
                            const isEnhancedPlus = currentLevel >= 2;
                            
                            // ì„ íƒëœ ê°•í™” ë‹¨ê³„ ê°€ì ¸ì˜¤ê¸°
                            const selectedLevelKey = `selectedHitEffectLevel_${item.id}`;
                            let selectedLevel = parseInt(localStorage.getItem(selectedLevelKey) || '0');
                            // ì„ íƒëœ ë‹¨ê³„ê°€ ê°•í™”í•œ ë‹¨ê³„ë¥¼ ì´ˆê³¼í•˜ì§€ ì•Šë„ë¡ ì œí•œ
                            if (selectedLevel > currentLevel) {
                                selectedLevel = 0;
                                localStorage.setItem(selectedLevelKey, '0');
                            }
                            
                            itemDiv.style.position = 'relative'; // ìƒëŒ€ ìœ„ì¹˜ ì„¤ì •
                            
                            itemDiv.innerHTML = `
                                ${rarityIcon}
                                <div class="selected-badge">ì„ íƒë¨</div>
                                <h4>${item.name}${isEnhancedPlus ? '<span style="opacity: 0.7;"> (ê°•í™”+)</span>' : isEnhanced ? '<span style="opacity: 0.7;"> (ê°•í™”)</span>' : ''}</h4>
                                <p>${item.description}</p>
                                ${isEnhanced ? `<p style="color: #4a9eff; margin-top: 10px;">í”¼ê²© ì‹œ ëœë¤ ìƒ‰ìƒ ì´í™íŠ¸</p>` : ''}
                                ${isEnhancedPlus ? `<p style="color: #ffc107; margin-top: 5px;">ë„¤ì˜¨ íš¨ê³¼ ì ìš©</p>` : ''}
                                ${currentLevel < 2 ? `<button onclick="enhanceHitEffect('${item.id}', event)" style="
                                    position: absolute;
                                    bottom: 10px;
                                    right: 10px;
                                    padding: 8px 16px;
                                    background: #4a9eff;
                                    color: white;
                                    border: none;
                                    border-radius: 5px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    display: flex;
                                    align-items: center;
                                    gap: 5px;
                                ">${currentLevel === 0 ? 'ê°•í™”' : 'ê°•í™”+'} (20<div class="neon-diamond" style="width: 12px; height: 12px; border: 2px solid #fff; display: inline-block; margin-left: 2px;"></div>)</button>` : ''}
                                ${isEnhanced ? `<button onclick="cycleHitEffectLevel('${item.id}', event)" style="
                                    position: absolute;
                                    bottom: 10px;
                                    left: 10px;
                                    padding: 8px 12px;
                                    background: ${selectedLevel === 2 ? 'rgba(255, 193, 7, 0.3)' : 'rgba(74, 158, 255, 0.3)'};
                                    color: white;
                                    border: 1px solid ${selectedLevel === 2 ? '#ffc107' : '#4a9eff'};
                                    border-radius: 5px;
                                    cursor: pointer;
                                    font-size: 16px;
                                    font-weight: bold;
                                    min-width: 40px;
                                ">${selectedLevel}</button>` : ''}
                            `;
                            
                            // í´ë¦­ ì´ë²¤íŠ¸: ì„ íƒ/í•´ì œ (ë²„íŠ¼ í´ë¦­ ì‹œì—ëŠ” ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€)
                            itemDiv.addEventListener('click', (e) => {
                                // ë²„íŠ¼ í´ë¦­ì´ë©´ ì„ íƒ ì´ë²¤íŠ¸ ì‹¤í–‰ ì•ˆ í•¨
                                if (e.target.tagName === 'BUTTON') return;
                                
                                // ëª¨ë“  ì„ íƒ í•´ì œ
                                document.querySelectorAll('.storage-item').forEach(el => {
                                    el.classList.remove('selected');
                                });
                                
                                // í˜„ì¬ ì•„ì´í…œ ì„ íƒ
                                if (selectedHitEffectItem === item.id) {
                                    // ì´ë¯¸ ì„ íƒëœ ì•„ì´í…œì´ë©´ í•´ì œ
                                    selectedHitEffectItem = null;
                                    localStorage.removeItem('selectedHitEffectItem');
                                } else {
                                    // ìƒˆë¡œ ì„ íƒ
                                    selectedHitEffectItem = item.id;
                                    itemDiv.classList.add('selected');
                                    localStorage.setItem('selectedHitEffectItem', item.id);
                                }
                            });
                            
                            itemsContainer.appendChild(itemDiv);
                        }
                    });
                }
            }
        }
        
        // ì´í™íŠ¸ ê°•í™” í•¨ìˆ˜
        function enhanceHitEffect(itemId, event) {
            event.stopPropagation(); // ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€
            
            const levelKey = `hitEffect_level_${itemId}`;
            let currentLevel = parseInt(localStorage.getItem(levelKey) || '0');
            // ê°•í™”ëŠ” ìµœëŒ€ 2ë‹¨ê³„ê¹Œì§€ë§Œ ê°€ëŠ¥í•˜ë¯€ë¡œ ì œí•œ
            if (currentLevel > 2) {
                currentLevel = 2;
                localStorage.setItem(levelKey, '2');
            }
            
            // ì´ë¯¸ ìµœëŒ€ ê°•í™”ë˜ì—ˆìœ¼ë©´ ê°•í™” ë¶ˆê°€
            if (currentLevel >= 2) {
                alert('ì´ë¯¸ ìµœëŒ€ ê°•í™”ëœ ì•„ì´í…œì…ë‹ˆë‹¤!');
                return;
            }
            
            // ê°•í™” ë¹„ìš© í™•ì¸
            const enhanceCost = 20;
            if (gameKillCount < enhanceCost) {
                alert('ì œí™”ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!');
                return;
            }
            
            // ì œí™” ì°¨ê°
            gameKillCount -= enhanceCost;
            updateKillCount(gameKillCount);
            
            // ê°•í™” (ë ˆë²¨ ì¦ê°€)
            const newLevel = currentLevel + 1;
            localStorage.setItem(levelKey, newLevel.toString());
            
            // ê°•í™” ë‹¨ê³„ë„ ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸
            const selectedLevelKey = `selectedHitEffectLevel_${itemId}`;
            localStorage.setItem(selectedLevelKey, newLevel.toString());
            
            // ë³´ê´€ì†Œ í™”ë©´ ìƒˆë¡œê³ ì¹¨
            openStorageModal();
            
            if (newLevel === 1) {
                alert('ê°•í™” ì™„ë£Œ! ì´ì œ í”¼ê²© ì‹œ ëœë¤ ìƒ‰ìƒ ì´í™íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤.');
            } else if (newLevel === 2) {
                alert('ê°•í™”+ ì™„ë£Œ! ì´ì œ í”¼ê²© ì‹œ ëœë¤ ìƒ‰ìƒ ì´í™íŠ¸ì™€ ë„¤ì˜¨ íš¨ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤.');
            }
        }
        
        // ê°•í™” ë‹¨ê³„ ìˆœí™˜ í•¨ìˆ˜
        function cycleHitEffectLevel(itemId, event) {
            event.stopPropagation(); // ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€
            
            const levelKey = `hitEffect_level_${itemId}`;
            let currentLevel = parseInt(localStorage.getItem(levelKey) || '0');
            // ê°•í™”ëŠ” ìµœëŒ€ 2ë‹¨ê³„ê¹Œì§€ë§Œ ê°€ëŠ¥í•˜ë¯€ë¡œ ì œí•œ
            if (currentLevel > 2) {
                currentLevel = 2;
                localStorage.setItem(levelKey, '2');
            }
            const selectedLevelKey = `selectedHitEffectLevel_${itemId}`;
            let currentSelectedLevel = parseInt(localStorage.getItem(selectedLevelKey) || '0');
            
            // ì„ íƒëœ ë‹¨ê³„ê°€ ê°•í™”í•œ ë‹¨ê³„ë¥¼ ì´ˆê³¼í•˜ì§€ ì•Šë„ë¡ ì œí•œ
            if (currentSelectedLevel > currentLevel) {
                currentSelectedLevel = 0;
                localStorage.setItem(selectedLevelKey, '0');
            }
            
            // ë‹¤ìŒ ë‹¨ê³„ ê³„ì‚°: 0ë¶€í„° ì‹œì‘í•´ì„œ ê°•í™”í•œ ë‹¨ê³„ê¹Œì§€ 1ì”© ì¦ê°€, ë„˜ì–´ì„œë©´ 0ìœ¼ë¡œ ìˆœí™˜
            let nextLevel = currentSelectedLevel + 1;
            if (nextLevel > currentLevel) {
                nextLevel = 0; // ìì‹ ì´ ê°•í™”í•œ ë‹¨ê³„ë³´ë‹¤ ë„˜ì–´ì„œë©´ 0ìœ¼ë¡œ ëŒì•„ì˜´
            }
            
            // ì„ íƒí•œ ê°•í™” ë‹¨ê³„ ì €ì¥
            localStorage.setItem(selectedLevelKey, nextLevel.toString());
            
            // ë³´ê´€ì†Œ í™”ë©´ ìƒˆë¡œê³ ì¹¨
            openStorageModal();
        }


        // ëª¨ë“œ ì„ íƒ ì ‘ê¸° í•¨ìˆ˜
        function collapseModeSelection() {
            const modeSelection = document.getElementById('modeSelection');
            if (modeSelection.classList.contains('expanded')) {
                modeSelection.classList.remove('expanded');
                // ë©€í‹° í”Œë ˆì´ ì›ë˜ ìœ„ì¹˜ë¡œ
                document.getElementById('multiPlayText').classList.remove('moved-down');
            }
        }

        function collapseMultiModeSelection() {
            const multiModeSelection = document.getElementById('multiModeSelection');
            if (multiModeSelection.classList.contains('expanded')) {
                multiModeSelection.classList.remove('expanded');
                // ë„ê°ë§Œ ì›ë˜ ìœ„ì¹˜ë¡œ
                document.getElementById('collectionText').classList.remove('moved-down');
            }
        }

        function showModeSelection() {
            const modeSelection = document.getElementById('modeSelection');
            const isExpanded = modeSelection.classList.contains('expanded');
            
            // ë©€í‹°í”Œë ˆì´ ì„ íƒì´ í¼ì³ì ¸ ìˆìœ¼ë©´ ì ‘ê¸°
            collapseMultiModeSelection();
            
            if (isExpanded) {
                // ì ‘ê¸°: ëª¨ë“œ ì„ íƒ í™”ë©´ ìˆ¨ê¸°ê¸°
                collapseModeSelection();
            } else {
                // í¼ì¹˜ê¸°: ëª¨ë“œ ì„ íƒ í™”ë©´ í‘œì‹œ
                modeSelection.classList.add('expanded');
                // ë©€í‹° í”Œë ˆì´ë§Œ ë‚´ë¦¬ê¸°
                document.getElementById('multiPlayText').classList.add('moved-down');
                // ë‚˜ë¨¸ì§€ ë©”ë‰´ëŠ” ì›ë˜ ìœ„ì¹˜ ìœ ì§€
                document.getElementById('collectionText').classList.remove('moved-down');
                document.getElementById('settingsText').classList.remove('moved-down');
                document.getElementById('storageText').classList.remove('moved-down');
            }
        }

        function showMultiModeSelection() {
            const multiModeSelection = document.getElementById('multiModeSelection');
            const isExpanded = multiModeSelection.classList.contains('expanded');
            
            // ì†”ë¡œí”Œë ˆì´ ì„ íƒì´ í¼ì³ì ¸ ìˆìœ¼ë©´ ì ‘ê¸°
            collapseModeSelection();
            
            if (isExpanded) {
                // ì ‘ê¸°: ë©€í‹° ëª¨ë“œ ì„ íƒ í™”ë©´ ìˆ¨ê¸°ê¸°
                collapseMultiModeSelection();
            } else {
                // í¼ì¹˜ê¸°: ë©€í‹° ëª¨ë“œ ì„ íƒ í™”ë©´ í‘œì‹œ
                multiModeSelection.classList.add('expanded');
                // ë„ê°ë§Œ ë‚´ë¦¬ê¸° (ë©€í‹°í”Œë ˆì´ì™€ ë„ê° ì‚¬ì´ ê°„ê²©ë§Œ ë„“íˆê¸°)
                document.getElementById('collectionText').classList.add('moved-down');
            }
        }

        // ë‹‰ë„¤ì„ ë³€ìˆ˜
        let playerNickname = localStorage.getItem('playerNickname') || null;
        let opponentNickname = null;
        
        // ë©€í‹°í”Œë ˆì´ ë³€ìˆ˜
        let multiplayerPeer = null;
        let multiplayerConnection = null;
        let currentRoomCode = null;
        let isHost = false;
        let myTeam = null; // 'blue' ë˜ëŠ” 'red'
        let opponentTeam = null;
        let opponentReady = false; // ìƒëŒ€ë°© ì—°ê²° ë° íŒ€ ì„ íƒ ì™„ë£Œ
        let gameStarted = false; // ê²Œì„ ì‹œì‘ ì—¬ë¶€
        
        // ë‹‰ë„¤ì„ í™•ì¸ (ì²˜ìŒ ì ‘ì† ì‹œì—ë§Œ ë¬¼ì–´ë´„)
        function checkNickname() {
            if (!playerNickname || playerNickname.trim() === '') {
                document.getElementById('nicknameModal').style.display = 'block';
            } else {
                showNicknameDisplay();
            }
        }
        
        // ë‹‰ë„¤ì„ ì €ì¥
        function saveNickname() {
            const input = document.getElementById('nicknameInput');
            const nickname = input.value.trim();
            
            if (nickname.length < 1) {
                input.style.borderColor = '#e94560';
                return;
            }
            
            playerNickname = nickname;
            localStorage.setItem('playerNickname', nickname);
            document.getElementById('nicknameModal').style.display = 'none';
            showNicknameDisplay();
        }
        
        // ì œí™” ë³€ìˆ˜ (ê²Œì„ ë‚´ ì œí™”, localStorageì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°)
        let gameKillCount = parseInt(localStorage.getItem('gameKillCount') || '0');
        
        // ì œí™” ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateKillCount(count) {
            gameKillCount = count;
            // localStorageì— ì €ì¥
            localStorage.setItem('gameKillCount', gameKillCount.toString());
            
            const killCountNumber = document.getElementById('killCountNumber');
            if (killCountNumber) {
                killCountNumber.textContent = gameKillCount;
            }
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì œí™” í‘œì‹œ ì—…ë°ì´íŠ¸ (ì¦‰ì‹œ ì‹¤í–‰)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                updateKillCount(gameKillCount);
                // ë©”ì¸ ë©”ë‰´ê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ë‹‰ë„¤ì„ í‘œì‹œ
                const mainMenu = document.getElementById('mainMenu');
                if (mainMenu && mainMenu.classList.contains('active')) {
                    if (playerNickname) {
                        showNicknameDisplay();
                    }
                }
            });
        } else {
            // ì´ë¯¸ ë¡œë“œëœ ê²½ìš° ì¦‰ì‹œ ì‹¤í–‰
            updateKillCount(gameKillCount);
            // ë©”ì¸ ë©”ë‰´ê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ë‹‰ë„¤ì„ í‘œì‹œ
            const mainMenu = document.getElementById('mainMenu');
            if (mainMenu && mainMenu.classList.contains('active')) {
                if (playerNickname) {
                    showNicknameDisplay();
                }
            }
        }
        
        // ë‹‰ë„¤ì„ í‘œì‹œ
        function showNicknameDisplay() {
            const nicknameDisplay = document.getElementById('nicknameDisplay');
            const playerNicknameSpan = document.getElementById('playerNickname');
            
            if (playerNickname && nicknameDisplay && playerNicknameSpan) {
                playerNicknameSpan.textContent = playerNickname;
                nicknameDisplay.style.display = 'flex';
                
                // ì œí™” í‘œì‹œë„ í•¨ê»˜ ì—…ë°ì´íŠ¸
                updateKillCount(gameKillCount);
            } else if (nicknameDisplay) {
                // ë‹‰ë„¤ì„ì´ ì—†ì–´ë„ ì œí™”ëŠ” í‘œì‹œ
                nicknameDisplay.style.display = 'flex';
                updateKillCount(gameKillCount);
            }
            
            // ì œí™” ì•„ì´ì½˜ í˜¸ë²„ ì´ë²¤íŠ¸ ì„¤ì • (ë™ì ìœ¼ë¡œ í‘œì‹œë  ë•Œë¥¼ ëŒ€ë¹„)
            setupKillCountHover();
        }
        
        // ë‹‰ë„¤ì„ ìˆ¨ê¸°ê¸°
        function hideNicknameDisplay() {
            const nicknameDisplay = document.getElementById('nicknameDisplay');
            if (nicknameDisplay) {
                nicknameDisplay.style.display = 'none';
            }
        }
        
        // ì œí™” ì•„ì´ì½˜ í˜¸ë²„ ì´ë²¤íŠ¸ ì„¤ì •
        function setupKillCountHover() {
            const killCountContainer = document.getElementById('killCountContainer');
            const killCountDisplay = document.getElementById('killCountDisplay');
            const killCountNumber = document.getElementById('killCountNumber');
            const killCountInfo = document.getElementById('killCountInfo');
            const nicknameDisplay = document.getElementById('nicknameDisplay');
            
            if (!killCountInfo) return;
            
            const showInfo = () => {
                if (killCountInfo) killCountInfo.style.display = 'block';
            };
            const hideInfo = () => {
                if (killCountInfo) killCountInfo.style.display = 'none';
            };
            
            if (killCountContainer) {
                killCountContainer.addEventListener('mouseenter', showInfo);
                killCountContainer.addEventListener('mouseleave', hideInfo);
            }
            if (killCountDisplay) {
                killCountDisplay.addEventListener('mouseenter', showInfo);
                killCountDisplay.addEventListener('mouseleave', hideInfo);
            }
            if (killCountNumber) {
                killCountNumber.addEventListener('mouseenter', showInfo);
                killCountNumber.addEventListener('mouseleave', hideInfo);
            }
            if (killCountInfo) {
                killCountInfo.addEventListener('mouseenter', showInfo);
                killCountInfo.addEventListener('mouseleave', hideInfo);
            }
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë‹‰ë„¤ì„ í™•ì¸
        document.addEventListener('DOMContentLoaded', () => {
            setupKillCountHover();
            setTimeout(() => {
                checkNickname();
                // ë©”ì¸ ë©”ë‰´ê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ë‹‰ë„¤ì„ í‘œì‹œ
                const mainMenu = document.getElementById('mainMenu');
                if (mainMenu && mainMenu.classList.contains('active')) {
                    if (playerNickname) {
                        showNicknameDisplay();
                    }
                }
            }, 100);
        });

        function generateRoomCode() {
            return Math.floor(10000 + Math.random() * 90000).toString();
        }

        function createRoom() {
            // ì´ì „ ì—°ê²°ì´ ìˆìœ¼ë©´ ì™„ì „íˆ ì •ë¦¬
            cleanupMultiplayerConnection();
            
            // ìƒíƒœ ì´ˆê¸°í™”
            myTeam = null;
            opponentTeam = null;
            opponentReady = false;
            opponentNickname = null;
            gameStarted = false;
            gameState.isMultiplayer = false;
            currentRoomCode = null;
            
            const modal = document.getElementById('roomModal');
            const title = document.getElementById('roomModalTitle');
            const roomCodeSection = document.getElementById('roomCodeSection');
            const joinInput = document.getElementById('roomJoinInput');
            const teamSelectUI = document.getElementById('teamSelectUI');
            const roomCodeElement = document.getElementById('roomCode');
            const waitingMessage = document.getElementById('waitingMessage');
            
            // ë°© ì½”ë“œ ìƒì„±
            currentRoomCode = generateRoomCode();
            isHost = true; // í˜¸ìŠ¤íŠ¸ë¡œ ì„¤ì • (initPeerConnection ì „ì— ì„¤ì •)
            
            // UI ì„¤ì •
            title.textContent = 'ë°© ìƒì„±';
            roomCodeSection.style.display = 'block';
            joinInput.style.display = 'none';
            teamSelectUI.style.display = 'none';
            roomCodeElement.textContent = currentRoomCode;
            waitingMessage.textContent = 'ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';
            waitingMessage.style.color = '#4a9eff';
            
            modal.style.display = 'block';
            
            // ë©€í‹° ë©”ë‰´ ì ‘ê¸°
            collapseMultiModeSelection();
            
            // UI ì´ˆê¸°í™”
            document.getElementById('startGameBtn').style.display = 'none';
            document.getElementById('guestWaitingMessage').style.display = 'none';
            updateTeamUI();
            
            // PeerJS ì—°ê²° ì´ˆê¸°í™”
            initPeerConnection(currentRoomCode);
        }

        function showJoinRoom() {
            // ì´ì „ ì—°ê²°ì´ ìˆìœ¼ë©´ ì™„ì „íˆ ì •ë¦¬
            cleanupMultiplayerConnection();
            
            // ìƒíƒœ ì´ˆê¸°í™”
            myTeam = null;
            opponentTeam = null;
            opponentReady = false;
            opponentNickname = null;
            gameStarted = false;
            gameState.isMultiplayer = false;
            isHost = false;
            currentRoomCode = null;
            
            const modal = document.getElementById('roomModal');
            const title = document.getElementById('roomModalTitle');
            const roomCodeSection = document.getElementById('roomCodeSection');
            const joinInput = document.getElementById('roomJoinInput');
            const teamSelectUI = document.getElementById('teamSelectUI');
            const joinCodeInput = document.getElementById('joinCodeInput');
            const errorMessage = document.getElementById('joinErrorMessage');
            
            isHost = false;
            
            // UI ì„¤ì •
            title.textContent = 'ë°© ì…ì¥';
            roomCodeSection.style.display = 'none';
            joinInput.style.display = 'block';
            teamSelectUI.style.display = 'none';
            joinCodeInput.value = '';
            errorMessage.style.display = 'none';
            
            modal.style.display = 'block';
            
            // ë©€í‹° ë©”ë‰´ ì ‘ê¸°
            collapseMultiModeSelection();
            
            // UI ì´ˆê¸°í™”
            document.getElementById('startGameBtn').style.display = 'none';
            document.getElementById('guestWaitingMessage').style.display = 'none';
            updateTeamUI();
            
            // ì…ë ¥ í•„ë“œì— í¬ì»¤ìŠ¤
            setTimeout(() => joinCodeInput.focus(), 100);
        }

        function joinRoom() {
            const joinCodeInput = document.getElementById('joinCodeInput');
            const errorMessage = document.getElementById('joinErrorMessage');
            const code = joinCodeInput.value.trim();
            
            if (code.length !== 5 || !/^\d+$/.test(code)) {
                errorMessage.textContent = '5ìë¦¬ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”';
                errorMessage.style.display = 'block';
                return;
            }
            
            // ì´ì „ ì—°ê²°ì´ ìˆìœ¼ë©´ ì™„ì „íˆ ì •ë¦¬
            cleanupMultiplayerConnection();
            
            // ìƒíƒœ ì´ˆê¸°í™”
            myTeam = null;
            opponentTeam = null;
            opponentReady = false;
            opponentNickname = null;
            gameStarted = false;
            gameState.isMultiplayer = false;
            isHost = false;
            
            currentRoomCode = code;
            errorMessage.style.display = 'none';
            
            // PeerJSë¡œ ë°©ì— ì—°ê²° ì‹œë„
            connectToRoom(code);
        }

        function closeRoomModal(keepConnection = false) {
            const modal = document.getElementById('roomModal');
            modal.style.display = 'none';
            
            // UI ì´ˆê¸°í™”
            document.getElementById('roomCodeSection').style.display = 'none';
            document.getElementById('roomJoinInput').style.display = 'none';
            document.getElementById('teamSelectUI').style.display = 'none';
            document.getElementById('startGameBtn').style.display = 'none';
            document.getElementById('guestWaitingMessage').style.display = 'none';
            document.getElementById('blueTeamPlayer').innerHTML = '';
            document.getElementById('redTeamPlayer').innerHTML = '';
            document.getElementById('joinCodeInput').value = '';
            document.getElementById('roomModalTitle').style.display = 'block';
            
            // keepConnectionì´ falseì¼ ë•Œë§Œ ì—°ê²° ì •ë¦¬ (ë‚˜ê°€ê¸° ë²„íŠ¼ ëˆ„ë¥¼ ë•Œ)
            if (!keepConnection) {
                // ìƒëŒ€ë°©ì—ê²Œ ë‚˜ê°€ê¸° ì•Œë¦¼
                if (multiplayerConnection && multiplayerConnection.open) {
                    sendMultiplayerData({ type: 'leave' });
                }
                
                myTeam = null;
                opponentTeam = null;
                opponentReady = false;
                opponentNickname = null;
                if (multiplayerPeer) {
                    multiplayerPeer.destroy();
                    multiplayerPeer = null;
                }
                multiplayerConnection = null;
                currentRoomCode = null;
            }
        }

        // ë©€í‹°í”Œë ˆì´ì–´ ì—°ê²° ì •ë¦¬ í•¨ìˆ˜
        function cleanupMultiplayerConnection() {
            console.log('ë©€í‹°í”Œë ˆì´ì–´ ì—°ê²° ì •ë¦¬ ì‹œì‘...');
            
            // ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ë£¨í”„ ì •ì§€
            stopMultiplayerGameLoop();
            
            // ìƒëŒ€ë°©ì—ê²Œ ì—°ê²° ì¢…ë£Œ ì•Œë¦¼ (ì—°ê²°ì´ ì—´ë ¤ìˆì„ ë•Œë§Œ)
            if (multiplayerConnection) {
                try {
                    if (multiplayerConnection.open) {
                        sendMultiplayerData({ type: 'leave' });
                        multiplayerConnection.close();
                    }
                } catch (e) {
                    console.log('ì—°ê²° ì¢…ë£Œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨:', e);
                }
                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
                try {
                    if (multiplayerConnection.removeAllListeners) {
                        multiplayerConnection.removeAllListeners();
                    }
                } catch (e) {
                    console.log('ì—°ê²° ë¦¬ìŠ¤ë„ˆ ì œê±° ì‹¤íŒ¨:', e);
                }
                multiplayerConnection = null;
            }
            
            if (multiplayerPeer) {
                try {
                    // PeerJSì˜ ëª¨ë“  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
                    if (multiplayerPeer.removeAllListeners) {
                        multiplayerPeer.removeAllListeners();
                    }
                    // Peer ì¸ìŠ¤í„´ìŠ¤ ì™„ì „íˆ ì •ë¦¬
                    if (multiplayerPeer.destroy) {
                        multiplayerPeer.destroy();
                    }
                    // Peer ì¸ìŠ¤í„´ìŠ¤ê°€ ì™„ì „íˆ ì •ë¦¬ë  ë•Œê¹Œì§€ ëŒ€ê¸°
                    // destroy()ëŠ” ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‘ë™í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì•½ê°„ì˜ ì§€ì—° í›„ null ì„¤ì •
                } catch (e) {
                    console.log('Peer ì¢…ë£Œ ì‹¤íŒ¨:', e);
                }
                multiplayerPeer = null;
            }
            
            // ìƒíƒœ ì´ˆê¸°í™”
            gameState.isMultiplayer = false;
            gameState.obstacles = []; // ì¥ì• ë¬¼ ì´ˆê¸°í™”
            gameState.isNextRoundProcessing = false; // ë¼ìš´ë“œ ì²˜ë¦¬ í”Œë˜ê·¸ ì´ˆê¸°í™”
            myTeam = null;
            opponentTeam = null;
            opponentReady = false;
            opponentNickname = null;
            currentRoomCode = null;
            isHost = false;
            gameStarted = false;
            
            console.log('ë©€í‹°í”Œë ˆì´ì–´ ì—°ê²° ì •ë¦¬ ì™„ë£Œ');
        }
        
        function initPeerConnection(roomCode) {
            const waitingMessage = document.getElementById('waitingMessage');
            
            // ì´ì „ ì—°ê²°ì´ ìˆìœ¼ë©´ ì •ë¦¬ (isHostëŠ” ë‚˜ì¤‘ì— ì„¤ì •ë˜ë¯€ë¡œ ì €ì¥)
            const wasHost = isHost;
            cleanupMultiplayerConnection();
            
            // PeerJSê°€ ì™„ì „íˆ ì •ë¦¬ë  ë•Œê¹Œì§€ ì•½ê°„ì˜ ì§€ì—°
            setTimeout(() => {
                // í˜¸ìŠ¤íŠ¸ì¸ ê²½ìš° isHost ë³µì›
                if (wasHost) {
                    isHost = true;
                }
                
                // PeerJS ì¸ìŠ¤í„´ìŠ¤ ìƒì„± (ë°© ì½”ë“œë¥¼ IDë¡œ ì‚¬ìš©)
                const peerId = 'revolver-duel-' + roomCode;
                
                try {
                    multiplayerPeer = new Peer(peerId);
                
                multiplayerPeer.on('open', (id) => {
                    console.log('PeerJS ì—°ê²°ë¨, ID:', id);
                    waitingMessage.textContent = 'ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';
                });
                
                multiplayerPeer.on('connection', (conn) => {
                    console.log('ìƒëŒ€ë°© ì—°ê²°ë¨!');
                    multiplayerConnection = conn;
                    
                    conn.on('open', () => {
                        // ë°© ì½”ë“œ ì„¹ì…˜ ìˆ¨ê¸°ê³  íŒ€ ì„ íƒ UI í‘œì‹œ
                        document.getElementById('roomCodeSection').style.display = 'none';
                        document.getElementById('teamSelectUI').style.display = 'block';
                        document.getElementById('roomModalTitle').style.display = 'none';
                        
                        // UI ì´ˆê¸°í™”
                        updateTeamUI();
                        
                        // ë‚´ ë‹‰ë„¤ì„ ì „ì†¡
                        sendMultiplayerData({
                            type: 'nickname',
                            nickname: playerNickname
                        });
                    });
                    
                    conn.on('data', (data) => {
                        handleMultiplayerData(data);
                    });
                    
                    conn.on('close', () => {
                        console.log('ìƒëŒ€ë°© ì—°ê²° ëŠê¹€');
                        // ê²Œì„ ì¤‘ì¼ ë•Œë§Œ disconnect ì²˜ë¦¬
                        if (gameState.isMultiplayer && !gameState.isMenu) {
                            handleDisconnect();
                        }
                    });
                });
                
                    multiplayerPeer.on('error', (err) => {
                        console.error('PeerJS ì—ëŸ¬:', err);
                        // ê°™ì€ IDë¥¼ ì‚¬ìš©í•˜ë ¤ê³  í•  ë•Œ ë°œìƒí•˜ëŠ” ì—ëŸ¬ ì²˜ë¦¬
                        if (err.type === 'peer-unavailable' || err.type === 'unavailable-id') {
                            // ì´ì „ ì¸ìŠ¤í„´ìŠ¤ê°€ ì•„ì§ ì •ë¦¬ ì¤‘ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì ì‹œ í›„ ì¬ì‹œë„
                            setTimeout(() => {
                                cleanupMultiplayerConnection();
                                // ì¬ì‹œë„
                                initPeerConnection(roomCode);
                            }, 1000);
                        } else {
                            waitingMessage.textContent = 'ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤';
                            waitingMessage.style.color = '#e94560';
                        }
                    });
                } catch (e) {
                    console.error('PeerJS ì´ˆê¸°í™” ì‹¤íŒ¨:', e);
                    waitingMessage.textContent = 'PeerJS ë¡œë“œ ì‹¤íŒ¨. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.';
                    waitingMessage.style.color = '#e94560';
                }
            }, 200); // 200ms ì§€ì—°ìœ¼ë¡œ PeerJS ì •ë¦¬ ì‹œê°„ í™•ë³´
        }

        function connectToRoom(roomCode) {
            const errorMessage = document.getElementById('joinErrorMessage');
            const joinInput = document.getElementById('roomJoinInput');
            
            // ì´ì „ ì—°ê²°ì´ ìˆìœ¼ë©´ ì •ë¦¬
            cleanupMultiplayerConnection();
            
            // PeerJSê°€ ì™„ì „íˆ ì •ë¦¬ë  ë•Œê¹Œì§€ ì•½ê°„ì˜ ì§€ì—°
            setTimeout(() => {
                // í˜¸ìŠ¤íŠ¸ì˜ Peer ID (ë°© ì½”ë“œ ê¸°ë°˜)
                const peerId = 'revolver-duel-' + roomCode;
                
                try {
                    // ìƒˆ Peer ì¸ìŠ¤í„´ìŠ¤ ìƒì„± (ê³ ìœ  IDë¡œ)
                    const myId = 'revolver-duel-guest-' + Math.random().toString(36).substr(2, 9);
                    multiplayerPeer = new Peer(myId);
                
                multiplayerPeer.on('open', () => {
                    console.log('PeerJS ì—°ê²°ë¨, ë°©ì— ì ‘ì† ì‹œë„...');
                    
                    // í˜¸ìŠ¤íŠ¸ì— ì—°ê²°
                    multiplayerConnection = multiplayerPeer.connect(peerId);
                    
                    multiplayerConnection.on('open', () => {
                        console.log('ë°©ì— ì—°ê²°ë¨!');
                        
                        // ì½”ë“œ ì…ë ¥ UI ìˆ¨ê¸°ê³  íŒ€ ì„ íƒ UI í‘œì‹œ
                        document.getElementById('roomJoinInput').style.display = 'none';
                        document.getElementById('teamSelectUI').style.display = 'block';
                        document.getElementById('roomModalTitle').style.display = 'none';
                        
                        // UI ì´ˆê¸°í™”
                        updateTeamUI();
                        
                        // ë‚´ ë‹‰ë„¤ì„ ì „ì†¡
                        sendMultiplayerData({
                            type: 'nickname',
                            nickname: playerNickname
                        });
                    });
                    
                    multiplayerConnection.on('data', (data) => {
                        handleMultiplayerData(data);
                    });
                    
                    multiplayerConnection.on('close', () => {
                        console.log('ì—°ê²° ëŠê¹€');
                        // ê²Œì„ ì¤‘ì¼ ë•Œë§Œ disconnect ì²˜ë¦¬
                        if (gameState.isMultiplayer && !gameState.isMenu) {
                            handleDisconnect();
                        }
                    });
                    
                    multiplayerConnection.on('error', (err) => {
                        console.error('ì—°ê²° ì—ëŸ¬:', err);
                        errorMessage.textContent = 'ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
                        errorMessage.style.display = 'block';
                    });
                    
                    // ì—°ê²° íƒ€ì„ì•„ì›ƒ (5ì´ˆ)
                    setTimeout(() => {
                        if (!multiplayerConnection || !multiplayerConnection.open) {
                            errorMessage.textContent = 'ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
                            errorMessage.style.display = 'block';
                            if (multiplayerPeer) {
                                multiplayerPeer.destroy();
                                multiplayerPeer = null;
                            }
                        }
                    }, 5000);
                });
                
                multiplayerPeer.on('error', (err) => {
                    console.error('PeerJS ì—ëŸ¬:', err);
                    // ì—°ê²° ì˜¤ë¥˜ ì²˜ë¦¬
                    if (err.type === 'peer-unavailable' || err.type === 'unavailable-id') {
                        // ì´ì „ ì¸ìŠ¤í„´ìŠ¤ê°€ ì•„ì§ ì •ë¦¬ ì¤‘ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì ì‹œ í›„ ì¬ì‹œë„
                        setTimeout(() => {
                            cleanupMultiplayerConnection();
                            // ì¬ì‹œë„
                            connectToRoom(roomCode);
                        }, 1000);
                    } else {
                        errorMessage.textContent = 'ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤';
                        errorMessage.style.display = 'block';
                    }
                });
                } catch (e) {
                    console.error('PeerJS ì´ˆê¸°í™” ì‹¤íŒ¨:', e);
                    errorMessage.textContent = 'PeerJS ë¡œë“œ ì‹¤íŒ¨';
                    errorMessage.style.display = 'block';
                }
            }, 200); // 200ms ì§€ì—°ìœ¼ë¡œ PeerJS ì •ë¦¬ ì‹œê°„ í™•ë³´
        }

        function handleMultiplayerData(data) {
            if (!data || !data.type) return;
            
            switch (data.type) {
                case 'gameState':
                    // ê²Œì„ì´ ì‹œì‘ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ë¬´ì‹œ
                    if (!gameStarted) return;
                    
                    // ìƒëŒ€ë°©ì˜ í”Œë ˆì´ì–´ ìƒíƒœë¥¼ ìš°ë¦¬ì˜ enemyì— ì ìš©
                    if (data.player) {
                        enemy.x = data.player.x;
                        enemy.y = data.player.y;
                        enemy.angle = data.player.angle;
                        enemy.health = data.player.health;
                        enemy.displayHealth = data.player.displayHealth;
                        enemy.ammo = data.player.ammo;
                        enemy.maxAmmo = data.player.maxAmmo;
                        enemy.isReloading = data.player.isReloading;
                        enemy.reloadStartTime = data.player.reloadStartTime;
                        enemy.reloadTime = data.player.reloadTime;
                        enemy.isDodging = data.player.isDodging;
                        enemy.isInvincible = data.player.isInvincible;
                        enemy.isReviving = data.player.isReviving;
                        enemy.shieldReady = data.player.shieldReady;
                        enemy.reflectActive = data.player.reflectActive;
                        enemy.isFortified = data.player.isFortified;
                    }
                    
                    // ê²Œì„ ìƒíƒœ ë™ê¸°í™” (isPaused, countdown)
                    if (data.gameState) {
                        // í˜¸ìŠ¤íŠ¸ì˜ isPaused ìƒíƒœë¥¼ ë”°ë¦„
                        if (isHost === false) {
                            gameState.isPaused = data.gameState.isPaused;
                            gameState.countdown = data.gameState.countdown;
                        }
                    }
                    break;
                    
                case 'shoot':
                    // ìƒëŒ€ë°©ì´ ì´ì„ ìˆì„ ë•Œ
                    if (data.bullets) {
                        data.bullets.forEach(bulletData => {
                            const bullet = new Bullet(
                                bulletData.x,
                                bulletData.y,
                                bulletData.angle,
                                enemy,
                                false
                            );
                            bullet.damage = bulletData.damage || enemy.damage;
                            bullet.hasPoison = bulletData.hasPoison || false;
                            bullet.hasBouncy = bulletData.hasBouncy || false;
                            bullet.maxBounces = bulletData.maxBounces || 0;
                            enemy.bullets.push(bullet);
                        });
                    }
                    break;
                    
                case 'teamSelect':
                    // ìƒëŒ€ë°© íŒ€ ì„ íƒ
                    opponentTeam = data.team;
                    console.log('ìƒëŒ€ë°© íŒ€ ì„ íƒ ìˆ˜ì‹ :', opponentTeam, 'ë‚´ íŒ€:', myTeam, 'í˜¸ìŠ¤íŠ¸:', isHost);
                    updateTeamUI();
                    // ì–‘ìª½ ëª¨ë‘ ì„ íƒë˜ì—ˆëŠ”ì§€ ë‹¤ì‹œ í•œë²ˆ í™•ì¸í•˜ì—¬ ë²„íŠ¼ í‘œì‹œ
                    if (isHost && myTeam && opponentTeam) {
                        const startGameBtn = document.getElementById('startGameBtn');
                        if (startGameBtn) {
                            startGameBtn.style.display = 'block';
                            console.log('âœ… ìƒëŒ€ë°© íŒ€ ì„ íƒ ìˆ˜ì‹  í›„ ì‹œì‘ ë²„íŠ¼ í‘œì‹œë¨!');
                        }
                    }
                    break;
                    
                case 'nickname':
                    // ìƒëŒ€ë°© ë‹‰ë„¤ì„ ìˆ˜ì‹ 
                    opponentNickname = data.nickname;
                    opponentReady = true;
                    updateTeamUI();
                    break;
                
                case 'leave':
                    // ìƒëŒ€ë°©ì´ ë°©ì„ ë‚˜ê° (ë©”ì‹œì§€ ë³´ë‚´ì§€ ì•Šê³  ì •ë¦¬)
                    console.log('ìƒëŒ€ë°©ì´ ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤');
                    // ê²Œì„ ì¤‘ì´ ì•„ë‹ˆë©´ ì•Œë¦¼ í‘œì‹œ
                    if (!gameStarted) {
                        alert('ìƒëŒ€ë°©ì´ ë‚˜ê°”ìŠµë‹ˆë‹¤');
                    }
                    // ì—°ê²° ì™„ì „íˆ ì •ë¦¬
                    cleanupMultiplayerConnection();
                    closeRoomModal(true); // keepConnection=trueë¡œ í•´ì„œ ë‹¤ì‹œ leave ë©”ì‹œì§€ ì•ˆ ë³´ëƒ„
                    currentRoomCode = null;
                    // UI ì´ˆê¸°í™”
                    document.getElementById('roomCodeSection').style.display = 'none';
                    document.getElementById('roomJoinInput').style.display = 'none';
                    document.getElementById('teamSelectUI').style.display = 'none';
                    document.getElementById('startGameBtn').style.display = 'none';
                    document.getElementById('guestWaitingMessage').style.display = 'none';
                    break;
                    
                case 'gameEnd':
                    // ìƒëŒ€ë°©ì´ ê²Œì„ ì¢…ë£Œ ì•Œë¦¼ (ë™ê¸°í™”)
                    console.log('ìƒëŒ€ë°© ê²Œì„ ì¢…ë£Œ:', data.winner);
                    // ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ë£¨í”„ ì •ì§€
                    stopMultiplayerGameLoop();
                    break;
                    
                case 'startGame':
                    // í˜¸ìŠ¤íŠ¸ê°€ ê²Œì„ ì‹œì‘
                    if (!isHost) {
                        closeRoomModal(true);
                        startMultiplayerGame();
                    }
                    break;
                    
                case 'roundEnd':
                    // ë¼ìš´ë“œ ì¢…ë£Œ ë™ê¸°í™” - ê²ŒìŠ¤íŠ¸ë§Œ ì²˜ë¦¬
                    if (!isHost && data.winner) {
                        if (data.winner === 'host') {
                            // í˜¸ìŠ¤íŠ¸ê°€ ì´ê¹€ = ë‚˜(ê²ŒìŠ¤íŠ¸)ê°€ ì§
                            handleRoundEndFromHost('enemy');
                        } else {
                            // ê²ŒìŠ¤íŠ¸ê°€ ì´ê¹€ = ë‚˜(ê²ŒìŠ¤íŠ¸)ê°€ ì´ê¹€
                            handleRoundEndFromHost('player');
                        }
                    }
                    break;
                    
                case 'augmentSelected':
                    // ìƒëŒ€ë°© ì¦ê°• ì„ íƒ ì™„ë£Œ
                    if (data.augment) {
                        const aug = augmentations.find(a => a.id === data.augment.id);
                        if (aug) {
                            aug.effect(enemy);
                            enemy.augmentations.push(aug);
                        }
                    }
                    // ìƒëŒ€ ì„ íƒ ì™„ë£Œ - ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                    gameState.showOpponentSelecting = false;
                    setTimeout(() => {
                        nextRound();
                    }, 500);
                    break;
                    
                case 'nextRound':
                    // ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘
                    if (!isHost) {
                        nextRound();
                    }
                    break;
                    
                case 'removeObstacle':
                    // í˜¸ìŠ¤íŠ¸ê°€ ì¥ì• ë¬¼ì„ ì œê±°í–ˆì„ ë•Œ ê²ŒìŠ¤íŠ¸ë„ ë™ê¸°í™”
                    if (!isHost && typeof data.obstacleIndex === 'number') {
                        if (gameState.obstacles && data.obstacleIndex < gameState.obstacles.length) {
                            gameState.obstacles.splice(data.obstacleIndex, 1);
                            gameState.lastObstacleRemoveTime = Date.now();
                        }
                    }
                    break;
                    
            }
        }
        
        // ê²ŒìŠ¤íŠ¸ìš©: í˜¸ìŠ¤íŠ¸ë¡œë¶€í„° ë¼ìš´ë“œ ì¢…ë£Œ ë°›ìŒ
        function handleRoundEndFromHost(winner) {
            // ëª¨ë“  ì´í™íŠ¸ ì§€ìš°ê¸°
            if (player.hitEffectParticles) {
                player.hitEffectParticles = [];
            }
            if (enemy.hitEffectParticles) {
                enemy.hitEffectParticles = [];
            }
            gameState.isPaused = true;
            gameState.roundWins.push(winner);
            
            if (winner === 'player') {
                gameState.playerWins++;
            } else {
                gameState.enemyWins++;
            }
            
            // ìŠ¹ë¦¬ ì²´í¬
            if (gameState.playerWins >= gameState.winsNeeded || gameState.enemyWins >= gameState.winsNeeded) {
                endGame(winner);
                return;
            }
            
            // ì¦ê°• ì„ íƒ
            if (winner === 'player') {
                // ë‚´ê°€ ìŠ¹ë¦¬: ìƒëŒ€ê°€ ì¦ê°• ì„ íƒ ì¤‘ - 15ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ë§Œ í‘œì‹œ
                gameState.showOpponentSelecting = true;
                gameState.augmentCountdown = 15;
                startOpponentWaitCountdown();
            } else {
                // ë‚´ê°€ íŒ¨ë°°: ì¦ê°• ì„ íƒ
                showAugmentModal(player);
            }
        }
        
        // ìƒëŒ€ë°© ì¦ê°• ì„ íƒ ëŒ€ê¸° ì¹´ìš´íŠ¸ë‹¤ìš´
        function startOpponentWaitCountdown() {
            const countdownInterval = setInterval(() => {
                gameState.augmentCountdown--;
                if (gameState.augmentCountdown <= 0 || !gameState.showOpponentSelecting) {
                    clearInterval(countdownInterval);
                    gameState.augmentCountdown = 0;
                }
            }, 1000);
        }
        
        // íŒ€ ì„ íƒ
        function selectTeam(team) {
            // ìƒëŒ€ë°©ì´ ì´ë¯¸ ê·¸ íŒ€ì„ ì„ íƒí–ˆìœ¼ë©´ ì„ íƒ ë¶ˆê°€
            if (opponentTeam === team) {
                return;
            }
            
            myTeam = team;
            
            // ìƒëŒ€ë°©ì—ê²Œ íŒ€ ì„ íƒ ì•Œë¦¼
            sendMultiplayerData({
                type: 'teamSelect',
                team: team
            });
            
            updateTeamUI();
        }
        
        // íŒ€ UI ì—…ë°ì´íŠ¸
        function updateTeamUI() {
            const blueTeamPlayer = document.getElementById('blueTeamPlayer');
            const redTeamPlayer = document.getElementById('redTeamPlayer');
            const blueTeamBox = document.getElementById('blueTeamBox');
            const redTeamBox = document.getElementById('redTeamBox');
            const teamSelectStatus = document.getElementById('teamSelectStatus');
            
            // ì™•ê´€ ì•„ì´ì½˜ (í˜¸ìŠ¤íŠ¸ í‘œì‹œ) - ë…¸ë€ìƒ‰
            
            // íŒŒë€íŒ€ í‘œì‹œ
            if (myTeam === 'blue') {
                const name = playerNickname || 'ë‚˜';
                blueTeamPlayer.innerHTML = name;
                blueTeamBox.style.boxShadow = '0 0 20px rgba(74, 158, 255, 0.5)';
            } else if (opponentTeam === 'blue') {
                const name = opponentNickname || 'ìƒëŒ€ë°©';
                blueTeamPlayer.innerHTML = name;
                blueTeamBox.style.boxShadow = 'none';
            } else {
                blueTeamPlayer.innerHTML = '';
                blueTeamBox.style.boxShadow = 'none';
            }
            
            // ë¹¨ê°„íŒ€ í‘œì‹œ
            if (myTeam === 'red') {
                const name = playerNickname || 'ë‚˜';
                redTeamPlayer.innerHTML = name;
                redTeamBox.style.boxShadow = '0 0 20px rgba(233, 69, 96, 0.5)';
            } else if (opponentTeam === 'red') {
                const name = opponentNickname || 'ìƒëŒ€ë°©';
                redTeamPlayer.innerHTML = name;
                redTeamBox.style.boxShadow = 'none';
            } else {
                redTeamPlayer.innerHTML = '';
                redTeamBox.style.boxShadow = 'none';
            }
            
            // ìƒíƒœ ë©”ì‹œì§€
            if (myTeam && opponentTeam) {
                teamSelectStatus.textContent = 'ì–‘ìª½ ëª¨ë‘ íŒ€ ì„ íƒ ì™„ë£Œ!';
                teamSelectStatus.style.color = '#00ff00';
            } else if (myTeam) {
                teamSelectStatus.textContent = 'ìƒëŒ€ë°©ì´ íŒ€ì„ ì„ íƒí•˜ëŠ” ì¤‘...';
                teamSelectStatus.style.color = '#ffc107';
            } else {
                teamSelectStatus.textContent = 'íŒ€ì„ ì„ íƒí•´ì£¼ì„¸ìš”';
                teamSelectStatus.style.color = '#aaa';
            }
            
            // í˜¸ìŠ¤íŠ¸: ì–‘ìª½ ëª¨ë‘ íŒ€ ì„ íƒ ì™„ë£Œí•˜ë©´ ì‹œì‘ ë²„íŠ¼ í‘œì‹œ
            const startGameBtn = document.getElementById('startGameBtn');
            if (startGameBtn) {
                // í˜¸ìŠ¤íŠ¸ì´ê³  ì–‘ìª½ ëª¨ë‘ íŒ€ì„ ì„ íƒí–ˆëŠ”ì§€ í™•ì¸
                const bothTeamsSelected = isHost && myTeam && opponentTeam;
                console.log('updateTeamUI í˜¸ì¶œë¨:', { isHost, myTeam, opponentTeam, bothTeamsSelected });
                
                if (bothTeamsSelected) {
                    // ì–‘ìª½ ëª¨ë‘ íŒ€ ì„ íƒ ì™„ë£Œ - ì‹œì‘ ë²„íŠ¼ í‘œì‹œ
                    startGameBtn.style.display = 'block';
                    console.log('âœ… ì‹œì‘ ë²„íŠ¼ í‘œì‹œë¨!');
                } else {
                    // ì¡°ê±´ì´ ë§ì§€ ì•Šìœ¼ë©´ ì‹œì‘ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
                    startGameBtn.style.display = 'none';
                    if (isHost) {
                        console.log('âŒ ì‹œì‘ ë²„íŠ¼ ìˆ¨ê¹€ - ì¡°ê±´ ë¶ˆì¼ì¹˜:', {
                            'isHost': isHost,
                            'myTeam': myTeam,
                            'opponentTeam': opponentTeam,
                            'myTeam truthy': !!myTeam,
                            'opponentTeam truthy': !!opponentTeam
                        });
                    }
                }
            } else {
                console.error('startGameBtn ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
            }
            
            // ê²ŒìŠ¤íŠ¸: ëŒ€ê¸° ë©”ì‹œì§€ í‘œì‹œ
            if (!isHost && myTeam) {
                document.getElementById('guestWaitingMessage').style.display = 'block';
            } else {
                document.getElementById('guestWaitingMessage').style.display = 'none';
            }
        }
        
        // ê²Œì„ ì‹œì‘ ì‹ í˜¸ ì „ì†¡ (í˜¸ìŠ¤íŠ¸ë§Œ)
        function sendStartGame() {
            if (!isHost || !myTeam) return;
            
            // ìƒëŒ€ë°©ì—ê²Œ ê²Œì„ ì‹œì‘ ì•Œë¦¼
            sendMultiplayerData({ type: 'startGame' });
            
            // ìì‹ ë„ ê²Œì„ ì‹œì‘
            closeRoomModal(true);
            startMultiplayerGame();
        }
        
        // ì—°ê²° ëŠê¹€ í™•ì¸
        function confirmDisconnect() {
            document.getElementById('disconnectModal').style.display = 'none';
            // ì—°ê²° ì™„ì „íˆ ì •ë¦¬
            cleanupMultiplayerConnection();
            restartGame();
        }

        function handleDisconnect() {
            // ì—°ê²° ëŠê¹€ ì²˜ë¦¬
            // ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ë£¨í”„ ì •ì§€
            stopMultiplayerGameLoop();
            
            // ì—°ê²° ì™„ì „íˆ ì •ë¦¬
            cleanupMultiplayerConnection();
            
            gameState.isMultiplayer = false;
            gameStarted = false;
            
            // ê²Œì„ ì¤‘ì´ì—ˆìœ¼ë©´ ëª¨ë‹¬ í‘œì‹œ
            if (!gameState.isMenu) {
                document.getElementById('disconnectModal').style.display = 'block';
            }
        }

        // ë©€í‹°í”Œë ˆì´ì–´ ë°ì´í„° ì „ì†¡
        function sendMultiplayerData(data) {
            if (multiplayerConnection && multiplayerConnection.open) {
                multiplayerConnection.send(data);
            }
        }

        // í”Œë ˆì´ì–´ ìƒíƒœ ì „ì†¡ (ê²Œì„ ë£¨í”„ì—ì„œ í˜¸ì¶œ)
        function sendPlayerState() {
            if (!gameState.isMultiplayer || !multiplayerConnection) return;
            
            const now = Date.now();
            // 30msë§ˆë‹¤ ì „ì†¡ (ì•½ 33fps)
            if (now - gameState.lastSyncTime < 30) return;
            gameState.lastSyncTime = now;
            
            sendMultiplayerData({
                type: 'gameState',
                player: {
                    x: player.x,
                    y: player.y,
                    angle: player.angle,
                    health: player.health,
                    displayHealth: player.displayHealth,
                    ammo: player.ammo,
                    maxAmmo: player.maxAmmo,
                    isReloading: player.isReloading,
                    reloadStartTime: player.reloadStartTime,
                    reloadTime: player.reloadTime,
                    isDodging: player.isDodging,
                    isInvincible: player.isInvincible,
                    isReviving: player.isReviving,
                    shieldReady: player.shieldReady,
                    reflectActive: player.reflectActive,
                    isFortified: player.isFortified
                },
                gameState: {
                    isPaused: gameState.isPaused,
                    countdown: gameState.countdown
                }
            });
        }

        // ì´ì•Œ ë°œì‚¬ ì „ì†¡
        function sendShootData(bullets) {
            if (!gameState.isMultiplayer) return;
            
            const bulletDataArray = bullets.map(b => ({
                x: b.x,
                y: b.y,
                angle: b.angle,
                damage: b.damage,
                hasPoison: b.hasPoison,
                hasBouncy: b.hasBouncy,
                maxBounces: b.maxBounces
            }));
            
            sendMultiplayerData({
                type: 'shoot',
                bullets: bulletDataArray
            });
        }

        // ë©€í‹°í”Œë ˆì´ì–´ ì¥ì• ë¬¼ ìƒì„± í•¨ìˆ˜
        function generateMultiplayerObstacles() {
            gameState.obstacles = [];
            const minSize = 50; // ìµœì†Œ í¬ê¸°
            const maxSize = 200; // ìµœëŒ€ í¬ê¸° (200px ì´ë‚´)
            const minDistance = 100; // ì¥ì• ë¬¼ ê°„ ìµœì†Œ ê±°ë¦¬
            const margin = 50; // ë§µ ê²½ê³„ë¡œë¶€í„°ì˜ ì—¬ë°±
            
            for (let i = 0; i < 4; i++) {
                let attempts = 0;
                let valid = false;
                let obstacle = null;
                
                while (!valid && attempts < 100) {
                    attempts++;
                    const width = Math.random() * (maxSize - minSize) + minSize;
                    const height = Math.random() * (maxSize - minSize) + minSize;
                    const angle = Math.random() * Math.PI * 2; // ëœë¤ íšŒì „
                    
                    // íšŒì „ëœ ì§ì‚¬ê°í˜•ì˜ ì‹¤ì œ í¬ê¸° ê³„ì‚°
                    const cos = Math.abs(Math.cos(angle));
                    const sin = Math.abs(Math.sin(angle));
                    const actualWidth = width * cos + height * sin;
                    const actualHeight = width * sin + height * cos;
                    
                    // ëœë¤ ìœ„ì¹˜ (ë§µ ê²½ê³„ ë‚´, ì—¬ë°± ê³ ë ¤)
                    const x = Math.random() * (gameState.mapBounds.maxX - gameState.mapBounds.minX - actualWidth - margin * 2) + 
                              gameState.mapBounds.minX + actualWidth / 2 + margin;
                    const y = Math.random() * (gameState.mapBounds.maxY - gameState.mapBounds.minY - actualHeight - margin * 2) + 
                              gameState.mapBounds.minY + actualHeight / 2 + margin;
                    
                    // ë‹¤ë¥¸ ì¥ì• ë¬¼ê³¼ì˜ ê±°ë¦¬ í™•ì¸
                    let tooClose = false;
                    for (let j = 0; j < gameState.obstacles.length; j++) {
                        const other = gameState.obstacles[j];
                        const dx = x - other.x;
                        const dy = y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minRequiredDistance = Math.max(actualWidth, actualHeight) / 2 + 
                                                   Math.max(other.width, other.height) / 2 + minDistance;
                        
                        if (distance < minRequiredDistance) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    // í”Œë ˆì´ì–´ì™€ ì ì˜ ì´ˆê¸° ìœ„ì¹˜ì™€ì˜ ê±°ë¦¬ í™•ì¸
                    const playerDist = Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2);
                    const enemyDist = Math.sqrt((x - enemy.x) ** 2 + (y - enemy.y) ** 2);
                    const minPlayerDistance = Math.max(actualWidth, actualHeight) / 2 + player.radius + 50;
                    
                    if (!tooClose && playerDist > minPlayerDistance && enemyDist > minPlayerDistance) {
                        obstacle = { x, y, width, height, angle };
                        valid = true;
                    }
                }
                
                if (obstacle) {
                    gameState.obstacles.push(obstacle);
                }
            }
            
            console.log('ë©€í‹°í”Œë ˆì´ì–´ ì¥ì• ë¬¼ ìƒì„±:', gameState.obstacles.length, 'ê°œ');
        }

        function startMultiplayerGame() {
            console.log('ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ì‹œì‘! í˜¸ìŠ¤íŠ¸:', isHost, 'íŒ€:', myTeam);
            
            gameStarted = true;
            
            // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
            gameState.isMultiplayer = true;
            gameState.isNextRoundProcessing = false; // í”Œë˜ê·¸ ì´ˆê¸°í™”
            
            // ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ë£¨í”„ ì‹œì‘ (ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ ì‹¤í–‰)
            startMultiplayerGameLoop();
            gameState.isMenu = false;
            gameState.gameMode = 'classic'; // ë©€í‹°í”Œë ˆì´ëŠ” í´ë˜ì‹ ëª¨ë“œ
            gameState.round = 0; // nextRoundì—ì„œ ++ í•˜ë¯€ë¡œ 0ìœ¼ë¡œ ì‹œì‘
            gameState.playerWins = 0;
            gameState.enemyWins = 0;
            gameState.roundWins = [];
            gameState.gameTime = 180;
            gameState.isGameOver = false;
            gameState.countdown = 3;
            gameState.isPaused = true;
            
            // ë©”ì¸ ë©”ë‰´ ìˆ¨ê¸°ê¸°
            showScreen('game'); // ê²Œì„ í™”ë©´ìœ¼ë¡œ ì „í™˜ (ì‹¤ì œë¡œëŠ” ëª¨ë“  í™”ë©´ ìˆ¨ê¹€)
            
            // ë‹‰ë„¤ì„ ìˆ¨ê¸°ê¸°
            hideNicknameDisplay();
            
            // ë§µ ê²½ê³„ ì„¤ì •
            gameState.mapBounds = {
                minX: 0,
                minY: 0,
                maxX: canvas.width,
                maxY: canvas.height
            };
            
            // ë©€í‹°í”Œë ˆì´ì–´ ì¥ì• ë¬¼ ìƒì„±
            generateMultiplayerObstacles();
            
            // íŒ€ì— ë”°ë¥¸ ìƒ‰ìƒ ë° ìœ„ì¹˜ ì„¤ì •
            const isBlueTeam = myTeam === 'blue';
            player.color = isBlueTeam ? '#4a9eff' : '#e94560';
            enemy.color = isBlueTeam ? '#e94560' : '#4a9eff';
            
            // íŒŒë€íŒ€ì€ ì™¼ìª½, ë¹¨ê°„íŒ€ì€ ì˜¤ë¥¸ìª½
            const leftX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            const rightX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            const centerY = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            
            player.x = isBlueTeam ? leftX : rightX;
            player.y = centerY;
            enemy.x = isBlueTeam ? rightX : leftX;
            enemy.y = centerY;
            
            // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.damage = 1;
            player.speed = 3;
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.reloadTime = 3000;
            player.baseReloadTime = 3000;
            player.shootCooldown = 1000;
            player.isReloading = false;
            player.isDodging = false;
            player.isReviving = false;
            player.isInvincible = false;
            player.hasRevived = 0;
            resetPlayerAugments(player);
            
            // ì (ìƒëŒ€ë°©) ì´ˆê¸°í™”
            enemy.health = 5;
            enemy.displayHealth = 5;
            enemy.maxHealth = 5;
            enemy.ammo = 6;
            enemy.maxAmmo = 6;
            enemy.bullets = [];
            enemy.augmentations = [];
            enemy.damage = 1;
            enemy.speed = 3;
            enemy.bulletSpeedMultiplier = 1;
            enemy.bulletSizeMultiplier = 1;
            enemy.reloadTime = 3000;
            enemy.baseReloadTime = 3000;
            enemy.shootCooldown = 1000;
            enemy.isReloading = false;
            enemy.isDodging = false;
            enemy.isReviving = false;
            enemy.isInvincible = false;
            enemy.hasRevived = 0;
            resetPlayerAugments(enemy);
            
            // ì²« ë¼ìš´ë“œ ì‹œì‘
            nextRound();
            
            // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.isPaused = false;
                }
            }, 1000);
        }
        
        // í”Œë ˆì´ì–´ ì¦ê°• ìƒíƒœ ì´ˆê¸°í™” í—¬í¼ í•¨ìˆ˜
        function resetPlayerAugments(char) {
            char.hasCritical = false;
            char.hasDoubleShot = false;
            char.hasDodge = false;
            char.hasRevive = false;
            char.hasDeepWound = false;
            char.hasOneShotOneKill = false;
            char.hasPoisonBullet = false;
            char.hasReloadHeal = false;
            char.hasSurvivalInstinct = false;
            char.hasLastBullet = false;
            char.hasRecoveryContract = false;
            char.hasRecoveryContractUsed = false;
            char.hasFocusedFire = false;
            char.hasShotgun = false;
            char.hasRagged = false;
            char.hasGhost = false;
            char.hasFortify = false;
            char.isFortified = false;
            char.hasOverheat = false;
            char.hasGamble = false;
            char.hasWeaken = false;
            char.isWeakened = false;
            char.hasDamageBoost = false;
            char.hasLightning = false;
            char.isStunned = false;
            char.hasShield = false;
            char.shieldReady = false;
            char.hasRegeneration = false;
            char.hasEvasiveManeuver = false;
            char.hasCombatExperience = false;
            char.hasHallucination = false;
            char.hasTasteOfBlood = false;
            char.hasCannon = false;
            char.hasTimeBarrier = false;
            char.hasBouncyBullet = false;
            char.hasGamble2 = false;
            char.hasReflect = false;
            char.reflectActive = false;
            char.hasExplosiveBullet = false;
            char.hasReaper = false;
            char.isInvisible = false;
            char.invisibilityEndTime = 0;
            char.hasOvercharge = false;
            char.overchargeActive = false;
            char.overchargeCooldown = 0;
            char.overchargeEndTime = 0;
            char.hasVictor = false;
            char.hasTimeStop = false;
            char.timeStopActive = false;
            char.hasScatter = false;
            char.hasRocket = false;
            char.hasTrinity = false;
            char.hasJudgment = false;
            char.hasBoomerang = false;
            char.poisonEffects = [];
            char.damageNumbers = [];
        }

        // ëœë¤ ëª¨ë“œ ì •ì˜
        const randomModes = [
            {
                id: 'doubleAugment',
                name: '2Xëª¨ë“œ',
                description: 'ì¦ê°•ì„ 2ê°œì”© ì„ íƒí•©ë‹ˆë‹¤'
            },
            {
                id: 'hp1',
                name: 'HP1ëª¨ë“œ',
                description: 'ì´ˆê¸° ìµœëŒ€ì²´ë ¥ì´ 1ì´ ë©ë‹ˆë‹¤'
            },
            {
                id: 'movingWork',
                name: 'ë¬´ë¹™ì›Œí¬ëª¨ë“œ',
                description: 'ëª¨ë“  í”Œë ˆì´ì–´ê°€ 5ì´ˆë§ˆë‹¤ ë°”ë€ŒëŠ” ë°©í–¥ìœ¼ë¡œ ì´ˆë‹¹ 25pxì”© ì´ë™í•©ë‹ˆë‹¤'
            },
            {
                id: 'turtle',
                name: 'ê±°ë¶ì´ëª¨ë“œ',
                description: 'ëª¨ë“  í”Œë ˆì´ì–´ì˜ ì´ë™ì†ë„ê°€ 50% ê°ì†Œí•©ë‹ˆë‹¤'
            },
            {
                id: 'flame',
                name: 'ìš©ì•”ëª¨ë“œ',
                description: 'ëª¨ë“  í”Œë ˆì´ì–´ê°€ 5ì´ˆë§ˆë‹¤ 0.5 ë°ë¯¸ì§€ë¥¼ ì…ìŠµë‹ˆë‹¤'
            },
            {
                id: 'noReload',
                name: 'ë¦¬ë¡œë“œ!ëª¨ë“œ',
                description: 'ì¬ì¥ì „ ì‹œê°„ì´ 0.3ì´ˆê°€ ë©ë‹ˆë‹¤'
            },
            {
                id: 'melee',
                name: 'ê·¼ì ‘ì „ëª¨ë“œ',
                description: 'ëª¨ë“  ì´ì•Œì´ 500pxê¹Œì§€ë§Œ ë°œì‚¬ë©ë‹ˆë‹¤'
            },
            {
                id: 'smallMap',
                name: '-25%ëª¨ë“œ',
                description: 'ë§µ í¬ê¸°ê°€ 25% ì¤„ì–´ë“­ë‹ˆë‹¤'
            },
            {
                id: 'ice',
                name: 'ë¹™íŒëª¨ë“œ',
                description: 'ëª¨ë“  í”Œë ˆì´ì–´ê°€ ì´ë™ë°©í–¥ìœ¼ë¡œ ë¯¸ë„ëŸ¬ì§‘ë‹ˆë‹¤'
            },
            {
                id: 'superAI',
                name: 'ìŠˆí¼AIëª¨ë“œ',
                description: 'AIê°€ ì¦ê°•ì„ ëœë¤ìœ¼ë¡œ 2ê°œ ì„ íƒí•˜ê³  ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤'
            }
        ];

        function startSoloGame(mode) {
            // ëª¨ë“œ ì„ íƒ ì ‘ê¸°
            collapseModeSelection();
            
            gameState.gameMode = mode || 'classic'; // 'classic' ë˜ëŠ” 'random'
            
            // ëœë¤ ëª¨ë“œì¸ ê²½ìš° ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ì‹œê°„ ë©ˆì¶”ê¸°)
            if (mode === 'random') {
                gameState.isPaused = true; // ìŠ¬ë¡¯ë¨¸ì‹  ì¤‘ ì‹œê°„ ë©ˆì¶”ê¸°
                gameState.isSlotMachine = true;
                gameState.slotMachineStartTime = Date.now();
                gameState.slotMachineCurrentIndex = 0;
                gameState.slotMachineSelectedMode = null;
                gameState.selectedRandomMode = null; // ì•„ì§ ì„ íƒë˜ì§€ ì•ŠìŒ
            } else {
                gameState.selectedRandomMode = null;
                gameState.isSlotMachine = false;
            }
            
            gameState.isMenu = false;
            showScreen('game'); // ê²Œì„ í™”ë©´ìœ¼ë¡œ ì „í™˜ (ì‹¤ì œë¡œëŠ” í™”ë©´ ìˆ¨ê¹€)
            
            // ë‹‰ë„¤ì„ ìˆ¨ê¸°ê¸°
            hideNicknameDisplay();
            
            initGame();
        }

        // ëœë¤ ëª¨ë“œ ì ìš© í•¨ìˆ˜
        function applyRandomMode(modeId) {
            switch(modeId) {
                case 'hp1':
                    // HP1ëª¨ë“œ: ìµœëŒ€ì²´ë ¥ 1ë¡œ ì‹œì‘
                    player.maxHealth = 1;
                    player.health = 1;
                    player.displayHealth = 1;
                    enemy.maxHealth = 1;
                    enemy.health = 1;
                    break;
                case 'turtle':
                    // ê±°ë¶ì´ëª¨ë“œ: ì´ë™ì†ë„ 50% ê°ì†Œ
                    player.speed *= 0.5;
                    enemy.speed *= 0.5;
                    break;
                case 'noReload':
                    // ë…¸ë¦¬ë¡œë“œëª¨ë“œ: ì¬ì¥ì „ ì‹œê°„ 0.3ì´ˆ
                    player.reloadTime = 300;
                    player.baseReloadTime = 300; // Reload! ëª¨ë“œ: ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ 0.3ì´ˆ
                    enemy.reloadTime = 300;
                    enemy.baseReloadTime = 300; // Reload! ëª¨ë“œ: ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ 0.3ì´ˆ
                    break;
                case 'smallMap':
                    // -25%ëª¨ë“œ: ë§µ í¬ê¸° 25% ê°ì†Œ
                    const mapScale = 0.75;
                    const mapWidth = canvas.width * mapScale;
                    const mapHeight = canvas.height * mapScale;
                    const mapOffsetX = (canvas.width - mapWidth) / 2;
                    const mapOffsetY = (canvas.height - mapHeight) / 2;
                    
                    gameState.mapBounds.minX = mapOffsetX;
                    gameState.mapBounds.minY = mapOffsetY;
                    gameState.mapBounds.maxX = mapOffsetX + mapWidth;
                    gameState.mapBounds.maxY = mapOffsetY + mapHeight;
                    
                    // í”Œë ˆì´ì–´ì™€ ì  ìœ„ì¹˜ë¥¼ ì¤„ì–´ë“  ë§µ ì•ˆìœ¼ë¡œ ì¡°ì •
                    player.x = Math.max(gameState.mapBounds.minX + player.radius, 
                                      Math.min(gameState.mapBounds.maxX - player.radius, player.x));
                    player.y = Math.max(gameState.mapBounds.minY + player.radius, 
                                      Math.min(gameState.mapBounds.maxY - player.radius, player.y));
                    enemy.x = Math.max(gameState.mapBounds.minX + enemy.radius, 
                                     Math.min(gameState.mapBounds.maxX - enemy.radius, enemy.x));
                    enemy.y = Math.max(gameState.mapBounds.minY + enemy.radius, 
                                     Math.min(gameState.mapBounds.maxY - enemy.radius, enemy.y));
                    break;
                case 'superAI':
                    // ìŠˆí¼AIëª¨ë“œ: AIê°€ ì¦ê°• 2ê°œ ëœë¤ ì„ íƒ
                    const availableAugments = augmentations.filter(aug => aug.id !== 'dodge' && aug.id !== 'fortify' && aug.id !== 'timeStop');
                    const shuffled = [...availableAugments].sort(() => Math.random() - 0.5);
                    // 2ê°œ ì„ íƒ
                    for (let i = 0; i < 2 && i < shuffled.length; i++) {
                        const selectedAugment = shuffled[i];
                        selectedAugment.effect(enemy);
                        enemy.augmentations.push(selectedAugment);
                        incrementAugmentSelectCount(selectedAugment.id);
                    }
                    break;
            }
        }

        function initGame() {
            // ìº”ë²„ìŠ¤ í¬ê¸° ì¬í™•ì¸
            resizeCanvas();
            
            // ì œí™”ëŠ” ê²Œì„ ì‹œì‘ ì‹œ ë¦¬ì…‹í•˜ì§€ ì•ŠìŒ (localStorageì—ì„œ ìœ ì§€)
            
            // ë§µ ê²½ê³„ ì´ˆê¸°í™” (ì „ì²´ ìº”ë²„ìŠ¤)
            gameState.mapBounds.minX = 0;
            gameState.mapBounds.minY = 0;
            gameState.mapBounds.maxX = canvas.width;
            gameState.mapBounds.maxY = canvas.height;
            
            // ë§µ ê²½ê³„ ì´ˆê¸°í™” (ì „ì²´ ìº”ë²„ìŠ¤)
            gameState.mapBounds.minX = 0;
            gameState.mapBounds.minY = 0;
            gameState.mapBounds.maxX = canvas.width;
            gameState.mapBounds.maxY = canvas.height;
            
            // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
            gameState.round = 1;
            gameState.playerWins = 0;
            gameState.enemyWins = 0;
            gameState.gameTime = 180;
            gameState.isGameOver = false;
            gameState.isPaused = true;
            gameState.countdown = 3;
            gameState.roundWins = [];
            gameState.augmentCountdown = 0;
            gameState.showOpponentSelecting = false;

            // ëœë¤ ëª¨ë“œ í‘œì‹œ ì—…ë°ì´íŠ¸ (ìŠ¬ë¡¯ë¨¸ì‹  ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
            if (!gameState.isSlotMachine) {
                const randomModeDisplay = document.getElementById('randomModeDisplay');
                const randomModeName = document.getElementById('randomModeName');
                const randomModeTooltip = document.getElementById('randomModeTooltip');
                
                if (gameState.selectedRandomMode) {
                    randomModeDisplay.style.display = 'block';
                    randomModeName.textContent = gameState.selectedRandomMode.name;
                    randomModeTooltip.textContent = gameState.selectedRandomMode.description;
                    
                } else {
                    randomModeDisplay.style.display = 'none';
                }
            }

            // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
            player.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            player.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.angle = 0;
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.speed = 3; // ê¸°ë³¸ ì†ë„ ì„¤ì •
            player.hasCritical = false;
            player.hasDoubleShot = false;
            player.hasDodge = false;
            player.hasRevive = false;
            player.hasRevived = false;
            player.hasDeepWound = false;
            player.hasOneShotOneKill = false;
            player.hasPoisonBullet = false;
            player.hasReloadHeal = false;
            player.hasSurvivalInstinct = false;
            player.hasLastBullet = false;
            player.hasRecoveryContract = false;
            player.hasRecoveryContractUsed = false;
            player.hasFocusedFire = false;
            player.hasShotgun = false;
            player.hasRagged = false;
            player.hasGhost = false;
            player.hasFortify = false;
            player.isFortified = false;
            player.fortifyStartTime = 0;
            player.lastPosition = { x: player.x, y: player.y };
            player.stationaryTime = 0;
            player.hasOverheat = false;
            player.overheatHitCount = 0;
            player.lastHitTime = 0;
            player.hasGamble = false;
            player.hasWeaken = false;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.hasDamageBoost = false;
            player.hasLightning = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.hasShield = false;
            player.shieldReady = false;
            player.shieldCooldown = 0;
            player.hasRegeneration = false;
            player.lastRegenTime = 0;
            player.hasEvasiveManeuver = false;
            player.hasCombatExperience = false;
            player.combatExperienceRounds = 0;
            player.hasHallucination = false;
            player.hasTasteOfBlood = false;
            player.hasCannon = false;
            player.hasTimeBarrier = false;
            player.timeBarrierRadius = 150;
            player.hasBouncyBullet = false;
            player.hasExplosiveBullet = false;
            player.hasReaper = false;
            player.isInvisible = false;
            player.invisibilityEndTime = 0;
            player.hasOvercharge = false;
            player.overchargeActive = false;
            player.overchargeCooldown = 0;
            player.overchargeEndTime = 0;
            player.hasVictor = false;
            player.hasReflect = false;
            player.reflectActive = false;
            player.reflectCooldown = 0;
            player.reflectEndTime = 0;
            player.hasTimeStop = false;
            player.timeStopCooldown = 0;
            player.timeStopActive = false;
            player.timeStopEndTime = 0;
            player.hasScatter = false;
            player.hasGamble2 = false;
            player.hasRocket = false;
            player.hasTrinity = false;
            player.hasJudgment = false;
            player.isJudgmentPushing = false;
            player.judgmentPushStartX = 0;
            player.judgmentPushStartY = 0;
            player.judgmentPushTargetX = 0;
            player.judgmentPushTargetY = 0;
            player.judgmentPushStartTime = 0;
            player.judgmentPushDuration = 0;
            player.hasBoomerang = false;
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.poisonEffects = [];
            player.isDodging = false;
            player.isReviving = false;
            player.isInvincible = false;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.damage = 1;
            player.speed = 3;
            player.reloadTime = 3000;
            player.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
            player.isReloading = false;
            player.reloadStartTime = 0;
            player.shootCooldown = 1000;
            player.lastShot = 0;

            // enemy ì´ˆê¸°í™”
                enemy.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
                enemy.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
                enemy.health = 5;
                enemy.displayHealth = 5;
                enemy.maxHealth = 5;
                enemy.ammo = 6;
                enemy.maxAmmo = 6;
                enemy.bullets = [];
                enemy.augmentations = [];
                enemy.angle = Math.PI;
                enemy.bulletSpeedMultiplier = 1;
                enemy.bulletSizeMultiplier = 1;
                enemy.hasCritical = false;
                enemy.hasDoubleShot = false;
                enemy.hasDodge = false;
                enemy.hasRevive = false;
                enemy.hasRevived = false;
                enemy.hasDeepWound = false;
                enemy.hasOneShotOneKill = false;
                enemy.hasPoisonBullet = false;
                enemy.hasReloadHeal = false;
                enemy.hasSurvivalInstinct = false;
                enemy.hasLastBullet = false;
                enemy.hasRecoveryContract = false;
                enemy.hasRecoveryContractUsed = false;
                enemy.hasFocusedFire = false;
            enemy.hasShotgun = false;
            enemy.hasRagged = false;
            enemy.hasGhost = false;
            enemy.hasFortify = false;
            enemy.isFortified = false;
            enemy.fortifyStartTime = 0;
            enemy.lastPosition = { x: enemy.x, y: enemy.y };
            enemy.stationaryTime = 0;
            enemy.hasOverheat = false;
            enemy.overheatHitCount = 0;
            enemy.lastHitTime = 0;
            enemy.hasGamble = false;
            enemy.hasWeaken = false;
            enemy.isWeakened = false;
            enemy.weakenEndTime = 0;
            enemy.hasDamageBoost = false;
            enemy.hasLightning = false;
            enemy.isStunned = false;
            enemy.stunEndTime = 0;
            enemy.hasShield = false;
            enemy.shieldReady = false;
            enemy.shieldCooldown = 0;
            enemy.hasRegeneration = false;
            enemy.lastRegenTime = 0;
            enemy.hasEvasiveManeuver = false;
            enemy.hasCombatExperience = false;
            enemy.combatExperienceRounds = 0;
            enemy.hasHallucination = false;
            enemy.hasTasteOfBlood = false;
            enemy.hasCannon = false;
            enemy.hasTimeBarrier = false;
            enemy.timeBarrierRadius = 150;
            enemy.hasBouncyBullet = false;
                enemy.isVulnerable = false;
                enemy.vulnerabilityUsed = false;
                enemy.poisonEffects = [];
                enemy.isDodging = false;
                enemy.isReviving = false;
                enemy.isInvincible = false;
                enemy.slowEndTime = 0;
                enemy.damageNumbers = [];
                enemy.usePrediction = false;
                enemy.lastPlayerX = 0;
                enemy.lastPlayerY = 0;
                enemy.playerVelocity = { x: 0, y: 0 };
                enemy.damage = 1;
                enemy.speed = 2.5; // ê¸°ë³¸ ì†ë„ ì„¤ì •
            enemy.reloadTime = 3000;
                enemy.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
                enemy.isReloading = false;
                enemy.reloadStartTime = 0;
                enemy.shootCooldown = 1000;
                enemy.lastShot = 0;
                
                // ëª¨ë“œë³„ ì´ˆê¸°í™” (ì†ë„ ì„¤ì • í›„ì— ì ìš©)
                if (gameState.selectedRandomMode) {
                    applyRandomMode(gameState.selectedRandomMode.id);
                }

            // ì²« ë¼ìš´ë“œ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (ëœë¤ ëª¨ë“œì´ê³  ìŠ¬ë¡¯ë¨¸ì‹  ì¤‘ì´ë©´ ìŠ¬ë¡¯ë¨¸ì‹ ì´ ëë‚œ í›„ ì‹œì‘)
            if (gameState.gameMode !== 'random' || !gameState.isSlotMachine) {
                const initialCountdown = setInterval(() => {
                    gameState.countdown--;
                    if (gameState.countdown <= 0) {
                        clearInterval(initialCountdown);
                        gameState.isPaused = false;
                    }
                }, 1000);
            }
        }

        function draw() {
            // ë©”ë‰´ í™”ë©´ í‘œì‹œ
            if (gameState.isMenu) {
                return; // ë©”ë‰´ëŠ” HTMLë¡œ í‘œì‹œë˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ê·¸ë¦¬ì§€ ì•ŠìŒ
            }

            // ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì¼ ë•ŒëŠ” ìŠ¬ë¡¯ë¨¸ì‹ ë§Œ ê·¸ë¦¬ê¸°
            if (gameState.isSlotMachine) {
                ctx.fillStyle = '#0f0f1e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ê·¸ë¦¬ê¸°
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // í˜„ì¬ í‘œì‹œí•  ëª¨ë“œ
                const currentMode = randomModes[gameState.slotMachineCurrentIndex];
                
                // ëª¨ë“œ ì´ë¦„ í‘œì‹œ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 64px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(currentMode.name, centerX, centerY);
                
                // ëª¨ë“œ ì„¤ëª… í‘œì‹œ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '32px Arial';
                ctx.fillText(currentMode.description, centerX, centerY + 60);
                
                return; // ìŠ¬ë¡¯ë¨¸ì‹  ì¤‘ì—ëŠ” ë‚˜ë¨¸ì§€ ê²Œì„ ìš”ì†Œ ê·¸ë¦¬ì§€ ì•ŠìŒ
            }

            // í˜¸ë²„ëœ ì¦ê°• ì´ˆê¸°í™”
            hoveredAugment = null;
            
            // í™”ë©´ í”ë“¤ë¦¼ ì ìš©
            let shakeX = 0;
            let shakeY = 0;
            if (gameState.shake.duration > 0) {
                shakeX = (Math.random() - 0.5) * gameState.shake.intensity;
                shakeY = (Math.random() - 0.5) * gameState.shake.intensity;
                gameState.shake.duration = Math.max(0, gameState.shake.duration - 16); // ì•½ 60fps ê¸°ì¤€
                gameState.shake.intensity *= 0.9; // ì ì§„ì ìœ¼ë¡œ ê°ì†Œ
            }

            // ë°°ê²½ í´ë¦¬ì–´ (í”ë“¤ë¦¼ ì „ì— ê·¸ë¦¬ê¸°)
            // ìš©ì•”ëª¨ë“œ: ë°°ê²½ì„ ë¶‰ì€ ê³„ì—´ë¡œ ë³€ê²½
            // ë¹™íŒëª¨ë“œ: ë°°ê²½ì„ í‘¸ë¥¸ ê³„ì—´ë¡œ ë³€ê²½
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'flame') {
                ctx.fillStyle = '#2a0f0f'; // ì–´ë‘ìš´ ë¶‰ì€ ê³„ì—´
            } else if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'ice') {
                ctx.fillStyle = '#0f1e3a'; // ë” íŒŒë€ìƒ‰ í‘¸ë¥¸ ê³„ì—´
            } else {
                ctx.fillStyle = '#0f0f1e';
            }
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // í™”ë©´ í”ë“¤ë¦¼ ì ìš©
            ctx.save();
            ctx.translate(shakeX, shakeY);

            // ê²©ì ê·¸ë¦¬ê¸° (ë§µ ê²½ê³„ ë‚´ë¶€ë§Œ, ê²½ê³„ì„  ì œì™¸)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const startX = gameState.mapBounds.minX;
            const startY = gameState.mapBounds.minY;
            const endX = gameState.mapBounds.maxX;
            const endY = gameState.mapBounds.maxY;
            
            // ê²©ì ì„ ì´ ë§µ ê²½ê³„ì„ ê³¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ê²½ê³„ì„ ì„ ì œì™¸í•˜ê³  ê·¸ë¦¬ê¸°
            const gridStartX = Math.ceil(startX / 50) * 50; // ê²½ê³„ì„  ë‹¤ìŒ ê²©ìë¶€í„°
            const gridStartY = Math.ceil(startY / 50) * 50;
            const gridEndX = Math.floor(endX / 50) * 50; // ê²½ê³„ì„  ì „ê¹Œì§€
            const gridEndY = Math.floor(endY / 50) * 50;
            
            for (let i = gridStartX; i <= gridEndX; i += 50) {
                if (i > startX && i < endX) { // ê²½ê³„ì„  ì œì™¸
                    ctx.beginPath();
                    ctx.moveTo(i, startY);
                    ctx.lineTo(i, endY);
                    ctx.stroke();
                }
            }
            for (let i = gridStartY; i <= gridEndY; i += 50) {
                if (i > startY && i < endY) { // ê²½ê³„ì„  ì œì™¸
                    ctx.beginPath();
                    ctx.moveTo(startX, i);
                    ctx.lineTo(endX, i);
                    ctx.stroke();
                }
            }

            // -25%ëª¨ë“œ: ì¤„ì–´ë“  ì˜ì—­ì„ ê²€ì€ìƒ‰ìœ¼ë¡œ í‘œì‹œ (ê²©ì ê·¸ë¦¬ê¸° í›„, ê²©ì ì„ ì„ ë®ê¸° ìœ„í•´)
            // í”ë“¤ë¦¼ìœ¼ë¡œ ì¸í•œ ì—¬ìœ  ê³µê°„ ì¶”ê°€ (ìµœëŒ€ í”ë“¤ë¦¼ ê°•ë„ ê³ ë ¤)
            const shakeMargin = 50; // í”ë“¤ë¦¼ ì—¬ìœ  ê³µê°„
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'smallMap') {
                ctx.fillStyle = '#000000'; // ê²€ì€ìƒ‰
                // ìœ„ìª½ ì˜ì—­ (ì—¬ìœ  ê³µê°„ ì¶”ê°€)
                ctx.fillRect(-shakeMargin, -shakeMargin, canvas.width + shakeMargin * 2, gameState.mapBounds.minY + shakeMargin);
                // ì•„ë˜ìª½ ì˜ì—­ (ì—¬ìœ  ê³µê°„ì€ ìœ„ìª½ë§Œ, ì•„ë˜ìª½ì€ ì •í™•íˆ ê²½ê³„ì—ì„œ ì‹œì‘)
                ctx.fillRect(-shakeMargin, gameState.mapBounds.maxY, canvas.width + shakeMargin * 2, canvas.height - gameState.mapBounds.maxY);
                // ì™¼ìª½ ì˜ì—­ (ì—¬ìœ  ê³µê°„ ì¶”ê°€)
                ctx.fillRect(-shakeMargin, gameState.mapBounds.minY - shakeMargin, gameState.mapBounds.minX + shakeMargin, gameState.mapBounds.maxY - gameState.mapBounds.minY + shakeMargin * 2);
                // ì˜¤ë¥¸ìª½ ì˜ì—­ (ì—¬ìœ  ê³µê°„ì€ ì™¼ìª½ë§Œ, ì˜¤ë¥¸ìª½ì€ ì •í™•íˆ ê²½ê³„ì—ì„œ ì‹œì‘)
                ctx.fillRect(gameState.mapBounds.maxX, gameState.mapBounds.minY - shakeMargin, canvas.width - gameState.mapBounds.maxX, gameState.mapBounds.maxY - gameState.mapBounds.minY + shakeMargin * 2);
            }

            // ë©€í‹°í”Œë ˆì´ì–´ ì¥ì• ë¬¼ ê·¸ë¦¬ê¸°
            if (gameState.isMultiplayer && gameState.obstacles && gameState.obstacles.length > 0) {
                ctx.save();
                gameState.obstacles.forEach(obstacle => {
                    ctx.save();
                    ctx.translate(obstacle.x, obstacle.y);
                    ctx.rotate(obstacle.angle);
                    
                    // ì¥ì• ë¬¼ ê·¸ë¦¬ê¸° (íšŒìƒ‰, ì•½ê°„ íˆ¬ëª…)
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
                    ctx.strokeStyle = 'rgba(150, 150, 150, 0.9)';
                    ctx.lineWidth = 2;
                    
                    // ì§ì‚¬ê°í˜• ê·¸ë¦¬ê¸°
                    ctx.beginPath();
                    ctx.rect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                });
                ctx.restore();
            }

            // ì´ì•Œ ê·¸ë¦¬ê¸°
            // í”¼ê²© ì´í™íŠ¸ ê·¸ë¦¬ê¸° (í”Œë ˆì´ì–´)
            if (player.hitEffectParticles && player.hitEffectParticles.length > 0) {
                ctx.save();
                player.hitEffectParticles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    ctx.globalAlpha = alpha * 0.8;
                    ctx.fillStyle = particle.color;
                    ctx.strokeStyle = particle.color;
                    // ë„¤ì˜¨ íš¨ê³¼ ì ìš© (2ë‹¨ê³„ ê°•í™” ì‹œ)
                    if (particle.hasNeon) {
                        // ë°˜ë”§ë¶ˆì´ì²˜ëŸ¼ ê°•í•œ ë„¤ì˜¨ íš¨ê³¼ - ì—¬ëŸ¬ ê²¹ìœ¼ë¡œ ê·¸ë¦¬ê¸°
                        const neonLayers = 5; // 5ê²¹ìœ¼ë¡œ ê·¸ë¦¬ê¸°
                        const baseBlur = 80 + (particle.size * 10); // í¬ê¸°ì— ë”°ë¼ ë¸”ëŸ¬ ê°•ë„ ì¡°ì ˆ
                        
                        for (let layer = 0; layer < neonLayers; layer++) {
                            const layerAlpha = (alpha * 0.8) / neonLayers;
                            const layerBlur = baseBlur * (1 - layer * 0.15); // ê° ë ˆì´ì–´ë§ˆë‹¤ ë¸”ëŸ¬ ê°ì†Œ
                            const layerSize = particle.size * (1 + layer * 0.3); // ê° ë ˆì´ì–´ë§ˆë‹¤ í¬ê¸° ì¦ê°€
                            
                            ctx.globalAlpha = layerAlpha;
                            ctx.shadowBlur = layerBlur;
                            ctx.shadowColor = particle.color;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;
                            
                            if (particle.type === 'dot') {
                                ctx.beginPath();
                                ctx.arc(particle.x, particle.y, layerSize, 0, Math.PI * 2);
                                ctx.fill();
                            } else if (particle.type === 'triangle') {
                                ctx.save();
                                ctx.translate(particle.x, particle.y);
                                ctx.rotate(particle.rotation || 0);
                                ctx.beginPath();
                                ctx.moveTo(0, -layerSize);
                                ctx.lineTo(-layerSize * 0.866, layerSize * 0.5);
                                ctx.lineTo(layerSize * 0.866, layerSize * 0.5);
                                ctx.closePath();
                                ctx.fill();
                                ctx.restore();
                            } else if (particle.type === 'square') {
                                ctx.save();
                                ctx.translate(particle.x, particle.y);
                                ctx.rotate(particle.rotation || 0);
                                ctx.fillRect(-layerSize, -layerSize, layerSize * 2, layerSize * 2);
                                ctx.restore();
                            } else if (particle.type === 'diamond') {
                                ctx.save();
                                ctx.translate(particle.x, particle.y);
                                ctx.rotate(Math.PI / 4);
                                ctx.fillRect(-layerSize, -layerSize, layerSize * 2, layerSize * 2);
                                ctx.restore();
                            } else if (particle.type === 'spark') {
                                ctx.save();
                                ctx.translate(particle.x, particle.y);
                                ctx.rotate(particle.angle);
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(particle.length, 0);
                                ctx.lineWidth = particle.size * (1 + layer * 0.2);
                                ctx.stroke();
                                ctx.restore();
                            }
                        }
                        // ì›ë˜ í¬ê¸°ë¡œ í•œ ë²ˆ ë” ê·¸ë¦¬ê¸° (ë°ì€ ì¤‘ì‹¬)
                        ctx.globalAlpha = alpha * 1.2;
                        ctx.shadowBlur = baseBlur * 0.5;
                        ctx.shadowColor = particle.color;
                    } else {
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = particle.color;
                    }
                    
                    if (particle.type === 'dot') {
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (particle.type === 'triangle') {
                        // ì‚¼ê°í˜• ê·¸ë¦¬ê¸° (ëœë¤ íšŒì „)
                        ctx.save();
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.rotation || 0); // ëœë¤ íšŒì „ ê°ë„ ì ìš©
                        ctx.beginPath();
                        ctx.moveTo(0, -particle.size); // ìœ„ìª½ ê¼­ì§“ì 
                        ctx.lineTo(-particle.size * 0.866, particle.size * 0.5); // ì™¼ìª½ ì•„ë˜
                        ctx.lineTo(particle.size * 0.866, particle.size * 0.5); // ì˜¤ë¥¸ìª½ ì•„ë˜
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    } else if (particle.type === 'square') {
                        // ì‚¬ê°í˜• ê·¸ë¦¬ê¸° (ëœë¤ íšŒì „)
                        ctx.save();
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.rotation || 0); // ëœë¤ íšŒì „ ê°ë„ ì ìš©
                        ctx.fillRect(-particle.size, -particle.size, particle.size * 2, particle.size * 2);
                        ctx.restore();
                    } else if (particle.type === 'diamond') {
                        ctx.save();
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(Math.PI / 4);
                        ctx.fillRect(-particle.size, -particle.size, particle.size * 2, particle.size * 2);
                        ctx.restore();
                    } else if (particle.type === 'spark') {
                        ctx.save();
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.angle);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(particle.length, 0);
                        ctx.lineWidth = particle.size;
                        ctx.stroke();
                        ctx.restore();
                    } else if (particle.type === 'firework') {
                        // í­ì£½ ì´í™íŠ¸: ì§ì‚¬ê°í˜• ê·¸ë¦¬ê¸° (ì¤‘ì•™ ë¶€ë¶„ ë¹„ìš°ê³  ê°ì† íš¨ê³¼, í¼ì§€ëŠ” ì†ë„ +25%, í¼ì§€ëŠ” ê±°ë¦¬ +25%, ë„ˆë¹„ -25%)
                        ctx.save();
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.angle);
                        
                        // ê°ì† íš¨ê³¼ë¥¼ ê³ ë ¤í•œ progress ê³„ì‚°
                        const lifeProgress = 1 - (particle.life / particle.maxLife);
                        const speedMultiplier = particle.speed || 1.0;
                        // ì´ˆê¸°ì—ëŠ” ë¹ ë¥´ê²Œ, ë‚˜ì¤‘ì—ëŠ” ëŠë¦¬ê²Œ (ê°ì† ê³¡ì„ )
                        const easedProgress = lifeProgress * speedMultiplier;
                        const progress = Math.min(1, easedProgress * 3 * 1.25); // í¼ì§€ëŠ” ì†ë„ 3ë°° * 1.25 (25% ì¦ê°€)
                        
                        const maxSize = (particle.size || 16.875) * 1.25 * 1.25 * 1.25; // í¼ì§€ëŠ” ê±°ë¦¬ ì¶”ê°€ 25% ì¦ê°€
                        const currentSize = maxSize * progress; // ì ì  ê¸¸ì–´ì§€ë©´ì„œ í¼ì§ (ê°ì† íš¨ê³¼ ì ìš©)
                        const rectWidth = currentSize * 0.225 * 1.25 * 0.8 * 0.85 * 0.75; // ì§ì‚¬ê°í˜• ë„ˆë¹„ 25% ê°ì†Œ
                        const startOffset = maxSize * 0.35 * 1.25; // ì¤‘ì•™ ë¶€ë¶„ ë¹„ìš°ê¸° ì¦ê°€ (0.2 -> 0.35)
                        // ì§ì‚¬ê°í˜• ê·¸ë¦¬ê¸° (ì¤‘ì•™ì—ì„œ ë” ë©€ë¦¬ ë–¨ì–´ì§„ ìœ„ì¹˜ì—ì„œ ì‹œì‘)
                        ctx.fillRect(startOffset, -rectWidth / 2, currentSize - startOffset, rectWidth);
                        ctx.restore();
                    } else if (particle.type === 'ring') {
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else if (particle.type === 'burst') {
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
            
            // í­ë°œ ì´í™íŠ¸ ê·¸ë¦¬ê¸°
            if (gameState.explosions && gameState.explosions.length > 0) {
                const now = Date.now();
                for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                    const explosion = gameState.explosions[i];
                    const elapsed = now - explosion.startTime;
                    const progress = Math.min(1, elapsed / explosion.duration);
                    
                    // í­ë°œ ì› í…Œë‘ë¦¬ (ì£¼í™©ìƒ‰)
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, explosion.radius * progress, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // í­ë°œ ì¤‘ì‹¬ (í˜ì´ë“œ ì•„ì›ƒ)
                    ctx.fillStyle = `rgba(255, 136, 0, ${1 - progress})`;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, explosion.radius * 0.3 * (1 - progress), 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (progress >= 1) {
                        gameState.explosions.splice(i, 1);
                    }
                }
                ctx.shadowBlur = 0;
            }
            
            player.bullets.forEach(bullet => bullet.draw());
            enemy.bullets.forEach(bullet => bullet.draw());

            // êµ¬ë¥´ê¸° ì”ìƒ ê·¸ë¦¬ê¸°
            function drawDodgeTrail(character) {
                if (character.isDodging && character.dodgeTrail && character.dodgeTrail.length > 0) {
                    // ì”ìƒ íš¨ê³¼ (ê³¼ê±° ìœ„ì¹˜ ê·¸ë¦¬ê¸°)
                    character.dodgeTrail.forEach((trail, index) => {
                        const fadeAlpha = trail.alpha * (1 - index * 0.2); // ì ì§„ì ìœ¼ë¡œ íˆ¬ëª…
                        ctx.globalAlpha = Math.max(0, fadeAlpha);
                        ctx.fillStyle = character.color;
                        ctx.beginPath();
                        ctx.arc(trail.x, trail.y, character.radius * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;
                }
            }
            
            // ê³¼ì¶©ì „ ì”ìƒ ê·¸ë¦¬ê¸° (íŒŒë€ìƒ‰)
            function drawOverchargeTrail(character) {
                if (character.overchargeActive && character.overchargeTrail && character.overchargeTrail.length > 0) {
                    character.overchargeTrail.forEach((trail, index) => {
                        const fadeAlpha = trail.alpha * (1 - index * 0.15); // ì ì§„ì ìœ¼ë¡œ íˆ¬ëª…
                        ctx.globalAlpha = Math.max(0, fadeAlpha);
                        ctx.fillStyle = '#4a9eff'; // íŒŒë€ìƒ‰
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#4a9eff';
                        ctx.beginPath();
                        ctx.arc(trail.x + shakeX, trail.y + shakeY, character.radius * 0.9, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;
                    ctx.shadowBlur = 0;
                }
            }

            // í´ë˜ì‹ ëª¨ë“œ ë˜ëŠ” ëœë¤ ëª¨ë“œì—ì„œ ë„¤ì˜¨ íš¨ê³¼ ì¶”ê°€ (ë§µ ê²½ê³„ì— ì˜ë¦¬ì§€ ì•Šë„ë¡ í”ë“¤ë¦¼ ë³€í™˜ ì „ì— ê·¸ë¦¬ê¸°)
            const isClassicOrRandom = gameState.gameMode === 'classic' || gameState.gameMode === 'random';
            
            // ë„¤ì˜¨ íš¨ê³¼ë¥¼ ë¨¼ì € ê·¸ë¦¬ê¸° (ë§µ ê²½ê³„ì— ì˜ë¦¬ì§€ ì•Šë„ë¡)
            if (isClassicOrRandom) {
                // ì  ë„¤ì˜¨ íš¨ê³¼
                if (enemy.x > -500 && enemy.y > -500) {
                    // ì‚¬ì‹  ì¦ê°•: ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ ì ì´ ì€ì‹  ì¤‘ì´ë©´ í”Œë ˆì´ì–´ì—ê²ŒëŠ” ì•„ì˜ˆ ë³´ì´ì§€ ì•ŠìŒ
                    if (gameState.isMultiplayer && enemy.isInvisible && Date.now() < enemy.invisibilityEndTime) {
                        // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” ìƒëŒ€ë°©ì´ ì€ì‹  ì¤‘ì´ë©´ ì•„ì˜ˆ ê·¸ë¦¬ì§€ ì•ŠìŒ
                    } else {
                        ctx.save();
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = enemy.color;
                        // ì‚¬ì‹  ì¦ê°•: ì‹±ê¸€í”Œë ˆì´ì–´ì—ì„œ ì ì´ ì€ì‹  ì¤‘ì´ë©´ 50% íˆ¬ëª…
                        if (enemy.isInvisible && Date.now() < enemy.invisibilityEndTime) {
                            ctx.globalAlpha = 0.5; // ì‹±ê¸€í”Œë ˆì´ì–´ì—ì„œëŠ” 50% íˆ¬ëª…
                        } else {
                            ctx.globalAlpha = 0.6; // ë„¤ì˜¨ íš¨ê³¼ëŠ” ì•½ê°„ íˆ¬ëª…í•˜ê²Œ
                        }
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                        ctx.fillStyle = enemy.color;
                        ctx.fill();
                        ctx.restore();
                    }
                }
                
                // í”Œë ˆì´ì–´ ë„¤ì˜¨ íš¨ê³¼
                ctx.save();
                ctx.shadowBlur = 20;
                ctx.shadowColor = player.color;
                // ì‚¬ì‹  ì¦ê°•: ì€ì‹  ì¤‘ì´ë©´ ìƒëŒ€ë°©ì—ê²ŒëŠ” ë³´ì´ì§€ ì•ŠìŒ (ìì‹ ì€ 50% íˆ¬ëª…)
                if (player.isInvisible && Date.now() < player.invisibilityEndTime) {
                    ctx.globalAlpha = 0.5; // ìì‹ ì€ 50% íˆ¬ëª…
                } else {
                    ctx.globalAlpha = 0.6; // ë„¤ì˜¨ íš¨ê³¼ëŠ” ì•½ê°„ íˆ¬ëª…í•˜ê²Œ
                }
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.restore();
            }

            // ì  ê·¸ë¦¬ê¸°
            if (enemy.x > -500 && enemy.y > -500) {
                // ì‚¬ì‹  ì¦ê°•: ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ ì ì´ ì€ì‹  ì¤‘ì´ë©´ í”Œë ˆì´ì–´ì—ê²ŒëŠ” ì•„ì˜ˆ ë³´ì´ì§€ ì•ŠìŒ
                if (gameState.isMultiplayer && enemy.isInvisible && Date.now() < enemy.invisibilityEndTime) {
                    // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œëŠ” ìƒëŒ€ë°©ì´ ì€ì‹  ì¤‘ì´ë©´ ì•„ì˜ˆ ê·¸ë¦¬ì§€ ì•ŠìŒ
                } else {
                    drawOverchargeTrail(enemy);
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y);
                    ctx.rotate(enemy.angle);
                    
                    // ê¸°ë³¸ alpha ì„¤ì •
                    ctx.globalAlpha = 1.0;
                    
                    // ë¬´ì  ìƒíƒœë©´ ê¹œë¹¡ì„ íš¨ê³¼
                    if (enemy.isInvincible) {
                        const blink = Math.floor(Date.now() / 100) % 2;
                        if (blink) {
                            ctx.globalAlpha = 0.5;
                        }
                    } else if (enemy.isInvisible && Date.now() < enemy.invisibilityEndTime) {
                        // ì‚¬ì‹  ì¦ê°•: ì‹±ê¸€í”Œë ˆì´ì–´ì—ì„œ ì ì´ ì€ì‹  ì¤‘ì´ë©´ 50% íˆ¬ëª…
                        ctx.globalAlpha = 0.5;
                    }
                
                // êµ¬ë¥´ê¸° ì”ìƒ ê·¸ë¦¬ê¸°
                if (enemy.dodgeTrail && enemy.dodgeTrail.length > 0) {
                    enemy.dodgeTrail.forEach((trail, index) => {
                        ctx.save();
                        ctx.globalAlpha = trail.alpha * (index / enemy.dodgeTrail.length);
                        ctx.translate(trail.x - enemy.x, trail.y - enemy.y);
                        ctx.beginPath();
                        ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                        ctx.fillStyle = enemy.color;
                        ctx.fill();
                        ctx.restore();
                    });
                }
                
                // ë§ê° ê¸€ë¦¬ì¹˜ íš¨ê³¼
                if (enemy.hasOblivion && enemy.oblivionActivated) {
                    const glitchOffset = (Math.random() - 0.5) * 3;
                    ctx.translate(glitchOffset, 0);
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.translate(-glitchOffset, 0);
                    // ì¶”ê°€ ê¸€ë¦¬ì¹˜ ë ˆì´ì–´ (ë¹¨ê°„ìƒ‰/íŒŒë€ìƒ‰)
                    if (Math.random() < 0.3) {
                        ctx.fillStyle = Math.random() < 0.5 ? '#ff0000' : '#0000ff';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(glitchOffset * 2, 0, enemy.radius * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                ctx.fillStyle = enemy.color;
                ctx.fill();
                
                // ë°©ì–´ë§‰: ì§„í•œ íŒŒë€ìƒ‰ í…Œë‘ë¦¬
                if (enemy.hasShield && enemy.shieldReady) {
                    ctx.strokeStyle = '#0066ff'; // ì§„í•œ íŒŒë€ìƒ‰
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                // ë°˜ì‚¬ ë³´í˜¸ë§‰: í•˜ì–€ìƒ‰ í…Œë‘ë¦¬
                if (enemy.reflectActive) {
                    ctx.strokeStyle = '#ffffff'; // í•˜ì–€ìƒ‰
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                
                // ë¦¬ë³¼ë²„ ê·¸ë¦¬ê¸° (ë„¤ì˜¨ íš¨ê³¼ ì¶”ê°€)
                ctx.save();
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#333333';
                ctx.fillStyle = '#333'; // íŒŒìŠ¤í…” ê·¸ë ˆì´
                ctx.fillRect(enemy.radius - 7.5, -4.5, 22.5, 9); // 1.5ë°° ì¦ê°€
                ctx.restore();
                
                    ctx.globalAlpha = 1.0; // ë³µì›
                    ctx.restore();
                    
                    // ì  ì²´ë ¥ê³¼ íƒ„í™˜ìˆ˜ëŠ” UI ì˜ì—­ì—ì„œ í‘œì‹œë¨
                    
                    // ì  ì¬ì¥ì „ ë°” í‘œì‹œ (ì  ë°”ë¡œ ì˜¤ë¥¸ìª½ ìœ„) - ì  ìœ„ì¹˜ì— í”ë“¤ë¦¼ ì ìš©
                    if (enemy.isReloading) {
                        drawReloadBar(enemy, enemy.x + 40 + shakeX, enemy.y - 40 + shakeY);
                    }
                }
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´: ìºë¦­í„° ìœ„ì— ë‹‰ë„¤ì„ í‘œì‹œ
            if (gameState.isMultiplayer) {
                ctx.save();
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = 0.6;
                
                // í”Œë ˆì´ì–´ ë‹‰ë„¤ì„
                ctx.fillStyle = player.color;
                ctx.fillText(playerNickname || 'ë‚˜', player.x + shakeX, player.y - player.radius - 10 + shakeY);
                
                // ìƒëŒ€ë°© ë‹‰ë„¤ì„ (ì€ì‹  ì¤‘ì´ë©´ í‘œì‹œí•˜ì§€ ì•ŠìŒ)
                if (enemy.x > -500 && enemy.y > -500) {
                    // ì‚¬ì‹  ì¦ê°•: ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ ì ì´ ì€ì‹  ì¤‘ì´ë©´ ë‹‰ë„¤ì„ë„ í‘œì‹œí•˜ì§€ ì•ŠìŒ
                    if (!(enemy.isInvisible && Date.now() < enemy.invisibilityEndTime)) {
                        ctx.fillStyle = enemy.color;
                        ctx.fillText(opponentNickname || 'ìƒëŒ€', enemy.x + shakeX, enemy.y - enemy.radius - 10 + shakeY);
                    }
                }
                
                ctx.restore();
            }

            // ì‹œê°„ì¥ë§‰ ê·¸ë¦¬ê¸° (í”Œë ˆì´ì–´)
            if (player.hasTimeBarrier) {
                ctx.save();
                ctx.globalAlpha = 0.2; // íˆ¬ëª…ë„ê°€ ê°•í•œ ì´ˆë¡ìƒ‰
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x + shakeX, player.y + shakeY, player.timeBarrierRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // ì‹œê°„ì¥ë§‰ ê·¸ë¦¬ê¸° (ì ) - ì€ì‹  ì¤‘ì´ë©´ í‘œì‹œí•˜ì§€ ì•ŠìŒ
            if (enemy.hasTimeBarrier && enemy.x > -500 && enemy.y > -500) {
                // ì‚¬ì‹  ì¦ê°•: ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ ì ì´ ì€ì‹  ì¤‘ì´ë©´ ì‹œê°„ì¥ë§‰ë„ í‘œì‹œí•˜ì§€ ì•ŠìŒ
                if (!(gameState.isMultiplayer && enemy.isInvisible && Date.now() < enemy.invisibilityEndTime)) {
                    ctx.save();
                    ctx.globalAlpha = 0.2; // íˆ¬ëª…ë„ê°€ ê°•í•œ ì´ˆë¡ìƒ‰
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x + shakeX, enemy.y + shakeY, enemy.timeBarrierRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
            drawDodgeTrail(player);
            drawOverchargeTrail(player);
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            
            // ë¬´ì  ìƒíƒœì¼ ë•Œ ë°˜íˆ¬ëª…
            ctx.globalAlpha = 1.0; // ê¸°ë³¸ê°’ ì„¤ì •
            if (player.isInvincible || player.isReviving) {
                ctx.globalAlpha = 0.5;
            } else if (player.hasGhost) {
                // ìœ ë ¹ ì¦ê°•: ì‚´ì§ íë ¤ì§€ê²Œ
                ctx.globalAlpha = 0.7;
            } else if (player.isInvisible && Date.now() < player.invisibilityEndTime) {
                // ì‚¬ì‹  ì¦ê°•: ì€ì‹  ì¤‘ì´ë©´ 50% íˆ¬ëª…
                ctx.globalAlpha = 0.5;
            }
            
            // ë§ê° ê¸€ë¦¬ì¹˜ íš¨ê³¼
            if (player.hasOblivion && player.oblivionActivated) {
                const glitchOffset = (Math.random() - 0.5) * 3;
                ctx.translate(glitchOffset, 0);
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.translate(-glitchOffset, 0);
                // ì¶”ê°€ ê¸€ë¦¬ì¹˜ ë ˆì´ì–´ (ë¹¨ê°„ìƒ‰/íŒŒë€ìƒ‰)
                if (Math.random() < 0.3) {
                    ctx.fillStyle = Math.random() < 0.5 ? '#ff0000' : '#0000ff';
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.arc(glitchOffset * 2, 0, player.radius * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            }
            
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
            ctx.fill();
            // ê±°ì í™•ë³´: í•˜ì–€ìƒ‰ í…Œë‘ë¦¬
            if (player.hasFortify && player.isFortified) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // ë°©ì–´ë§‰: ì§„í•œ íŒŒë€ìƒ‰ í…Œë‘ë¦¬
            if (player.hasShield && player.shieldReady) {
                ctx.strokeStyle = '#0066ff'; // ì§„í•œ íŒŒë€ìƒ‰
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            // ë°˜ì‚¬ ë³´í˜¸ë§‰: í•˜ì–€ìƒ‰ í…Œë‘ë¦¬
            if (player.reflectActive) {
                ctx.strokeStyle = '#ffffff'; // í•˜ì–€ìƒ‰
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            // ë¦¬ë³¼ë²„ ê·¸ë¦¬ê¸° (ë„¤ì˜¨ íš¨ê³¼ ì¶”ê°€)
            ctx.save();
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#333333';
            ctx.fillStyle = '#333'; // íŒŒìŠ¤í…” ê·¸ë ˆì´
            ctx.fillRect(player.radius - 7.5, -4.5, 22.5, 9); // 1.5ë°° ì¦ê°€
            ctx.restore();
            ctx.globalAlpha = 1.0;
            ctx.restore();

            // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼ ì¢…ë£Œ
            ctx.restore();
            
            // ë°ë¯¸ì§€ ìˆ«ì ê·¸ë¦¬ê¸° (í”ë“¤ë¦¼ ì˜í–¥ ë°›ìŒ)
            ctx.save();
            ctx.translate(shakeX, shakeY);
            drawDamageNumbers(player);
                drawDamageNumbers(enemy);
            
            // ë¬´ë¹™ì›Œí¬ ëª¨ë“œ: í™”ë©´ ì¤‘ì•™ì— ë°©í–¥ í™”ì‚´í‘œ ì•„ì´ì½˜ í‘œì‹œ (í”ë“¤ë¦¼ ì˜í–¥ ë°›ìŒ)
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'movingWork' && gameState.movingWorkDirection !== undefined) {
                const centerX = canvas.width / 2;
                let centerY = canvas.height / 2;
                
                // ì¦ê°•ì´ 5ê°œë¥¼ ë„˜ìœ¼ë©´ ì•„ë˜ë¡œ ë‚´ë¦¼
                const totalAugments = (player.augmentations ? player.augmentations.length : 0) + (enemy.augmentations ? enemy.augmentations.length : 0);
                if (totalAugments > 5) {
                    centerY = canvas.height / 2 + 100; // ì•„ë˜ë¡œ 100px ì´ë™
                }
                
                // í™”ì‚´í‘œ ë°©í–¥ì— ë”°ë¥¸ ìœ ë‹ˆì½”ë“œ í™”ì‚´í‘œ
                const angle = gameState.movingWorkDirection;
                let arrowChar;
                // 0 (ìš°), Ï€/2 (ì•„ë˜), Ï€ (ì¢Œ), 3Ï€/2 (ìœ„)
                if (Math.abs(angle - 0) < 0.1) {
                    arrowChar = 'â†’'; // ìš°
                } else if (Math.abs(angle - Math.PI / 2) < 0.1) {
                    arrowChar = 'â†“'; // ì•„ë˜
                } else if (Math.abs(angle - Math.PI) < 0.1) {
                    arrowChar = 'â†'; // ì¢Œ
                } else if (Math.abs(angle - 3 * Math.PI / 2) < 0.1) {
                    arrowChar = 'â†‘'; // ìœ„
                } else {
                    arrowChar = 'â†’'; // ê¸°ë³¸ê°’
                }
                
                // ë‘êº¼ìš´ í™”ì‚´í‘œ ì•„ì´ì½˜ í‘œì‹œ (í•˜ì–€ìƒ‰ ë‹¨ìƒ‰)
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // í•˜ì–€ìƒ‰ ë‹¨ìƒ‰, ì¡°ê¸ˆ ë” íˆ¬ëª…í•˜ê²Œ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillText(arrowChar, centerX, centerY);
            }
            
            ctx.restore();

            // UI ìš”ì†Œë“¤ (í”ë“¤ë¦¼ì˜ ì˜í–¥ì„ ë°›ì§€ ì•ŠìŒ)
            // ìŠ¹ë¦¬ í‘œì‹œ ë§ˆë¦„ëª¨ (í™”ë©´ ìœ„ìª½ ê°€ìš´ë°)
            drawWinIndicators();
            
            // ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ (ë§ˆë¦„ëª¨ ì•„ë˜)
            if (gameState.countdown > 0 || gameState.augmentCountdown > 0) {
                drawCountdown();
            }
            
            // ìƒëŒ€ ì„ íƒ ì¤‘ ë©”ì‹œì§€ í‘œì‹œ
            if (gameState.showOpponentSelecting) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const text = 'ìƒëŒ€ê°€ ì„ íƒì¤‘ì…ë‹ˆë‹¤';
                const textWidth = ctx.measureText(text).width;
                const padding = 40;
                const y = canvas.height / 2;
                
                // ë°°ê²½ ì‚¬ê°í˜•
                ctx.fillRect(
                    canvas.width / 2 - textWidth / 2 - padding,
                    y - 40,
                    textWidth + padding * 2,
                    80
                );
                
                // í…ìŠ¤íŠ¸
                ctx.fillStyle = '#ffffff';
                ctx.fillText(text, canvas.width / 2, y);
                ctx.restore();
            }
            
            // ì‹œê°„ ì •ì§€ í‘ë°± íš¨ê³¼: í”Œë ˆì´ì–´ì™€ í”Œë ˆì´ì–´ì˜ ì´ì•Œ ì œì™¸í•˜ê³  í‘ë°± ì²˜ë¦¬
            if (player.timeStopActive) {
                // í˜„ì¬ canvas ì´ë¯¸ì§€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // í”Œë ˆì´ì–´ì™€ í”Œë ˆì´ì–´ ì´ì•Œ ì˜ì—­ ì €ì¥ (ì»¬ëŸ¬ ìœ ì§€)
                const playerColorRegions = [];
                const playerRadius = player.radius + 5; // ì•½ê°„ì˜ ì—¬ìœ 
                for (let y = Math.max(0, Math.floor(player.y - playerRadius)); y < Math.min(canvas.height, Math.floor(player.y + playerRadius)); y++) {
                    for (let x = Math.max(0, Math.floor(player.x - playerRadius)); x < Math.min(canvas.width, Math.floor(player.x + playerRadius)); x++) {
                        const dx = x - player.x;
                        const dy = y - player.y;
                        if (dx * dx + dy * dy <= playerRadius * playerRadius) {
                            const idx = (y * canvas.width + x) * 4;
                            playerColorRegions.push({
                                x, y,
                                r: data[idx],
                                g: data[idx + 1],
                                b: data[idx + 2],
                                a: data[idx + 3]
                            });
                        }
                    }
                }
                
                // í”Œë ˆì´ì–´ ì´ì•Œ ì˜ì—­ ì €ì¥
                player.bullets.forEach(bullet => {
                    const bulletRadius = bullet.radius + 5;
                    for (let y = Math.max(0, Math.floor(bullet.y - bulletRadius)); y < Math.min(canvas.height, Math.floor(bullet.y + bulletRadius)); y++) {
                        for (let x = Math.max(0, Math.floor(bullet.x - bulletRadius)); x < Math.min(canvas.width, Math.floor(bullet.x + bulletRadius)); x++) {
                            const dx = x - bullet.x;
                            const dy = y - bullet.y;
                            if (dx * dx + dy * dy <= bulletRadius * bulletRadius) {
                                const idx = (y * canvas.width + x) * 4;
                                playerColorRegions.push({
                                    x, y,
                                    r: data[idx],
                                    g: data[idx + 1],
                                    b: data[idx + 2],
                                    a: data[idx + 3]
                                });
                            }
                        }
                    }
                });
                
                // ì „ì²´ë¥¼ í‘ë°±ìœ¼ë¡œ ë³€í™˜
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray;     // R
                    data[i + 1] = gray; // G
                    data[i + 2] = gray; // B
                }
                
                // í”Œë ˆì´ì–´ì™€ í”Œë ˆì´ì–´ ì´ì•Œ ì˜ì—­ ì›ë˜ ì»¬ëŸ¬ë¡œ ë³µì›
                playerColorRegions.forEach(region => {
                    const idx = (region.y * canvas.width + region.x) * 4;
                    data[idx] = region.r;
                    data[idx + 1] = region.g;
                    data[idx + 2] = region.b;
                    data[idx + 3] = region.a;
                });
                
                // ë³€í™˜ëœ ì´ë¯¸ì§€ ë°ì´í„° ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                ctx.putImageData(imageData, 0, 0);
            }

            // ë©€í‹°í”Œë ˆì´ì–´: íŒ€ ê¸°ì¤€ìœ¼ë¡œ UI í‘œì‹œ (íŒŒë€íŒ€ ì™¼ìª½, ë¹¨ê°„íŒ€ ì˜¤ë¥¸ìª½)
            // ì†”ë¡œ: í”Œë ˆì´ì–´ ì™¼ìª½, ì  ì˜¤ë¥¸ìª½
            let leftChar, rightChar;
            if (gameState.isMultiplayer && myTeam) {
                // ë©€í‹°í”Œë ˆì´ì–´: íŒŒë€íŒ€ì´ ì™¼ìª½, ë¹¨ê°„íŒ€ì´ ì˜¤ë¥¸ìª½
                if (myTeam === 'blue') {
                    leftChar = player;
                    rightChar = enemy;
                } else {
                    leftChar = enemy;
                    rightChar = player;
                }
            } else {
                // ì†”ë¡œ: í”Œë ˆì´ì–´ ì™¼ìª½, ì  ì˜¤ë¥¸ìª½
                leftChar = player;
                rightChar = enemy;
            }
            
            // ì™¼ìª½ UI (íŒŒë€íŒ€ / í”Œë ˆì´ì–´)
            const leftHealthY = 20;
            drawHealthHearts(leftChar, 20, leftHealthY, leftChar === player);
            const leftAmmoY = leftHealthY + 40;
            drawAmmoCount(leftChar, 20, leftAmmoY, 'left');
            drawAugmentIcons(leftChar, 20, leftAmmoY + 50, 'left');
            
            // ì˜¤ë¥¸ìª½ UI (ë¹¨ê°„íŒ€ / ì )
            {
                const fixedBarWidth = 150;
                const rightHealthX = canvas.width - fixedBarWidth - 20;
                const rightHealthY = 20;
                drawHealthHearts(rightChar, rightHealthX, rightHealthY, rightChar === player);
                const rightAmmoY = rightHealthY + 40;
                drawAmmoCount(rightChar, rightHealthX + fixedBarWidth, rightAmmoY, 'right');
                drawAugmentIcons(rightChar, rightHealthX + fixedBarWidth, rightAmmoY + 50, 'right');
            }
            
            // í”Œë ˆì´ì–´ ì¬ì¥ì „ ë°” í‘œì‹œ (í”Œë ˆì´ì–´ ë°”ë¡œ ì˜†) - í”Œë ˆì´ì–´ ìœ„ì¹˜ì— í”ë“¤ë¦¼ ì ìš©
            if (player.isReloading) {
                drawReloadBar(player, player.x - 40 + shakeX, player.y - 40 + shakeY);
            }
            // ì¦ê°• íˆ´íŒ í‘œì‹œ
            if (hoveredAugment) {
                drawAugmentTooltip(hoveredAugment.aug, hoveredAugment.x, hoveredAugment.y);
            }
            
        }
        
        // ì¦ê°• íˆ´íŒ ê·¸ë¦¬ê¸°
        function drawAugmentTooltip(aug, x, y) {
            ctx.save();
            
            const padding = 12;
            const lineHeight = 24;
            const fontSize = 18;
            ctx.font = `bold ${fontSize}px Arial`;
            
            // í…ìŠ¤íŠ¸ í¬ê¸° ì¸¡ì •
            const titleWidth = ctx.measureText(aug.name).width;
            ctx.font = `${fontSize - 2}px Arial`;
            const descWidth = ctx.measureText(aug.description).width;
            const tooltipWidth = Math.max(titleWidth, descWidth) + padding * 2;
            const tooltipHeight = lineHeight * 2 + padding * 2;
            
            // íˆ´íŒ ìœ„ì¹˜ (ì•„ì´ì½˜ ìœ„ìª½ ë˜ëŠ” ì•„ë˜ìª½)
            let tooltipX = x;
            let tooltipY = y - 50 - tooltipHeight; // ì•„ì´ì½˜ ìœ„ìª½
            
            // í™”ë©´ ê²½ê³„ ì²´í¬
            if (tooltipY < 0) {
                tooltipY = y + 50; // ì•„ì´ì½˜ ì•„ë˜ìª½
            }
            if (tooltipX + tooltipWidth / 2 > canvas.width) {
                tooltipX = canvas.width - tooltipWidth / 2;
            }
            if (tooltipX - tooltipWidth / 2 < 0) {
                tooltipX = tooltipWidth / 2;
            }
            
            // ë°°ê²½
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.strokeStyle = '#ffc107';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffc107';
            ctx.lineWidth = 2;
            drawRoundedRect(
                tooltipX - tooltipWidth / 2,
                tooltipY,
                tooltipWidth,
                tooltipHeight,
                8
            );
            ctx.fill();
            ctx.stroke();
            
            // ì œëª© (ë„¤ì˜¨ íš¨ê³¼)
            ctx.fillStyle = '#ffc107';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#ffc107';
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(aug.name, tooltipX, tooltipY + padding);
            
            // ì„¤ëª…
            ctx.fillStyle = '#ffffff';
            ctx.font = `${fontSize - 2}px Arial`;
            ctx.fillText(aug.description, tooltipX, tooltipY + padding + lineHeight);
            
            ctx.restore();
        }

        // UI ì—…ë°ì´íŠ¸ (ì²´ë ¥ ì• ë‹ˆë©”ì´ì…˜ ë° ë°ë¯¸ì§€ ìˆ«ì)
        function updateUI() {
            // í”Œë ˆì´ì–´ ì²´ë ¥ ì• ë‹ˆë©”ì´ì…˜
            if (player.displayHealth !== player.health) {
                const diff = player.health - player.displayHealth;
                const speed = 0.15; // ì• ë‹ˆë©”ì´ì…˜ ì†ë„
                player.displayHealth += diff * speed;
                // ê±°ì˜ ê°™ì•„ì§€ë©´ ë°”ë¡œ ë§ì¶¤
                if (Math.abs(diff) < 0.01) {
                    player.displayHealth = player.health;
                }
            }
            
            // ì  ì²´ë ¥ ì• ë‹ˆë©”ì´ì…˜
            if (enemy.displayHealth !== enemy.health) {
                const diff = enemy.health - enemy.displayHealth;
                const speed = 0.15; // ì• ë‹ˆë©”ì´ì…˜ ì†ë„
                enemy.displayHealth += diff * speed;
                // ê±°ì˜ ê°™ì•„ì§€ë©´ ë°”ë¡œ ë§ì¶¤
                if (Math.abs(diff) < 0.01) {
                    enemy.displayHealth = enemy.health;
                }
            }
            
            // ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸
            updateDamageNumbers(player);
            updateDamageNumbers(enemy);
            
            // ë… íš¨ê³¼ ì²˜ë¦¬
            updatePoisonEffects(player);
                updatePoisonEffects(enemy);
        }
        
        // ë… íš¨ê³¼ ì—…ë°ì´íŠ¸
        function updatePoisonEffects(character) {
            const now = Date.now();
            for (let i = character.poisonEffects.length - 1; i >= 0; i--) {
                const poison = character.poisonEffects[i];
                const elapsed = now - poison.startTime;
                
                // 2ì´ˆê°€ ì§€ë‚˜ê±°ë‚˜ ìµœëŒ€ íˆíŠ¸ íšŸìˆ˜ì— ë„ë‹¬í•˜ë©´ ì œê±°
                if (elapsed >= poison.duration || (poison.hitCount >= poison.maxHits)) {
                    character.poisonEffects.splice(i, 1);
                    continue;
                }
                
                // 1ì´ˆë§ˆë‹¤ 0.2 ë°ë¯¸ì§€ (ìµœëŒ€ 2ë²ˆ, ì •í™” ì¦ê°•ì´ ìˆìœ¼ë©´ ë¬´ì‹œ)
                // ê¸°ì¡´ ë… íš¨ê³¼ í˜¸í™˜ì„±ì„ ìœ„í•´ hitCountê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
                if (!poison.hasOwnProperty('hitCount')) {
                    poison.hitCount = 0;
                    poison.maxHits = 3;
                }
                if (now - poison.lastDamageTime >= 1000 && (poison.hitCount || 0) < (poison.maxHits || 3)) {
                    // ê²Œì„ì´ ì¼ì‹œì •ì§€ëœ ìƒíƒœë©´ ë°ë¯¸ì§€ ë¬´ì‹œ (ì¦ê°• ì„ íƒ ì‹œê°„ ë™ì•ˆ)
                    if (gameState.isPaused) {
                        continue;
                    }
                    // ìœ ë ¹ ì¦ê°•: í™•ë¥  ì¤‘ì²© (25% * count)
                    const ghostCount = poison.target.ghostCount || 1;
                    if (poison.target.hasGhost && Math.random() < (0.25 * ghostCount)) {
                        // "ë¬´ì‹œ" í…ìŠ¤íŠ¸ í‘œì‹œ
                        poison.target.damageNumbers.push({
                            x: poison.target.x,
                            y: poison.target.y,
                            damage: 0,
                            isCritical: false,
                            isGhost: true, // ìœ ë ¹ ë¬´ì‹œ ì—¬ë¶€
                            startTime: now,
                            duration: 1000,
                            offsetY: 0
                        });
                        poison.lastDamageTime = now; // ë‹¤ìŒ ë°ë¯¸ì§€ íƒ€ì´ë¨¸ ë¦¬ì…‹
                        continue; // ë°ë¯¸ì§€ ì ìš©í•˜ì§€ ì•ŠìŒ
                    }
                    
                    let poisonDamage = poison.damagePerSecond;
                    // ê±°ì í™•ë³´: ë°ë¯¸ì§€ *0.5
                    if (poison.target.hasFortify && poison.target.isFortified) {
                        poisonDamage *= 0.5;
                    }
                    // ì†Œìˆ˜ì  3ìë¦¬ ì´ìƒì´ë©´ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
                    poisonDamage = roundToMaxTwoDecimals(poisonDamage);
                    
                    poison.target.health -= poisonDamage;
                    poison.target.health = roundToMaxTwoDecimals(poison.target.health);
                    poison.lastDamageTime = now;
                    poison.hitCount = (poison.hitCount || 0) + 1; // íˆíŠ¸ íšŸìˆ˜ ì¦ê°€
                    
                    // ë… ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ (ì–´ë‘ìš´ ì´ˆë¡ìƒ‰)
                    poison.target.damageNumbers.push({
                        x: poison.target.x,
                        y: poison.target.y,
                        damage: poisonDamage,
                        isCritical: false,
                        isPoison: true, // ë… ë°ë¯¸ì§€ ì—¬ë¶€
                        startTime: now,
                        duration: 1000,
                        offsetY: 0
                    });
                    
                    // ì²´ë ¥ì´ 0 ì´í•˜ê°€ ë˜ë©´ ì²˜ë¦¬
                    if (poison.target.health <= 0) {
                        poison.target.health = 0;
                        // ë¶€í™œ ì²´í¬ (íšŸìˆ˜ ì¤‘ì²©)
                        const reviveCount = poison.target.reviveCount || 1;
                        const hasRevivedCount = (typeof poison.target.hasRevived === 'number' ? poison.target.hasRevived : (poison.target.hasRevived ? 1 : 0));
                        if (poison.target.hasRevive && hasRevivedCount < reviveCount && !poison.target.isReviving) {
                            poison.target.hasRevived = hasRevivedCount + 1;
                            poison.target.isReviving = true;
                            poison.target.reviveTime = now + 1000;
                        } else {
                            endRound(poison.target === player ? 'enemy' : 'player');
                        }
                    }
                }
            }
        }
        
        // ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸
        function updateDamageNumbers(character) {
            const now = Date.now();
            for (let i = character.damageNumbers.length - 1; i >= 0; i--) {
                const damageNum = character.damageNumbers[i];
                const elapsed = now - damageNum.startTime;
                
                // ì‹œê°„ì´ ì§€ë‚˜ë©´ ì œê±°
                if (elapsed >= damageNum.duration) {
                    character.damageNumbers.splice(i, 1);
                    continue;
                }
                
                // ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì• ë‹ˆë©”ì´ì…˜
                const progress = elapsed / damageNum.duration;
                damageNum.offsetY = -30 * progress; // ìœ„ë¡œ 30px ì´ë™
            }
        }
        
        // ë°ë¯¸ì§€ ìˆ«ì ê·¸ë¦¬ê¸°
        function drawDamageNumbers(character) {
            const now = Date.now();
            character.damageNumbers.forEach(damageNum => {
                const elapsed = now - damageNum.startTime;
                const progress = elapsed / damageNum.duration;
                
                // í˜ì´ë“œì•„ì›ƒ íš¨ê³¼
                const alpha = 1 - progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // ìƒ‰ìƒ ê²°ì •: íšŒë³µì´ë©´ ë¹¨ê°„ìƒ‰, ë°©ì–´ë§‰ ë¬´ì‹œë©´ ì§„í•œ íŒŒë€ìƒ‰, ìœ ë ¹ ë¬´ì‹œë©´ íšŒìƒ‰, ê¸°ì ˆì´ë©´ ë…¸ë€ìƒ‰, ë… ë°ë¯¸ì§€ë©´ ì–´ë‘ìš´ ì´ˆë¡ìƒ‰, í¬ë¦¬í‹°ì»¬ì´ë©´ ì–´ë‘ìš´ ë…¸ë€ìƒ‰, ì•„ë‹ˆë©´ í•˜ì–€ìƒ‰
                let shadowColor = '#ffffff';
                if (damageNum.isHeal) {
                    ctx.fillStyle = '#ff0000'; // ë¹¨ê°„ìƒ‰
                    shadowColor = '#ff0000';
                } else if (damageNum.isShield) {
                    ctx.fillStyle = '#0066ff'; // ì§„í•œ íŒŒë€ìƒ‰
                    shadowColor = '#0066ff';
                } else if (damageNum.isGhost) {
                    ctx.fillStyle = '#888888'; // íšŒìƒ‰
                    shadowColor = '#888888';
                } else if (damageNum.isStunned) {
                    ctx.fillStyle = '#ffffff'; // í•˜ì–€ìƒ‰
                    shadowColor = '#ffffff';
                } else if (damageNum.isPoison) {
                    ctx.fillStyle = '#006600'; // ì–´ë‘ìš´ ì´ˆë¡ìƒ‰
                    shadowColor = '#006600';
                } else if (damageNum.isCritical) {
                    ctx.fillStyle = '#CCAA00'; // ì–´ë‘ìš´ ë…¸ë€ìƒ‰
                    shadowColor = '#CCAA00';
                } else if (damageNum.isFlame) {
                    ctx.fillStyle = '#ff6600'; // ì£¼í™©/ë¹¨ê°• ê³„ì—´
                    shadowColor = '#ff6600';
                } else {
                    ctx.fillStyle = '#ffffff'; // í•˜ì–€ìƒ‰
                    shadowColor = '#ffffff';
                }
                ctx.shadowBlur = 10;
                ctx.shadowColor = shadowColor;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // ìºë¦­í„° ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ë°ë¯¸ì§€ ìˆ«ì ë˜ëŠ” íŠ¹ìˆ˜ í…ìŠ¤íŠ¸ í‘œì‹œ
                let displayText;
                if (damageNum.isShield || damageNum.isGhost) {
                    displayText = 'ë¬´ì‹œ';
                } else if (damageNum.isStunned) {
                    displayText = 'ê¸°ì ˆ';
                } else {
                    // ì†Œìˆ˜ì  3ìë¦¬ ì´ìƒì´ë©´ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼, 1~2ìë¦¬ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
                    let value = damageNum.damage;
                    // ì†Œìˆ˜ì  ìë¦¬ìˆ˜ í™•ì¸ (ë¬¸ìì—´ë¡œ ë³€í™˜í•´ì„œ í™•ì¸)
                    const strValue = value.toString();
                    const decimalIndex = strValue.indexOf('.');
                    if (decimalIndex !== -1) {
                        const decimalPart = strValue.substring(decimalIndex + 1);
                        if (decimalPart.length > 2) {
                            // 3ìë¦¬ ì´ìƒì´ë©´ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
                            value = Math.round(value * 100) / 100;
                        }
                    }
                    // ë¶ˆí•„ìš”í•œ ì†Œìˆ˜ì  ì œê±° (ì •ìˆ˜ë©´ ì†Œìˆ˜ì  ì œê±°)
                    if (value % 1 === 0) {
                        displayText = value.toString();
                    } else {
                        // ì†Œìˆ˜ì  ìë¦¬ìˆ˜ì— ë§ê²Œ í‘œì‹œ
                        const strValue2 = value.toString();
                        const decimalIndex2 = strValue2.indexOf('.');
                        if (decimalIndex2 !== -1) {
                            const decimalPart2 = strValue2.substring(decimalIndex2 + 1);
                            displayText = value.toFixed(Math.min(decimalPart2.length, 2));
                        } else {
                            displayText = value.toString();
                        }
                    }
                }
                ctx.fillText(
                    displayText,
                    damageNum.x,
                    damageNum.y + damageNum.offsetY
                );
                
                ctx.restore();
            });
        }

        // ê²Œì„ ë£¨í”„
        let lastTime = 0;
        let gameLoopInterval = null; // ë©€í‹°í”Œë ˆì´ì–´ìš© ì¸í„°ë²Œ
        
        function gameLoop(currentTime) {
            // ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ì²˜ë¦¬
            if (gameState.isSlotMachine) {
                const elapsed = Date.now() - gameState.slotMachineStartTime;
                const slotSpeed = 80; // 80msë§ˆë‹¤ ëª¨ë“œ ë³€ê²½ (ë¹ ë¥¸ ìˆœí™˜)
                const spinningDuration = 1200; // 1.2ì´ˆ ë™ì•ˆ ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜
                const displayDuration = 2000; // ì„ íƒëœ ëª¨ë“œ í‘œì‹œ ì‹œê°„ 2ì´ˆ
                
                // ëª¨ë“œ ìˆœí™˜
                if (elapsed < spinningDuration) {
                    const newIndex = Math.floor(elapsed / slotSpeed) % randomModes.length;
                    gameState.slotMachineCurrentIndex = newIndex;
                } else if (elapsed < spinningDuration + displayDuration) {
                    // ì„ íƒëœ ëª¨ë“œì—ì„œ ë©ˆì¶¤ (ì„¤ëª… ì½ì„ ìˆ˜ ìˆê²Œ)
                    if (!gameState.slotMachineSelectedMode) {
                        // ëœë¤ ëª¨ë“œ ì„ íƒ
                        const randomIndex = Math.floor(Math.random() * randomModes.length);
                        gameState.selectedRandomMode = randomModes[randomIndex];
                        gameState.slotMachineSelectedMode = gameState.selectedRandomMode;
                        gameState.slotMachineCurrentIndex = randomIndex; // ì„ íƒëœ ëª¨ë“œë¡œ ê³ ì •
                        
                        // ëœë¤ ëª¨ë“œ í‘œì‹œ ì—…ë°ì´íŠ¸
                        const randomModeDisplay = document.getElementById('randomModeDisplay');
                        const randomModeName = document.getElementById('randomModeName');
                        const randomModeTooltip = document.getElementById('randomModeTooltip');
                        
                        randomModeDisplay.style.display = 'block';
                        randomModeName.textContent = gameState.selectedRandomMode.name;
                        randomModeTooltip.textContent = gameState.selectedRandomMode.description;
                        
                        // ëœë¤ ëª¨ë“œ ì ìš© (ì†ë„ ì´ˆê¸°í™” í›„ ì ìš©)
                        player.speed = 3;
                        enemy.speed = 2.5;
                        player.reloadTime = 3000;
                        player.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
                        enemy.reloadTime = 3000;
                        enemy.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
                        applyRandomMode(gameState.selectedRandomMode.id);
                    }
                } else {
                    // í‘œì‹œ ì‹œê°„ ì¢…ë£Œ, ìŠ¬ë¡¯ë¨¸ì‹  ì¢…ë£Œ í›„ 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                    gameState.isSlotMachine = false;
                    gameState.countdown = 3; // 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                    gameState.isPaused = true; // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¤‘ì´ë¯€ë¡œ ë©ˆì¶¤
                    
                    // ì¹´ìš´íŠ¸ë‹¤ìš´ ì²˜ë¦¬
                    const countdownInterval = setInterval(() => {
                        gameState.countdown--;
                        if (gameState.countdown <= 0) {
                            clearInterval(countdownInterval);
                            gameState.isPaused = false; // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¢…ë£Œ í›„ ê²Œì„ ì‹œì‘
                        }
                    }, 1000);
                }
            }
            
            // ë©”ë‰´ í™”ë©´ì´ ì•„ë‹ ë•Œë§Œ ê²Œì„ ë¡œì§ ì‹¤í–‰ (ìŠ¬ë¡¯ë¨¸ì‹  ì¤‘ì´ ì•„ë‹ ë•Œ)
            if (!gameState.isMenu && !gameState.isPaused && !gameState.isGameOver && !gameState.isSlotMachine) {
                let rawDeltaTime = currentTime - lastTime;
                // deltaTimeì„ ìµœëŒ€ 100msë¡œ ì œí•œ (í”„ë ˆì„ ë“œë¡­ì´ë‚˜ íƒ­ ë¹„í™œì„±í™” ì‹œ ê³¼ë„í•œ ì´ë™ ë°©ì§€)
                const deltaTime = Math.min(rawDeltaTime, 100);
                lastTime = currentTime;

                // íƒ€ì´ë¨¸ ê°ì†Œ (ì´ˆë‹¹ 1ì”©) - ì›ë³¸ deltaTime ì‚¬ìš©
                if (rawDeltaTime >= 1000) {
                    gameState.gameTime--;
                    lastTime = currentTime;

                    // ì‹œê°„ ì´ˆê³¼
                    if (gameState.gameTime <= 0) {
                        if (player.health > enemy.health) {
                            endRound('player');
                        } else if (enemy.health > player.health) {
                            endRound('enemy');
                        } else {
                            // ë¬´ìŠ¹ë¶€ - ì²´ë ¥ì´ ë” ë§ì€ ìª½ì´ ìŠ¹ë¦¬
                            endRound(player.health >= enemy.health ? 'player' : 'enemy');
                        }
                    }
                }

                // ìš©ì•”ëª¨ë“œ: 5ì´ˆë§ˆë‹¤ 0.5 ë°ë¯¸ì§€
                const now = Date.now();
                if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'flame') {
                    if (!gameState.flameLastDamage) {
                        gameState.flameLastDamage = now;
                    }
                    
                    if (now - gameState.flameLastDamage >= 5000) {
                        // í”Œë ˆì´ì–´ì™€ ì  ëª¨ë‘ ë°ë¯¸ì§€
                        if (player.health > 0) {
                            player.health = Math.max(0, player.health - 0.5);
                            // ìš©ì•” ë°ë¯¸ì§€ í‘œì‹œ (ì£¼í™©/ë¹¨ê°• ìƒ‰ìƒ)
                            player.damageNumbers.push({
                                damage: 0.5,
                                x: player.x,
                                y: player.y - player.radius - 20,
                                alpha: 1,
                                isFlame: true,
                                startTime: now,
                                duration: 1000
                            });
                        }
                        if (enemy.health > 0) {
                            enemy.health = Math.max(0, enemy.health - 0.5);
                            enemy.damageNumbers.push({
                                damage: 0.5,
                                x: enemy.x,
                                y: enemy.y - enemy.radius - 20,
                                alpha: 1,
                                isFlame: true,
                                startTime: now,
                                duration: 1000
                            });
                        }
                        gameState.flameLastDamage = now;
                        
                        // í™”ì—¼ ë°ë¯¸ì§€ë¡œ ì²´ë ¥ì´ 0 ì´í•˜ê°€ ë˜ë©´ ë¼ìš´ë“œ íŒ¨ë°° ì²˜ë¦¬
                        if (player.health <= 0 && !player.isReviving) {
                            // ë¶€í™œ ì²´í¬ (íšŸìˆ˜ ì¤‘ì²©)
                            const reviveCount = player.reviveCount || 1;
                            const hasRevivedCount = (typeof player.hasRevived === 'number' ? player.hasRevived : (player.hasRevived ? 1 : 0));
                            if (player.hasRevive && hasRevivedCount < reviveCount) {
                                player.hasRevived = hasRevivedCount + 1;
                                player.isReviving = true;
                                player.reviveTime = now + 1000;
                            } else {
                                endRound('enemy');
                            }
                        }
                        if (enemy.health <= 0 && !enemy.isReviving) {
                            // ë¶€í™œ ì²´í¬ (íšŸìˆ˜ ì¤‘ì²©)
                            const reviveCount = enemy.reviveCount || 1;
                            const hasRevivedCount = (typeof enemy.hasRevived === 'number' ? enemy.hasRevived : (enemy.hasRevived ? 1 : 0));
                            if (enemy.hasRevive && hasRevivedCount < reviveCount) {
                                enemy.hasRevived = hasRevivedCount + 1;
                                enemy.isReviving = true;
                                enemy.reviveTime = now + 1000;
                            } else {
                                endRound('player');
                            }
                        }
                    }
                }


                updatePlayer(deltaTime);
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ AI ì—…ë°ì´íŠ¸
                if (!gameState.isMultiplayer) {
                    updateEnemy(deltaTime);
                }
                
                updateBullets(enemy, deltaTime);
                updateBullets(player, deltaTime);
                
                // ë©€í‹°í”Œë ˆì´ì–´: 15ì´ˆë§ˆë‹¤ ì¥ì• ë¬¼ ì œê±° (í˜¸ìŠ¤íŠ¸ë§Œ ì²˜ë¦¬)
                if (gameState.isMultiplayer && gameState.obstacles && gameState.obstacles.length > 0) {
                    const now = Date.now();
                    const timeSinceRoundStart = now - gameState.roundStartTime;
                    const timeSinceLastRemove = now - gameState.lastObstacleRemoveTime;
                    
                    // ë¼ìš´ë“œ ì‹œì‘ í›„ 15ì´ˆê°€ ì§€ë‚¬ê³ , ë§ˆì§€ë§‰ ì œê±° í›„ 15ì´ˆê°€ ì§€ë‚¬ìœ¼ë©´ ì¥ì• ë¬¼ ì œê±°
                    if (timeSinceRoundStart >= 15000 && timeSinceLastRemove >= 15000) {
                        if (isHost) {
                            // ëœë¤ìœ¼ë¡œ ì¥ì• ë¬¼ í•˜ë‚˜ ì œê±°
                            const randomIndex = Math.floor(Math.random() * gameState.obstacles.length);
                            gameState.obstacles.splice(randomIndex, 1);
                            gameState.lastObstacleRemoveTime = now;
                            
                            // ê²ŒìŠ¤íŠ¸ì—ê²Œ ì¥ì• ë¬¼ ì œê±° ì•Œë¦¼
                            sendMultiplayerData({
                                type: 'removeObstacle',
                                obstacleIndex: randomIndex
                            });
                        }
                    }
                }
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì¼ ë•Œ í”Œë ˆì´ì–´ ìƒíƒœ ì „ì†¡
                if (gameState.isMultiplayer) {
                    sendPlayerState();
                }
            }

            draw();
            
            // ë©”ë‰´ í™”ë©´ì´ ì•„ë‹ ë•Œë§Œ UI ì—…ë°ì´íŠ¸
            if (!gameState.isMenu) {
            updateUI();
            }

            // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ requestAnimationFrame ì‚¬ìš©
            if (!gameState.isMultiplayer) {
            requestAnimationFrame(gameLoop);
            }
        }
        
        // ë©€í‹°í”Œë ˆì´ì–´ìš© ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ ì‹¤í–‰)
        function multiplayerGameUpdate() {
            const currentTime = performance.now();
            if (!lastTime) lastTime = currentTime;
            
            // ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ì²˜ë¦¬
            if (gameState.isSlotMachine) {
                const elapsed = Date.now() - gameState.slotMachineStartTime;
                const slotSpeed = 80;
                const spinningDuration = 1200;
                const displayDuration = 2000;
                
                if (elapsed < spinningDuration) {
                    const newIndex = Math.floor(elapsed / slotSpeed) % randomModes.length;
                    gameState.slotMachineCurrentIndex = newIndex;
                } else if (elapsed < spinningDuration + displayDuration) {
                    if (!gameState.slotMachineSelectedMode) {
                        const randomIndex = Math.floor(Math.random() * randomModes.length);
                        gameState.selectedRandomMode = randomModes[randomIndex];
                        gameState.slotMachineSelectedMode = gameState.selectedRandomMode;
                        gameState.slotMachineCurrentIndex = randomIndex;
                        
                        const randomModeDisplay = document.getElementById('randomModeDisplay');
                        const randomModeName = document.getElementById('randomModeName');
                        const randomModeTooltip = document.getElementById('randomModeTooltip');
                        
                        randomModeDisplay.style.display = 'block';
                        randomModeName.textContent = gameState.selectedRandomMode.name;
                        randomModeTooltip.textContent = gameState.selectedRandomMode.description;
                        
                        player.speed = 3;
                        enemy.speed = 2.5;
                        player.reloadTime = 3000;
                        player.baseReloadTime = 3000;
                        enemy.reloadTime = 3000;
                        enemy.baseReloadTime = 3000;
                        applyRandomMode(gameState.selectedRandomMode.id);
                    }
                } else {
                    gameState.isSlotMachine = false;
                    gameState.countdown = 3;
                    gameState.isPaused = true;
                    
                    const countdownInterval = setInterval(() => {
                        gameState.countdown--;
                        if (gameState.countdown <= 0) {
                            clearInterval(countdownInterval);
                            gameState.isPaused = false;
                        }
                    }, 1000);
                }
            }
            
            // ë©”ë‰´ í™”ë©´ì´ ì•„ë‹ ë•Œë§Œ ê²Œì„ ë¡œì§ ì‹¤í–‰
            if (!gameState.isMenu && !gameState.isPaused && !gameState.isGameOver && !gameState.isSlotMachine) {
                let rawDeltaTime = currentTime - lastTime;
                const deltaTime = Math.min(rawDeltaTime, 100);
                lastTime = currentTime;

                // íƒ€ì´ë¨¸ ê°ì†Œ
                if (rawDeltaTime >= 1000) {
                    gameState.gameTime--;
                    lastTime = currentTime;

                    if (gameState.gameTime <= 0) {
                        if (player.health > enemy.health) {
                            endRound('player');
                        } else if (enemy.health > player.health) {
                            endRound('enemy');
                        } else {
                            endRound(player.health >= enemy.health ? 'player' : 'enemy');
                        }
                    }
                }

                // ìš©ì•”ëª¨ë“œ ì²˜ë¦¬
                const now = Date.now();
                if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'flame') {
                    if (!gameState.flameLastDamage) {
                        gameState.flameLastDamage = now;
                    }
                    
                    if (now - gameState.flameLastDamage >= 5000) {
                        if (player.health > 0) {
                            player.health = Math.max(0, player.health - 0.5);
                            player.damageNumbers.push({
                                damage: 0.5,
                                x: player.x,
                                y: player.y - player.radius - 20,
                                alpha: 1,
                                isFlame: true,
                                startTime: now,
                                duration: 1000
                            });
                        }
                        if (enemy.health > 0) {
                            enemy.health = Math.max(0, enemy.health - 0.5);
                            enemy.damageNumbers.push({
                                damage: 0.5,
                                x: enemy.x,
                                y: enemy.y - enemy.radius - 20,
                                alpha: 1,
                                isFlame: true,
                                startTime: now,
                                duration: 1000
                            });
                        }
                        gameState.flameLastDamage = now;
                        
                        if (player.health <= 0 && !player.isReviving) {
                            const reviveCount = player.reviveCount || 1;
                            const hasRevivedCount = (typeof player.hasRevived === 'number' ? player.hasRevived : (player.hasRevived ? 1 : 0));
                            if (player.hasRevive && hasRevivedCount < reviveCount) {
                                player.hasRevived = hasRevivedCount + 1;
                                player.isReviving = true;
                                player.reviveTime = now + 1000;
                            } else {
                                endRound('enemy');
                            }
                        }
                        if (enemy.health <= 0 && !enemy.isReviving) {
                            const reviveCount = enemy.reviveCount || 1;
                            const hasRevivedCount = (typeof enemy.hasRevived === 'number' ? enemy.hasRevived : (enemy.hasRevived ? 1 : 0));
                            if (enemy.hasRevive && hasRevivedCount < reviveCount) {
                                enemy.hasRevived = hasRevivedCount + 1;
                                enemy.isReviving = true;
                                enemy.reviveTime = now + 1000;
                            } else {
                                endRound('player');
                            }
                        }
                    }
                }


                updatePlayer(deltaTime);
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ AI ì—…ë°ì´íŠ¸
                if (!gameState.isMultiplayer) {
                    updateEnemy(deltaTime);
                }
                
                updateBullets(enemy, deltaTime);
                updateBullets(player, deltaTime);
                
                // ë©€í‹°í”Œë ˆì´ì–´: 15ì´ˆë§ˆë‹¤ ì¥ì• ë¬¼ ì œê±° (í˜¸ìŠ¤íŠ¸ë§Œ ì²˜ë¦¬)
                if (gameState.isMultiplayer && gameState.obstacles && gameState.obstacles.length > 0) {
                    const now = Date.now();
                    const timeSinceRoundStart = now - gameState.roundStartTime;
                    const timeSinceLastRemove = now - gameState.lastObstacleRemoveTime;
                    
                    // ë¼ìš´ë“œ ì‹œì‘ í›„ 15ì´ˆê°€ ì§€ë‚¬ê³ , ë§ˆì§€ë§‰ ì œê±° í›„ 15ì´ˆê°€ ì§€ë‚¬ìœ¼ë©´ ì¥ì• ë¬¼ ì œê±°
                    if (timeSinceRoundStart >= 15000 && timeSinceLastRemove >= 15000) {
                        if (isHost) {
                            // ëœë¤ìœ¼ë¡œ ì¥ì• ë¬¼ í•˜ë‚˜ ì œê±°
                            const randomIndex = Math.floor(Math.random() * gameState.obstacles.length);
                            gameState.obstacles.splice(randomIndex, 1);
                            gameState.lastObstacleRemoveTime = now;
                            
                            // ê²ŒìŠ¤íŠ¸ì—ê²Œ ì¥ì• ë¬¼ ì œê±° ì•Œë¦¼
                            sendMultiplayerData({
                                type: 'removeObstacle',
                                obstacleIndex: randomIndex
                            });
                        }
                    }
                }
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì¼ ë•Œ í”Œë ˆì´ì–´ ìƒíƒœ ì „ì†¡
                if (gameState.isMultiplayer) {
                    sendPlayerState();
                }
            }
        }
        
        // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œ ì‹œì‘/ì¢…ë£Œ ì‹œ ê²Œì„ ë£¨í”„ ì „í™˜
        function startMultiplayerGameLoop() {
            if (gameLoopInterval) return; // ì´ë¯¸ ì‹¤í–‰ ì¤‘ì´ë©´ ë¬´ì‹œ
            
            // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œëŠ” setIntervalë¡œ ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸
            gameLoopInterval = setInterval(() => {
                multiplayerGameUpdate();
            }, 16); // ì•½ 60fps
            
            // ë Œë”ë§ì€ requestAnimationFrameìœ¼ë¡œ ê³„ì†
            function renderLoop() {
                if (!gameState.isMultiplayer) {
                    // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œê°€ ëë‚˜ë©´ ì¸í„°ë²Œ ì •ë¦¬
                    if (gameLoopInterval) {
                        clearInterval(gameLoopInterval);
                        gameLoopInterval = null;
                    }
                    return;
                }
                
                draw();
                if (!gameState.isMenu) {
                    updateUI();
                }
                requestAnimationFrame(renderLoop);
            }
            renderLoop();
        }
        
        function stopMultiplayerGameLoop() {
            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
                gameLoopInterval = null;
            }
        }

        // ê²Œì„ ì‹œì‘ (ë©”ë‰´ì—ì„œ ì‹œì‘)
        gameLoop(0);
    </script>
</body>
</html>
