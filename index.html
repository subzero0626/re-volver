<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¦¬ë³¼ë²„ ë“€ì–¼</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #0f0f1e;
            color: #fff;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #0f0f1e;
        }


        #augmentModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #e94560;
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        #augmentModal h2 {
            color: #e94560;
            margin-bottom: 20px;
        }

        #augmentViewModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        #augmentViewModal h2 {
            color: #4a9eff;
            margin-bottom: 20px;
        }

        .augment-option {
            background: rgba(233, 69, 96, 0.2);
            border: 2px solid #e94560;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .augment-option:hover {
            background: rgba(233, 69, 96, 0.4);
            transform: scale(1.05);
        }

        .augment-option h4 {
            color: #ffc107;
            margin-bottom: 5px;
        }

        #gameOverModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #ffc107;
            border-radius: 15px;
            padding: 40px;
            z-index: 1001;
            text-align: center;
        }

        #gameOverModal h2 {
            color: #ffc107;
            font-size: 32px;
            margin-bottom: 20px;
        }

        #collectionModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 3000;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
            pointer-events: auto;
        }

        #collectionModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        #roomModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 40px;
            padding-bottom: 80px;
            z-index: 3002;
            max-width: 500px;
            width: 90%;
            text-align: center;
            pointer-events: auto;
        }

        #roomModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 30px;
        }

        #controlsModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 3001;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        #controlsModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        #controlsModal .control-item {
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        #controlsModal .control-item h3 {
            color: #4a9eff;
            font-size: 20px;
            margin-bottom: 10px;
        }

        #controlsModal .control-item p {
            color: #ffffff;
            font-size: 16px;
            line-height: 1.6;
            margin: 5px 0;
        }

        #controlsModal .key {
            display: inline-block;
            padding: 5px 10px;
            background: rgba(74, 158, 255, 0.3);
            border: 1px solid #4a9eff;
            border-radius: 5px;
            font-weight: bold;
            margin: 0 5px;
        }

        .collection-item {
            background: rgba(74, 158, 255, 0.1);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            transition: all 0.3s;
            position: relative; /* ì„ íƒ íšŸìˆ˜ ìœ„ì¹˜ ì§€ì •ì„ ìœ„í•´ */
        }
        
        .collection-item .select-count {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(74, 158, 255, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .collection-item.locked {
            background: rgba(100, 100, 100, 0.1);
            border-color: #666;
            filter: grayscale(100%);
            opacity: 0.5;
        }

        .collection-item h4 {
            color: #4a9eff;
            margin-bottom: 8px;
            font-size: 20px;
        }

        .collection-item.locked h4 {
            color: #666;
        }

        .collection-item p {
            color: #ccc;
            margin: 0;
            font-size: 16px;
        }

        .collection-item.locked p {
            color: #888;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s;
        }

        button:hover {
            background: #c7364d;
        }

        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 30, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 40px;
            padding-top: 60px;
            z-index: 2000;
        }

        #mainMenu h1 {
            font-size: 100px;
            color: #e94560;
            margin-bottom: 25px;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            animation: neonFlicker 1.67s ease-in-out;
            animation-fill-mode: forwards;
            opacity: 0;
        }

        @keyframes neonFlicker {
            0% {
                opacity: 0;
                text-shadow: 0 0 5px rgba(233, 69, 96, 0.2);
            }
            20% {
                opacity: 0.3;
                text-shadow: 0 0 10px rgba(233, 69, 96, 0.4);
            }
            40% {
                opacity: 0.1;
                text-shadow: 0 0 5px rgba(233, 69, 96, 0.2);
            }
            60% {
                opacity: 0.6;
                text-shadow: 0 0 18px rgba(233, 69, 96, 0.6);
            }
            80% {
                opacity: 0.3;
                text-shadow: 0 0 10px rgba(233, 69, 96, 0.4);
            }
            100% {
                opacity: 1;
                text-shadow: 0 0 20px rgba(233, 69, 96, 0.5),
                            0 0 40px rgba(233, 69, 96, 0.5),
                            0 0 60px rgba(233, 69, 96, 0.3);
            }
        }

        @keyframes neonFlickerLocked {
            0% {
                opacity: 0;
                text-shadow: 0 0 5px rgba(136, 136, 136, 0.1);
            }
            20% {
                opacity: 0.2;
                text-shadow: 0 0 8px rgba(136, 136, 136, 0.2);
            }
            40% {
                opacity: 0.1;
                text-shadow: 0 0 5px rgba(136, 136, 136, 0.1);
            }
            60% {
                opacity: 0.4;
                text-shadow: 0 0 12px rgba(136, 136, 136, 0.3);
            }
            80% {
                opacity: 0.2;
                text-shadow: 0 0 8px rgba(136, 136, 136, 0.2);
            }
            100% {
                opacity: 0.6;
                text-shadow: 0 0 10px rgba(136, 136, 136, 0.3),
                            0 0 20px rgba(136, 136, 136, 0.2),
                            0 0 30px rgba(136, 136, 136, 0.1);
            }
        }

        #soloPlayText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            margin-left: 12px;
            display: block;
            margin-top: 15px;
        }

        #soloPlayText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #multiPlayText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        #multiPlayText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #multiModeSelection {
            max-height: 0;
            opacity: 0;
            overflow: visible;
            margin-top: 0;
            margin-left: 12px;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
            pointer-events: none;
        }

        #multiModeSelection.expanded {
            max-height: 200px;
            opacity: 1;
            margin-top: 10px;
            pointer-events: auto;
        }

        #settingsText {
            font-size: 42px;
            color: #888;
            cursor: not-allowed;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            opacity: 0.6;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3),
                        0 0 20px rgba(255, 255, 255, 0.2),
                        0 0 30px rgba(255, 255, 255, 0.1);
        }

        .lock-icon {
            filter: grayscale(100%);
            opacity: 0.6;
            margin-right: 4px;
        }

        .menu-text {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            margin-left: 12px;
            display: block;
            margin-top: 15px;
        }

        .menu-text:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        .menu-button {
            background: rgba(233, 69, 96, 0.3);
            border: 3px solid #e94560;
            color: #fff;
            padding: 20px 50px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            margin: 15px;
            transition: all 0.3s;
            min-width: 250px;
        }

        .menu-button:hover {
            background: rgba(233, 69, 96, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.7);
        }

        .menu-button:active {
            transform: scale(1.05);
        }

        #controlsInfo {
            margin-top: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            text-align: center;
            max-width: 600px;
        }

        #controlsInfo h3 {
            color: #4a9eff;
            margin-bottom: 15px;
        }

        #controlsInfo p {
            margin: 8px 0;
            color: #ccc;
        }

        #modeSelection {
            max-height: 0;
            opacity: 0;
            overflow: visible;
            margin-top: 0;
            margin-left: 12px;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
            pointer-events: none;
        }

        #modeSelection.expanded {
            max-height: 200px;
            opacity: 1;
            margin-top: 10px;
            pointer-events: auto;
        }

        .mode-option {
            font-size: 32px;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2),
                        0 0 20px rgba(255, 255, 255, 0.15),
                        0 0 30px rgba(255, 255, 255, 0.1),
                        0 0 40px rgba(255, 255, 255, 0.05);
            margin-top: 8px;
            margin-left: 0;
            display: block;
        }

        .mode-option:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        .menu-text.moved-down {
            margin-top: 120px;
        }

        #multiPlayText.moved-down {
            margin-top: 20px;
            transition: margin-top 0.3s ease;
        }

        #collectionText.moved-down {
            margin-top: 20px;
            transition: margin-top 0.3s ease;
        }

        #settingsText.moved-down {
            margin-top: 120px;
        }

        #randomModeDisplay {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 28px;
            z-index: 100;
            cursor: pointer;
            transition: all 0.3s;
            max-width: 200px;
        }

        #randomModeDisplay::before,
        #randomModeDisplay::after {
            display: none;
        }

        #randomModeDisplay:hover {
            background: transparent;
        }

        #randomModeName {
            display: block;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        #randomModeTooltip {
            position: absolute;
            bottom: 100%;
            right: 0;
            margin-bottom: 10px;
            background: rgba(15, 15, 30, 0.95);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 10px 15px;
            color: #fff;
            font-size: 14px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #randomModeDisplay:hover #randomModeTooltip {
            opacity: 1;
        }


    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="augmentModal">
            <h2>ì¦ê°• ì„ íƒ</h2>
            <p style="margin-bottom: 20px;">íŒ¨ë°°í•˜ì…¨ìŠµë‹ˆë‹¤. ì¦ê°•ì„ ì„ íƒí•˜ì„¸ìš”:</p>
            <div id="enemySelection" style="margin-bottom: 20px; padding: 10px; background: rgba(233, 69, 96, 0.2); border-radius: 5px; display: none;">
                <p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>
            </div>
            <div id="augmentOptions"></div>
        </div>

        <div id="augmentViewModal">
            <h2>ì¦ê°• í™•ì¸</h2>
            <p style="margin-bottom: 20px;">ìŠ¹ë¦¬í•˜ì…¨ìŠµë‹ˆë‹¤! ìƒëŒ€ì˜ ì¦ê°• ì„ íƒì„ í™•ì¸í•˜ì„¸ìš”:</p>
            <div id="opponentSelection" style="margin-bottom: 20px; padding: 10px; background: rgba(233, 69, 96, 0.2); border-radius: 5px;">
                <p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>
            </div>
            <button onclick="closeAugmentViewModal()" style="margin-top: 20px;">í™•ì¸</button>
        </div>

        <div id="gameOverModal">
            <h2 id="gameOverTitle">ê²Œì„ ì¢…ë£Œ</h2>
            <p id="gameOverMessage" style="font-size: 20px; margin-bottom: 20px;"></p>
            <button onclick="restartGame()">ë©”ì¸ë©”ë‰´ë¡œ</button>
        </div>

        <div id="collectionModal">
            <h2>ë„ê°</h2>
            <div id="collectionContent" style="max-height: 70vh; overflow-y: auto; padding: 10px;"></div>
            <button onclick="closeCollectionModal()" style="margin-top: 20px;">ë‹«ê¸°</button>
        </div>

        <div id="roomModal">
            <h2 id="roomModalTitle">ë°© ìƒì„±</h2>
            
            <!-- ë°© ì½”ë“œ í‘œì‹œ (í˜¸ìŠ¤íŠ¸ìš©, ì—°ê²° ì „) -->
            <div id="roomCodeSection" style="display: none;">
                <p style="margin-bottom: 10px;">ë°© ì½”ë“œ:</p>
                <div id="roomCode" style="font-size: 48px; color: #ffc107; text-shadow: 0 0 20px rgba(255, 193, 7, 0.5); letter-spacing: 10px; margin: 20px 0;"></div>
                <p style="color: #aaa; font-size: 14px;">ìƒëŒ€ë°©ì—ê²Œ ì´ ì½”ë“œë¥¼ ì•Œë ¤ì£¼ì„¸ìš”</p>
                <p id="waitingMessage" style="color: #4a9eff; margin-top: 20px;">ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</p>
            </div>
            
            <!-- ë°© ì½”ë“œ ì…ë ¥ (ê²ŒìŠ¤íŠ¸ìš©, ì—°ê²° ì „) -->
            <div id="roomJoinInput" style="display: none;">
                <p style="margin-bottom: 10px;">ë°© ì½”ë“œ ì…ë ¥:</p>
                <input type="text" id="joinCodeInput" maxlength="5" placeholder="12345" style="
                    font-size: 36px;
                    text-align: center;
                    letter-spacing: 8px;
                    width: 200px;
                    padding: 15px;
                    border: 2px solid #4a9eff;
                    border-radius: 10px;
                    background: rgba(0, 0, 0, 0.3);
                    color: #fff;
                    outline: none;
                ">
                <p id="joinErrorMessage" style="color: #e94560; margin-top: 10px; display: none;">ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</p>
                <button id="joinRoomBtn" onclick="joinRoom()" style="margin-top: 20px; background: #4a9eff;">ì…ì¥</button>
            </div>
            
            <!-- íŒ€ ì„ íƒ UI (ì—°ê²° í›„) -->
            <div id="teamSelectUI" style="display: none;">
                <p style="margin-bottom: 20px; color: #aaa;">íŒ€ì„ ì„ íƒí•˜ì„¸ìš”</p>
                <div style="display: flex; justify-content: center; gap: 30px; margin: 20px 0;">
                    <!-- íŒŒë€íŒ€ -->
                    <div id="blueTeamBox" onclick="selectTeam('blue')" style="
                        width: 180px;
                        height: 120px;
                        background: rgba(74, 158, 255, 0.1);
                        border: 2px solid rgba(74, 158, 255, 0.4);
                        border-radius: 15px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: flex-start;
                        padding-top: 15px;
                        cursor: pointer;
                        transition: all 0.3s;
                    ">
                        <p style="color: #4a9eff; font-size: 18px; margin-bottom: 8px;">íŒŒë€íŒ€</p>
                        <p id="blueTeamPlayer" style="color: #fff; font-size: 16px; font-weight: bold;"></p>
                    </div>
                    <!-- ë¹¨ê°„íŒ€ -->
                    <div id="redTeamBox" onclick="selectTeam('red')" style="
                        width: 180px;
                        height: 120px;
                        background: rgba(233, 69, 96, 0.1);
                        border: 2px solid rgba(233, 69, 96, 0.4);
                        border-radius: 15px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: flex-start;
                        padding-top: 15px;
                        cursor: pointer;
                        transition: all 0.3s;
                    ">
                        <p style="color: #e94560; font-size: 18px; margin-bottom: 8px;">ë¹¨ê°„íŒ€</p>
                        <p id="redTeamPlayer" style="color: #fff; font-size: 16px; font-weight: bold;"></p>
                    </div>
                </div>
                <p id="teamSelectStatus" style="color: #aaa; margin-top: 10px;"></p>
                <p id="guestWaitingMessage" style="display: none; color: #4a9eff; margin-top: 15px;">í˜¸ìŠ¤íŠ¸ê°€ ê²Œì„ì„ ì‹œì‘í•˜ë©´ ì‹œì‘ë©ë‹ˆë‹¤...</p>
            </div>
            
            <!-- í•˜ë‹¨ ë²„íŠ¼ ì˜ì—­ -->
            <div style="position: absolute; bottom: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between;">
                <button onclick="closeRoomModal()" style="background: #e94560; padding: 12px 30px;">ë‚˜ê°€ê¸°</button>
                <button id="startGameBtn" onclick="sendStartGame()" style="display: none; background: #00cc66; font-size: 18px; padding: 12px 30px;">ê²Œì„ ì‹œì‘</button>
            </div>
        </div>
        
        <div id="disconnectModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(15, 15, 30, 1); border: 3px solid #e94560; border-radius: 15px; padding: 40px; z-index: 4000; text-align: center;">
            <h2 style="color: #e94560; margin-bottom: 20px;">ì—°ê²° ëŠê¹€</h2>
            <p style="color: #fff; margin-bottom: 30px;">ìƒëŒ€ë°©ê³¼ì˜ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.</p>
            <button onclick="confirmDisconnect()" style="background: #4a9eff; padding: 15px 40px;">í™•ì¸</button>
        </div>
        
        <div id="nicknameModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(15, 15, 30, 1); border: 3px solid #ffc107; border-radius: 15px; padding: 50px; z-index: 5000; text-align: center; min-width: 400px;">
            <h2 style="color: #ffc107; margin-bottom: 15px; font-size: 28px;">ë¦¬ë³¼ë²„ ë“€ì–¼ì— ì˜¤ì‹ ê±¸ í™˜ì˜í•©ë‹ˆë‹¤</h2>
            <p style="color: #fff; margin-bottom: 30px; font-size: 18px;">í”Œë ˆì´ì–´ë‹˜ì˜ ë‹‰ë„¤ì„ì„ ì§€ì–´ì£¼ì„¸ìš”</p>
            <input type="text" id="nicknameInput" maxlength="12" placeholder="ë‹‰ë„¤ì„ ì…ë ¥" style="
                font-size: 24px;
                text-align: center;
                width: 280px;
                padding: 15px;
                border: 2px solid #ffc107;
                border-radius: 10px;
                background: rgba(0, 0, 0, 0.3);
                color: #fff;
                outline: none;
                margin-bottom: 20px;
            ">
            <br>
            <button onclick="saveNickname()" style="background: #ffc107; color: #000; padding: 15px 50px; font-size: 18px; font-weight: bold;">í™•ì¸</button>
        </div>
        

        <div id="controlsModal">
            <h2>ì¡°ì‘ë²•</h2>
            <div class="control-item">
                <h3>ì´ë™</h3>
                <p><span class="key">W</span> ìœ„ë¡œ ì´ë™</p>
                <p><span class="key">S</span> ì•„ë˜ë¡œ ì´ë™</p>
                <p><span class="key">A</span> ì™¼ìª½ìœ¼ë¡œ ì´ë™</p>
                <p><span class="key">D</span> ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™</p>
            </div>
            <div class="control-item">
                <h3>ì¡°ì¤€ ë° ë°œì‚¬</h3>
                <p>ë§ˆìš°ìŠ¤ë¥¼ ì›€ì§ì—¬ ì¡°ì¤€</p>
                <p><span class="key">ë§ˆìš°ìŠ¤ ì™¼ìª½ í´ë¦­</span> ë°œì‚¬</p>
            </div>
            <button onclick="closeControlsModal()" style="margin-top: 20px; padding: 10px 30px; background: #4a9eff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">ë‹«ê¸°</button>
        </div>

        <div id="mainMenu">
            <div id="nicknameDisplay" style="display: none; position: absolute; top: 25px; right: 30px; color: #fff; font-size: 24px; opacity: 0.7;">
                <span id="playerNickname" style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);"></span>
            </div>
            <h1>ë¦¬ë³¼ë²„ ë“€ì–¼</h1>
            <span id="soloPlayText" onclick="showModeSelection()">ì†”ë¡œ í”Œë ˆì´</span>
            <div id="modeSelection">
                <span class="mode-option" onclick="startSoloGame('classic')">- í´ë˜ì‹ ëª¨ë“œ</span>
                <span class="mode-option" onclick="startSoloGame('random')">- ëœë¤ ëª¨ë“œ</span>
            </div>
            <span id="multiPlayText" onclick="showMultiModeSelection()">ë©€í‹° í”Œë ˆì´</span>
            <div id="multiModeSelection">
                <span class="mode-option" onclick="createRoom()">- ë°© ìƒì„±</span>
                <span class="mode-option" onclick="showJoinRoom()">- ë°© ì…ì¥</span>
            </div>
            <span class="menu-text" id="collectionText" onclick="openCollectionModal()">ë„ê°</span>
            <span id="settingsText"><span class="lock-icon">ğŸ”’</span>ìƒì </span>
            <span class="menu-text" id="controlsText" onclick="openControlsModal()">ì¡°ì‘ë²•</span>
        </div>

        <div id="randomModeDisplay" style="display: none;">
            <div id="randomModeTooltip"></div>
            <span id="randomModeName"></span>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ í™”ë©´ ì „ì²´ë¡œ ì„¤ì •
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ë©”ì¸ ë©”ë‰´ ì™¸ë¶€ í´ë¦­ ì‹œ ëª¨ë“œ ì„ íƒ ì ‘ê¸°
        document.addEventListener('click', (e) => {
            const mainMenu = document.getElementById('mainMenu');
            const modeSelection = document.getElementById('modeSelection');
            const multiModeSelection = document.getElementById('multiModeSelection');
            const soloPlayText = document.getElementById('soloPlayText');
            const multiPlayText = document.getElementById('multiPlayText');
            
            // ë©”ì¸ ë©”ë‰´ê°€ í‘œì‹œë˜ì–´ ìˆì„ ë•Œ
            if (mainMenu && mainMenu.style.display === 'flex') {
                // ì†”ë¡œí”Œë ˆì´ ëª¨ë“œ ì„ íƒì´ í¼ì³ì ¸ ìˆì„ ë•Œ
                if (modeSelection && modeSelection.classList.contains('expanded')) {
                    // í´ë¦­í•œ ìš”ì†Œê°€ ëª¨ë“œ ì„ íƒ ì˜ì—­ì´ë‚˜ ì†”ë¡œ í”Œë ˆì´ í…ìŠ¤íŠ¸ê°€ ì•„ë‹ ë•Œ
                    if (!modeSelection.contains(e.target) && !soloPlayText.contains(e.target)) {
                        collapseModeSelection();
                    }
                }
                // ë©€í‹°í”Œë ˆì´ ëª¨ë“œ ì„ íƒì´ í¼ì³ì ¸ ìˆì„ ë•Œ
                if (multiModeSelection && multiModeSelection.classList.contains('expanded')) {
                    // í´ë¦­í•œ ìš”ì†Œê°€ ë©€í‹° ëª¨ë“œ ì„ íƒ ì˜ì—­ì´ë‚˜ ë©€í‹° í”Œë ˆì´ í…ìŠ¤íŠ¸ê°€ ì•„ë‹ ë•Œ
                    if (!multiModeSelection.contains(e.target) && !multiPlayText.contains(e.target)) {
                        collapseMultiModeSelection();
                    }
                }
            }
        });

        // ê²Œì„ ìƒíƒœ
        let gameState = {
            round: 1,
            playerWins: 0,
            enemyWins: 0,
            winsNeeded: 5, // 5ë¼ìš´ë“œ ì„ ìŠ¹ì œ
            gameTime: 180, // 3ë¶„ = 180ì´ˆ
            isGameOver: false,
            isPaused: false,
            isMenu: true, // ë©”ë‰´ í™”ë©´ í‘œì‹œ ì—¬ë¶€
            roundWins: [], // ê° ë¼ìš´ë“œì˜ ìŠ¹ì ê¸°ë¡ ('player' ë˜ëŠ” 'enemy')
            countdown: 3, // ë¼ìš´ë“œ ì‹œì‘ ì¹´ìš´íŠ¸ë‹¤ìš´
            augmentCountdown: 0, // ì¦ê°• ì„ íƒ ì¹´ìš´íŠ¸ë‹¤ìš´ (0ì´ë©´ í‘œì‹œ ì•ˆí•¨)
            showOpponentSelecting: false, // ìƒëŒ€ ì„ íƒ ì¤‘ ë©”ì‹œì§€ í‘œì‹œ ì—¬ë¶€
            shake: {
                intensity: 0,
                duration: 0
            },
            // ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ
            isSlotMachine: false,
            slotMachineStartTime: 0,
            slotMachineCurrentIndex: 0,
            slotMachineSelectedMode: null,
            // ë§µ í¬ê¸° (ê¸°ë³¸ê°’ì€ ì „ì²´ ìº”ë²„ìŠ¤)
            mapBounds: {
                minX: 0,
                minY: 0,
                maxX: 0, // initGameì—ì„œ ì„¤ì •
                maxY: 0  // initGameì—ì„œ ì„¤ì •
            },
            // ë©€í‹°í”Œë ˆì´ ìƒíƒœ
            isMultiplayer: false,
            multiplayerReady: false, // ì–‘ìª½ ëª¨ë‘ ì¤€ë¹„ë¨
            lastSyncTime: 0 // ë§ˆì§€ë§‰ ë™ê¸°í™” ì‹œê°„
        };

        // íŠœí† ë¦¬ì–¼ ìƒíƒœ

        // í”Œë ˆì´ì–´
        const player = {
            x: canvas.width * 0.2,
            y: canvas.height * 0.5,
            radius: 30, // 1.5ë°° ì¦ê°€ (20 -> 30)
            speed: 3,
            health: 5,
            displayHealth: 5, // í‘œì‹œë˜ëŠ” ì²´ë ¥ (ì• ë‹ˆë©”ì´ì…˜ìš©)
            maxHealth: 5,
            ammo: 6,
            maxAmmo: 6,
            reloadTime: 3000, // 3ì´ˆ
            isReloading: false,
            reloadStartTime: 0, // ì¬ì¥ì „ ì‹œì‘ ì‹œê°„
            angle: 0,
            color: '#4a9eff',
            bullets: [],
            lastShot: 0,
            shootCooldown: 1000, // 1ì´ˆë¡œ ê³ ì •
            damage: 1, // ê¸°ë³¸ ë°ë¯¸ì§€
            augmentations: [],
            // ì¦ê°• ê´€ë ¨ ìƒíƒœ
            bulletSpeedMultiplier: 1,
            bulletSizeMultiplier: 1, // íƒ„í™˜ í¬ê¸° ë°°ìœ¨
            hasCritical: false,
            hasDoubleShot: false,
            hasDodge: false,
            hasRevive: false,
            hasRevived: 0, // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜
            hasDeepWound: false,
            hasOneShotOneKill: false,
            hasPoisonBullet: false,
            hasReloadHeal: false,
            hasSurvivalInstinct: false, // ìƒì¡´ë³¸ëŠ¥
            hasLastBullet: false, // ë¹„ì¥ì˜ í•œë°œ
            hasRecoveryContract: false, // íšŒë³µê³„ì•½
            hasRecoveryContractUsed: false, // íšŒë³µê³„ì•½ ì‚¬ìš© ì—¬ë¶€ (ë¼ìš´ë“œë‹¹ í•œë²ˆ)
            hasFocusedFire: false, // ì§‘ì¤‘ ì‚¬ê²©
            hasShotgun: false, // ìƒ·ê±´
            hasRagged: false, // ë‹¤ë‹¤ìµì„ 
            hasGhost: false, // ìœ ë ¹
            hasFortify: false, // ê±°ì í™•ë³´
            isFortified: false, // ê±°ì  í™•ë³´ ìƒíƒœ
            fortifyStartTime: 0, // ê±°ì  í™•ë³´ ì‹œì‘ ì‹œê°„
            lastPosition: { x: 0, y: 0 }, // ë§ˆì§€ë§‰ ìœ„ì¹˜
            stationaryTime: 0, // ì •ì§€í•œ ì‹œê°„
            hasOverheat: false, // ê³¼ì—´
            overheatHitCount: 0, // ì—°ì† íˆíŠ¸ ì¹´ìš´íŠ¸
            lastHitTime: 0, // ë§ˆì§€ë§‰ íˆíŠ¸ ì‹œê°„
            hasGamble: false, // ë„ë°•
            hasWeaken: false, // ì•½í™”
            isWeakened: false, // ì•½í™” ìƒíƒœ
            weakenEndTime: 0, // ì•½í™” ì¢…ë£Œ ì‹œê°„
            hasDamageBoost: false, // ë°ë¯¸ì§€ 1.2ë°°
            hasLightning: false, // ë²ˆê°œ
            isStunned: false, // ê¸°ì ˆ ìƒíƒœ
            stunEndTime: 0, // ê¸°ì ˆ ì¢…ë£Œ ì‹œê°„
            hasShield: false, // ë°©ì–´ë§‰
            shieldReady: false, // ë°©ì–´ë§‰ ì¤€ë¹„ë¨
            shieldCooldown: 0, // ë°©ì–´ë§‰ ì¿¨íƒ€ì„
            hasRegeneration: false, // ì¬ìƒ
            lastRegenTime: 0, // ë§ˆì§€ë§‰ íšŒë³µ ì‹œê°„
            isVulnerable: false, // ì·¨ì•½ ìƒíƒœ
            vulnerabilityUsed: false, // ì·¨ì•½ ì‚¬ìš© ì—¬ë¶€
            poisonEffects: [], // ë… íš¨ê³¼ ë°°ì—´ {target, startTime, duration, damagePerSecond}
            isDodging: false,
            dodgeStartTime: 0, // êµ¬ë¥´ê¸° ì‹œì‘ ì‹œê°„
            dodgeEndTime: 0,
            dodgeStartX: 0,
            dodgeStartY: 0,
            dodgeTargetX: 0,
            dodgeTargetY: 0,
            dodgeTrail: [], // êµ¬ë¥´ê¸° ì”ìƒ ìœ„ì¹˜ ë°°ì—´
            lastDodgeTime: 0, // ë§ˆì§€ë§‰ êµ¬ë¥´ê¸° ì‹œê°„ (ì¿¨íƒ€ì„ìš©)
            isReviving: false,
            reviveTime: 0,
            isInvincible: false,
            invincibleEndTime: 0,
            slowEndTime: 0,
            damageNumbers: [] // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œìš©
        };

        // ì  (AI)
        const enemy = {
            x: canvas.width * 0.8,
            y: canvas.height * 0.5,
            radius: 30, // 1.5ë°° ì¦ê°€ (20 -> 30)
            speed: 2.5,
            health: 5,
            displayHealth: 5, // í‘œì‹œë˜ëŠ” ì²´ë ¥ (ì• ë‹ˆë©”ì´ì…˜ìš©)
            maxHealth: 5,
            ammo: 6,
            maxAmmo: 6,
            reloadTime: 3000, // 3ì´ˆ
            isReloading: false,
            reloadStartTime: 0, // ì¬ì¥ì „ ì‹œì‘ ì‹œê°„
            angle: Math.PI,
            color: '#e94560',
            bullets: [],
            lastShot: 0,
            shootCooldown: 1000, // 1ì´ˆë¡œ ê³ ì •
            damage: 1, // ê¸°ë³¸ ë°ë¯¸ì§€
            augmentations: [],
            // ì¦ê°• ê´€ë ¨ ìƒíƒœ
            bulletSpeedMultiplier: 1,
            bulletSizeMultiplier: 1, // íƒ„í™˜ í¬ê¸° ë°°ìœ¨
            hasCritical: false,
            hasDoubleShot: false,
            hasDodge: false,
            hasRevive: false,
            hasRevived: 0, // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜
            hasDeepWound: false,
            hasOneShotOneKill: false,
            hasPoisonBullet: false,
            hasReloadHeal: false,
            hasSurvivalInstinct: false, // ìƒì¡´ë³¸ëŠ¥
            hasLastBullet: false, // ë¹„ì¥ì˜ í•œë°œ
            hasRecoveryContract: false, // íšŒë³µê³„ì•½
            hasRecoveryContractUsed: false, // íšŒë³µê³„ì•½ ì‚¬ìš© ì—¬ë¶€ (ë¼ìš´ë“œë‹¹ í•œë²ˆ)
            hasFocusedFire: false, // ì§‘ì¤‘ ì‚¬ê²©
            hasShotgun: false, // ìƒ·ê±´
            hasRagged: false, // ë‹¤ë‹¤ìµì„ 
            hasGhost: false, // ìœ ë ¹
            hasFortify: false, // ê±°ì í™•ë³´
            isFortified: false, // ê±°ì  í™•ë³´ ìƒíƒœ
            fortifyStartTime: 0, // ê±°ì  í™•ë³´ ì‹œì‘ ì‹œê°„
            lastPosition: { x: 0, y: 0 }, // ë§ˆì§€ë§‰ ìœ„ì¹˜
            stationaryTime: 0, // ì •ì§€í•œ ì‹œê°„
            hasOverheat: false, // ê³¼ì—´
            overheatHitCount: 0, // ì—°ì† íˆíŠ¸ ì¹´ìš´íŠ¸
            lastHitTime: 0, // ë§ˆì§€ë§‰ íˆíŠ¸ ì‹œê°„
            hasGamble: false, // ë„ë°•
            hasWeaken: false, // ì•½í™”
            isWeakened: false, // ì•½í™” ìƒíƒœ
            weakenEndTime: 0, // ì•½í™” ì¢…ë£Œ ì‹œê°„
            hasDamageBoost: false, // ë°ë¯¸ì§€ 1.2ë°°
            hasLightning: false, // ë²ˆê°œ
            isStunned: false, // ê¸°ì ˆ ìƒíƒœ
            stunEndTime: 0, // ê¸°ì ˆ ì¢…ë£Œ ì‹œê°„
            hasShield: false, // ë°©ì–´ë§‰
            shieldReady: false, // ë°©ì–´ë§‰ ì¤€ë¹„ë¨
            shieldCooldown: 0, // ë°©ì–´ë§‰ ì¿¨íƒ€ì„
            hasRegeneration: false, // ì¬ìƒ
            lastRegenTime: 0, // ë§ˆì§€ë§‰ íšŒë³µ ì‹œê°„
            hasEvasiveManeuver: false, // íšŒí”¼ê¸°ë™
            hasCombatExperience: false, // ì „íˆ¬ ê²½í—˜
            combatExperienceRounds: 0, // ì „íˆ¬ ê²½í—˜ ë¼ìš´ë“œ ìˆ˜
            hasHallucination: false, // í™˜ê°
            hasTasteOfBlood: false, // í”¼ì˜ ë§›
            hasCannon: false, // ëŒ€í¬
            hasTimeBarrier: false, // ì‹œê°„ì¥ë§‰
            timeBarrierRadius: 150, // ì‹œê°„ì¥ë§‰ ë°˜ì§€ë¦„
            hasBouncyBullet: false, // í†µí†µíƒ„
            hasGamble2: false, // ìŠ¤ë„¤ì´í¬
            hasReflect: false, // ë°˜ì‚¬
            reflectActive: false, // ë°˜ì‚¬ ë³´í˜¸ë§‰ í™œì„±í™” ì—¬ë¶€
            reflectCooldown: 0, // ë°˜ì‚¬ ì¿¨íƒ€ì„
            reflectEndTime: 0, // ë°˜ì‚¬ ì¢…ë£Œ ì‹œê°„
            hasGatling: false, // ê²Œí‹€ë§
            gatlingBullets: 0, // ê²Œí‹€ë§ ë‚¨ì€ ë°œì‚¬ ìˆ˜
            gatlingNextShot: 0, // ê²Œí‹€ë§ ë‹¤ìŒ ë°œì‚¬ ì‹œê°„
            hasTimeStop: false, // ì‹œê°„ì •ì§€
            timeStopCooldown: 0, // ì‹œê°„ì •ì§€ ì¿¨íƒ€ì„
            timeStopActive: false, // ì‹œê°„ì •ì§€ í™œì„±í™” ì—¬ë¶€
            timeStopEndTime: 0, // ì‹œê°„ì •ì§€ ì¢…ë£Œ ì‹œê°„
            hasScatter: false, // ë¹„ì‚°íƒ„
            hasRocket: false, // ë¡œì¼“íƒ„
            hasTrinity: false, // ì‚¼ìœ„ì¼ì²´
            hasJudgment: false, // ì„ ê³ 
            isJudgmentPushing: false, // ì„ ê³  ë°€ë ¤ë‚˜ëŠ” ì¤‘
            judgmentPushStartX: 0,
            judgmentPushStartY: 0,
            judgmentPushTargetX: 0,
            judgmentPushTargetY: 0,
            judgmentPushStartTime: 0,
            judgmentPushDuration: 0,
            hasBoomerang: false, // ë¶€ë§¤ë‘
            isVulnerable: false, // ì·¨ì•½ ìƒíƒœ
            vulnerabilityUsed: false, // ì·¨ì•½ ì‚¬ìš© ì—¬ë¶€
            poisonEffects: [], // ë… íš¨ê³¼ ë°°ì—´ {target, startTime, duration, damagePerSecond}
            isDodging: false,
            dodgeStartTime: 0, // êµ¬ë¥´ê¸° ì‹œì‘ ì‹œê°„
            dodgeEndTime: 0,
            dodgeStartX: 0,
            dodgeStartY: 0,
            dodgeTargetX: 0,
            dodgeTargetY: 0,
            dodgeTrail: [], // êµ¬ë¥´ê¸° ì”ìƒ ìœ„ì¹˜ ë°°ì—´
            lastDodgeTime: 0, // ë§ˆì§€ë§‰ êµ¬ë¥´ê¸° ì‹œê°„ (ì¿¨íƒ€ì„ìš©)
            isReviving: false,
            reviveTime: 0,
            isInvincible: false,
            invincibleEndTime: 0,
            slowEndTime: 0,
            aiTimer: 0,
            aiDirection: Math.random() * Math.PI * 2,
            usePrediction: false, // ë°œì‚¬ íŒ¨í„´: false=í˜„ì¬ ìœ„ì¹˜, true=ì˜ˆì¸¡ ìœ„ì¹˜
            lastPlayerX: 0, // í”Œë ˆì´ì–´ ì´ì „ ìœ„ì¹˜ (ì´ë™ ë°©í–¥ ê³„ì‚°ìš©)
            lastPlayerY: 0,
            playerVelocity: { x: 0, y: 0 }, // í”Œë ˆì´ì–´ ì´ë™ ì†ë„
            lastPlayerBulletCount: 0, // í”Œë ˆì´ì–´ ì´ì•Œ ê°œìˆ˜ ì¶”ì  (ë°œì‚¬ ê°ì§€ìš©)
            bulletDodgeTargetY: 0, // ì´ì•Œ íšŒí”¼ ëª©í‘œ Y ìœ„ì¹˜
            isDodgingBullet: false, // ì´ì•Œ íšŒí”¼ ì¤‘ì¸ì§€
            damageNumbers: [] // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œìš©
        };

        // ì¦ê°• ëª©ë¡
        // ì¦ê°• ì¤‘ì²© íšŸìˆ˜ ê³„ì‚° í—¬í¼ í•¨ìˆ˜
        function getAugmentCount(character, augmentId) {
            return character.augmentations.filter(aug => aug.id === augmentId).length;
        }

        const augmentations = [
            { 
                id: 'health', 
                name: 'ìµœëŒ€ì²´ë ¥ +1.5', 
                description: 'ìµœëŒ€ ì²´ë ¥ +1.5', 
                effect: (character) => { 
                    // ì¤‘ì²© ê°€ëŠ¥: íšŸìˆ˜ë§Œí¼ ì¶”ê°€
                    const count = character.augmentations.filter(aug => aug.id === 'health').length + 1;
                    character.maxHealth += 1.5;
                    character.health += 1.5;
                } 
            },
            { 
                id: 'speed', 
                name: 'ì´ë™ì†ë„ +25%', 
                description: 'ì´ë™ ì†ë„ +25%', 
                effect: (character) => { 
                    character.speed *= 1.25; 
                } 
            },
            { 
                id: 'bulletSpeed', 
                name: 'ì´ì•Œ ì†ë„ +25%', 
                description: 'ì´ì•Œ ì†ë„ +25%', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 1.25; 
                } 
            },
            { 
                id: 'ammo', 
                name: 'íƒ„ì•½ +1', 
                description: 'ìµœëŒ€ íƒ„ì•½ +1', 
                effect: (character) => { 
                    character.maxAmmo += 1; 
                    character.ammo += 1; 
                } 
            },
            { 
                id: 'fireRate', 
                name: 'ë°œì‚¬ì†ë„ -25%', 
                description: 'ë°œì‚¬ì†ë„ -25%', 
                effect: (character) => { 
                    character.shootCooldown *= 0.75; 
                } 
            },
            { 
                id: 'reload', 
                name: 'ì¬ì¥ì „ ì†ë„ -1.5ì´ˆ', 
                description: 'ì¬ì¥ì „ ì‹œê°„ -1.5ì´ˆ', 
                effect: (character) => { 
                    character.reloadSpeedCount = (character.reloadSpeedCount || 0) + 1;
                    // ì¤‘ì²© ì ìš©: ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ì—ì„œ ì¤‘ì²© íšŸìˆ˜ * 1.5ì´ˆë¥¼ ëºŒ
                    const baseReloadTime = character.baseReloadTime || 3000;
                    character.reloadTime = Math.max(1000, baseReloadTime - (1500 * character.reloadSpeedCount));
                } 
            },
            { 
                id: 'critical', 
                name: 'í¬ë¦¬í‹°ì»¬', 
                description: 'í”¼ê²© ì‹œ 25% í™•ë¥ ë¡œ ë°ë¯¸ì§€ 2ë°°', 
                effect: (character) => { 
                    character.hasCritical = true; 
                    character.criticalCount = (character.criticalCount || 0) + 1; 
                } 
            },
            { 
                id: 'doubleShot', 
                name: 'ë”ë¸”ìƒ·', 
                description: 'ë°œì‚¬ ì‹œ 25% í™•ë¥ ë¡œ ì¶”ê°€ ë°œì‚¬', 
                effect: (character) => { 
                    character.hasDoubleShot = true; 
                    character.doubleShotCount = (character.doubleShotCount || 0) + 1; 
                } 
            },
            { 
                id: 'dodge', 
                name: 'êµ¬ë¥´ê¸°', 
                description: 'ìš°í´ë¦­ìœ¼ë¡œ êµ¬ë¥´ê¸° (êµ¬ë¥´ëŠ” ë™ì•ˆ ë¬´ì )', 
                effect: (character) => { 
                    character.hasDodge = true; 
                } 
            },
            { 
                id: 'revive', 
                name: 'ë¶€í™œ', 
                description: 'ì£½ì—ˆì„ ë•Œ 2ì´ˆ í›„ ì²´ë ¥ 1ë¡œ ë¶€í™œ', 
                effect: (character) => { 
                    character.hasRevive = true; 
                    character.reviveCount = (character.reviveCount || 0) + 1; 
                } 
            },
            { 
                id: 'deepWound', 
                name: 'ê¹Šì€ ìƒì²˜', 
                description: 'í”¼ê²© ì‹œ ìƒëŒ€ ì´ë™ì†ë„ -25%', 
                effect: (character) => { 
                    character.hasDeepWound = true; 
                    character.deepWoundCount = (character.deepWoundCount || 0) + 1; 
                } 
            },
            { 
                id: 'giant', 
                name: 'ê±°ëŒ€í™”', 
                description: 'ì²´ë ¥ +3, ì´ë™ì†ë„ -25%', 
                effect: (character) => { 
                    character.maxHealth += 3; 
                    character.health += 3; 
                    character.speed *= 0.75; 
                } 
            },
            { 
                id: 'sniper', 
                name: 'ì €ê²©ìˆ˜', 
                description: 'ì´ì•Œ ì†ë„ +75%, ìµœëŒ€ íƒ„ì•½ -3', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 1.75; 
                    character.maxAmmo = Math.max(1, character.maxAmmo - 3); 
                    character.ammo = Math.min(character.ammo, character.maxAmmo); 
                } 
            },
            { 
                id: 'oneShotOneKill', 
                name: 'ì›ìƒ·ì›í‚¬', 
                description: 'ìµœëŒ€ íƒ„ì•½ 1ê°œë¡œ ê³ ì •, ì´ì•Œ ë°ë¯¸ì§€ *3', 
                effect: (character) => { 
                    character.maxAmmo = 1; 
                    character.ammo = Math.min(character.ammo, 1); 
                    character.damage = (character.damage || 1) * 3; // ì´ì•Œ ë°ë¯¸ì§€ *3
                    character.hasOneShotOneKill = true; 
                } 
            },
            { 
                id: 'poisonBullet', 
                name: 'ë… íƒ„í™˜', 
                description: 'ì  í”¼ê²©ì‹œ 0.2ë°ë¯¸ì§€ë¥¼ 1ì´ˆê°„ê²©ìœ¼ë¡œ 2ë²ˆ ì¶”ê°€í”¼í•´', 
                effect: (character) => { 
                    character.hasPoisonBullet = true; 
                    character.poisonBulletCount = (character.poisonBulletCount || 0) + 1; 
                } 
            },
            { 
                id: 'reloadHeal', 
                name: 'ì¬ì¥ì „ íšŒë³µ', 
                description: 'ì¬ì¥ì „ ì‹œ ì²´ë ¥ 1íšŒë³µ', 
                effect: (character) => { 
                    character.hasReloadHeal = true; 
                    character.reloadHealCount = (character.reloadHealCount || 0) + 1; 
                } 
            },
            { 
                id: 'bigBullet', 
                name: 'í° íƒ„í™˜', 
                description: 'íƒ„í™˜ í¬ê¸° +50%', 
                effect: (character) => { 
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 1.5; 
                } 
            },
            { 
                id: 'survivalInstinct', 
                name: 'ìƒì¡´ë³¸ëŠ¥', 
                description: 'ì²´ë ¥ì´ 1ì¼ ë•Œ ì´ë™ì†ë„ +50%', 
                effect: (character) => { 
                    character.hasSurvivalInstinct = true; 
                    character.survivalInstinctCount = (character.survivalInstinctCount || 0) + 1; 
                } 
            },
            { 
                id: 'lastBullet', 
                name: 'ë¹„ì¥ì˜ í•œë°œ', 
                description: 'ë§ˆì§€ë§‰ íƒ„í™˜ì˜ ë°ë¯¸ì§€ +1.5', 
                effect: (character) => { 
                    character.hasLastBullet = true; 
                    character.lastBulletCount = (character.lastBulletCount || 0) + 1; 
                } 
            },
            { 
                id: 'recoveryContract', 
                name: 'íšŒë³µê³„ì•½', 
                description: 'ì²´ë ¥ì´ 1ì¼ ë•Œ ì²´ë ¥ 2íšŒë³µ', 
                effect: (character) => { 
                    character.hasRecoveryContract = true; 
                    character.recoveryContractCount = (character.recoveryContractCount || 0) + 1; 
                } 
            },
            { 
                id: 'focusedFire', 
                name: 'ì§‘ì¤‘ ì‚¬ê²©', 
                description: 'í”¼ê²©ì‹œ 50% í™•ë¥ ë¡œ ìƒëŒ€ì—ê²Œ ì·¨ì•½ ë¶€ì—¬ (ë‹¤ìŒ ë°ë¯¸ì§€ *1.5ë°°)', 
                effect: (character) => { 
                    character.hasFocusedFire = true; 
                } 
            },
            { 
                id: 'shotgun', 
                name: 'ìƒ·ê±´', 
                description: 'ëª¨ë“  íƒ„ì•½ì„ Â±20ë„ ë²”ìœ„ì—ì„œ í•œë²ˆì— ë°œì‚¬', 
                effect: (character) => { 
                    character.hasShotgun = true; 
                } 
            },
            { 
                id: 'ragged', 
                name: 'ë‹¤ë‹¤ìµì„ ', 
                description: 'ìµœëŒ€ íƒ„ì•½ +3, ë°œì‚¬ì†ë„ -50%, ì´ì•Œ ë°ë¯¸ì§€ *0.5', 
                effect: (character) => { 
                    character.maxAmmo += 3; 
                    character.ammo += 3; 
                    character.shootCooldown *= 0.5; // ë°œì‚¬ì†ë„ -50% (ì¿¨íƒ€ì„ ì ˆë°˜)
                    character.damage = (character.damage || 1) * 0.5; // ì´ì•Œ ë°ë¯¸ì§€ *0.5
                    character.hasRagged = true; 
                } 
            },
            { 
                id: 'ghost', 
                name: 'ìœ ë ¹', 
                description: 'ìƒëŒ€ì˜ ê³µê²©ì„ 25% í™•ë¥ ë¡œ ë¬´ì‹œ', 
                effect: (character) => { 
                    character.hasGhost = true; 
                    character.ghostCount = (character.ghostCount || 0) + 1; 
                } 
            },
            { 
                id: 'fortify', 
                name: 'ê±°ì í™•ë³´', 
                description: '3ì´ˆë™ì•ˆ ê°€ë§Œíˆ ì„œìˆì„ ê²½ìš° ë‹¤ì‹œ ì›€ì§ì¼ë•Œê¹Œì§€ ë°›ëŠ” ë°ë¯¸ì§€ *0.5', 
                effect: (character) => { 
                    character.hasFortify = true; 
                    character.fortifyStartTime = 0; // ê±°ì  í™•ë³´ ì‹œì‘ ì‹œê°„
                    character.isFortified = false; // ê±°ì  í™•ë³´ ìƒíƒœ
                    character.lastPosition = { x: character.x, y: character.y }; // ë§ˆì§€ë§‰ ìœ„ì¹˜
                    character.stationaryTime = 0; // ì •ì§€í•œ ì‹œê°„
                } 
            },
            { 
                id: 'overheat', 
                name: 'ê³¼ì—´', 
                description: 'ìƒëŒ€ì—ê²Œ ì´ì•Œì„ ì—°ì†ìœ¼ë¡œ ë§ì¶œ ì‹œ ë§ì¶œë•Œë§ˆë‹¤ ë°ë¯¸ì§€ 0.5ë°°ì”© ìƒìŠ¹', 
                effect: (character) => { 
                    character.hasOverheat = true; 
                    character.overheatHitCount = 0; // ì—°ì† íˆíŠ¸ ì¹´ìš´íŠ¸
                    character.lastHitTime = 0; // ë§ˆì§€ë§‰ íˆíŠ¸ ì‹œê°„
                } 
            },
            { 
                id: 'gamble', 
                name: 'ë„ë°•', 
                description: 'ì´ì•Œì´ Â±10ë„ ë²”ìœ„ì—ì„œ ëœë¤í•˜ê²Œ ë‚˜ê°€ì§€ë§Œ ë°ë¯¸ì§€ëŠ” 1~2ë°° ì‚¬ì´ë¡œ ëœë¤', 
                effect: (character) => { 
                    character.hasGamble = true; 
                } 
            },
            { 
                id: 'weaken', 
                name: 'ì•½í™”', 
                description: 'ìƒëŒ€ì—ê²Œ ì´ì•Œì„ ë§ì¶œ ì‹œ 3ì´ˆë™ì•ˆ ìƒëŒ€ ë°ë¯¸ì§€ -0.25', 
                effect: (character) => { 
                    character.hasWeaken = true; 
                    character.weakenCount = (character.weakenCount || 0) + 1; 
                } 
            },
            { 
                id: 'damageBoost', 
                name: 'ë°ë¯¸ì§€ 1.2ë°°', 
                description: 'ì´ì•Œ ë°ë¯¸ì§€ *1.2', 
                effect: (character) => { 
                    character.damage = (character.damage || 1) * 1.2; 
                    character.hasDamageBoost = true; 
                } 
            },
            { 
                id: 'lightning', 
                name: 'ë²ˆê°œ', 
                description: 'ì ì—ê²Œ ì´ì•Œì„ ë§ì¶œ ì‹œ 25% í™•ë¥ ë¡œ ì  0.75ì´ˆ ê¸°ì ˆ', 
                effect: (character) => { 
                    character.hasLightning = true; 
                    character.lightningCount = (character.lightningCount || 0) + 1; 
                } 
            },
            { 
                id: 'shield', 
                name: 'ë°©ì–´ë§‰', 
                description: 'ë°›ëŠ” ë°ë¯¸ì§€ 1íšŒ ë¬´ì‹œ (ì¿¨íƒ€ì„ 7.5ì´ˆ)', 
                effect: (character) => { 
                    character.hasShield = true; 
                    character.shieldReady = true; // ë°©ì–´ë§‰ ì¤€ë¹„ë¨
                    character.shieldCooldown = 0; // ì¿¨íƒ€ì„
                } 
            },
            { 
                id: 'regeneration', 
                name: 'ì¬ìƒ', 
                description: '1ì´ˆë§ˆë‹¤ ì²´ë ¥ 0.1 íšŒë³µ', 
                effect: (character) => { 
                    character.hasRegeneration = true; 
                    character.lastRegenTime = 0; // ë§ˆì§€ë§‰ íšŒë³µ ì‹œê°„
                    character.regenerationCount = (character.regenerationCount || 0) + 1; 
                } 
            },
            { 
                id: 'evasiveManeuver', 
                name: 'íšŒí”¼ê¸°ë™', 
                description: 'ì¬ì¥ì „ ì¤‘ ì´ë™ì†ë„ +75%', 
                effect: (character) => { 
                    character.hasEvasiveManeuver = true; 
                    character.evasiveManeuverCount = (character.evasiveManeuverCount || 0) + 1; 
                } 
            },
            { 
                id: 'combatExperience', 
                name: 'ì „íˆ¬ ê²½í—˜', 
                description: 'ì§„ ë¼ìš´ë“œ ìˆ˜ë§ˆë‹¤ ìµœëŒ€ì²´ë ¥ 0.5, ë°ë¯¸ì§€ 0.1 ì¦ê°€', 
                effect: (character) => { 
                    character.hasCombatExperience = true; 
                    character.combatExperienceRounds = 0; // í˜„ì¬ ë¼ìš´ë“œ ìˆ˜
                    character.combatExperienceCount = (character.combatExperienceCount || 0) + 1; 
                } 
            },
            { 
                id: 'hallucination', 
                name: 'í™˜ê°', 
                description: 'ì´ì•Œì´ ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.1ì´ˆë§ˆë‹¤ ì†ë„ê°€ 0.75ë°°~2ë°° ì‚¬ì´ë¡œ ëœë¤ìœ¼ë¡œ ì¡°ì •ë¨', 
                effect: (character) => { 
                    character.hasHallucination = true; 
                } 
            },
            { 
                id: 'tasteOfBlood', 
                name: 'í”¼ì˜ ë§›', 
                description: 'ì ì—ê²Œ ì…íŒ í”¼í•´ì˜ 20%ë§Œí¼ íšŒë³µ', 
                effect: (character) => { 
                    character.hasTasteOfBlood = true; 
                    character.tasteOfBloodCount = (character.tasteOfBloodCount || 0) + 1; 
                } 
            },
            { 
                id: 'cannon', 
                name: 'ëŒ€í¬', 
                description: 'ì´ì•Œì˜ ì†ë„ -50% ëŒ€ì‹  ì´ì•Œì˜ í¬ê¸° +200%', 
                effect: (character) => { 
                    // ì†ë„ëŠ” 0.5ë°°ì”© ê³±í•˜ê¸° (ì¤‘ì²©)
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 0.5; 
                    // í¬ê¸°ëŠ” 200%ì”© ì¤‘ì²© (3ë°°ì”© ê³±í•˜ê¸°)
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 3; // +200% = 3ë°°
                    character.hasCannon = true; 
                } 
            },
            { 
                id: 'timeBarrier', 
                name: 'ì‹œê°„ì¥ë§‰', 
                description: 'ìì‹  ì£¼ìœ„ì˜ ë°˜ì§€ë¦„ 150pxì§œë¦¬ ì› ìƒì„±, ì´ ì› ì•ˆì— ë“¤ì–´ì˜¤ëŠ” ì ì˜ ì´ì•Œ 35% ë‘”í™”', 
                effect: (character) => { 
                    character.hasTimeBarrier = true; 
                    character.timeBarrierRadius = 150; 
                } 
            },
            { 
                id: 'bouncyBullet', 
                name: 'í†µí†µíƒ„', 
                description: 'ì´ì•Œì´ ë²½ì— ë§ìœ¼ë©´ 1íšŒ íŠ•ê¹€', 
                effect: (character) => { 
                    character.hasBouncyBullet = true; 
                    character.bouncyBulletCount = (character.bouncyBulletCount || 0) + 1; 
                } 
            },
            { 
                id: 'gamble2', 
                name: 'ìŠ¤ë„¤ì´í¬', 
                description: 'ì´ì•Œì´ ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.2ì´ˆë§ˆë‹¤ Â±20ë„ë§Œí¼ ëœë¤ìœ¼ë¡œ ë°©í–¥ ì „í™˜ + ì´ì•Œì†ë„ -50% + ë°œì‚¬ì†ë„ -50%', 
                effect: (character) => { 
                    character.hasGamble2 = true; 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 0.5;
                    character.shootCooldown *= 0.5; // ë°œì‚¬ì†ë„ -50% (ì¿¨íƒ€ì„ ì ˆë°˜)
                } 
            },
            { 
                id: 'reflect', 
                name: 'ë°˜ì‚¬', 
                description: '5ì´ˆë§ˆë‹¤ ìš°í´ë¦­ìœ¼ë¡œ 0.1ì´ˆë™ì•ˆ ë°˜ì‚¬ë¥¼ í•  ìˆ˜ ìˆëŠ” ë³´í˜¸ë§‰ì„ ì–»ì„ ìˆ˜ ìˆìŒ. ë³´í˜¸ë§‰ì´ ìˆëŠ”ë™ì•ˆ ì ì˜ ì´ì•Œì— ë§ìœ¼ë©´ ìƒëŒ€ê°€ ìˆëŠ” ìª½ìœ¼ë¡œ ë‚ ì•„ê°', 
                effect: (character) => { 
                    character.hasReflect = true;
                    character.reflectCooldown = 0;
                } 
            },
            { 
                id: 'gatling', 
                name: 'ê²Œí‹€ë§', 
                description: 'ê³µê²© ì‹œ ë‚¨ì€ íƒ„ì•½ì„ ëª¨ë‘ ì‚¬ìš©í•´ ê·¸ ê°¯ìˆ˜ë§Œí¼ 0.1ì´ˆë§ˆë‹¤ ë§ˆìš°ìŠ¤ê°€ ë³´ê³ ìˆëŠ” ë°©í–¥ìœ¼ë¡œ ì´ì•Œ ë°œì‚¬ + ì¬ì¥ì „ ì‹œê°„ +0.5ì´ˆ', 
                effect: (character) => { 
                    character.hasGatling = true;
                    character.reloadTime += 500; // ì¬ì¥ì „ ì‹œê°„ +0.5ì´ˆ
                } 
            },
            { 
                id: 'timeStop', 
                name: 'ì‹œê°„ì •ì§€', 
                description: '10ì´ˆë§ˆë‹¤ ìš°í´ë¦­ìœ¼ë¡œ 1ì´ˆë™ì•ˆ ì‹œê°„ì„ ì •ì§€ì‹œì¼œ ìƒëŒ€ì˜ ì´ì•Œì€ ê·¸ ìƒíƒœì—ì„œ ë©ˆì¶”ê³ , ìƒëŒ€ëŠ” ì›€ì§ì´ì§€ ëª»í•˜ê²Œ í•  ìˆ˜ ìˆìŒ', 
                effect: (character) => { 
                    character.hasTimeStop = true;
                    character.timeStopCooldown = 0;
                } 
            },
            { 
                id: 'scatter', 
                name: 'ë¹„ì‚°íƒ„', 
                description: 'ì´ì•Œ í¬ê¸° -25%, ì´ì•Œì´ Â±4ë„ ì‚¬ì´ì—ì„œ 2ë„ ê°„ê²©ìœ¼ë¡œ 4ê°œë¡œ ë‚˜ëˆ” + í•œë°œë‹¹ ë°ë¯¸ì§€ 0.25ë°°', 
                effect: (character) => { 
                    character.hasScatter = true;
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 0.75; // ì´ì•Œ í¬ê¸° -25%
                } 
            },
            { 
                id: 'rocket', 
                name: 'ë¡œì¼“íƒ„', 
                description: 'ì´ì•Œ ì†ë„ê°€ ì´ˆê¸° ì†ë„ì˜ 0.1ë°°ë¶€í„° ì‹œì‘í•´ 0.2ì´ˆë§ˆë‹¤ 2ë°°ì”© ì¦ê°€ (ìµœëŒ€ 6.4ë°°)', 
                effect: (character) => { 
                    character.hasRocket = true; 
                } 
            },
            { 
                id: 'trinity', 
                name: 'ì‚¼ìœ„ì¼ì²´', 
                description: 'ì´ë™ì†ë„ +10%, ë°œì‚¬ì†ë„ +10%, ìµœëŒ€ì²´ë ¥ +0.5', 
                effect: (character) => { 
                    character.speed *= 1.1;
                    character.shootCooldown *= 0.9; // ë°œì‚¬ì†ë„ +10% (ì¿¨íƒ€ì„ 10% ê°ì†Œ)
                    character.maxHealth += 0.5;
                    character.health += 0.5;
                    character.hasTrinity = true;
                } 
            },
            { 
                id: 'judgment', 
                name: 'ì„ ê³ ', 
                description: 'ì ì„ ë§ì¶œ ì‹œ ì ì´ ë§ì€ ë°©í–¥ìœ¼ë¡œ 75px ë°€ë ¤ë‚©ë‹ˆë‹¤', 
                effect: (character) => { 
                    character.hasJudgment = true;
                } 
            },
            { 
                id: 'boomerang', 
                name: 'ë¶€ë§¤ë‘', 
                description: 'ì´ì•Œ ë°ë¯¸ì§€ -0.25, ì´ì•Œì˜ ìµœëŒ€ ì‚¬ê±°ë¦¬ 850pxë¡œ ì œí•œ ëŒ€ì‹  ì´ì•Œì´ ìµœëŒ€ ì‚¬ê±°ë¦¬ê¹Œì§€ ê°”ë‹¤ê°€ ë‹¤ì‹œ ë˜ëŒì•„ì˜µë‹ˆë‹¤', 
                effect: (character) => { 
                    character.hasBoomerang = true;
                } 
            },
        ];

        // í‚¤ ì…ë ¥ ìƒíƒœ
        const keys = {};
        let mouse = { x: 0, y: 0 };
        let hoveredAugment = null; // ë§ˆìš°ìŠ¤ í˜¸ë²„ëœ ì¦ê°• ì •ë³´

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        canvas.addEventListener('click', (e) => {
            if (!gameState.isPaused && !gameState.isGameOver && !player.isDodging) {
                shoot(player);
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // ìš°í´ë¦­ ë©”ë‰´ ë°©ì§€
            
            if (gameState.isPaused || gameState.isGameOver) return;
            
            // í”Œë ˆì´ì–´ êµ¬ë¥´ê¸° (ìš°í´ë¦­)
            if (player.hasDodge && !player.isDodging) {
                    dodge(player);
            }
            
            // ë°˜ì‚¬ ë³´í˜¸ë§‰ í™œì„±í™” (ìš°í´ë¦­)
            if (player.hasReflect && !player.reflectActive && player.reflectCooldown === 0) {
                player.reflectActive = true;
                player.reflectEndTime = Date.now() + 100; // 0.1ì´ˆ
            }
            
            // ì‹œê°„ì •ì§€ í™œì„±í™” (ìš°í´ë¦­)
            if (player.hasTimeStop && !player.timeStopActive && player.timeStopCooldown === 0) {
                player.timeStopActive = true;
                player.timeStopEndTime = Date.now() + 1000; // 1ì´ˆ
            }
        });

        // ì´ì•Œ í´ë˜ìŠ¤
        class Bullet {
            constructor(x, y, angle, owner, isFreeShot = false) {
                this.x = x;
                this.y = y;
                this.startX = x; // ì‹œì‘ ìœ„ì¹˜ ì €ì¥ (ê·¼ì ‘ì „ëª¨ë“œìš©)
                this.startY = y;
                this.angle = angle;
                this.createTime = Date.now(); // ìƒì„± ì‹œê°„ ì €ì¥ (10ì´ˆ í›„ ì‚­ì œìš©)
                const baseSpeed = 20;
                const speedMultiplier = owner.bulletSpeedMultiplier || 1;
                this.speed = baseSpeed * speedMultiplier;
                this.baseSpeed = this.speed; // ì›ë˜ ì†ë„ ì €ì¥ (ì‹œê°„ì¥ë§‰ìš©)
                // í™˜ê°: ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.1ì´ˆë§ˆë‹¤ ì†ë„ ë³€ê²½ì„ ìœ„í•œ ë³€ìˆ˜
                if (owner.hasHallucination) {
                    this.hallucinationLastChange = Date.now(); // ë§ˆì§€ë§‰ ì†ë„ ë³€ê²½ ì‹œê°„
                    // ì´ˆê¸° ì†ë„ë„ ëœë¤ìœ¼ë¡œ ì„¤ì • (0.75ë°°~2ë°°)
                    const randomMultiplier = 0.75 + Math.random() * 1.25; // 0.75 ~ 2.0
                    this.hallucinationSpeed = this.baseSpeed * randomMultiplier;
                    this.speed = this.hallucinationSpeed; // ì´ˆê¸° ì†ë„ëŠ” í™˜ê° ì†ë„ë¡œ
                }
                this.isInTimeBarrier = false; // ì‹œê°„ì¥ë§‰ ì•ˆì— ìˆëŠ”ì§€ ì—¬ë¶€
                const sizeMultiplier = owner.bulletSizeMultiplier || 1;
                this.radius = 9 * sizeMultiplier;
                this.owner = owner;
                this.damage = owner.damage || 1;
                // ë¶€ë§¤ë‘: ì´ì•Œ ë°ë¯¸ì§€ -0.25
                if (owner.hasBoomerang) {
                    this.damage = Math.max(0.25, this.damage - 0.25);
                }
                // ë¹„ì¥ì˜ í•œë°œ: ë§ˆì§€ë§‰ íƒ„í™˜ì˜ ë°ë¯¸ì§€ +1.5 (ì¤‘ì²©)
                if (owner.hasLastBullet && owner.ammo === 1) {
                    const lastBulletCount = owner.lastBulletCount || 1;
                    this.damage += 1.5 * lastBulletCount;
                }
                // ì•½í™” ìƒíƒœ: ëª¨ë“  ê³µê²© ë°ë¯¸ì§€ -0.25 (ì¤‘ì²©)
                if (owner.isWeakened) {
                    const weakenCount = owner.weakenCount || 1;
                    this.damage = Math.max(0.25, this.damage - (0.25 * weakenCount));
                }
                this.isFreeShot = isFreeShot; // íƒ„ì•½ ì†Œëª¨ ì—†ëŠ” ì´ì•Œ (ë”ë¸”ìƒ·ìš©)
                this.hasPoison = owner.hasPoisonBullet || false; // ë… íƒ„í™˜ ì—¬ë¶€
                this.hasBouncy = owner.hasBouncyBullet || false; // í†µí†µíƒ„ ì—¬ë¶€
                this.bounceCount = 0; // íŠ•ê¹€ íšŸìˆ˜
                this.maxBounces = owner.hasBouncyBullet ? (owner.bouncyBulletCount || 1) : 0; // ìµœëŒ€ íŠ•ê¹€ íšŸìˆ˜
                this.lastX = x; // ì´ì „ ìœ„ì¹˜ (ë²½ ì¶©ëŒ ê°ì§€ìš©)
                this.lastY = y;
                // ë„ë°•íƒ„_2: 0.2ì´ˆë§ˆë‹¤ Â±10ë„ ëœë¤ ë°©í–¥ ì „í™˜
                if (owner.hasGamble2) {
                    this.gamble2LastChange = Date.now();
                }
                // ë¡œì¼“íƒ„: 0.1ë°°ë¶€í„° ì‹œì‘, 0.2ì´ˆë§ˆë‹¤ 2ë°°ì”© ì¦ê°€
                if (owner.hasRocket) {
                    this.rocketSpeed = this.baseSpeed * 0.1; // 0.1ë°°
                    this.rocketLastChange = Date.now();
                    this.speed = this.rocketSpeed;
                }
                // ê·¼ì ‘ì „ëª¨ë“œ: ë©ˆì¶¤ ìƒíƒœ
                this.isStopped = false; // ë©ˆì¶¤ ì—¬ë¶€
                this.stopTime = 0; // ë©ˆì¶˜ ì‹œê°„
                this.fadeStartTime = 0; // í˜ì´ë“œ ì•„ì›ƒ ì‹œì‘ ì‹œê°„
                // ë¶€ë§¤ë‘: ì´ì•Œì´ ë˜ëŒì•„ì˜´
                this.hasBoomerang = owner.hasBoomerang || false;
                this.isReturning = false; // ë˜ëŒì•„ê°€ëŠ” ì¤‘ì¸ì§€
                this.maxDistance = owner.hasBoomerang ? 850 : Infinity; // ìµœëŒ€ ì‚¬ê±°ë¦¬
            }

            update() {
                // ë¡œì¼“íƒ„: 0.2ì´ˆë§ˆë‹¤ ì†ë„ 2ë°°ì”© ì¦ê°€ (ìµœëŒ€ 6.4ë°°)
                if (this.owner && this.owner.hasRocket && this.rocketSpeed !== undefined) {
                    const now = Date.now();
                    if (now - this.rocketLastChange >= 200) { // 0.2ì´ˆ = 200ms
                        if (this.rocketSpeed < this.baseSpeed * 6.4) {
                            this.rocketSpeed *= 2;
                            if (this.rocketSpeed > this.baseSpeed * 6.4) {
                                this.rocketSpeed = this.baseSpeed * 6.4;
                            }
                        }
                        this.rocketLastChange = now;
                    }
                    // ì‹œê°„ì¥ë§‰ì´ ì—†ê±°ë‚˜ ë°–ì— ìˆì„ ë•Œë§Œ ë¡œì¼“ ì†ë„ ì ìš©
                    if (!this.isInTimeBarrier) {
                        this.speed = this.rocketSpeed;
                    }
                }
                
                // ìŠ¤ë„¤ì´í¬: 0.2ì´ˆë§ˆë‹¤ Â±20ë„ ëœë¤ ë°©í–¥ ì „í™˜
                if (this.owner && this.owner.hasGamble2 && this.gamble2LastChange !== undefined) {
                    const now = Date.now();
                    if (now - this.gamble2LastChange >= 200) { // 0.2ì´ˆ = 200ms
                        const randomOffset = (Math.random() - 0.5) * 40 * Math.PI / 180; // Â±20ë„
                        this.angle += randomOffset;
                        this.gamble2LastChange = now;
                    }
                }
                
                // í™˜ê°: ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.1ì´ˆë§ˆë‹¤ ì´ì•Œ ì†ë„ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³€ê²½
                if (this.owner && this.owner.hasHallucination && this.hallucinationLastChange !== undefined) {
                    const now = Date.now();
                    if (now - this.hallucinationLastChange >= 100) { // 0.1ì´ˆ = 100ms
                        // 0.75ë°°~2ë°° ì‚¬ì´ë¡œ ëœë¤ ì¡°ì •
                        const randomMultiplier = 0.75 + Math.random() * 1.25; // 0.75 ~ 2.0
                        this.hallucinationSpeed = this.baseSpeed * randomMultiplier;
                        this.hallucinationLastChange = now;
                    }
                    // í™˜ê° ì†ë„ ì‚¬ìš© (ì‹œê°„ì¥ë§‰ì´ ì ìš©ë˜ë©´ ê·¸ê²Œ ìš°ì„ ì´ë¯€ë¡œ ì‹œê°„ì¥ë§‰ ë¡œì§ì—ì„œ ì²˜ë¦¬)
                    // ì‹œê°„ì¥ë§‰ì´ ì—†ê±°ë‚˜ ë°–ì— ìˆì„ ë•Œë§Œ í™˜ê° ì†ë„ ì ìš©
                    if (!this.isInTimeBarrier && !this.owner.hasRocket) { // ë¡œì¼“íƒ„ì´ ìˆìœ¼ë©´ ë¡œì¼“ ì†ë„ ìš°ì„ 
                        this.speed = this.hallucinationSpeed;
                    }
                }
                
                // ë¶€ë§¤ë‘: ì´ì•Œì´ ìµœëŒ€ ì‚¬ê±°ë¦¬ê¹Œì§€ ê°€ê±°ë‚˜ ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ë˜ëŒì•„ì˜´
                if (this.hasBoomerang && !this.isReturning) {
                    const distance = Math.sqrt(
                        Math.pow(this.x - this.startX, 2) + 
                        Math.pow(this.y - this.startY, 2)
                    );
                    
                    // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°”ê±°ë‚˜ ìµœëŒ€ ì‚¬ê±°ë¦¬ì— ë„ë‹¬í•˜ë©´ ë˜ëŒì•„ê°€ê¸° ì‹œì‘
                    if (this.isOutOfBounds() || distance >= this.maxDistance) {
                        // ë˜ëŒì•„ê°€ê¸° ì‹œì‘
                        this.isReturning = true;
                        // ì†ë„ê°€ ë§¤ìš° ì¤„ì–´ë“¦
                        this.speed = this.baseSpeed * 0.1;
                    }
                }
                
                // ë¶€ë§¤ë‘: ë˜ëŒì•„ê°€ëŠ” ì¤‘
                if (this.hasBoomerang && this.isReturning) {
                    // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ì´ë™
                    const dxToOwner = this.owner.x - this.x;
                    const dyToOwner = this.owner.y - this.y;
                    const distanceToOwner = Math.sqrt(dxToOwner * dxToOwner + dyToOwner * dyToOwner);
                    
                    if (distanceToOwner > 0) {
                        this.angle = Math.atan2(dyToOwner, dxToOwner);
                        // ì†ë„ ì ì§„ì ìœ¼ë¡œ ì¦ê°€
                        this.speed = Math.min(this.baseSpeed * 1.5, this.speed * 1.05);
                    }
                }
                
                // í†µí†µíƒ„: ë²½ì— ë§ìœ¼ë©´ íŠ•ê¹€ (ì¤‘ì²© íšŸìˆ˜ë§Œí¼)
                if (this.hasBouncy && this.bounceCount < this.maxBounces) {
                    const nextX = this.x + Math.cos(this.angle) * this.speed;
                    const nextY = this.y + Math.sin(this.angle) * this.speed;
                    
                    // ë²½ ì¶©ëŒ ê°ì§€
                    let hitWall = false;
                    let newAngle = this.angle;
                    
                    // ì™¼ìª½ ë²½ ë˜ëŠ” ì˜¤ë¥¸ìª½ ë²½ì— ì¶©ëŒ
                    if (nextX - this.radius < 0 || nextX + this.radius > canvas.width) {
                        hitWall = true;
                        // ë°˜ëŒ€ë°©í–¥ì—ì„œ Â±25ë„ (ìˆ˜í‰ ë°˜ì‚¬)
                        const reflectAngle = Math.PI - this.angle; // ë°˜ì‚¬ê°
                        const randomOffset = (Math.random() - 0.5) * 50 * Math.PI / 180; // Â±25ë„
                        newAngle = reflectAngle + randomOffset;
                    }
                    // ìœ„ìª½ ë²½ ë˜ëŠ” ì•„ë˜ìª½ ë²½ì— ì¶©ëŒ
                    if (nextY - this.radius < 0 || nextY + this.radius > canvas.height) {
                        hitWall = true;
                        // ë°˜ëŒ€ë°©í–¥ì—ì„œ Â±25ë„ (ìˆ˜ì§ ë°˜ì‚¬)
                        const reflectAngle = -this.angle; // ë°˜ì‚¬ê°
                        const randomOffset = (Math.random() - 0.5) * 50 * Math.PI / 180; // Â±25ë„
                        newAngle = reflectAngle + randomOffset;
                    }
                    
                    if (hitWall) {
                        this.bounceCount++;
                        this.angle = newAngle;
                        // ë²½ ê²½ê³„ë¡œ ìœ„ì¹˜ ì¡°ì • (ë§µ ê²½ê³„ ì‚¬ìš©)
                        this.x = Math.max(gameState.mapBounds.minX + this.radius, Math.min(gameState.mapBounds.maxX - this.radius, this.x));
                        this.y = Math.max(gameState.mapBounds.minY + this.radius, Math.min(gameState.mapBounds.maxY - this.radius, this.y));
                    } else {
                        this.x = nextX;
                        this.y = nextY;
                    }
                } else {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // í˜ì´ë“œ ì•„ì›ƒ íš¨ê³¼ (ê·¼ì ‘ì „ëª¨ë“œì—ì„œ ë©ˆì¶˜ ì´ì•Œ)
                let alpha = 1.0;
                if (this.isStopped && this.fadeStartTime > 0) {
                    const fadeElapsed = Date.now() - this.fadeStartTime;
                    const fadeDuration = 300; // 0.3ì´ˆ
                    alpha = Math.max(0, 1 - (fadeElapsed / fadeDuration));
                }
                ctx.globalAlpha = alpha;
                
                // ì§ì‚¬ê°í˜• ì´ì•Œ ê·¸ë¦¬ê¸° (ë„¤ì˜¨ íš¨ê³¼ ì¶”ê°€)
                // ë… íƒ„í™˜ì´ë©´ ì–´ë‘ìš´ ì´ˆë¡ìƒ‰, ì•„ë‹ˆë©´ í•˜ì–€ìƒ‰
                const bulletColor = this.hasPoison ? '#006600' : '#ffffff';
                ctx.fillStyle = bulletColor;
                ctx.shadowBlur = 10;
                ctx.shadowColor = bulletColor;
                const sizeMultiplier = this.owner.bulletSizeMultiplier || 1;
                const bulletWidth = 24 * sizeMultiplier; // ì´ì•Œ ë„ˆë¹„
                const bulletHeight = 9 * sizeMultiplier; // ì´ì•Œ ë†’ì´
                ctx.fillRect(-bulletWidth / 2, -bulletHeight / 2, bulletWidth, bulletHeight);
                
                ctx.globalAlpha = 1.0; // ë³µì›
                ctx.restore();
            }

            isOutOfBounds() {
                // ë§µ ê²½ê³„ ì²´í¬
                return this.x < gameState.mapBounds.minX || this.x > gameState.mapBounds.maxX || 
                       this.y < gameState.mapBounds.minY || this.y > gameState.mapBounds.maxY;
            }
        }

        // ì†Œìˆ˜ì  ë°˜ì˜¬ë¦¼ í—¬í¼ í•¨ìˆ˜: 1~2ìë¦¬ëŠ” ìœ ì§€, 3ìë¦¬ ì´ìƒì€ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
        function roundToMaxTwoDecimals(value) {
            const strValue = value.toString();
            const decimalIndex = strValue.indexOf('.');
            if (decimalIndex === -1) {
                return value; // ì •ìˆ˜ë©´ ê·¸ëŒ€ë¡œ
            }
            const decimalPart = strValue.substring(decimalIndex + 1);
            if (decimalPart.length <= 2) {
                return value; // 2ìë¦¬ ì´í•˜ë©´ ê·¸ëŒ€ë¡œ
            }
            // 3ìë¦¬ ì´ìƒì´ë©´ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
            return Math.round(value * 100) / 100;
        }

        // í™”ë©´ í”ë“¤ë¦¼ í•¨ìˆ˜
        function addScreenShake(intensity, duration) {
            gameState.shake.intensity = intensity;
            gameState.shake.duration = duration;
        }

        // ë°œì‚¬ í•¨ìˆ˜
        function shoot(character) {
            const now = Date.now();
            // ê¸°ì ˆ ìƒíƒœë©´ ë°œì‚¬ ë¶ˆê°€
            if (character.isStunned) return;
            if (character.ammo > 0 && !character.isReloading && 
                now - character.lastShot > character.shootCooldown) {
                
                // ê²Œí‹€ë§ ì¦ê°•: ë‚¨ì€ íƒ„ì•½ ëª¨ë‘ ì‚¬ìš©, 0.1ì´ˆë§ˆë‹¤ ë°œì‚¬
                if (character.hasGatling) {
                    character.gatlingBullets = character.ammo;
                    character.ammo = 0; // ëª¨ë“  íƒ„ì•½ ì†Œëª¨
                    character.gatlingNextShot = now; // ì²« ë°œì‚¬ëŠ” ì¦‰ì‹œ
                    character.lastShot = now; // ì¿¨íƒ€ì„ ì ìš©
                    character.gatlingAngle = character.angle; // ë°œì‚¬ ì‹œì‘ ì‹œ ë°©í–¥ ì €ì¥
                    return; // ì‹¤ì œ ë°œì‚¬ëŠ” ê²Œì„ ë£¨í”„ì—ì„œ ì²˜ë¦¬
                }
                
                // ë¹„ì‚°íƒ„ ì¦ê°•ì´ ìˆì„ ë•Œì˜ ë°œì‚¬ ì²˜ë¦¬
                if (character.hasScatter) {
                    // ë¹„ì‚°íƒ„: Â±4ë„ ë²”ìœ„ì—ì„œ 2ë„ ê°„ê²©ìœ¼ë¡œ 4ê°œë¡œ ë‚˜ëˆ” + ë°ë¯¸ì§€ 0.25ë°°
                    const scatterAngles = [-4, -2, 0, 2];
                    
                    // ë„ë°• ì¦ê°•: ê° ë°œì‚¬ë§ˆë‹¤ ëœë¤ ë°°ìœ¨ ì ìš©
                    let scatterGambleMultiplier = 1;
                    let scatterBaseAngle = character.angle;
                    if (character.hasGamble) {
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„
                        scatterBaseAngle = character.angle + randomAngle;
                        scatterGambleMultiplier = 1 + Math.random(); // 1~2ë°°
                    }
                    
                    if (character.hasShotgun) {
                        // ìƒ·ê±´ + ë¹„ì‚°íƒ„: ëª¨ë“  íƒ„ì•½ì„ ìƒ·ê±´ìœ¼ë¡œ ë°œì‚¬í•˜ë˜, ê° ì´ì•Œì„ ë¹„ì‚°íƒ„ìœ¼ë¡œ ë¶„ì‚°
                        const currentAmmo = character.ammo;
                        for (let i = 0; i < currentAmmo; i++) {
                            // Â±20ë„ ë²”ìœ„ ë‚´ ëœë¤ ê°ë„
                            const randomAngle = (Math.random() - 0.5) * (Math.PI * 40 / 180); // -20ë„ ~ +20ë„
                            const baseAngle = scatterBaseAngle + randomAngle;
                            
                            // ê° ì´ì•Œì„ ë¹„ì‚°íƒ„ìœ¼ë¡œ ë¶„ì‚°
                            scatterAngles.forEach(angleDeg => {
                                const angle = baseAngle + (angleDeg * Math.PI / 180);
                                const bullet = new Bullet(
                                    character.x + Math.cos(character.angle) * character.radius,
                                    character.y + Math.sin(character.angle) * character.radius,
                                    angle,
                                    character,
                                    false
                                );
                                // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                                if (character.hasGamble) {
                                    bullet.damage = Math.round(bullet.damage * scatterGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                                }
                                bullet.damage = bullet.damage * 0.25; // ë°ë¯¸ì§€ 0.25ë°°
                                character.bullets.push(bullet);
                            });
                        }
                        character.ammo = 0; // ëª¨ë“  íƒ„ì•½ ì†Œëª¨
                        character.lastShot = now;
                    } else {
                        // ë¹„ì‚°íƒ„ë§Œ: í•œ ë°œì”© ë°œì‚¬í•  ë•Œ Â±4ë„ ë²”ìœ„ì—ì„œ 2ë„ ê°„ê²©ìœ¼ë¡œ 4ê°œë¡œ ë‚˜ëˆ”
                        scatterAngles.forEach(angleDeg => {
                            const angle = scatterBaseAngle + (angleDeg * Math.PI / 180);
                            const bullet = new Bullet(
                                character.x + Math.cos(character.angle) * character.radius,
                                character.y + Math.sin(character.angle) * character.radius,
                                angle,
                                character,
                                false
                            );
                            // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                            if (character.hasGamble) {
                                bullet.damage = Math.round(bullet.damage * scatterGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                            }
                            bullet.damage = bullet.damage * 0.25; // ë°ë¯¸ì§€ 0.25ë°°
                            character.bullets.push(bullet);
                        });
                        character.ammo--; // í•œ ë°œë§Œ ì†Œëª¨
                        character.lastShot = now;
                    }
                } else if (character.hasShotgun) {
                // ìƒ·ê±´ ì¦ê°•: ëª¨ë“  íƒ„ì•½ì„ Â±20ë„ ë²”ìœ„ì—ì„œ í•œë²ˆì— ë°œì‚¬
                    // ë„ë°• ì¦ê°•: ê° ë°œì‚¬ë§ˆë‹¤ ëœë¤ ë°°ìœ¨ ì ìš©
                    let shotgunGambleMultiplier = 1;
                    if (character.hasGamble) {
                        shotgunGambleMultiplier = 1 + Math.random(); // 1~2ë°°
                    }
                    
                    const currentAmmo = character.ammo;
                    for (let i = 0; i < currentAmmo; i++) {
                        // Â±20ë„ ë²”ìœ„ ë‚´ ëœë¤ ê°ë„
                        let randomAngle = (Math.random() - 0.5) * (Math.PI * 40 / 180); // -20ë„ ~ +20ë„
                        // ë„ë°• ì¦ê°•: ê°ë„ì—ë„ Â±10ë„ ì¶”ê°€
                        if (character.hasGamble) {
                            randomAngle += (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„ ì¶”ê°€
                        }
                const bullet = new Bullet(
                    character.x + Math.cos(character.angle) * character.radius,
                    character.y + Math.sin(character.angle) * character.radius,
                            character.angle + randomAngle,
                    character,
                    false
                );
                        // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                        if (character.hasGamble) {
                            bullet.damage = Math.round(bullet.damage * shotgunGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                        }
                        character.bullets.push(bullet);
                    }
                    character.ammo = 0; // ëª¨ë“  íƒ„ì•½ ì†Œëª¨
                    character.lastShot = now;
                } else {
                    // ì¼ë°˜ ë°œì‚¬
                    let bulletAngle = character.angle;
                    let bulletDamage = character.damage || 1;
                    
                    // ë„ë°• ì¦ê°•: Â±10ë„ ëœë¤ ê°ë„, ë°ë¯¸ì§€ 1~2ë°° ëœë¤
                    let gambleMultiplier = 1;
                    if (character.hasGamble) {
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„
                        bulletAngle = character.angle + randomAngle;
                        gambleMultiplier = 1 + Math.random(); // 1~2ë°°
                    }
                    
                    // ë¹„ì‚°íƒ„ì´ ìˆìœ¼ë©´ ì¼ë°˜ ë°œì‚¬ë„ ë¹„ì‚°íƒ„ìœ¼ë¡œ ë¶„ì‚°
                    if (character.hasScatter) {
                        const scatterAngles = [-4, -2, 0, 2];
                        scatterAngles.forEach(angleDeg => {
                            const scatterAngle = bulletAngle + (angleDeg * Math.PI / 180);
                            const bullet = new Bullet(
                                character.x + Math.cos(character.angle) * character.radius,
                                character.y + Math.sin(character.angle) * character.radius,
                                scatterAngle,
                                character,
                                false
                            );
                            // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                            if (character.hasGamble) {
                                bullet.damage = Math.round(bullet.damage * gambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                            }
                            bullet.damage = bullet.damage * 0.25; // ë°ë¯¸ì§€ 0.25ë°°
                            character.bullets.push(bullet);
                        });
                    } else {
                        const bullet = new Bullet(
                            character.x + Math.cos(character.angle) * character.radius,
                            character.y + Math.sin(character.angle) * character.radius,
                            bulletAngle,
                            character,
                            false
                        );
                        // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                        if (character.hasGamble) {
                            bullet.damage = Math.round(bullet.damage * gambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                        }
                        character.bullets.push(bullet);
                    }
                    character.ammo--;
                    character.lastShot = now;

                // ë”ë¸”ìƒ· (í™•ë¥  ì¤‘ì²©: 25% * count)
                const doubleShotCount = character.doubleShotCount || 1;
                if (character.hasDoubleShot && Math.random() < (0.25 * doubleShotCount)) {
                    // Â±15ë„ ì‚¬ì´ì˜ ëœë¤ ê°ë„
                    const randomAngle = (Math.random() - 0.5) * (Math.PI * 30 / 180); // -15ë„ ~ +15ë„
                    let doubleBulletAngle = character.angle + randomAngle;
                    
                    // ë”ë¸”ìƒ·ì—ë„ ë„ë°• ì¦ê°• ì ìš© (ê°ë„ë§Œ, ë°ë¯¸ì§€ëŠ” ì´ì•Œ ìƒì„± í›„ ì ìš©)
                    let doubleGambleMultiplier = 1;
                    if (character.hasGamble) {
                        const doubleRandomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„
                        doubleBulletAngle = character.angle + doubleRandomAngle;
                        doubleGambleMultiplier = 1 + Math.random(); // 1~2ë°°
                    }
                    
                    // ë”ë¸”ìƒ·ì—ë„ ë¹„ì‚°íƒ„ ì ìš©
                    if (character.hasScatter) {
                        const scatterAngles = [-4, -2, 0, 2];
                        scatterAngles.forEach(angleDeg => {
                            const angle = doubleBulletAngle + (angleDeg * Math.PI / 180);
                            const doubleBullet = new Bullet(
                                character.x + Math.cos(character.angle) * character.radius,
                                character.y + Math.sin(character.angle) * character.radius,
                                angle,
                                character,
                                true // íƒ„ì•½ ì†Œëª¨ ì—†ìŒ
                            );
                            // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                            if (character.hasGamble) {
                                doubleBullet.damage = Math.round(doubleBullet.damage * doubleGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                            }
                            doubleBullet.damage = doubleBullet.damage * 0.25; // ë°ë¯¸ì§€ 0.25ë°°
                            character.bullets.push(doubleBullet);
                        });
                    } else {
                        const doubleBullet = new Bullet(
                            character.x + Math.cos(character.angle) * character.radius,
                            character.y + Math.sin(character.angle) * character.radius,
                            doubleBulletAngle,
                            character,
                            true // íƒ„ì•½ ì†Œëª¨ ì—†ìŒ
                        );
                        // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                        if (character.hasGamble) {
                            doubleBullet.damage = Math.round(doubleBullet.damage * doubleGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                        }
                        character.bullets.push(doubleBullet);
                    }
                    }
                }

                // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼ (í”Œë ˆì´ì–´ ë°œì‚¬ ì‹œì—ë§Œ)
                if (character === player) {
                    addScreenShake(18, 200);
                }

                // ìë™ ì¬ì¥ì „
                if (character.ammo === 0 && !character.isReloading) {
                    reload(character);
                }
                
                // ë©€í‹°í”Œë ˆì´ì–´: í”Œë ˆì´ì–´ê°€ ìœ ì´ì•Œ ì •ë³´ ì „ì†¡
                if (gameState.isMultiplayer && character === player && character.bullets.length > 0) {
                    // ë°©ê¸ˆ ì¶”ê°€ëœ ì´ì•Œë“¤ë§Œ ì „ì†¡ (ë§ˆì§€ë§‰ì— ì¶”ê°€ëœ ì´ì•Œ)
                    const newBullets = character.bullets.slice(-10); // ìµœëŒ€ 10ê°œ (ìƒ·ê±´/ë¹„ì‚°íƒ„ ëŒ€ë¹„)
                    sendShootData(newBullets);
                }
            }
        }

        // ì¬ì¥ì „ í•¨ìˆ˜
        function reload(character) {
            if (character.ammo < character.maxAmmo && !character.isReloading) {
                character.isReloading = true;
                character.reloadStartTime = Date.now();
                
                setTimeout(() => {
                    character.ammo = character.maxAmmo;
                    character.isReloading = false;
                    character.reloadStartTime = 0;
                    
                    // ì¬ì¥ì „ íšŒë³µ ì¦ê°• (íšŒë³µëŸ‰ ì¤‘ì²©)
                    if (character.hasReloadHeal) {
                        const reloadHealCount = character.reloadHealCount || 1;
                        character.health = Math.min(character.health + (1 * reloadHealCount), character.maxHealth);
                    }
                }, character.reloadTime);
            }
        }

        // ì¶©ëŒ ê°ì§€
        function checkCollision(bullet, target) {
            const dx = bullet.x - target.x;
            const dy = bullet.y - target.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < bullet.radius + target.radius;
        }

        // êµ¬ë¥´ê¸° í•¨ìˆ˜
        function dodge(character) {
            const now = Date.now();
            // ê¸°ì ˆ ìƒíƒœë©´ êµ¬ë¥´ê¸° ë¶ˆê°€
            if (character.isStunned) return;
            // ì¿¨íƒ€ì„ ì²´í¬ (3ì´ˆ)
            if (character.isDodging || now - character.lastDodgeTime < 3000) return;
            
            character.isDodging = true;
            const dodgeDistance = character.radius * 6.4; // í”Œë ˆì´ì–´ í¬ê¸°ì˜ 3.2ë°° (20% ê°ì†Œ: 8 -> 6.4)
            const dodgeDuration = 300; // 0.3ì´ˆ
            character.dodgeStartTime = now; // êµ¬ë¥´ê¸° ì‹œì‘ ì‹œê°„
            character.dodgeEndTime = now + dodgeDuration;
            character.lastDodgeTime = now; // ì¿¨íƒ€ì„ ì‹œì‘
            character.dodgeTrail = []; // ì”ìƒ ì´ˆê¸°í™”
            
            // êµ¬ë¥´ê¸° ì‹œì‘ ìœ„ì¹˜ ì €ì¥
            character.dodgeStartX = character.x;
            character.dodgeStartY = character.y;
            character.dodgeTrail.push({ x: character.x, y: character.y, alpha: 0.5 });
            
            // êµ¬ë¥´ê¸° ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            const targetX = character.x + Math.cos(character.angle) * dodgeDistance;
            const targetY = character.y + Math.sin(character.angle) * dodgeDistance;
            
            // ê²½ê³„ ì²´í¬
            character.dodgeTargetX = Math.max(character.radius, Math.min(canvas.width - character.radius, targetX));
            character.dodgeTargetY = Math.max(character.radius, Math.min(canvas.height - character.radius, targetY));
        }

        // í”Œë ˆì´ì–´ ì´ë™
        function updatePlayer() {
            const now = Date.now();
            
            // ì‹œê°„ì •ì§€ ìƒíƒœ ì²´í¬ (ìƒëŒ€ê°€ ì‹œê°„ì •ì§€ ì¤‘ì´ë©´ ì˜í–¥ ì—†ìŒ)
            // ì‹œê°„ì •ì§€ê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì•„ë¬´ê²ƒë„ í•  ìˆ˜ ì—†ìŒ
            
            // êµ¬ë¥´ê¸° ìƒíƒœ ì²´í¬
            if (player.isDodging) {
                if (now >= player.dodgeEndTime) {
                    // êµ¬ë¥´ê¸° ì™„ë£Œ
                    player.x = player.dodgeTargetX;
                    player.y = player.dodgeTargetY;
                    player.isDodging = false;
                    player.dodgeTrail = [];
                } else {
                    // êµ¬ë¥´ëŠ” ë™ì•ˆ ë¹ ë¥¸ ì†ë„ë¡œ ì´ë™
                    const elapsed = now - player.dodgeStartTime; // ì‹œì‘ ì‹œê°„ìœ¼ë¡œë¶€í„°ì˜ ê²½ê³¼ ì‹œê°„
                    const progress = Math.min(elapsed / 300, 1); // 0~1 (300ms = 0.3ì´ˆ)
                    
                    // ì‹œì‘ ìœ„ì¹˜ì—ì„œ ëª©í‘œ ìœ„ì¹˜ë¡œ ì„ í˜• ë³´ê°„
                    player.x = player.dodgeStartX + (player.dodgeTargetX - player.dodgeStartX) * progress;
                    player.y = player.dodgeStartY + (player.dodgeTargetY - player.dodgeStartY) * progress;
                    
                    // ì”ìƒ ì—…ë°ì´íŠ¸ (ë§¤ í”„ë ˆì„ë§ˆë‹¤)
                    if (!player.dodgeTrail) player.dodgeTrail = [];
                    player.dodgeTrail.push({ x: player.x, y: player.y, alpha: 0.3 });
                    // ì”ìƒì´ ë„ˆë¬´ ë§ì•„ì§€ë©´ ì œê±°
                    if (player.dodgeTrail.length > 5) {
                        player.dodgeTrail.shift();
                    }
                }
                return; // êµ¬ë¥´ëŠ” ì¤‘ì—ëŠ” ì¼ë°˜ ì´ë™ ë¶ˆê°€
            }

            // ë¶€í™œ ì²˜ë¦¬
            if (player.isReviving) {
                if (now >= player.reviveTime) {
                    player.isReviving = false;
                    player.health = 1;
                    // displayHealthëŠ” ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ìë™ ì—…ë°ì´íŠ¸ë¨
                    player.isInvincible = true;
                    player.invincibleEndTime = now + 1000; // 1ì´ˆ ë¬´ì 
                    // ë¶€í™œ íšŸìˆ˜ í™•ì¸ - ì•„ì§ ë” ë¶€í™œí•  ìˆ˜ ìˆìœ¼ë©´ ê³„ì† ì§„í–‰
                    const reviveCount = player.reviveCount || 1;
                    const hasRevivedCount = (typeof player.hasRevived === 'number' ? player.hasRevived : (player.hasRevived ? 1 : 0));
                    if (hasRevivedCount >= reviveCount) {
                        // ë” ì´ìƒ ë¶€í™œ ë¶ˆê°€
                    }
                }
                return; // ë¶€í™œ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            }

            // ë¬´ì  ìƒíƒœ ì²´í¬
            if (player.isInvincible && now >= player.invincibleEndTime) {
                player.isInvincible = false;
            }

            // ì•½í™” ìƒíƒœ ì²´í¬
            if (player.isWeakened && now >= player.weakenEndTime) {
                player.isWeakened = false;
                // ì•½í™”ëŠ” ì´ì•Œ ìƒì„± ì‹œì—ë§Œ ë°ë¯¸ì§€ë¥¼ ê°ì†Œì‹œí‚¤ë¯€ë¡œ, damage ìì²´ëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ
            }

            // ê¸°ì ˆ ìƒíƒœ ì²´í¬
            if (player.isStunned && now >= player.stunEndTime) {
                player.isStunned = false;
            }

            // ë°©ì–´ë§‰ ì¿¨íƒ€ì„ ì²´í¬
            if (player.hasShield && !player.shieldReady && now >= player.shieldCooldown) {
                player.shieldReady = true;
            }
            
            // ë°˜ì‚¬ ì¿¨íƒ€ì„ ì²´í¬
            if (player.hasReflect && !player.reflectActive && now >= player.reflectCooldown) {
                player.reflectCooldown = 0; // ì¿¨íƒ€ì„ ì™„ë£Œ
            }
            
            // ë°˜ì‚¬ ë³´í˜¸ë§‰ ì¢…ë£Œ ì²´í¬
            if (player.reflectActive && now >= player.reflectEndTime) {
                player.reflectActive = false;
                player.reflectCooldown = now + 5000; // 5ì´ˆ ì¿¨íƒ€ì„
            }
            
            // ì‹œê°„ì •ì§€ ì¿¨íƒ€ì„ ì²´í¬
            if (player.hasTimeStop && now >= player.timeStopCooldown) {
                player.timeStopCooldown = 0; // ì¿¨íƒ€ì„ ì™„ë£Œ
            }
            
            // ì‹œê°„ì •ì§€ ì¢…ë£Œ ì²´í¬
            if (player.timeStopActive && now >= player.timeStopEndTime) {
                player.timeStopActive = false;
                player.timeStopCooldown = now + 10000; // 10ì´ˆ ì¿¨íƒ€ì„
            }

            // ì¬ìƒ: 1ì´ˆë§ˆë‹¤ ì²´ë ¥ 0.1 íšŒë³µ (íšŒë³µëŸ‰ ì¤‘ì²©)
            if (player.hasRegeneration) {
                if (now - player.lastRegenTime >= 1000) {
                    const regenerationCount = player.regenerationCount || 1;
                    player.health = Math.min(player.health + (0.1 * regenerationCount), player.maxHealth);
                    player.lastRegenTime = now;
                }
            }

            // ê¸°ì ˆ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            if (player.isStunned) {
                return;
            }
            
            // ì„ ê³ : ë°€ë ¤ë‚˜ëŠ” íš¨ê³¼ ì²˜ë¦¬
            if (player.isJudgmentPushing) {
                const elapsed = now - player.judgmentPushStartTime;
                const progress = Math.min(1, elapsed / player.judgmentPushDuration);
                
                // ë¶€ë“œëŸ¬ìš´ ì´ë™ (ease-out)
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                player.x = player.judgmentPushStartX + (player.judgmentPushTargetX - player.judgmentPushStartX) * easeProgress;
                player.y = player.judgmentPushStartY + (player.judgmentPushTargetY - player.judgmentPushStartY) * easeProgress;
                
                // ê²½ê³„ ì²´í¬
                player.x = Math.max(gameState.mapBounds.minX + player.radius, Math.min(gameState.mapBounds.maxX - player.radius, player.x));
                player.y = Math.max(gameState.mapBounds.minY + player.radius, Math.min(gameState.mapBounds.maxY - player.radius, player.y));
                
                if (progress >= 1) {
                    player.isJudgmentPushing = false;
                } else {
                    return; // ë°€ë ¤ë‚˜ëŠ” ì¤‘ì—ëŠ” ë‹¤ë¥¸ ì´ë™ ë¶ˆê°€
                }
            }

            // ì´ë™ì†ë„ ê°ì†Œ ì²˜ë¦¬ (ê¹Šì€ ìƒì²˜)
            let currentSpeed = player.speed;
            if (now < player.slowEndTime) {
                    currentSpeed *= 0.75; // -25%
                }
            
            // íšŒí”¼ê¸°ë™: ì¬ì¥ì „ ì¤‘ ì´ë™ì†ë„ +75% (ì¤‘ì²©)
            if (player.hasEvasiveManeuver && player.isReloading) {
                const evasiveManeuverCount = player.evasiveManeuverCount || 1;
                currentSpeed *= (1 + 0.75 * evasiveManeuverCount);
            }
            
            // ìƒì¡´ë³¸ëŠ¥: ì²´ë ¥ì´ 1ì¼ ë•Œ ì´ë™ì†ë„ +50% (ì¤‘ì²©)
            if (player.hasSurvivalInstinct && player.health === 1) {
                const survivalInstinctCount = player.survivalInstinctCount || 1;
                currentSpeed *= (1 + 0.5 * survivalInstinctCount);
            }
            
            // íšŒë³µê³„ì•½: ì²´ë ¥ì´ 1ì¼ ë•Œ ì²´ë ¥ 2íšŒë³µ (íšŒë³µëŸ‰ ì¤‘ì²©)
            if (player.hasRecoveryContract && !player.hasRecoveryContractUsed && player.health === 1) {
                const recoveryContractCount = player.recoveryContractCount || 1;
                player.health = Math.min(player.health + (2 * recoveryContractCount), player.maxHealth);
                player.hasRecoveryContractUsed = true;
            }

            let dx = 0;
            let dy = 0;

            // ë¬´ë¹™ì›Œí¬ëª¨ë“œ: 5ì´ˆë§ˆë‹¤ ë°”ë€ŒëŠ” ë°©í–¥ìœ¼ë¡œ ì´ˆë‹¹ 25px ì´ë™ + WASD ì…ë ¥ë„ ê°€ëŠ¥
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'movingWork') {
                // ìœ„, ì•„ë˜, ì¢Œ, ìš° 4ë°©í–¥ ì¤‘ 1ê°œ ì„ íƒ
                if (!gameState.movingWorkDirection) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // ìš°, ì•„ë˜, ì¢Œ, ìœ„
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // 5ì´ˆë§ˆë‹¤ ë°©í–¥ ë³€ê²½
                if (now - gameState.movingWorkLastChange >= 5000) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // ìš°, ì•„ë˜, ì¢Œ, ìœ„
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // ì´ˆë‹¹ 25px ì´ë™ (ë¶€ë“œëŸ½ê²Œ)
                const moveSpeed = 25 / 60; // 60fps ê¸°ì¤€
                let autoDx = Math.cos(gameState.movingWorkDirection) * moveSpeed;
                let autoDy = Math.sin(gameState.movingWorkDirection) * moveSpeed;
                
                // WASD ì…ë ¥ë„ ë°›ê¸°
                if (keys['w']) dy -= 1;
                if (keys['s']) dy += 1;
                if (keys['a']) dx -= 1;
                if (keys['d']) dx += 1;
                
                // ëŒ€ê°ì„  ì´ë™ ì •ê·œí™”
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                // ìë™ ì´ë™ê³¼ WASD ì…ë ¥ í•©ì‚°
                dx += autoDx;
                dy += autoDy;
            } else {
                // ì¼ë°˜ ì´ë™
                if (keys['w']) dy -= 1;
                if (keys['s']) dy += 1;
                if (keys['a']) dx -= 1;
                if (keys['d']) dx += 1;
                
                // ëŒ€ê°ì„  ì´ë™ ì •ê·œí™”
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
            }

            // ê±°ì í™•ë³´: ìœ„ì¹˜ ë³€í™” ì²´í¬
            if (player.hasFortify) {
                const moved = Math.abs(player.x - (player.lastPosition?.x || player.x)) > 0.1 || 
                             Math.abs(player.y - (player.lastPosition?.y || player.y)) > 0.1;
                
                if (moved) {
                    // ì›€ì§ì„: ê±°ì  í™•ë³´ í•´ì œ
                    player.isFortified = false;
                    player.stationaryTime = 0;
                    if (!player.lastPosition) player.lastPosition = { x: player.x, y: player.y };
                    player.lastPosition.x = player.x;
                    player.lastPosition.y = player.y;
                } else {
                    // ì •ì§€: ì‹œê°„ ëˆ„ì 
                    if (!player.lastPosition) player.lastPosition = { x: player.x, y: player.y };
                    player.stationaryTime += 16; // ì•½ 60fps ê¸°ì¤€
                    
                    // 3ì´ˆ(3000ms) ë™ì•ˆ ì •ì§€í•˜ë©´ ê±°ì  í™•ë³´
                    if (player.stationaryTime >= 3000 && !player.isFortified) {
                        player.isFortified = true;
                        player.fortifyStartTime = now;
                    }
                }
            }

            // ë¹™íŒëª¨ë“œ: ë¯¸ë„ëŸ¬ì§ íš¨ê³¼
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'ice') {
                // ì†ë„ ë²¡í„° ì´ˆê¸°í™”
                if (!player.velocityX) player.velocityX = 0;
                if (!player.velocityY) player.velocityY = 0;
                
                // ì…ë ¥ì´ ìˆìœ¼ë©´ ì†ë„ ë²¡í„° ì—…ë°ì´íŠ¸
                if (dx !== 0 || dy !== 0) {
                    player.velocityX = dx * currentSpeed;
                    player.velocityY = dy * currentSpeed;
                }
                
                // ë§ˆì°° ì ìš© (ì†ë„ ê°ì†Œ) - ë¹™íŒëª¨ë“œì—ì„œëŠ” í›¨ì”¬ ë” ì˜ ë¯¸ë„ëŸ¬ì§
                player.velocityX *= 0.995;
                player.velocityY *= 0.995;
                
                // ì†ë„ê°€ ë§¤ìš° ì‘ìœ¼ë©´ ì •ì§€
                if (Math.abs(player.velocityX) < 0.01) player.velocityX = 0;
                if (Math.abs(player.velocityY) < 0.01) player.velocityY = 0;
                
                // ì†ë„ ë²¡í„°ë¡œ ì´ë™
                let newX = player.x + player.velocityX;
                let newY = player.y + player.velocityY;
                
                // ê²½ê³„ ì²´í¬ (ë§µ ê²½ê³„ ì‚¬ìš©) - ê²½ê³„ë¥¼ ë„˜ì–´ê°€ë©´ ê°•ì œë¡œ ê²½ê³„ ì•ˆìœ¼ë¡œ ì œí•œ
                newX = Math.max(gameState.mapBounds.minX + player.radius, Math.min(gameState.mapBounds.maxX - player.radius, newX));
                newY = Math.max(gameState.mapBounds.minY + player.radius, Math.min(gameState.mapBounds.maxY - player.radius, newY));
                
                // ê²½ê³„ì— ë‹¿ìœ¼ë©´ ì†ë„ ë°˜ì‚¬
                if (newX !== player.x + player.velocityX) player.velocityX *= -0.5;
                if (newY !== player.y + player.velocityY) player.velocityY *= -0.5;
                
                player.x = newX;
                player.y = newY;
            } else {
                // ì¼ë°˜ ì´ë™
                let newX = player.x + dx * currentSpeed;
                let newY = player.y + dy * currentSpeed;

                // ê²½ê³„ ì²´í¬ (ë§µ ê²½ê³„ ì‚¬ìš©) - ê²½ê³„ë¥¼ ë„˜ì–´ê°€ë©´ ê°•ì œë¡œ ê²½ê³„ ì•ˆìœ¼ë¡œ ì œí•œ
                newX = Math.max(gameState.mapBounds.minX + player.radius, Math.min(gameState.mapBounds.maxX - player.radius, newX));
                newY = Math.max(gameState.mapBounds.minY + player.radius, Math.min(gameState.mapBounds.maxY - player.radius, newY));
                
                player.x = newX;
                player.y = newY;
            }

            // ê°ë„ ê³„ì‚° (ë§ˆìš°ìŠ¤ ë°©í–¥)
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
        }


        // AI ì  ì—…ë°ì´íŠ¸
        function updateEnemy() {
            const now = Date.now();
            
            // ë¶€í™œ ì²˜ë¦¬
            if (enemy.isReviving) {
                if (now >= enemy.reviveTime) {
                    enemy.isReviving = false;
                    enemy.health = 1;
                    // displayHealthëŠ” ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ìë™ ì—…ë°ì´íŠ¸ë¨
                    enemy.isInvincible = true;
                    enemy.invincibleEndTime = now + 1000; // 1ì´ˆ ë¬´ì 
                    // ë¶€í™œ íšŸìˆ˜ í™•ì¸ - ì•„ì§ ë” ë¶€í™œí•  ìˆ˜ ìˆìœ¼ë©´ ê³„ì† ì§„í–‰
                    const reviveCount = enemy.reviveCount || 1;
                    const hasRevivedCount = (typeof enemy.hasRevived === 'number' ? enemy.hasRevived : (enemy.hasRevived ? 1 : 0));
                    if (hasRevivedCount >= reviveCount) {
                        // ë” ì´ìƒ ë¶€í™œ ë¶ˆê°€
                    }
                }
                return; // ë¶€í™œ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            }

            // ë¬´ì  ìƒíƒœ ì²´í¬
            if (enemy.isInvincible && now >= enemy.invincibleEndTime) {
                enemy.isInvincible = false;
            }

            // ì•½í™” ìƒíƒœ ì²´í¬
            if (enemy.isWeakened && now >= enemy.weakenEndTime) {
                enemy.isWeakened = false;
                // ì•½í™”ëŠ” ì´ì•Œ ìƒì„± ì‹œì—ë§Œ ë°ë¯¸ì§€ë¥¼ ê°ì†Œì‹œí‚¤ë¯€ë¡œ, damage ìì²´ëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ
            }

            // ê¸°ì ˆ ìƒíƒœ ì²´í¬
            if (enemy.isStunned && now >= enemy.stunEndTime) {
                enemy.isStunned = false;
            }

            // ë°©ì–´ë§‰ ì¿¨íƒ€ì„ ì²´í¬
            if (enemy.hasShield && !enemy.shieldReady && now >= enemy.shieldCooldown) {
                enemy.shieldReady = true;
            }

            // ì¬ìƒ: 1ì´ˆë§ˆë‹¤ ì²´ë ¥ 0.1 íšŒë³µ (íšŒë³µëŸ‰ ì¤‘ì²©)
            if (enemy.hasRegeneration) {
                if (now - enemy.lastRegenTime >= 1000) {
                    const regenerationCount = enemy.regenerationCount || 1;
                    enemy.health = Math.min(enemy.health + (0.1 * regenerationCount), enemy.maxHealth);
                    enemy.health = roundToMaxTwoDecimals(enemy.health);
                    enemy.lastRegenTime = now;
                }
            }

            // ê¸°ì ˆ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            if (enemy.isStunned) {
                return;
            }
            
            // ì‹œê°„ì •ì§€: ìƒëŒ€ê°€ ì‹œê°„ì •ì§€ë¥¼ ì‚¬ìš© ì¤‘ì´ë©´ ì›€ì§ì´ì§€ ëª»í•¨
            if (player.timeStopActive) {
                return;
            }
            
            // ì„ ê³ : ë°€ë ¤ë‚˜ëŠ” íš¨ê³¼ ì²˜ë¦¬
            if (enemy.isJudgmentPushing) {
                const elapsed = now - enemy.judgmentPushStartTime;
                const progress = Math.min(1, elapsed / enemy.judgmentPushDuration);
                
                // ë¶€ë“œëŸ¬ìš´ ì´ë™ (ease-out)
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                enemy.x = enemy.judgmentPushStartX + (enemy.judgmentPushTargetX - enemy.judgmentPushStartX) * easeProgress;
                enemy.y = enemy.judgmentPushStartY + (enemy.judgmentPushTargetY - enemy.judgmentPushStartY) * easeProgress;
                
                // ê²½ê³„ ì²´í¬
                enemy.x = Math.max(gameState.mapBounds.minX + enemy.radius, Math.min(gameState.mapBounds.maxX - enemy.radius, enemy.x));
                enemy.y = Math.max(gameState.mapBounds.minY + enemy.radius, Math.min(gameState.mapBounds.maxY - enemy.radius, enemy.y));
                
                if (progress >= 1) {
                    enemy.isJudgmentPushing = false;
                } else {
                    return; // ë°€ë ¤ë‚˜ëŠ” ì¤‘ì—ëŠ” ë‹¤ë¥¸ ì´ë™ ë¶ˆê°€
                }
            }

            // ì´ë™ì†ë„ ê°ì†Œ ì²˜ë¦¬ (ê¹Šì€ ìƒì²˜)
            let currentSpeed = enemy.speed;
            if (now < enemy.slowEndTime) {
                    currentSpeed *= 0.75; // -25%
                }
            
            // íšŒí”¼ê¸°ë™: ì¬ì¥ì „ ì¤‘ ì´ë™ì†ë„ +75% (ì¤‘ì²©)
            if (enemy.hasEvasiveManeuver && enemy.isReloading) {
                const evasiveManeuverCount = enemy.evasiveManeuverCount || 1;
                currentSpeed *= (1 + 0.75 * evasiveManeuverCount);
            }
            
            // ìƒì¡´ë³¸ëŠ¥: ì²´ë ¥ì´ 1ì¼ ë•Œ ì´ë™ì†ë„ +50% (ì¤‘ì²©)
            if (enemy.hasSurvivalInstinct && enemy.health === 1) {
                const survivalInstinctCount = enemy.survivalInstinctCount || 1;
                currentSpeed *= (1 + 0.5 * survivalInstinctCount);
            }
            
            // íšŒë³µê³„ì•½: ì²´ë ¥ì´ 1ì¼ ë•Œ ì²´ë ¥ 2íšŒë³µ (íšŒë³µëŸ‰ ì¤‘ì²©)
            if (enemy.hasRecoveryContract && !enemy.hasRecoveryContractUsed && enemy.health === 1) {
                const recoveryContractCount = enemy.recoveryContractCount || 1;
                enemy.health = Math.min(enemy.health + (2 * recoveryContractCount), enemy.maxHealth);
                enemy.hasRecoveryContractUsed = true;
            }

            enemy.aiTimer++;

            // í”Œë ˆì´ì–´ê°€ ì´ì„ ì˜ëŠ”ì§€ ê°ì§€
            const currentPlayerBulletCount = player.bullets.length;
            if (currentPlayerBulletCount > enemy.lastPlayerBulletCount) {
                // í”Œë ˆì´ì–´ê°€ ì´ì„ ìˆìŒ
                const dodgeProbability = 0.85; // 85% í™•ë¥ 
                if (Math.random() < dodgeProbability) {
                    // 85% í™•ë¥ ë¡œ íšŒí”¼
                    enemy.isDodgingBullet = true;
                    // ì´ì•Œ ë°©í–¥ì—ì„œ +90ë„ ë˜ëŠ” -90ë„ë¡œ ì´ë™
                    const bulletAngle = player.angle; // í”Œë ˆì´ì–´ê°€ ìœ ì´ì•Œì˜ ë°©í–¥
                    const dodgeDirection = Math.random() < 0.5 ? 1 : -1; // 1 = +90ë„, -1 = -90ë„
                    const dodgeAngle = bulletAngle + (dodgeDirection * Math.PI / 2); // Â±90ë„
                    const dodgeDistance = 30 + Math.random() * 30; // 30px~60px ëœë¤
                    
                    // Â±90ë„ ë°©í–¥ìœ¼ë¡œ ëœë¤ ê±°ë¦¬ë§Œí¼ ì´ë™í•œ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
                    const targetX = enemy.x + Math.cos(dodgeAngle) * dodgeDistance;
                    const targetY = enemy.y + Math.sin(dodgeAngle) * dodgeDistance;
                    
                    // ê²½ê³„ ì²´í¬
                    enemy.bulletDodgeTargetX = Math.max(
                        enemy.radius,
                        Math.min(canvas.width - enemy.radius, targetX)
                    );
                    enemy.bulletDodgeTargetY = Math.max(
                        enemy.radius,
                        Math.min(canvas.height - enemy.radius, targetY)
                    );
                    // í˜„ì¬ ì›€ì§ì„ ë©ˆì¶”ê¸°
                    enemy.aiTimer = 0;
                }
            }
            enemy.lastPlayerBulletCount = currentPlayerBulletCount;

            // ì´ì•Œ íšŒí”¼ ì¤‘ì´ë©´ ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
            if (enemy.isDodgingBullet) {
                const dxToTarget = enemy.bulletDodgeTargetX - enemy.x;
                const dyToTarget = enemy.bulletDodgeTargetY - enemy.y;
                const distanceToTarget = Math.sqrt(dxToTarget * dxToTarget + dyToTarget * dyToTarget);
                
                if (distanceToTarget > 2) {
                    // ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
                    enemy.aiDirection = Math.atan2(dyToTarget, dxToTarget);
                } else {
                    // ëª©í‘œ ìœ„ì¹˜ì— ë„ë‹¬í–ˆìœ¼ë©´ íšŒí”¼ ì¢…ë£Œ
                    enemy.isDodgingBullet = false;
                    enemy.aiTimer = 0; // ìƒˆë¡œìš´ ë°©í–¥ ì„ íƒ
                }
            }

            // í”Œë ˆì´ì–´ ì´ë™ ë°©í–¥ ì¶”ì  (ì˜ˆì¸¡ ë°œì‚¬ìš©)
            if (enemy.lastPlayerX === 0 && enemy.lastPlayerY === 0) {
                enemy.lastPlayerX = player.x;
                enemy.lastPlayerY = player.y;
            }
            // í”Œë ˆì´ì–´ ì†ë„ ê³„ì‚° (í”„ë ˆì„ë‹¹ ì´ë™ëŸ‰)
            enemy.playerVelocity.x = player.x - enemy.lastPlayerX;
            enemy.playerVelocity.y = player.y - enemy.lastPlayerY;
            enemy.lastPlayerX = player.x;
            enemy.lastPlayerY = player.y;

            // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ê°ë„ ì„¤ì •
            const dxToPlayer = player.x - enemy.x;
            const dyToPlayer = player.y - enemy.y;
            enemy.angle = Math.atan2(dyToPlayer, dxToPlayer);

            // í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ ê³„ì‚°
            const distance = Math.sqrt(dxToPlayer * dxToPlayer + dyToPlayer * dyToPlayer);
            const safeDistance = 500; // ì•ˆì „ ê±°ë¦¬ (500px)

            const aiTimerThreshold = 30; // ì›ë˜ëŒ€ë¡œ ë³µêµ¬ (30í”„ë ˆì„ = ì•½ 0.5ì´ˆ)
            
            // ì  ì´ë™ íŒ¨í„´ ê°œì„  - ìœ„ì•„ë˜ë¡œ ë” ìì£¼ ì›€ì§ì„ (íšŒí”¼ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
            if (!enemy.isDodgingBullet && enemy.aiTimer > aiTimerThreshold) {
                let targetAngle;
                
                // ëœë¤í•˜ê²Œ ë‹¤ì–‘í•œ ì›€ì§ì„ íŒ¨í„´ ì‚¬ìš©
                const movementPattern = Math.random();
                
                if (movementPattern < 0.2) {
                    // 20% í™•ë¥ : í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ì´ë™
                    targetAngle = Math.atan2(dyToPlayer, dxToPlayer);
                } else if (movementPattern < 0.35) {
                    // 15% í™•ë¥ : í”Œë ˆì´ì–´ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì´ë™
                    targetAngle = Math.atan2(-dyToPlayer, -dxToPlayer);
                } else if (movementPattern < 0.45) {
                    // 10% í™•ë¥ : ì¸¡ë©´ ì´ë™ (ì™¼ìª½/ì˜¤ë¥¸ìª½)
                    targetAngle = Math.atan2(dyToPlayer, dxToPlayer) + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                } else if (movementPattern < 0.75) {
                    // 30% í™•ë¥ : ìœ„ì•„ë˜ ì´ë™ (í”Œë ˆì´ì–´ ë°©í–¥ ê¸°ì¤€ ìœ„/ì•„ë˜)
                    const playerAngle = Math.atan2(dyToPlayer, dxToPlayer);
                    targetAngle = playerAngle + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                } else {
                    // 25% í™•ë¥ : ì™„ì „ ëœë¤ ë°©í–¥
                    targetAngle = Math.random() * Math.PI * 2;
                }
                
                // ê±°ë¦¬ ê¸°ë°˜ ì¡°ì • (ì„ íƒì )
                if (distance < safeDistance * 0.7) {
                    // ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë©€ì–´ì§€ëŠ” ê²½í–¥
                    if (movementPattern < 0.5) {
                        targetAngle = Math.atan2(-dyToPlayer, -dxToPlayer);
                    }
                }
                
                // ëœë¤ ê°ë„ ì¶”ê°€ë¡œ ë” ìì—°ìŠ¤ëŸ¬ìš´ ì›€ì§ì„
                const randomAngle = (Math.random() - 0.5) * Math.PI * 0.5; // Â±45ë„ ëœë¤
                enemy.aiDirection = targetAngle + randomAngle;
                enemy.aiTimer = 0;
            }

            // ë²½ì— ë„ˆë¬´ ë¶™ìœ¼ë©´ ë§µ ì¤‘ì•™ìœ¼ë¡œ ì´ë™ (íšŒí”¼ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
            if (!enemy.isDodgingBullet) {
                const mapWidth = gameState.mapBounds.maxX - gameState.mapBounds.minX;
                const mapHeight = gameState.mapBounds.maxY - gameState.mapBounds.minY;
                const wallThreshold = Math.min(mapWidth, mapHeight) * 0.05; // ë§µ í¬ê¸°ì˜ 5% ì´ë‚´
                
                const distToLeftWall = enemy.x - (gameState.mapBounds.minX + enemy.radius);
                const distToRightWall = (gameState.mapBounds.maxX - enemy.radius) - enemy.x;
                const distToTopWall = enemy.y - (gameState.mapBounds.minY + enemy.radius);
                const distToBottomWall = (gameState.mapBounds.maxY - enemy.radius) - enemy.y;
                
                // ë²½ì— ë„ˆë¬´ ë¶™ì—ˆëŠ”ì§€ í™•ì¸
                if (distToLeftWall < wallThreshold || distToRightWall < wallThreshold ||
                    distToTopWall < wallThreshold || distToBottomWall < wallThreshold) {
                    // ë§µ ì¤‘ì•™ìœ¼ë¡œ ì´ë™
                    const centerX = (gameState.mapBounds.minX + gameState.mapBounds.maxX) / 2;
                    const centerY = (gameState.mapBounds.minY + gameState.mapBounds.maxY) / 2;
                    const dxToCenter = centerX - enemy.x;
                    const dyToCenter = centerY - enemy.y;
                    enemy.aiDirection = Math.atan2(dyToCenter, dxToCenter);
                    enemy.aiTimer = 0;
                }
            }
            
            // ê²½ê³„ì— ë‹¿ìœ¼ë©´ ë°©í–¥ ë³€ê²½ (ë§µ ê²½ê³„ ì‚¬ìš©)
            if (enemy.x < gameState.mapBounds.minX + enemy.radius || enemy.x > gameState.mapBounds.maxX - enemy.radius ||
                enemy.y < gameState.mapBounds.minY + enemy.radius || enemy.y > gameState.mapBounds.maxY - enemy.radius) {
                enemy.aiDirection = Math.random() * Math.PI * 2;
                enemy.aiTimer = 0;
            }

            // ì´ë™ ê³„ì‚°
            let dx = Math.cos(enemy.aiDirection) * currentSpeed;
            let dy = Math.sin(enemy.aiDirection) * currentSpeed;
            
            // ë¬´ë¹™ì›Œí¬ëª¨ë“œ: 5ì´ˆë§ˆë‹¤ ë°”ë€ŒëŠ” ë°©í–¥ìœ¼ë¡œ ì´ˆë‹¹ 25px ì´ë™ ì¶”ê°€ (í”Œë ˆì´ì–´ì™€ ê°™ì€ ë°©í–¥)
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'movingWork') {
                // ìœ„, ì•„ë˜, ì¢Œ, ìš° 4ë°©í–¥ ì¤‘ 1ê°œ ì„ íƒ (í”Œë ˆì´ì–´ì™€ ê°™ì€ ë°©í–¥ ì‚¬ìš©)
                if (!gameState.movingWorkDirection) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // ìš°, ì•„ë˜, ì¢Œ, ìœ„
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // 5ì´ˆë§ˆë‹¤ ë°©í–¥ ë³€ê²½
                if (now - gameState.movingWorkLastChange >= 5000) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // ìš°, ì•„ë˜, ì¢Œ, ìœ„
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // ì´ˆë‹¹ 25px ì´ë™ (ë¶€ë“œëŸ½ê²Œ) - currentSpeedë¥¼ ê³±í•˜ì§€ ì•Šê³  ì§ì ‘ ì¶”ê°€
                const moveSpeed = 25 / 60; // 60fps ê¸°ì¤€
                const moveDx = Math.cos(gameState.movingWorkDirection) * moveSpeed;
                const moveDy = Math.sin(gameState.movingWorkDirection) * moveSpeed;
                
                // AI ì´ë™ê³¼ ë¬´ë¹™ì›Œí¬ ì´ë™ í•©ì‚°
                dx += moveDx;
                dy += moveDy;
            }

            // ë¹™íŒëª¨ë“œ: ë¯¸ë„ëŸ¬ì§ íš¨ê³¼
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'ice') {
                // ì†ë„ ë²¡í„° ì´ˆê¸°í™”
                if (enemy.velocityX === undefined) enemy.velocityX = 0;
                if (enemy.velocityY === undefined) enemy.velocityY = 0;
                
                // ì…ë ¥ì´ ìˆìœ¼ë©´ ì†ë„ ë²¡í„° ì—…ë°ì´íŠ¸ (í•­ìƒ ì—…ë°ì´íŠ¸)
                enemy.velocityX = dx;
                enemy.velocityY = dy;
                
                // ë§ˆì°° ì ìš© (ì†ë„ ê°ì†Œ) - ë¹™íŒëª¨ë“œì—ì„œëŠ” í›¨ì”¬ ë” ì˜ ë¯¸ë„ëŸ¬ì§
                enemy.velocityX *= 0.995;
                enemy.velocityY *= 0.995;
                
                // ì†ë„ê°€ ë§¤ìš° ì‘ìœ¼ë©´ ì •ì§€
                if (Math.abs(enemy.velocityX) < 0.01) enemy.velocityX = 0;
                if (Math.abs(enemy.velocityY) < 0.01) enemy.velocityY = 0;
                
                // ì†ë„ ë²¡í„°ë¡œ ì´ë™
                let newX = enemy.x + enemy.velocityX;
                let newY = enemy.y + enemy.velocityY;
                
                // ê²½ê³„ ì²´í¬ (ë§µ ê²½ê³„ ì‚¬ìš©) - ê²½ê³„ë¥¼ ë„˜ì–´ê°€ë©´ ê°•ì œë¡œ ê²½ê³„ ì•ˆìœ¼ë¡œ ì œí•œ
                newX = Math.max(gameState.mapBounds.minX + enemy.radius, Math.min(gameState.mapBounds.maxX - enemy.radius, newX));
                newY = Math.max(gameState.mapBounds.minY + enemy.radius, Math.min(gameState.mapBounds.maxY - enemy.radius, newY));
                
                // ê²½ê³„ì— ë‹¿ìœ¼ë©´ ì†ë„ ë°˜ì‚¬
                if (newX !== enemy.x + enemy.velocityX) enemy.velocityX *= -0.5;
                if (newY !== enemy.y + enemy.velocityY) enemy.velocityY *= -0.5;
                
                enemy.x = newX;
                enemy.y = newY;
            } else {
                // ì¼ë°˜ ì´ë™
                enemy.x = Math.max(gameState.mapBounds.minX + enemy.radius, Math.min(gameState.mapBounds.maxX - enemy.radius, enemy.x + dx));
                enemy.y = Math.max(gameState.mapBounds.minY + enemy.radius, Math.min(gameState.mapBounds.maxY - enemy.radius, enemy.y + dy));
                // ë¹™íŒëª¨ë“œê°€ ì•„ë‹ ë•ŒëŠ” ì†ë„ ë²¡í„° ì´ˆê¸°í™”
                enemy.velocityX = 0;
                enemy.velocityY = 0;
            }
            
            // ê°ë„ ê³„ì‚° (í”Œë ˆì´ì–´ ë°©í–¥)
            enemy.angle = Math.atan2(dyToPlayer, dxToPlayer);


            // ê·¼ì ‘ì „ëª¨ë“œ: í”Œë ˆì´ì–´ê°€ 500px ì•ˆì— ë“¤ì–´ì™”ì„ ë•Œë§Œ ë°œì‚¬
            const isMeleeMode = gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'melee';
            const maxDistance = isMeleeMode ? 500 : Math.max(canvas.width, canvas.height) * 0.8; // ê·¼ì ‘ì „ëª¨ë“œë©´ 500px, ì•„ë‹ˆë©´ í™”ë©´ í¬ê¸°ì˜ 80%
            const shootProbability = isMeleeMode ? 0.6 : 0.3; // ê·¼ì ‘ì „ëª¨ë“œë©´ ë” ì ê·¹ì ìœ¼ë¡œ ë°œì‚¬ (60%)
            const nowForShoot = Date.now();
            // ì¿¨íƒ€ì„ ì²´í¬ ì¶”ê°€ (ê·¼ì ‘ì „ëª¨ë“œë©´ ì¿¨íƒ€ì„ ê°ì†Œ)
            const shootCooldown = isMeleeMode ? enemy.shootCooldown * 0.7 : enemy.shootCooldown; // ê·¼ì ‘ì „ëª¨ë“œë©´ ì¿¨íƒ€ì„ 30% ê°ì†Œ
            const canShoot = !enemy.lastShot || (nowForShoot - enemy.lastShot >= shootCooldown);
            if (distance < maxDistance && enemy.ammo > 0 && !enemy.isReloading && canShoot && Math.random() < shootProbability) {
                // í”Œë ˆì´ì–´ê°€ ì›€ì§ì´ê³  ìˆëŠ”ì§€ í™•ì¸
                const playerSpeed = Math.sqrt(enemy.playerVelocity.x * enemy.playerVelocity.x + enemy.playerVelocity.y * enemy.playerVelocity.y);
                const isPlayerMoving = playerSpeed > 0.1; // 0.1px ì´ìƒ ì›€ì§ì´ë©´ ì›€ì§ì´ëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼
                
                const originalAngle = enemy.angle;
                const currentAngle = Math.atan2(dyToPlayer, dxToPlayer);
                
                // í”Œë ˆì´ì–´ê°€ ë©ˆì¶°ìˆìœ¼ë©´ í•­ìƒ ì •í™•íˆ ì˜ê³ , ì›€ì§ì´ë©´ 70% ì •í™•íˆ, 30% Â±5ë„ ëœë¤
                if (!isPlayerMoving) {
                    // ë©ˆì¶°ìˆì„ ë•Œ: í•­ìƒ ì •í™•íˆ
                    enemy.angle = currentAngle;
                } else {
                    // ì›€ì§ì¼ ë•Œ: 70% ì •í™•íˆ, 30% Â±5ë„ ëœë¤
                    if (Math.random() < 0.7) {
                        // 70% í™•ë¥ : ì •í™•íˆ í”Œë ˆì´ì–´ ìœ„ì¹˜
                        enemy.angle = currentAngle;
                    } else {
                        // 30% í™•ë¥ : Â±5ë„ ëœë¤
                        const randomOffset = (Math.random() - 0.5) * 10 * Math.PI / 180; // Â±5ë„
                        enemy.angle = currentAngle + randomOffset;
                    }
                }
                
                shoot(enemy);
                enemy.lastShot = nowForShoot; // ë°œì‚¬ ì‹œê°„ ê¸°ë¡
                // ë°œì‚¬ í›„ ê°ë„ ë³µì› (ì´ë™ ë°©í–¥ ìœ ì§€)
                enemy.angle = originalAngle;
            }

            // ìë™ ì¬ì¥ì „
            if (enemy.ammo === 0 && !enemy.isReloading) {
                reload(enemy);
            }
        }

        // ì´ì•Œ ì—…ë°ì´íŠ¸
        function updateBullets(character) {
            for (let i = character.bullets.length - 1; i >= 0; i--) {
                const bullet = character.bullets[i];
                
                // ì‹œê°„ì •ì§€: ìƒëŒ€ì˜ ì´ì•Œì€ ë©ˆì¶¤ (ì‚¬ìš©ìëŠ” ì˜í–¥ ì—†ìŒ)
                const target = character === player ? enemy : player;
                if (target.timeStopActive && character !== target) {
                    continue; // ì´ì•Œ ì—…ë°ì´íŠ¸ ì•ˆ í•¨ (ë©ˆì¶¤)
                }
                
                // ì‹œê°„ì¥ë§‰: ì ì˜ ì´ì•Œì´ í”Œë ˆì´ì–´ì˜ ì‹œê°„ì¥ë§‰ ì•ˆì— ìˆìœ¼ë©´ ì†ë„ 35% ë‘”í™”
                if (character === enemy && player.hasTimeBarrier) {
                    const dx = bullet.x - player.x;
                    const dy = bullet.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= player.timeBarrierRadius) {
                        // ì†ë„ 65%ë¡œ ì„¤ì • (35% ê°ì†Œ) - í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„ ê¸°ì¤€ìœ¼ë¡œ
                        const baseSpeedForBarrier = bullet.hallucinationSpeed !== undefined ? bullet.hallucinationSpeed : (bullet.baseSpeed || bullet.speed);
                        bullet.speed = baseSpeedForBarrier * 0.65;
                        bullet.isInTimeBarrier = true;
                    } else {
                        // ì‹œê°„ì¥ë§‰ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì›ë˜ ì†ë„ë¡œ ë³µì› (í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„)
                        bullet.isInTimeBarrier = false;
                        if (bullet.hallucinationSpeed !== undefined) {
                            bullet.speed = bullet.hallucinationSpeed;
                        } else {
                            bullet.speed = bullet.baseSpeed || bullet.speed;
                        }
                    }
                }
                // ì‹œê°„ì¥ë§‰: í”Œë ˆì´ì–´ì˜ ì´ì•Œì´ ì ì˜ ì‹œê°„ì¥ë§‰ ì•ˆì— ìˆìœ¼ë©´ ì†ë„ 35% ë‘”í™”
                if (character === player && enemy.hasTimeBarrier) {
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= enemy.timeBarrierRadius) {
                        // ì†ë„ 65%ë¡œ ì„¤ì • (35% ê°ì†Œ) - í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„ ê¸°ì¤€ìœ¼ë¡œ
                        const baseSpeedForBarrier = bullet.hallucinationSpeed !== undefined ? bullet.hallucinationSpeed : (bullet.baseSpeed || bullet.speed);
                        bullet.speed = baseSpeedForBarrier * 0.65;
                        bullet.isInTimeBarrier = true;
                    } else {
                        // ì‹œê°„ì¥ë§‰ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì›ë˜ ì†ë„ë¡œ ë³µì› (í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„)
                        bullet.isInTimeBarrier = false;
                        if (bullet.hallucinationSpeed !== undefined) {
                            bullet.speed = bullet.hallucinationSpeed;
                        } else {
                            bullet.speed = bullet.baseSpeed || bullet.speed;
                        }
                    }
                }
                
                // ê·¼ì ‘ì „ëª¨ë“œ: ì´ì•Œì´ 500px ì´ë™í–ˆëŠ”ì§€ ì²´í¬
                if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'melee') {
                    if (!bullet.isStopped) {
                        // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê±°ë¦¬ ê³„ì‚°
                        const currentDistance = Math.sqrt(
                            Math.pow(bullet.x - bullet.startX, 2) + 
                            Math.pow(bullet.y - bullet.startY, 2)
                        );
                        
                        if (currentDistance >= 500) {
                            // ì´ì•Œì´ 500pxë¥¼ ë„˜ì—ˆìœ¼ë©´ ì •í™•íˆ 500px ìœ„ì¹˜ë¡œ ì¡°ì •
                            const angle = Math.atan2(bullet.y - bullet.startY, bullet.x - bullet.startX);
                            bullet.x = bullet.startX + Math.cos(angle) * 500;
                            bullet.y = bullet.startY + Math.sin(angle) * 500;
                            
                            // ì´ì•Œ ë©ˆì¶”ê¸°
                            bullet.isStopped = true;
                            bullet.stopTime = Date.now();
                            bullet.speed = 0; // ì†ë„ 0ìœ¼ë¡œ ì„¤ì •
                        } else {
                            // ì•„ì§ 500px ë¯¸ë§Œì´ë©´ ì—…ë°ì´íŠ¸
                            bullet.update();
                            
                            // update í›„ ë‹¤ì‹œ ì²´í¬ (500pxë¥¼ ë„˜ì—ˆëŠ”ì§€)
                            const newDistance = Math.sqrt(
                                Math.pow(bullet.x - bullet.startX, 2) + 
                                Math.pow(bullet.y - bullet.startY, 2)
                            );
                            if (newDistance >= 500) {
                                // ì •í™•íˆ 500px ìœ„ì¹˜ë¡œ ì¡°ì •
                                const angle = Math.atan2(bullet.y - bullet.startY, bullet.x - bullet.startX);
                                bullet.x = bullet.startX + Math.cos(angle) * 500;
                                bullet.y = bullet.startY + Math.sin(angle) * 500;
                                
                                bullet.isStopped = true;
                                bullet.stopTime = Date.now();
                                bullet.speed = 0;
                            }
                        }
                    } else {
                        // ë©ˆì¶˜ ì´ì•Œ: 0.7ì´ˆ í›„ í˜ì´ë“œ ì•„ì›ƒ ì‹œì‘, 1ì´ˆ í›„ ì œê±°
                        const now = Date.now();
                        const elapsed = now - bullet.stopTime;
                        
                        if (elapsed >= 700 && bullet.fadeStartTime === 0) {
                            // í˜ì´ë“œ ì•„ì›ƒ ì‹œì‘
                            bullet.fadeStartTime = now;
                        }
                        
                        if (elapsed >= 1000) {
                            character.bullets.splice(i, 1);
                            continue;
                        }
                    }
                } else {
                    // ê·¼ì ‘ì „ëª¨ë“œê°€ ì•„ë‹ˆë©´ ì¼ë°˜ ì—…ë°ì´íŠ¸
                    bullet.update();
                }

                // ë¶€ë§¤ë‘: ë˜ëŒì•„ì˜¤ëŠ” ì´ì•Œì´ í”Œë ˆì´ì–´ì—ê²Œ ë‹¿ìœ¼ë©´ ì‚­ì œ
                if (bullet.hasBoomerang && bullet.isReturning && bullet.owner) {
                    if (checkCollision(bullet, bullet.owner)) {
                        character.bullets.splice(i, 1);
                        continue;
                    }
                }
                
                // ê²½ê³„ ì²´í¬ (ë©ˆì¶˜ ì´ì•Œì€ ê²½ê³„ ì²´í¬ ì•ˆ í•¨, ë¶€ë§¤ë‘ ì´ì•Œì€ ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ë„ ë˜ëŒì•„ì˜¤ë¯€ë¡œ ê²½ê³„ ì²´í¬ ì•ˆ í•¨)
                if (!bullet.isStopped && !bullet.hasBoomerang && bullet.isOutOfBounds()) {
                    character.bullets.splice(i, 1);
                    continue;
                }

                // ì¶©ëŒ ì²´í¬ (targetì€ ìœ„ì—ì„œ ì´ë¯¸ ì„ ì–¸ë¨)
                if (checkCollision(bullet, target)) {
                    // ê²Œì„ì´ ì¼ì‹œì •ì§€ëœ ìƒíƒœë©´ ë°ë¯¸ì§€ ë¬´ì‹œ (ì¦ê°• ì„ íƒ ì‹œê°„ ë™ì•ˆ)
                    if (gameState.isPaused) {
                        character.bullets.splice(i, 1);
                        continue;
                    }
                    // ë°˜ì‚¬ ë³´í˜¸ë§‰: ì ì˜ ì´ì•Œì„ ë°˜ì‚¬
                    if (target.reflectActive && character !== target) {
                        // ì´ì•Œ ë°©í–¥ì„ ë°˜ëŒ€ë¡œ (ìƒëŒ€ ìª½ìœ¼ë¡œ)
                        const dxToTarget = character.x - target.x;
                        const dyToTarget = character.y - target.y;
                        bullet.angle = Math.atan2(dyToTarget, dxToTarget);
                        bullet.owner = target; // ì´ì•Œ ì†Œìœ ìë¥¼ ë³€ê²½
                        // ì´ì•Œì„ targetì˜ bullets ë°°ì—´ë¡œ ì´ë™
                        character.bullets.splice(i, 1);
                        target.bullets.push(bullet);
                        continue; // ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                    }
                    // ë°˜ì‚¬ ë³´í˜¸ë§‰: ì ì˜ ì´ì•Œì„ ë°˜ì‚¬
                    if (target.reflectActive && character !== target) {
                        // ì´ì•Œ ë°©í–¥ì„ ë°˜ëŒ€ë¡œ (ìƒëŒ€ ìª½ìœ¼ë¡œ)
                        const dxToTarget = character.x - target.x;
                        const dyToTarget = character.y - target.y;
                        bullet.angle = Math.atan2(dyToTarget, dxToTarget);
                        bullet.owner = target; // ì´ì•Œ ì†Œìœ ìë¥¼ ë³€ê²½
                        // ì´ì•Œì„ targetì˜ bullets ë°°ì—´ë¡œ ì´ë™
                        character.bullets.splice(i, 1);
                        target.bullets.push(bullet);
                        continue; // ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                    }
                    
                    // êµ¬ë¥´ëŠ” ì¤‘ì´ê±°ë‚˜ ë¬´ì  ìƒíƒœë©´ ë°ë¯¸ì§€ ë¬´ì‹œ
                    if (target.isDodging || target.isInvincible || target.isReviving) {
                        character.bullets.splice(i, 1);
                        continue;
                    }

                    // ë°©ì–´ë§‰: ë°ë¯¸ì§€ 1íšŒ ë¬´ì‹œ (ì¿¨íƒ€ì„ 7.5ì´ˆ)
                    if (target.hasShield && target.shieldReady) {
                        target.shieldReady = false;
                        target.shieldCooldown = Date.now() + 7500; // 7.5ì´ˆ ì¿¨íƒ€ì„
                        character.bullets.splice(i, 1);
                        // "ë¬´ì‹œ" í…ìŠ¤íŠ¸ í‘œì‹œ
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isShield: true, // ë°©ì–´ë§‰ ë¬´ì‹œ ì—¬ë¶€
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: 0
                        });
                        continue; // ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                    }

                    // ìœ ë ¹ ì¦ê°•: í™•ë¥  ì¤‘ì²© (25% * count)
                    const ghostCount = target.ghostCount || 1;
                    if (target.hasGhost && Math.random() < (0.25 * ghostCount)) {
                        // "ë¬´ì‹œ" í…ìŠ¤íŠ¸ í‘œì‹œ
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isGhost: true, // ìœ ë ¹ ë¬´ì‹œ ì—¬ë¶€
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: 0
                        });
                        // ì´ì•Œ ì œê±°í•˜ê³  ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                        character.bullets.splice(i, 1);
                        i--; // ì¸ë±ìŠ¤ ì¡°ì •
                        continue; // ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                    }

                    // í¬ë¦¬í‹°ì»¬ ê³„ì‚° (í™•ë¥  ì¤‘ì²©: 25% * count)
                    let finalDamage = bullet.damage;
                    let isCritical = false;
                    const criticalCount = character.criticalCount || 1;
                    if (character.hasCritical && Math.random() < (0.25 * criticalCount)) {
                        finalDamage *= 2;
                        isCritical = true;
                    }
                    
                    // ì·¨ì•½ ìƒíƒœ: ë‹¤ìŒ ë°ë¯¸ì§€ 1.5ë°°
                    if (target.isVulnerable && !target.vulnerabilityUsed) {
                        finalDamage *= 1.5;
                        target.vulnerabilityUsed = true; // ì·¨ì•½ ì‚¬ìš©ë¨
                        target.isVulnerable = false; // ì·¨ì•½ ìƒíƒœ í•´ì œ
                    }

                    // ê±°ì í™•ë³´: ë°ë¯¸ì§€ *0.5
                    if (target.hasFortify && target.isFortified) {
                        finalDamage *= 0.5;
                    }

                    // ê³¼ì—´: ì—°ì† íˆíŠ¸ ì‹œ ë°ë¯¸ì§€ ë°°ìœ¨ ì ìš©
                    if (character.hasOverheat) {
                        const now = Date.now();
                        // 2ì´ˆ ì´ë‚´ì— íˆíŠ¸í•˜ë©´ ì—°ì† íˆíŠ¸ë¡œ ê°„ì£¼
                        if (now - character.lastHitTime < 2000) {
                            character.overheatHitCount++;
                        } else {
                            // 2ì´ˆ ì´ìƒ ì§€ë‚˜ë©´ ì´ˆê¸°í™”
                            character.overheatHitCount = 0;
                        }
                        // ë°ë¯¸ì§€ ë°°ìœ¨: 1 + hitCount * 0.5 (ì²«ë²ˆì§¸ëŠ” 1ë°°, ë‘ë²ˆì§¸ëŠ” 1.5ë°°, ì„¸ë²ˆì§¸ëŠ” 2ë°°...)
                        finalDamage *= (1 + character.overheatHitCount * 0.5);
                        character.lastHitTime = now;
                    }

                    // ì•½í™”: ìƒëŒ€ì—ê²Œ ì•½í™” ìƒíƒœ ë¶€ì—¬ (3ì´ˆ ë™ì•ˆ ëª¨ë“  ê³µê²© ë°ë¯¸ì§€ -0.25, ì¤‘ì²© ì•ˆë¨)
                    // ì•½í™”: ìƒëŒ€ì—ê²Œ ì´ì•Œì„ ë§ì¶œ ì‹œ 3ì´ˆë™ì•ˆ ìƒëŒ€ ë°ë¯¸ì§€ -0.25 (ì¤‘ì²©)
                    if (character.hasWeaken && !target.isWeakened) {
                        target.isWeakened = true;
                        target.weakenEndTime = Date.now() + 3000;
                    }

                    // ì†Œìˆ˜ì  3ìë¦¬ ì´ìƒì´ë©´ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼, 1~2ìë¦¬ëŠ” ìœ ì§€
                    finalDamage = roundToMaxTwoDecimals(finalDamage);
                    target.health -= finalDamage;
                    target.health = roundToMaxTwoDecimals(target.health);
                    
                    // í”¼ì˜ ë§›: ì ì—ê²Œ ì…íŒ í”¼í•´ì˜ 20%ë§Œí¼ íšŒë³µ (20%ì”© ì¤‘ì²©)
                    if (character.hasTasteOfBlood) {
                        const tasteOfBloodCount = character.tasteOfBloodCount || 1;
                        let healAmount = finalDamage * (0.2 * tasteOfBloodCount);
                        healAmount = roundToMaxTwoDecimals(healAmount);
                        const oldHealth = character.health;
                        character.health = Math.min(character.health + healAmount, character.maxHealth);
                        character.health = roundToMaxTwoDecimals(character.health);
                        const actualHeal = character.health - oldHealth;
                        if (actualHeal > 0) {
                            // íšŒë³µ ìˆ«ì í‘œì‹œ (ë¹¨ê°„ìƒ‰)
                            character.damageNumbers.push({
                                x: character.x,
                                y: character.y,
                                damage: roundToMaxTwoDecimals(actualHeal),
                                isCritical: false,
                                isHeal: true, // íšŒë³µ ì—¬ë¶€
                                startTime: Date.now(),
                                duration: 1000,
                                offsetY: 0
                            });
                        }
                    }
                    
                    // ì„ ê³ : ì ì„ ë§ì€ ë°©í–¥ìœ¼ë¡œ 75px ë°€ë ¤ë‚¨ (0.1ì´ˆ ì†Œìš”)
                    if (character.hasJudgment) {
                        const bulletAngle = bullet.angle;
                        const pushDistance = 75;
                        const pushDuration = 100; // 0.1ì´ˆ
                        const pushDx = Math.cos(bulletAngle) * pushDistance;
                        const pushDy = Math.sin(bulletAngle) * pushDistance;
                        
                        // ë°€ë ¤ë‚˜ëŠ” ëª©í‘œ ìœ„ì¹˜
                        const targetPushX = Math.max(
                            gameState.mapBounds.minX + target.radius,
                            Math.min(gameState.mapBounds.maxX - target.radius, target.x + pushDx)
                        );
                        const targetPushY = Math.max(
                            gameState.mapBounds.minY + target.radius,
                            Math.min(gameState.mapBounds.maxY - target.radius, target.y + pushDy)
                        );
                        
                        // ë°€ë ¤ë‚˜ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                        target.judgmentPushStartX = target.x;
                        target.judgmentPushStartY = target.y;
                        target.judgmentPushTargetX = targetPushX;
                        target.judgmentPushTargetY = targetPushY;
                        target.judgmentPushStartTime = Date.now();
                        target.judgmentPushDuration = pushDuration;
                        target.isJudgmentPushing = true;
                    }
                    
                    character.bullets.splice(i, 1);

                    // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ ì¶”ê°€
                    target.damageNumbers.push({
                        x: target.x,
                        y: target.y,
                        damage: finalDamage,
                        isCritical: isCritical, // í¬ë¦¬í‹°ì»¬ ì—¬ë¶€
                        startTime: Date.now(),
                        duration: 1000, // 1ì´ˆ ë™ì•ˆ í‘œì‹œ
                        offsetY: 0 // ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì˜¤í”„ì…‹
                    });

                    // ë²ˆê°œ: í™•ë¥  ì¤‘ì²© (25% * count)
                    const lightningCount = character.lightningCount || 1;
                    if (character.hasLightning && Math.random() < (0.25 * lightningCount)) {
                        target.isStunned = true;
                        target.stunEndTime = Date.now() + 750; // 0.75ì´ˆ
                        // ê¸°ì ˆ í…ìŠ¤íŠ¸ í‘œì‹œ (ë°ë¯¸ì§€ ìˆ«ì ìœ„ì— í‘œì‹œ)
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isStunned: true, // ê¸°ì ˆ ì—¬ë¶€
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: -40 // ë°ë¯¸ì§€ ìˆ«ì ìœ„ì— í‘œì‹œ
                        });
                    }

                    // ê¹Šì€ ìƒì²˜ (í”¼ê²© ì‹œ ìƒëŒ€ ì´ë™ì†ë„ -25% (ì‹œê°„ ì¤‘ì²©))
                    if (character.hasDeepWound) {
                        const deepWoundCount = character.deepWoundCount || 1;
                        target.slowEndTime = Date.now() + (500 * deepWoundCount);
                    }
                    
                    // ë… íƒ„í™˜ íš¨ê³¼ (1ì´ˆê°„ê²©ìœ¼ë¡œ 3ë²ˆ, ë°ë¯¸ì§€ ì¤‘ì²©)
                    if (bullet.hasPoison) {
                        const poisonCount = character.poisonBulletCount || 1;
                        character.poisonEffects.push({
                            target: target,
                            startTime: Date.now(),
                            duration: 3000, // 3ì´ˆ (1ì´ˆê°„ê²©ìœ¼ë¡œ 3ë²ˆ)
                            damagePerSecond: 0.2 * poisonCount, // ì¤‘ì²©ëœ ë°ë¯¸ì§€
                            lastDamageTime: Date.now(),
                            hitCount: 0, // íˆíŠ¸ íšŸìˆ˜
                            maxHits: 3 // ìµœëŒ€ íˆíŠ¸ íšŸìˆ˜
                        });
                    }
                    
                    // ì§‘ì¤‘ ì‚¬ê²©: í”¼ê²©ì‹œ 50% í™•ë¥ ë¡œ ìƒëŒ€ì—ê²Œ ì·¨ì•½ ë¶€ì—¬
                    if (target.hasFocusedFire && Math.random() < 0.5) {
                        character.isVulnerable = true;
                        character.vulnerabilityUsed = false;
                    }

                    if (target.health <= 0) {
                        target.health = 0;
                        
                        // ë¶€í™œ ì²´í¬ (íšŸìˆ˜ ì¤‘ì²©)
                        const reviveCount = target.reviveCount || 1;
                        const hasRevivedCount = (typeof target.hasRevived === 'number' ? target.hasRevived : (target.hasRevived ? 1 : 0));
                        if (target.hasRevive && hasRevivedCount < reviveCount && !target.isReviving) {
                            target.hasRevived = hasRevivedCount + 1; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì¦ê°€
                            target.isReviving = true;
                            target.reviveTime = Date.now() + 2000; // 2ì´ˆ
                        } else {
                            endRound(character === player ? 'player' : 'enemy');
                        }
                    }
                    // ì²´ë ¥ì´ ìŒìˆ˜ê°€ ë˜ì§€ ì•Šë„ë¡
                    if (target.health < 0) target.health = 0;
                }
            }
        }

        // ë¼ìš´ë“œ ì¢…ë£Œ
        function endRound(winner) {
            // ë©€í‹°í”Œë ˆì´ì–´: ê²ŒìŠ¤íŠ¸ëŠ” í˜¸ìŠ¤íŠ¸ë¡œë¶€í„° ê²°ê³¼ë¥¼ ë°›ìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
            if (gameState.isMultiplayer && !isHost) {
                return; // ê²ŒìŠ¤íŠ¸ëŠ” handleRoundEndFromHostì—ì„œ ì²˜ë¦¬
            }
            
            gameState.isPaused = true;

            // ë©€í‹°í”Œë ˆì´ì–´: í˜¸ìŠ¤íŠ¸ê°€ ê²°ê³¼ ì „ì†¡
            if (gameState.isMultiplayer && isHost) {
                sendMultiplayerData({
                    type: 'roundEnd',
                    winner: winner === 'player' ? 'host' : 'guest'
                });
            }

            // ë¼ìš´ë“œ ìŠ¹ë¦¬ ê¸°ë¡ì— ì¶”ê°€ (ìˆœì„œëŒ€ë¡œ)
            gameState.roundWins.push(winner);

            if (winner === 'player') {
                gameState.playerWins++;
            } else {
                gameState.enemyWins++;
            }

            // ìŠ¹ë¦¬ ì²´í¬ (5ë¼ìš´ë“œ ì„ ìŠ¹ì œ)
            if (gameState.playerWins >= gameState.winsNeeded || gameState.enemyWins >= gameState.winsNeeded) {
                const finalWinner = winner === 'player' ? 'player' : 'enemy';
                endGame(finalWinner);
                return;
            }

            // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œ (í˜¸ìŠ¤íŠ¸)
            if (gameState.isMultiplayer) {
                if (winner === 'player') {
                    // ë‚´ê°€ ìŠ¹ë¦¬: ìƒëŒ€ê°€ ì¦ê°• ì„ íƒ ì¤‘ - 15ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ë§Œ í‘œì‹œ
                    gameState.showOpponentSelecting = true;
                    gameState.augmentCountdown = 15;
                    startOpponentWaitCountdown();
                } else {
                    // ë‚´ê°€ íŒ¨ë°°: ì¦ê°• ì„ íƒ
                    showAugmentModal(player);
                }
                return;
            }

            // ì†”ë¡œ ëª¨ë“œ: íŒ¨ë°°ìê°€ ì¦ê°• ì„ íƒ, ìŠ¹ë¦¬ìëŠ” í™•ì¸ë§Œ
            if (winner === 'player') {
                // í”Œë ˆì´ì–´ ìŠ¹ë¦¬: AIê°€ ì„ íƒ
                gameState.showOpponentSelecting = true;
                selectAugmentForEnemy();
            } else {
                // enemy ìŠ¹ë¦¬: í”Œë ˆì´ì–´ëŠ” ì„ íƒ
                showAugmentModal(player);
            }
        }

        // ì ì„ ìœ„í•œ ì¦ê°• ìë™ ì„ íƒ
        function selectAugmentForEnemy() {
            const enemySelectionDiv = document.getElementById('enemySelection');
            const opponentSelectionDiv = document.getElementById('opponentSelection');
            
            if (enemySelectionDiv) {
            enemySelectionDiv.style.display = 'block';
            enemySelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>';
            }
            
            if (opponentSelectionDiv) {
                opponentSelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>';
            }
            
            // 2Xëª¨ë“œ ì²´í¬ - AIë„ 2ê°œ ì„ íƒ
            const isDoubleAugmentMode = gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'doubleAugment';
            const selectCount = isDoubleAugmentMode ? 2 : 1;
            
            // 3ì´ˆ ëŒ€ê¸° í›„ ì„ íƒ
            setTimeout(() => {
                // AIëŠ” êµ¬ë¥´ê¸°, ê±°ì í™•ë³´, ì‹œê°„ì •ì§€ ì¦ê°•ì„ ë½‘ì§€ ì•ŠìŒ
                const availableAugments = augmentations.filter(aug => aug.id !== 'dodge' && aug.id !== 'fortify' && aug.id !== 'timeStop');
                const shuffled = [...availableAugments].sort(() => Math.random() - 0.5);
                
                // selectCountë§Œí¼ ì¦ê°• ì„ íƒ
                const selectedAugments = [];
                for (let i = 0; i < selectCount && i < shuffled.length; i++) {
                    const selectedAugment = shuffled[i];
                    selectedAugment.effect(enemy);
                    enemy.augmentations.push(selectedAugment);
                    incrementAugmentSelectCount(selectedAugment.id); // ì„ íƒ íšŸìˆ˜ ì¦ê°€
                    markAugmentAsSeen(selectedAugment.id); // ë³¸ ì¦ê°• ëª©ë¡ì— ì¶”ê°€
                    selectedAugments.push(selectedAugment);
                }
                
                // ì„ íƒí•œ ì¦ê°• í‘œì‹œ
                const selectedNames = selectedAugments.map(aug => aug.name).join(', ');
                if (enemySelectionDiv) {
                    enemySelectionDiv.innerHTML = `<p style="color: #e94560; margin: 0;">ìƒëŒ€ ì„ íƒ: <strong style="color: #ffc107;">${selectedNames}</strong></p>`;
                }
                if (opponentSelectionDiv) {
                    opponentSelectionDiv.innerHTML = `<p style="color: #e94560; margin: 0;">ìƒëŒ€ ì„ íƒ: <strong style="color: #ffc107;">${selectedNames}</strong></p>`;
                }
                
                // í”Œë ˆì´ì–´ê°€ ìŠ¹ë¦¬í•œ ê²½ìš°: ìƒëŒ€ ì„ íƒ ì™„ë£Œ í›„ ìë™ìœ¼ë¡œ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                if (gameState.showOpponentSelecting) {
                    gameState.showOpponentSelecting = false;
                    // ì•½ê°„ì˜ ë”œë ˆì´ í›„ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                    setTimeout(() => {
                        nextRound();
                    }, 500);
                }
            }, 3000);
        }

        // ì¦ê°• ëª¨ë‹¬ í‘œì‹œ (í”Œë ˆì´ì–´ìš© - ì„ íƒ ê°€ëŠ¥)
        function showAugmentModal(character) {
            const modal = document.getElementById('augmentModal');
            const optionsDiv = document.getElementById('augmentOptions');
            optionsDiv.innerHTML = '';

            // ëœë¤ ì¦ê°• 3ê°œ ì„ íƒ (ì¤‘ë³µ ì„ íƒ ê°€ëŠ¥)
            const shuffled = [...augmentations].sort(() => Math.random() - 0.5);
            const selectedAugments = shuffled.slice(0, 3);

            // ì„ íƒ ê°€ëŠ¥í•œ 3ê°œ ì¦ê°• ëª¨ë‘ ë„ê°ì— ì €ì¥
            selectedAugments.forEach(aug => {
                markAugmentAsSeen(aug.id);
            });

            let timeLeft = 15;
            let isSelected = false;
            let timerInterval;

            // 2Xëª¨ë“œ ì²´í¬
            const isDoubleAugmentMode = gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'doubleAugment';
            
            // 2Xëª¨ë“œì—ì„œ í˜„ì¬ ë¼ìš´ë“œì— ì„ íƒí•œ ì¦ê°• ê°œìˆ˜ ì´ˆê¸°í™” (ì²˜ìŒ í˜¸ì¶œ ì‹œì—ë§Œ)
            if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount === undefined) {
                gameState.doubleAugmentSelectedCount = 0;
            }
            
            const maxSelections = isDoubleAugmentMode ? 2 : 1;
            const currentSelectedCount = isDoubleAugmentMode ? (gameState.doubleAugmentSelectedCount || 0) : 0;

            // ì¦ê°• ì„ íƒ í•¨ìˆ˜
            const selectAugment = (aug) => {
                if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount >= maxSelections) return;
                if (!isDoubleAugmentMode && isSelected) return;
                
                aug.effect(character);
                character.augmentations.push(aug);
                incrementAugmentSelectCount(aug.id); // ì„ íƒ íšŸìˆ˜ ì¦ê°€
                
                // ë©€í‹°í”Œë ˆì´ì–´: ì¦ê°• ì„ íƒ ì •ë³´ ì „ì†¡
                if (gameState.isMultiplayer) {
                    sendMultiplayerData({
                        type: 'augmentSelected',
                        augment: { id: aug.id, name: aug.name }
                    });
                }
                
                if (isDoubleAugmentMode) {
                    gameState.doubleAugmentSelectedCount = (gameState.doubleAugmentSelectedCount || 0) + 1;
                }
                
                // 2Xëª¨ë“œì´ê³  ì²« ë²ˆì§¸ ì„ íƒì´ë©´ ì°½ì„ ë‹«ê³  ìƒˆë¡œìš´ ì°½ ë„ìš°ê¸°
                if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount === 1) {
                    isSelected = true;
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    modal.style.display = 'none';
                    
                    // ì•½ê°„ì˜ ë”œë ˆì´ í›„ ìƒˆë¡œìš´ ì°½ ë„ìš°ê¸°
                    setTimeout(() => {
                        showAugmentModal(character);
                    }, 300);
                    
                    return; // ì•„ì§ ì„ íƒ ì¤‘
                }
                
                // ì„ íƒ ì™„ë£Œ
                if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount >= maxSelections) {
                    isSelected = true;
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    gameState.doubleAugmentSelectedCount = 0; // ë‹¤ìŒ ë¼ìš´ë“œë¥¼ ìœ„í•´ ì´ˆê¸°í™”
                    modal.style.display = 'none';
                    const viewModal = document.getElementById('augmentViewModal');
                    if (viewModal) {
                        viewModal.style.display = 'none';
                    }
                    nextRound();
                } else if (!isDoubleAugmentMode) {
                    isSelected = true;
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    modal.style.display = 'none';
                    const viewModal = document.getElementById('augmentViewModal');
                    if (viewModal) {
                        viewModal.style.display = 'none';
                    }
                    nextRound();
                }
            };

            // ì¦ê°• ì˜µì…˜ ìƒì„±
            selectedAugments.forEach(aug => {
                const option = document.createElement('div');
                option.className = 'augment-option';
                option.innerHTML = `
                    <h4>${aug.name}</h4>
                    <p>${aug.description}</p>
                `;
                option.onclick = () => selectAugment(aug);
                optionsDiv.appendChild(option);
            });

            // ëª¨ë‹¬ í‘œì‹œ
            modal.style.display = 'block';
            const enemySelectionDiv = document.getElementById('enemySelection');
            // í”Œë ˆì´ì–´ê°€ íŒ¨ë°°í•œ ê²½ìš°: ì ì€ ìŠ¹ë¦¬ìì´ë¯€ë¡œ ì¦ê°•ì„ ì„ íƒí•˜ì§€ ì•ŠìŒ, ë©”ì‹œì§€ í‘œì‹œ ì•ˆí•¨
            enemySelectionDiv.style.display = 'none';
            
            // í™”ë©´ ê°€ìš´ë° ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
            gameState.augmentCountdown = 15;
            timerInterval = setInterval(() => {
                timeLeft--;
                gameState.augmentCountdown = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    if (!isSelected) {
                        // ì‹œê°„ ì´ˆê³¼ ì‹œ ëœë¤ ì„ íƒ
                        const randomAug = selectedAugments[Math.floor(Math.random() * selectedAugments.length)];
                        selectAugment(randomAug);
                    }
                }
            }, 1000);
        }

        // ì¦ê°• í™•ì¸ ëª¨ë‹¬ í‘œì‹œ (ìŠ¹ë¦¬ììš© - í™•ì¸ë§Œ ê°€ëŠ¥)
        function showAugmentViewModal(winnerCharacter, loserType) {
            const modal = document.getElementById('augmentViewModal');
            const opponentSelectionDiv = document.getElementById('opponentSelection');
            
            // ëª¨ë‹¬ í‘œì‹œ
            modal.style.display = 'block';
            opponentSelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>';
        }

        // ì¦ê°• í™•ì¸ ëª¨ë‹¬ ë‹«ê¸°
        function closeAugmentViewModal() {
            const modal = document.getElementById('augmentViewModal');
            modal.style.display = 'none';
            
            // ìƒëŒ€ ì„ íƒì´ ì™„ë£Œë˜ì—ˆìœ¼ë©´ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
            if (enemy.augmentations.length > 0) {
                nextRound();
            } else {
                // ì•„ì§ ì ì´ ì„ íƒ ì¤‘ì´ë©´ ëŒ€ê¸°
                const checkEnemySelection = setInterval(() => {
                    if (enemy.augmentations.length > 0) {
                        clearInterval(checkEnemySelection);
                        nextRound();
                    }
                }, 100);
            }
        }

        // ë‹¤ìŒ ë¼ìš´ë“œ
        function nextRound() {
            // ë©€í‹°í”Œë ˆì´ì–´: í˜¸ìŠ¤íŠ¸ê°€ ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘ ì•Œë¦¼
            if (gameState.isMultiplayer && isHost) {
                sendMultiplayerData({ type: 'nextRound' });
            }
            
            resizeCanvas();
            gameState.round++;
            gameState.gameTime = 180;
            gameState.showOpponentSelecting = false;
            // 2Xëª¨ë“œ ì„ íƒ ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'doubleAugment') {
                gameState.doubleAugmentSelectedCount = 0;
            }
            
            // ì „íˆ¬ ê²½í—˜: ì§„ ë¼ìš´ë“œ ìˆ˜ë§ˆë‹¤ ìµœëŒ€ì²´ë ¥ 0.5, ë°ë¯¸ì§€ 0.1 ì¦ê°€ (ì¤‘ì²©)
            if (player.hasCombatExperience) {
                player.combatExperienceRounds = gameState.enemyWins; // í”Œë ˆì´ì–´ê°€ ì§„ ë¼ìš´ë“œ ìˆ˜ (ì ì´ ì´ê¸´ ë¼ìš´ë“œ)
                const combatExperienceCount = player.combatExperienceCount || 1;
                player.maxHealth = 5 + player.combatExperienceRounds * (0.5 * combatExperienceCount);
                player.damage = 1 + player.combatExperienceRounds * (0.1 * combatExperienceCount);
            }
            if (enemy.hasCombatExperience) {
                enemy.combatExperienceRounds = gameState.playerWins; // ì ì´ ì§„ ë¼ìš´ë“œ ìˆ˜ (í”Œë ˆì´ì–´ê°€ ì´ê¸´ ë¼ìš´ë“œ)
                const combatExperienceCount = enemy.combatExperienceCount || 1;
                enemy.maxHealth = 5 + enemy.combatExperienceRounds * (0.5 * combatExperienceCount);
                enemy.damage = 1 + enemy.combatExperienceRounds * (0.1 * combatExperienceCount);
            }

            // í”Œë ˆì´ì–´ ìƒíƒœ ì´ˆê¸°í™” - ë©€í‹°í”Œë ˆì´ì–´ì¼ ë•Œ íŒ€ì— ë”°ë¥¸ ìœ„ì¹˜ ì„¤ì •
            const leftX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            const rightX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            const centerY = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            
            if (gameState.isMultiplayer && myTeam) {
                // ë©€í‹°í”Œë ˆì´ì–´: íŒŒë€íŒ€ì€ ì™¼ìª½, ë¹¨ê°„íŒ€ì€ ì˜¤ë¥¸ìª½
                player.x = myTeam === 'blue' ? leftX : rightX;
                enemy.x = myTeam === 'blue' ? rightX : leftX;
            } else {
                // ì†”ë¡œ: í”Œë ˆì´ì–´ ì™¼ìª½, ì  ì˜¤ë¥¸ìª½
                player.x = leftX;
            }
            player.y = centerY;
            player.health = player.maxHealth;
            player.displayHealth = player.maxHealth;
            player.ammo = player.maxAmmo;
            player.bullets = [];
            player.isReloading = false;
            player.isDodging = false;
            player.dodgeStartTime = 0;
            player.dodgeEndTime = 0;
            player.dodgeStartX = 0;
            player.dodgeStartY = 0;
            player.dodgeTargetX = 0;
            player.dodgeTargetY = 0;
            player.dodgeTrail = [];
            player.lastDodgeTime = 0;
            player.isReviving = false;
            player.reviveTime = 0;
            player.hasRevived = 0; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
            player.isInvincible = false;
            player.invincibleEndTime = 0;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.poisonEffects = [];
            player.hasRecoveryContractUsed = false; // íšŒë³µê³„ì•½ ì´ˆê¸°í™”
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.shieldReady = true; // ë°©ì–´ë§‰ ì¤€ë¹„ ìƒíƒœë¡œ ì´ˆê¸°í™”
            player.shieldCooldown = 0;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.lastRegenTime = Date.now(); // ì¬ìƒ ì‹œì‘ ì‹œê°„
            // ìƒˆë¡œìš´ ì¦ê°• ìƒíƒœ ì´ˆê¸°í™” (ë¼ìš´ë“œ ì´ˆê¸°í™”)
            player.gatlingBullets = 0;
            player.gatlingNextShot = 0;
            player.reflectActive = false;
            player.reflectCooldown = 0;
            player.reflectEndTime = 0;
            player.timeStopActive = false;
            player.timeStopCooldown = 0;
            player.timeStopEndTime = 0;

            // ì  ìƒíƒœ ì´ˆê¸°í™” - ë©€í‹°í”Œë ˆì´ì–´ê°€ ì•„ë‹ ë•Œë§Œ ìœ„ì¹˜ ì„¤ì • (ìœ„ì—ì„œ ì´ë¯¸ ì„¤ì •í•¨)
            if (!gameState.isMultiplayer) {
                enemy.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            }
            enemy.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            enemy.health = enemy.maxHealth;
            enemy.displayHealth = enemy.maxHealth;
            enemy.ammo = enemy.maxAmmo;
            enemy.bullets = [];
            enemy.isReloading = false;
            enemy.isDodging = false;
            enemy.dodgeStartTime = 0;
            enemy.dodgeEndTime = 0;
            enemy.dodgeStartX = 0;
            enemy.dodgeStartY = 0;
            enemy.dodgeTargetX = 0;
            enemy.dodgeTargetY = 0;
            enemy.bulletDodgeTargetY = 0;
            enemy.isDodgingBullet = false;
            enemy.lastPlayerBulletCount = 0;
            enemy.dodgeTrail = [];
            enemy.lastDodgeTime = 0;
            enemy.isReviving = false;
            enemy.reviveTime = 0;
            enemy.hasRevived = 0; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
            enemy.isInvincible = false;
            enemy.invincibleEndTime = 0;
            enemy.slowEndTime = 0;
            enemy.damageNumbers = [];
            enemy.usePrediction = false;
            enemy.lastPlayerX = 0;
            enemy.lastPlayerY = 0;
            enemy.playerVelocity = { x: 0, y: 0 };
            enemy.poisonEffects = [];
            enemy.hasRecoveryContractUsed = false; // íšŒë³µê³„ì•½ ì´ˆê¸°í™”
            enemy.isVulnerable = false;
            enemy.vulnerabilityUsed = false;
            enemy.isStunned = false;
            enemy.stunEndTime = 0;
            enemy.shieldReady = true; // ë°©ì–´ë§‰ ì¤€ë¹„ ìƒíƒœë¡œ ì´ˆê¸°í™”
            enemy.shieldCooldown = 0;
            enemy.isWeakened = false;
            enemy.weakenEndTime = 0;
            enemy.lastRegenTime = Date.now(); // ì¬ìƒ ì‹œì‘ ì‹œê°„
            // ìƒˆë¡œìš´ ì¦ê°• ìƒíƒœ ì´ˆê¸°í™” (ë¼ìš´ë“œ ì´ˆê¸°í™”)
            enemy.gatlingBullets = 0;
            enemy.gatlingNextShot = 0;
            enemy.reflectActive = false;
            enemy.reflectCooldown = 0;
            enemy.reflectEndTime = 0;
            enemy.timeStopActive = false;
            enemy.timeStopCooldown = 0;
            enemy.timeStopEndTime = 0;

            // 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (ê²Œì„ ì™„ì „íˆ ë©ˆì¶¤)
            gameState.countdown = 3;
            gameState.isPaused = true;
            
            // ì¹´ìš´íŠ¸ë‹¤ìš´ ì²˜ë¦¬ - ë©€í‹°í”Œë ˆì´ì–´ ê²ŒìŠ¤íŠ¸ëŠ” í˜¸ìŠ¤íŠ¸ì˜ ì¹´ìš´íŠ¸ë‹¤ìš´ì„ ë”°ë¦„
            if (!gameState.isMultiplayer || isHost) {
                const countdownInterval = setInterval(() => {
                    gameState.countdown--;
                    if (gameState.countdown <= 0) {
                        clearInterval(countdownInterval);
                        gameState.isPaused = false;
                    }
                }, 1000);
            }
        }

        // ê²Œì„ ì¢…ë£Œ
        function endGame(winner) {
            gameState.isGameOver = true;
            const modal = document.getElementById('gameOverModal');
            const title = document.getElementById('gameOverTitle');
            const message = document.getElementById('gameOverMessage');

            if (winner === 'player') {
                title.textContent = 'ìŠ¹ë¦¬';
                title.style.color = '#4a9eff'; // íŒŒë€ìƒ‰
                message.textContent = 'ìŠ¹ë¦¬';
                message.style.color = '#4a9eff'; // íŒŒë€ìƒ‰
            } else {
                title.textContent = 'íŒ¨ë°°';
                title.style.color = '#e94560'; // ë¹¨ê°„ìƒ‰
                message.textContent = 'íŒ¨ë°°';
                message.style.color = '#e94560'; // ë¹¨ê°„ìƒ‰
            }

            modal.style.display = 'block';
            
            // 10ì´ˆ í›„ ë©”ì¸í™”ë©´ìœ¼ë¡œ ì´ë™
            setTimeout(() => {
                // ìŠ¤í¬ë¡¤ì„ ë§¨ ìœ„ë¡œ ì´ë™
                window.scrollTo(0, 0);
                restartGame();
            }, 10000);
        }

        // ê²Œì„ ì¬ì‹œì‘
        function restartGame() {
            // ìŠ¤í¬ë¡¤ì„ ë§¨ ìœ„ë¡œ ì´ë™
            window.scrollTo(0, 0);
            
            // ë©€í‹°í”Œë ˆì´ì–´ ì—°ê²° ì •ë¦¬
            if (gameState.isMultiplayer || multiplayerPeer) {
                gameState.isMultiplayer = false;
                gameStarted = false;
                myTeam = null;
                opponentTeam = null;
                opponentReady = false;
                if (multiplayerPeer) {
                    multiplayerPeer.destroy();
                    multiplayerPeer = null;
                }
                multiplayerConnection = null;
                currentRoomCode = null;
            }
            
            // í”Œë ˆì´ì–´ ìƒ‰ìƒ ì´ˆê¸°í™”
            player.color = '#4a9eff';
            enemy.color = '#e94560';
            
            // ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
            gameState.isMenu = true;
            gameState.isGameOver = false;
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            
            // ë‹‰ë„¤ì„ í‘œì‹œ
            showNicknameDisplay();
            
            // ëª¨ë“œ ì„ íƒ ì ‘ê¸°
            collapseModeSelection();
            collapseMultiModeSelection();
            
            // ì²« ë¼ìš´ë“œ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
            gameState.isPaused = true;
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.isPaused = false;
                }
            }, 1000);

            player.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            player.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.hasCritical = false;
            player.hasDoubleShot = false;
            player.hasDodge = false;
            player.hasRevive = false;
            player.hasDeepWound = false;
            player.hasOneShotOneKill = false;
            player.hasPoisonBullet = false;
            player.hasReloadHeal = false;
            player.hasSurvivalInstinct = false;
            player.hasLastBullet = false;
            player.hasRecoveryContract = false;
            player.hasRecoveryContractUsed = false;
            player.hasFocusedFire = false;
            player.hasShotgun = false;
            player.hasRagged = false;
            player.hasGhost = false;
            player.hasFortify = false;
            player.isFortified = false;
            player.fortifyStartTime = 0;
            player.lastPosition = { x: player.x, y: player.y };
            player.stationaryTime = 0;
            player.hasOverheat = false;
            player.overheatHitCount = 0;
            player.lastHitTime = 0;
            player.hasGamble = false;
            player.hasWeaken = false;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.hasDamageBoost = false;
            player.hasLightning = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.hasShield = false;
            player.shieldReady = false;
            player.shieldCooldown = 0;
            player.hasRegeneration = false;
            player.lastRegenTime = 0;
            player.hasEvasiveManeuver = false;
            player.hasCombatExperience = false;
            player.combatExperienceRounds = 0;
            player.hasHallucination = false;
            player.hasTasteOfBlood = false;
            player.hasCannon = false;
            player.hasTimeBarrier = false;
            player.timeBarrierRadius = 150;
            player.hasBouncyBullet = false;
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.poisonEffects = [];
            player.isDodging = false;
            player.dodgeStartTime = 0;
            player.dodgeEndTime = 0;
            player.dodgeStartX = 0;
            player.dodgeStartY = 0;
            player.dodgeTargetX = 0;
            player.dodgeTargetY = 0;
            player.dodgeTrail = [];
            player.lastDodgeTime = 0;
            player.isReviving = false;
            player.reviveTime = 0;
            player.hasRevived = 0; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
            player.isInvincible = false;
            player.invincibleEndTime = 0;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.damage = 1;
            player.speed = 3;
            player.reloadTime = 3000;
            player.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
            player.reloadStartTime = 0;
            player.shootCooldown = 1000;

            enemy.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            enemy.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            enemy.health = 5;
            enemy.displayHealth = 5;
            enemy.maxHealth = 5;
            enemy.ammo = 6;
            enemy.maxAmmo = 6;
            enemy.bullets = [];
            enemy.augmentations = [];
            enemy.bulletSpeedMultiplier = 1;
            enemy.bulletSizeMultiplier = 1;
            enemy.hasCritical = false;
            enemy.hasDoubleShot = false;
            enemy.hasDodge = false;
            enemy.hasRevive = false;
            enemy.hasRevived = 0; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
            enemy.hasDeepWound = false;
            enemy.hasOneShotOneKill = false;
            enemy.hasPoisonBullet = false;
            enemy.hasReloadHeal = false;
            enemy.hasSurvivalInstinct = false;
            enemy.hasLastBullet = false;
            enemy.hasRecoveryContract = false;
            enemy.hasRecoveryContractUsed = false;
            enemy.hasFocusedFire = false;
            enemy.hasEvasiveManeuver = false;
            enemy.hasCombatExperience = false;
            enemy.combatExperienceRounds = 0;
            enemy.hasHallucination = false;
            enemy.hasTasteOfBlood = false;
            enemy.hasCannon = false;
            enemy.hasTimeBarrier = false;
            enemy.timeBarrierRadius = 150;
            enemy.hasBouncyBullet = false;
            enemy.hasGatling = false;
            enemy.gatlingBullets = 0;
            enemy.gatlingNextShot = 0;
            enemy.hasReflect = false;
            enemy.reflectActive = false;
            enemy.reflectCooldown = 0;
            enemy.reflectEndTime = 0;
            enemy.hasTimeStop = false;
            enemy.timeStopCooldown = 0;
            enemy.timeStopActive = false;
            enemy.timeStopEndTime = 0;
            enemy.hasScatter = false;
            enemy.hasGamble2 = false;
            enemy.hasRocket = false;
            enemy.hasTrinity = false;
            enemy.hasJudgment = false;
            enemy.isJudgmentPushing = false;
            enemy.judgmentPushStartX = 0;
            enemy.judgmentPushStartY = 0;
            enemy.judgmentPushTargetX = 0;
            enemy.judgmentPushTargetY = 0;
            enemy.judgmentPushStartTime = 0;
            enemy.judgmentPushDuration = 0;
            enemy.hasBoomerang = false;
            enemy.isVulnerable = false;
            enemy.vulnerabilityUsed = false;
            enemy.poisonEffects = [];
            enemy.isDodging = false;
            enemy.dodgeStartTime = 0;
            enemy.dodgeEndTime = 0;
            enemy.dodgeStartX = 0;
            enemy.dodgeStartY = 0;
            enemy.dodgeTargetX = 0;
            enemy.dodgeTargetY = 0;
            enemy.bulletDodgeTargetY = 0;
            enemy.isDodgingBullet = false;
            enemy.lastPlayerBulletCount = 0;
            enemy.dodgeTrail = [];
            enemy.lastDodgeTime = 0;
            enemy.isReviving = false;
            enemy.reviveTime = 0;
            enemy.hasRevived = 0; // ë¶€í™œ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
            enemy.isInvincible = false;
            enemy.invincibleEndTime = 0;
            enemy.slowEndTime = 0;
            enemy.damageNumbers = [];
            enemy.usePrediction = false;
            enemy.lastPlayerX = 0;
            enemy.lastPlayerY = 0;
            enemy.playerVelocity = { x: 0, y: 0 };
            enemy.damage = 1;
            enemy.reloadTime = 3000;
            enemy.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
            enemy.reloadStartTime = 0;
            enemy.shootCooldown = 1000;

            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('augmentModal').style.display = 'none';
        }

        // ë‘¥ê·¼ ì‚¬ê°í˜• ê·¸ë¦¬ê¸° í—¬í¼ í•¨ìˆ˜
        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            // ìƒë‹¨ ì™¼ìª½
            ctx.moveTo(x + radius, y);
            // ìƒë‹¨ ì˜¤ë¥¸ìª½
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            // ì˜¤ë¥¸ìª½ ì•„ë˜
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            // ì•„ë˜ ì™¼ìª½
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            // ì™¼ìª½ ìœ„
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
        }

        // ì²´ë ¥ í‘œì‹œ ê·¸ë¦¬ê¸° (ì§ì‚¬ê°í˜• ë°”)
        function drawHealthHearts(character, x, y, isPlayer) {
            const fixedBarWidth = 150; // ê³ ì •ëœ ë°” ê¸¸ì´ (200 -> 150)
            const barHeight = 20;
            const borderRadius = 4;
            // ë©€í‹°í”Œë ˆì´ì–´: ìºë¦­í„°ì˜ ì‹¤ì œ ìƒ‰ìƒ ì‚¬ìš©, ì†”ë¡œ: ê¸°ë³¸ ìƒ‰ìƒ
            const color = character.color || (isPlayer ? '#4a9eff' : '#e94560');
            
            // ë°°ê²½ (ë¹ˆ ë°”)
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
            ctx.fill();
            ctx.restore();
            
            // ì±„ì›Œì§„ ë¶€ë¶„ (ì• ë‹ˆë©”ì´ì…˜) - í•­ìƒ ë„¤ì˜¨ íš¨ê³¼ ì ìš©
            const fillRatio = Math.max(0, Math.min(1, character.displayHealth / character.maxHealth));
            const fillWidth = fixedBarWidth * fillRatio;
            
            if (fillWidth > 0) {
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.fillStyle = color;
                // ë¶€ë¶„ ì±„ìš°ê¸°ë¥¼ ìœ„í•´ í´ë¦¬í•‘ ì‚¬ìš©
                if (fillWidth < fixedBarWidth) {
                    ctx.save();
                    ctx.beginPath();
                    drawRoundedRect(x, y, fillWidth, barHeight, borderRadius);
                    ctx.clip();
                    drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                    ctx.fill();
                    ctx.restore();
                } else {
                    drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                    ctx.fill();
                }
                ctx.restore();
            }
            
            // í…Œë‘ë¦¬ - í•­ìƒ ë„¤ì˜¨ íš¨ê³¼ ì ìš©
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
            ctx.stroke();
            ctx.restore();
        }

        // ì¦ê°• ì•„ì´ì½˜ ê·¸ë¦¬ê¸°
        function drawAugmentIcon(ctx, x, y, size, augId) {
            ctx.save();
            ctx.translate(x, y);
            ctx.shadowBlur = 8; // ê¸°ë³¸ ë„¤ì˜¨ íš¨ê³¼
            
            switch(augId) {
                case 'health':
                    // ì²´ë ¥: í•˜íŠ¸ ëª¨ì–‘ (ì¤‘ì•™ ì •ë ¬, ì¡°ê¸ˆ ë” ìœ„ë¡œ)
                    ctx.fillStyle = '#ff006e';
                    ctx.shadowColor = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * -0.05);
                    ctx.bezierCurveTo(0, -size * 0.35, -size * 0.4, -size * 0.35, -size * 0.4, size * -0.05);
                    ctx.bezierCurveTo(-size * 0.4, size * 0.2, 0, size * 0.45, 0, size * 0.45);
                    ctx.bezierCurveTo(0, size * 0.45, size * 0.4, size * 0.2, size * 0.4, size * -0.05);
                    ctx.bezierCurveTo(size * 0.4, -size * 0.35, 0, -size * 0.35, 0, size * -0.05);
                    ctx.fill();
                    break;
                case 'speed':
                    // ì†ë„: í™”ì‚´í‘œ
                    ctx.fillStyle = '#00ff88';
                    ctx.shadowColor = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, 0);
                    ctx.lineTo(size * 0.3, 0);
                    ctx.lineTo(0, -size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, 0);
                    ctx.lineTo(0, size * 0.4);
                    ctx.lineTo(size * 0.3, 0);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bulletSpeed':
                    // ì´ì•Œ ì†ë„: ë²ˆê°œ
                    ctx.fillStyle = '#ffaa00'; // íŒŒìŠ¤í…” ì˜¤ë Œì§€
                    ctx.shadowColor = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.4);
                    ctx.lineTo(size * 0.1, 0);
                    ctx.lineTo(-size * 0.1, 0);
                    ctx.lineTo(size * 0.2, size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'ammo':
                    // íƒ„ì•½: ì›
                    ctx.fillStyle = '#ffffff'; // íŒŒìŠ¤í…” í™”ì´íŠ¸
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'fireRate':
                    // ë°œì‚¬ ì†ë„: ë³„
                    ctx.fillStyle = '#ff00ff'; // íŒŒìŠ¤í…” ë§ˆì  íƒ€
                    ctx.shadowColor = '#ff00ff';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.4 : size * 0.2;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'reload':
                    // ì¬ì¥ì „: ì‹œê³„
                    ctx.strokeStyle = '#00ffff'; // íŒŒìŠ¤í…” ì‹œì•ˆ
                    ctx.shadowColor = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -size * 0.3);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.2, 0);
                    ctx.stroke();
                    break;
                case 'critical':
                    // í¬ë¦¬í‹°ì»¬: X í‘œì‹œ
                    ctx.strokeStyle = '#ff0000'; // íŒŒìŠ¤í…” ë ˆë“œ
                    ctx.shadowColor = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, -size * 0.3);
                    ctx.lineTo(size * 0.3, size * 0.3);
                    ctx.moveTo(size * 0.3, -size * 0.3);
                    ctx.lineTo(-size * 0.3, size * 0.3);
                    ctx.stroke();
                    break;
                case 'doubleShot':
                    // ë”ë¸”ìƒ·: ë‘ ê°œì˜ ì›
                    ctx.fillStyle = '#ffc107'; // íŒŒìŠ¤í…” ì˜ë¡œìš°
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.2, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'dodge':
                    // êµ¬ë¥´ê¸°: ëŒ€ì‹œì„ 
                    ctx.strokeStyle = '#8888ff'; // íŒŒìŠ¤í…” ë¸”ë£¨
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.4, 0);
                    ctx.lineTo(size * 0.4, 0);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    break;
                case 'revive':
                    // ë¶€í™œ: ì‹­ìê°€
                    ctx.fillStyle = '#00ff88'; // íŒŒìŠ¤í…” ê·¸ë¦°
                    ctx.fillRect(-size * 0.15, -size * 0.4, size * 0.3, size * 0.8);
                    ctx.fillRect(-size * 0.4, -size * 0.15, size * 0.8, size * 0.3);
                    break;
                case 'deepWound':
                    // ê¹Šì€ ìƒì²˜: ì¹¼
                    ctx.fillStyle = '#880000';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.1, size * 0.2);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.1, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'giant':
                    // ê±°ëŒ€í™”: í° ì‚¬ê°í˜•
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-size * 0.4, -size * 0.4, size * 0.8, size * 0.8);
                    // ë‚´ë¶€ ì‘ì€ ì‚¬ê°í˜•
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(-size * 0.25, -size * 0.25, size * 0.5, size * 0.5);
                    break;
                case 'sniper':
                    // ì €ê²©ìˆ˜: ìŠ¤ì½”í”„
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    // ì™¸ë¶€ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    // ì‹­ìì„ 
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.4, 0);
                    ctx.lineTo(size * 0.4, 0);
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(0, size * 0.4);
                    ctx.stroke();
                    // ì¤‘ì•™ ì 
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'oneShotOneKill':
                    // ì›ìƒ·ì›í‚¬: í° ì´ì•Œ
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    // ì¤‘ì•™ X
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.2);
                    ctx.lineTo(size * 0.2, size * 0.2);
                    ctx.moveTo(size * 0.2, -size * 0.2);
                    ctx.lineTo(-size * 0.2, size * 0.2);
                    ctx.stroke();
                    break;
                case 'poisonBullet':
                    // ë… íƒ„í™˜: ë… ë°©ìš¸
                    ctx.fillStyle = '#006600';
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.1, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // ì‘ì€ ë°©ìš¸
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, size * 0.15, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, size * 0.15, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'reloadHeal':
                    // ì¬ì¥ì „ íšŒë³µ: í•˜íŠ¸ + í™”ì‚´í‘œ
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.3, -size * 0.1, -size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.3, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.3, size * 0.3, size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(size * 0.3, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    // í™”ì‚´í‘œ
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(size * 0.2, 0);
                    ctx.lineTo(0, -size * 0.2);
                    ctx.lineTo(0, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bigBullet':
                    // í° íƒ„í™˜: í° ì›
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // ë‚´ë¶€ ì‘ì€ ì›
                    ctx.fillStyle = '#888888';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'survivalInstinct':
                    // ìƒì¡´ë³¸ëŠ¥: ë²ˆê°œ + í•˜íŠ¸
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.3);
                    ctx.lineTo(size * 0.1, 0);
                    ctx.lineTo(-size * 0.1, 0);
                    ctx.lineTo(size * 0.2, size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.25, -size * 0.1, -size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.25, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.25, size * 0.3, size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(size * 0.25, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    break;
                case 'lastBullet':
                    // ë¹„ì¥ì˜ í•œë°œ: í° ì´ì•Œ + ë³„
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-size * 0.3, -size * 0.15, size * 0.6, size * 0.3);
                    ctx.fillStyle = '#ffc107';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.2 : size * 0.1;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'recoveryContract':
                    // íšŒë³µê³„ì•½: í•˜íŠ¸ + í™”ì‚´í‘œ ìœ„
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.3, -size * 0.1, -size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.3, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.3, size * 0.3, size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(size * 0.3, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(-size * 0.15, -size * 0.1);
                    ctx.lineTo(size * 0.15, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'focusedFire':
                    // ì§‘ì¤‘ ì‚¬ê²©: ëˆˆ ëª¨ì–‘
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, 0, size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, 0, size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, 0, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, 0, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'ghost':
                    // ìœ ë ¹: ë°˜íˆ¬ëª… ì› + ì‘ì€ ì›ë“¤
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#cccccc';
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.1, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // ì‘ì€ ì›ë“¤ (ìœ ë ¹ ëŠë‚Œ)
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, size * 0.1, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, size * 0.1, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    break;
                case 'fortify':
                    // ê±°ì í™•ë³´: ë°©íŒ¨ ëª¨ì–‘
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    // ë°©íŒ¨ ë³¸ì²´
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.3, -size * 0.2);
                    ctx.lineTo(-size * 0.3, size * 0.2);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.3, size * 0.2);
                    ctx.lineTo(size * 0.3, -size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // ì‹­ìê°€
                    ctx.strokeStyle = '#000000';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.2);
                    ctx.lineTo(0, size * 0.1);
                    ctx.moveTo(-size * 0.15, -size * 0.05);
                    ctx.lineTo(size * 0.15, -size * 0.05);
                    ctx.stroke();
                    break;
                case 'overheat':
                    // ê³¼ì—´: ë¶ˆê½ƒ ëª¨ì–‘
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.2, -size * 0.1);
                    ctx.lineTo(-size * 0.15, size * 0.1);
                    ctx.lineTo(0, size * 0.2);
                    ctx.lineTo(size * 0.15, size * 0.1);
                    ctx.lineTo(size * 0.2, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ì‘ì€ ë¶ˆê½ƒë“¤
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.2);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.lineTo(0, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(size * 0.1, -size * 0.2);
                    ctx.lineTo(size * 0.05, 0);
                    ctx.lineTo(0, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'gamble':
                    // ë„ë°•: ì£¼ì‚¬ìœ„ ëª¨ì–‘
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
                    // ì£¼ì‚¬ìœ„ ëˆˆ
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, -size * 0.15, size * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, size * 0.15, size * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'weaken':
                    // ì•½í™”: ì•„ë˜ í™”ì‚´í‘œ
                    ctx.fillStyle = '#888888';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(-size * 0.2, size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.2, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ê°ì†Œ í‘œì‹œ
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, size * 0.2);
                    ctx.lineTo(size * 0.15, size * 0.2);
                    ctx.stroke();
                    break;
                case 'damageBoost':
                    // ë°ë¯¸ì§€ 1.2ë°°: ìœ„ í™”ì‚´í‘œ
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(-size * 0.2, -size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.2, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ì¦ê°€ í‘œì‹œ
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, -size * 0.2);
                    ctx.lineTo(size * 0.15, -size * 0.2);
                    ctx.stroke();
                    break;
                case 'lightning':
                    // ë²ˆê°œ: ë²ˆê°œ ëª¨ì–‘
                    ctx.fillStyle = '#ffff00';
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.4);
                    ctx.lineTo(size * 0.1, -size * 0.2);
                    ctx.lineTo(-size * 0.05, -size * 0.1);
                    ctx.lineTo(size * 0.15, size * 0.2);
                    ctx.lineTo(-size * 0.1, size * 0.3);
                    ctx.lineTo(0, size * 0.1);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'shield':
                    // ë°©ì–´ë§‰: ë°©íŒ¨ ëª¨ì–‘
                    ctx.fillStyle = '#0066ff';
                    ctx.strokeStyle = '#0044cc';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.3, -size * 0.2);
                    ctx.lineTo(-size * 0.3, size * 0.1);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.3, size * 0.1);
                    ctx.lineTo(size * 0.3, -size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'regeneration':
                    // ì¬ìƒ: í•˜íŠ¸ + í”ŒëŸ¬ìŠ¤
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.25, -size * 0.1, -size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.25, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.25, size * 0.3, size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(size * 0.25, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    // í”ŒëŸ¬ìŠ¤ í‘œì‹œ
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-size * 0.1, -size * 0.05, size * 0.2, size * 0.03);
                    ctx.fillRect(-size * 0.05, -size * 0.1, size * 0.03, size * 0.2);
                    break;
                case 'shotgun':
                    // ìƒ·ê±´: ì‚°íƒ„ì´ ëª¨ì–‘
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-size * 0.4, -size * 0.1, size * 0.8, size * 0.2);
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(-size * 0.35, -size * 0.05, size * 0.7, size * 0.1);
                    break;
                case 'ragged':
                    // ë‹¤ë‹¤ìµì„ : ê¹¨ì§„ ì´ì•Œ
                    ctx.fillStyle = '#888888';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.2);
                    ctx.lineTo(size * 0.2, size * 0.2);
                    ctx.stroke();
                    break;
                case 'evasiveManeuver':
                    // íšŒí”¼ê¸°ë™: í™”ì‚´í‘œ + ë²ˆê°œ
                    ctx.fillStyle = '#4a9eff';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(-size * 0.2, size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.2, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.1);
                    ctx.lineTo(size * 0.1, size * 0.1);
                    ctx.moveTo(size * 0.1, -size * 0.1);
                    ctx.lineTo(-size * 0.1, size * 0.1);
                    ctx.stroke();
                    break;
                case 'combatExperience':
                    // ì „íˆ¬ ê²½í—˜: ë³„
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.3 : size * 0.15;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'hallucination':
                    // í™˜ê°: ë¬¼ê²° ëª¨ì–‘
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = -size * 0.4; i <= size * 0.4; i += 5) {
                        const y = Math.sin(i * 0.2) * size * 0.2;
                        if (i === -size * 0.4) ctx.moveTo(i, y);
                        else ctx.lineTo(i, y);
                    }
                    ctx.stroke();
                    break;
                case 'tasteOfBlood':
                    // í”¼ì˜ ë§›: ë¹¨ê°„ í•˜íŠ¸
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.25, -size * 0.1, -size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.25, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.25, size * 0.3, size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(size * 0.25, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    break;
                case 'cannon':
                    // ëŒ€í¬: í° ì›
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
                case 'timeBarrier':
                    // ì‹œê°„ì¥ë§‰: ì› + ì‹œê³„
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    // ì‹œê³„ ë°”ëŠ˜
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -size * 0.2);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.15, size * 0.1);
                    ctx.stroke();
                    break;
                case 'bouncyBullet':
                    // í†µí†µíƒ„: íŠ•ê¸°ëŠ” í™”ì‚´í‘œ
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    // ìœ„ìª½ í™”ì‚´í‘œ
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(-size * 0.15, -size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.15, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ì•„ë˜ìª½ í™”ì‚´í‘œ (ë°˜ëŒ€ ë°©í–¥)
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(-size * 0.15, size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.15, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'gamble2':
                    // ìŠ¤ë„¤ì´í¬: ë‹¨ìˆœí•œ í™”ì‚´í‘œ (ë°©í–¥ ì „í™˜)
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.25, 0);
                    ctx.lineTo(size * 0.25, 0);
                    ctx.moveTo(size * 0.2, -size * 0.15);
                    ctx.lineTo(size * 0.25, 0);
                    ctx.lineTo(size * 0.2, size * 0.15);
                    ctx.stroke();
                    break;
                case 'reflect':
                    // ë°˜ì‚¬: ë°©íŒ¨ + í™”ì‚´í‘œ ë°˜ì‚¬
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.3, -size * 0.2);
                    ctx.lineTo(-size * 0.3, size * 0.2);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.3, size * 0.2);
                    ctx.lineTo(size * 0.3, -size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // ë°˜ì‚¬ í™”ì‚´í‘œ
                    ctx.strokeStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, 0);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.2, 0);
                    ctx.moveTo(size * 0.15, -size * 0.1);
                    ctx.lineTo(size * 0.2, 0);
                    ctx.lineTo(size * 0.15, size * 0.1);
                    ctx.stroke();
                    break;
                case 'gatling':
                    // ê²Œí‹€ë§: íšŒì „í•˜ëŠ” ì´ì—´
                    ctx.fillStyle = '#666666';
                    ctx.fillRect(-size * 0.4, -size * 0.2, size * 0.8, size * 0.4);
                    ctx.fillStyle = '#000000';
                    // ì´ì—´ êµ¬ë©ë“¤
                    for (let i = -2; i <= 2; i++) {
                        ctx.beginPath();
                        ctx.arc(i * size * 0.15, 0, size * 0.05, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                case 'timeStop':
                    // ì‹œê°„ì •ì§€: íšŒìƒ‰ ë©ˆì¶¤ ì•„ì´ì½˜ (pause icon)
                    ctx.fillStyle = '#888888';
                    ctx.shadowColor = '#888888';
                    // ë‘ ê°œì˜ ì„¸ë¡œ ë§‰ëŒ€ (pause icon)
                    ctx.fillRect(-size * 0.15, -size * 0.2, size * 0.1, size * 0.4);
                    ctx.fillRect(size * 0.05, -size * 0.2, size * 0.1, size * 0.4);
                    break;
                case 'scatter':
                    // ë¹„ì‚°íƒ„: 4ë°©í–¥ í™”ì‚´í‘œ
                    ctx.fillStyle = '#ffaa00';
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI * 2 / 4) - Math.PI / 2;
                        const x = Math.cos(angle) * size * 0.25;
                        const y = Math.sin(angle) * size * 0.25;
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.15);
                        ctx.lineTo(-size * 0.08, -size * 0.05);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(size * 0.08, -size * 0.05);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    break;
                case 'rocket':
                    // ë¡œì¼“íƒ„: ë¡œì¼“ ëª¨ì–‘
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.2, size * 0.2);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.2, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    // ë¶ˆê½ƒ
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, size * 0.3);
                    ctx.lineTo(-size * 0.05, size * 0.4);
                    ctx.lineTo(0, size * 0.35);
                    ctx.lineTo(size * 0.05, size * 0.4);
                    ctx.lineTo(size * 0.15, size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'trinity':
                    // ì‚¼ìœ„ì¼ì²´: ì„¸ ê°œì˜ ì›ì´ ì—°ê²°ëœ ëª¨ì–‘ (ì‚¼ê°í˜• ë°°ì¹˜)
                    ctx.fillStyle = '#9b59b6'; // ë³´ë¼ìƒ‰
                    ctx.shadowColor = '#9b59b6';
                    // ìœ„ìª½ ì›
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.2, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    // ì™¼ìª½ ì•„ë˜ ì›
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, size * 0.2, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    // ì˜¤ë¥¸ìª½ ì•„ë˜ ì›
                    ctx.beginPath();
                    ctx.arc(size * 0.2, size * 0.2, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    // ì—°ê²°ì„ 
                    ctx.strokeStyle = '#9b59b6';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.05);
                    ctx.lineTo(-size * 0.2, size * 0.05);
                    ctx.moveTo(0, -size * 0.05);
                    ctx.lineTo(size * 0.2, size * 0.05);
                    ctx.moveTo(-size * 0.2, size * 0.05);
                    ctx.lineTo(size * 0.2, size * 0.05);
                    ctx.stroke();
                    break;
                case 'judgment':
                    // ì„ ê³ : ì¶©ê²©íŒŒ ëª¨ì–‘ (ì›í˜• íŒŒë™)
                    ctx.strokeStyle = '#ff4444'; // ë¹¨ê°„ìƒ‰
                    ctx.shadowColor = '#ff4444';
                    ctx.lineWidth = 3;
                    // ë°”ê¹¥ìª½ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    // ì¤‘ê°„ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    // ì•ˆìª½ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
                    ctx.stroke();
                    // ì¤‘ì•™ í™”ì‚´í‘œ (ë°€ì–´ë‚´ëŠ” ë°©í–¥)
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.2, -size * 0.15);
                    ctx.lineTo(size * 0.15, -size * 0.1);
                    ctx.lineTo(size * 0.25, -size * 0.1);
                    ctx.lineTo(size * 0.25, -size * 0.2);
                    ctx.lineTo(size * 0.35, 0);
                    ctx.lineTo(size * 0.25, size * 0.2);
                    ctx.lineTo(size * 0.25, size * 0.1);
                    ctx.lineTo(size * 0.15, size * 0.1);
                    ctx.lineTo(size * 0.2, size * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'boomerang':
                    // ë¶€ë§¤ë‘: ë¶€ë©”ë‘ ëª¨ì–‘ (ê³¡ì„  í™”ì‚´í‘œ)
                    ctx.strokeStyle = '#00aaff'; // í•˜ëŠ˜ìƒ‰
                    ctx.shadowColor = '#00aaff';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    // ë¶€ë©”ë‘ ë³¸ì²´ (ê³¡ì„ )
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.3, -Math.PI * 0.3, Math.PI * 1.3);
                    ctx.stroke();
                    // í™”ì‚´í‘œ ë¨¸ë¦¬ (ë˜ëŒì•„ì˜¤ëŠ” ë°©í–¥)
                    ctx.fillStyle = '#00aaff';
                    ctx.beginPath();
                    ctx.moveTo(size * 0.25, -size * 0.15);
                    ctx.lineTo(size * 0.35, -size * 0.25);
                    ctx.lineTo(size * 0.3, -size * 0.2);
                    ctx.lineTo(size * 0.4, -size * 0.15);
                    ctx.lineTo(size * 0.3, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ë°˜ëŒ€ ë°©í–¥ í™”ì‚´í‘œ (ëŒì•„ì˜¤ëŠ” ë°©í–¥)
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.25, size * 0.15);
                    ctx.lineTo(-size * 0.35, size * 0.25);
                    ctx.lineTo(-size * 0.3, size * 0.2);
                    ctx.lineTo(-size * 0.4, size * 0.15);
                    ctx.lineTo(-size * 0.3, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                default:
                    // ê¸°ë³¸: ì‚¬ê°í˜•
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
            }
            
            ctx.restore();
        }

        // ì¦ê°• ì•„ì´ì½˜ ëª©ë¡ ê·¸ë¦¬ê¸°
        function drawAugmentIcons(character, x, y, align = 'left') {
            const iconSize = 32; // 2ë°° ì¦ê°€ (16 -> 32)
            const spacing = 8; // ê°„ê²©ë„ 2ë°° ì¦ê°€
            const bgSize = iconSize + 4; // ë°°ê²½ í¬ê¸°
            
            // ë§ˆìš°ìŠ¤ í˜¸ë²„ ê°ì§€
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseCanvasX = (mouse.x - rect.left) * scaleX;
            const mouseCanvasY = (mouse.y - rect.top) * scaleY;
            
            character.augmentations.forEach((aug, index) => {
                let iconX;
                if (align === 'right') {
                    iconX = x - (character.augmentations.length - index - 1) * (iconSize + spacing) - iconSize / 2;
                } else {
                    iconX = x + index * (iconSize + spacing) + iconSize / 2;
                }
                
                // ë§ˆìš°ìŠ¤ í˜¸ë²„ ì²´í¬
                const iconLeft = iconX - bgSize / 2;
                const iconRight = iconX + bgSize / 2;
                const iconTop = y - bgSize / 2;
                const iconBottom = y + bgSize / 2;
                
                if (mouseCanvasX >= iconLeft && mouseCanvasX <= iconRight &&
                    mouseCanvasY >= iconTop && mouseCanvasY <= iconBottom) {
                    hoveredAugment = {
                        aug: aug,
                        x: iconX,
                        y: y
                    };
                }
                
                // ë°°ê²½ ì‚¬ê°í˜• (í˜¸ë²„ ì‹œ ê°•ì¡°)
                if (hoveredAugment && hoveredAugment.aug === aug) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                }
                ctx.fillRect(iconX - bgSize / 2, y - bgSize / 2, bgSize, bgSize);
                
                // ì•„ì´ì½˜ ê·¸ë¦¬ê¸°
                drawAugmentIcon(ctx, iconX, y, iconSize, aug.id);
            });
        }

        // íƒ„í™˜ìˆ˜ í‘œì‹œ (ì²´ë ¥ ì•„ë˜ - í•˜ì–€ìƒ‰ ì›)
        function drawAmmoCount(character, x, y, align = 'left') {
            const circleSize = 12; // ì²´ë ¥ë°”(30px)ë³´ë‹¤ ë” ì‘ì€ ì›
            const spacing = 4;
            const radius = circleSize / 2;
            const centerY = y + radius; // ì›ì˜ ì¤‘ì‹¬ Y ì¢Œí‘œ
            
            // ì´ íƒ„í™˜ìˆ˜ë§Œí¼ ì› ê·¸ë¦¬ê¸° (ì‚¬ìš©í•œ íƒ„í™˜ì€ ë°˜íˆ¬ëª…)
            for (let i = 0; i < character.maxAmmo; i++) {
                ctx.save();
                if (i < character.ammo) {
                    // ë‚¨ì€ íƒ„í™˜: ë¶ˆíˆ¬ëª… í•˜ì–€ìƒ‰ + ë„¤ì˜¨ íš¨ê³¼
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff'; // íŒŒìŠ¤í…” í™”ì´íŠ¸
                } else {
                    // ì‚¬ìš©í•œ íƒ„í™˜: ë°˜íˆ¬ëª…
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                }
                
                let centerX;
                if (align === 'right') {
                    // ì˜¤ë¥¸ìª½ ì •ë ¬: ì˜¤ë¥¸ìª½ë¶€í„° ì™¼ìª½ìœ¼ë¡œ
                    centerX = x - (character.maxAmmo - i - 1) * (circleSize + spacing) - radius;
                } else {
                    // ì™¼ìª½ ì •ë ¬: ì™¼ìª½ë¶€í„° ì˜¤ë¥¸ìª½ìœ¼ë¡œ
                    centerX = x + i * (circleSize + spacing) + radius;
                }
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ë§ˆë¦„ëª¨ ê·¸ë¦¬ê¸° í•¨ìˆ˜
        function drawDiamond(x, y, size, color) {
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2); // ìœ„
            ctx.lineTo(x + size / 2, y); // ì˜¤ë¥¸ìª½
            ctx.lineTo(x, y + size / 2); // ì•„ë˜
            ctx.lineTo(x - size / 2, y); // ì™¼ìª½
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ (ë§ˆë¦„ëª¨ ì•„ë˜)
        function drawCountdown() {
            const countdownValue = gameState.countdown > 0 ? gameState.countdown : gameState.augmentCountdown;
            if (countdownValue <= 0) return;
            
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const y = 100; // ë§ˆë¦„ëª¨ ì•„ë˜
            
            // ë°˜íˆ¬ëª… ë°°ê²½
            const textWidth = ctx.measureText(countdownValue).width;
            const padding = 30;
            ctx.fillRect(
                canvas.width / 2 - textWidth / 2 - padding,
                y - 50,
                textWidth + padding * 2,
                100
            );
            
            // ìˆ«ì í‘œì‹œ (ë„¤ì˜¨ íš¨ê³¼)
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffffff';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(countdownValue, canvas.width / 2, y);
            ctx.restore();
        }

        // ìŠ¹ë¦¬ í‘œì‹œ ë§ˆë¦„ëª¨ ê·¸ë¦¬ê¸° (í™”ë©´ ìœ„ìª½ ê°€ìš´ë°)
        function drawWinIndicators() {
            const diamondSize = 20;
            const spacing = 5;
            const groupSpacing = 15; // ê·¸ë£¹ ì‚¬ì´ ê°„ê²© (ì–‡ì€ ì„  í¬í•¨)
            const diamondsPerGroup = 5;
            
            // ì²« ë²ˆì§¸ ê·¸ë£¹ ë„ˆë¹„ ê³„ì‚°
            const groupWidth = (diamondsPerGroup * diamondSize) + ((diamondsPerGroup - 1) * spacing);
            // ì „ì²´ ë„ˆë¹„ ê³„ì‚° (ë‘ ê·¸ë£¹ + ê·¸ë£¹ ì‚¬ì´ ê°„ê²©)
            const totalWidth = (groupWidth * 2) + groupSpacing;
            const startX = (canvas.width - totalWidth) / 2;
            const y = 35; // ì‚´ì§ ì•„ë˜ë¡œ ë‚´ë¦¼

            // ë©€í‹°í”Œë ˆì´ì–´: íŒ€ ê¸°ì¤€ìœ¼ë¡œ ìŠ¹ë¦¬ ìˆ˜ ê³„ì‚°
            // ì™¼ìª½ì€ í•­ìƒ íŒŒë€íŒ€, ì˜¤ë¥¸ìª½ì€ í•­ìƒ ë¹¨ê°„íŒ€
            let blueWins, redWins;
            if (gameState.isMultiplayer && myTeam) {
                if (myTeam === 'blue') {
                    blueWins = gameState.playerWins;
                    redWins = gameState.enemyWins;
                } else {
                    blueWins = gameState.enemyWins;
                    redWins = gameState.playerWins;
                }
            } else {
                // ì†”ë¡œ: í”Œë ˆì´ì–´=íŒŒë€, ì =ë¹¨ê°•
                blueWins = gameState.playerWins;
                redWins = gameState.enemyWins;
            }

            // ì™¼ìª½ ê·¸ë£¹: íŒŒë€íŒ€ ìŠ¹ë¦¬ (íŒŒë€ìƒ‰)
            for (let i = 0; i < diamondsPerGroup; i++) {
                let color;
                if (i < blueWins) {
                    // íŒŒë€íŒ€ ìŠ¹ë¦¬: íŒŒë€ìƒ‰
                    color = 'rgba(74, 158, 255, 0.8)';
                } else {
                    // ì•„ì§ ì§„í–‰ë˜ì§€ ì•Šì€ ë¼ìš´ë“œ: ë°˜íˆ¬ëª… íšŒìƒ‰
                    color = 'rgba(255, 255, 255, 0.2)';
                }
                
                const x = startX + i * (diamondSize + spacing) + diamondSize / 2;
                drawDiamond(x, y, diamondSize, color);
            }
            
            // ì˜¤ë¥¸ìª½ ê·¸ë£¹: ë¹¨ê°„íŒ€ ìŠ¹ë¦¬ (ë¹¨ê°„ìƒ‰) - ì˜¤ë¥¸ìª½ë¶€í„° ì±„ì›Œì§
            for (let i = 0; i < diamondsPerGroup; i++) {
                let color;
                // ì˜¤ë¥¸ìª½ë¶€í„° ì±„ìš°ê¸° ìœ„í•´ ì—­ìˆœìœ¼ë¡œ ê³„ì‚°
                if ((diamondsPerGroup - 1 - i) < redWins) {
                    // ë¹¨ê°„íŒ€ ìŠ¹ë¦¬: ë¹¨ê°„ìƒ‰
                    color = 'rgba(233, 69, 96, 0.8)';
                } else {
                    // ì•„ì§ ì§„í–‰ë˜ì§€ ì•Šì€ ë¼ìš´ë“œ: ë°˜íˆ¬ëª… íšŒìƒ‰
                    color = 'rgba(255, 255, 255, 0.2)';
                }
                
                const x = startX + groupWidth + groupSpacing + i * (diamondSize + spacing) + diamondSize / 2;
                drawDiamond(x, y, diamondSize, color);
            }
            
            // ê·¸ë£¹ ì‚¬ì´ ì–‡ì€ ì„  ê·¸ë¦¬ê¸°
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            const lineX = startX + groupWidth + groupSpacing / 2;
            ctx.beginPath();
            ctx.moveTo(lineX, y - diamondSize / 2 - 5);
            ctx.lineTo(lineX, y + diamondSize / 2 + 5);
            ctx.stroke();
            ctx.restore();
        }

        // ì¬ì¥ì „ ì§„í–‰ë¥  ë°” ê·¸ë¦¬ê¸° (ë™ê·¸ë€ ë°”ë¡œ)
        function drawReloadBar(character, x, y) {
            if (!character.isReloading) return;
            
            const now = Date.now();
            const elapsed = now - character.reloadStartTime;
            const progress = Math.min(elapsed / character.reloadTime, 1); // 0~1 ì‚¬ì´ ê°’
            
            const radius = 8; // ì›ì˜ ë°˜ì§€ë¦„ (20% ì¤„ì„: 10 -> 8)
            const lineWidth = 4; // ì„  ë‘ê»˜ (30% ëŠ˜ë¦¼: 3 -> 4)
            
            ctx.save();
            // ë°°ê²½ ì› (íšŒìƒ‰)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ì§„í–‰ë¥  ì› (í•˜ì–€ìƒ‰ + ë„¤ì˜¨ íš¨ê³¼)
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffffff';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(x, y, radius, -Math.PI / 2, -Math.PI / 2 + (progress * Math.PI * 2));
            ctx.stroke();
            ctx.restore();
        }

        // ê·¸ë¦¬ê¸° í•¨ìˆ˜
        // ê²Œì„ ì‹œì‘ í•¨ìˆ˜ë“¤
        // ë³¸ ì¦ê°• ëª©ë¡ ê´€ë¦¬ (localStorage ì‚¬ìš©)
        function getSeenAugments() {
            const seen = localStorage.getItem('seenAugments');
            return seen ? JSON.parse(seen) : [];
        }

        function markAugmentAsSeen(augmentId) {
            const seen = getSeenAugments();
            if (!seen.includes(augmentId)) {
                seen.push(augmentId);
                localStorage.setItem('seenAugments', JSON.stringify(seen));
            }
        }

        // ì¦ê°• ì„ íƒ íšŸìˆ˜ ê´€ë¦¬ (localStorage ì‚¬ìš©)
        function getAugmentSelectCounts() {
            const counts = localStorage.getItem('augmentSelectCounts');
            return counts ? JSON.parse(counts) : {};
        }

        function incrementAugmentSelectCount(augmentId) {
            const counts = getAugmentSelectCounts();
            counts[augmentId] = (counts[augmentId] || 0) + 1;
            localStorage.setItem('augmentSelectCounts', JSON.stringify(counts));
        }

        function getAugmentSelectCount(augmentId) {
            const counts = getAugmentSelectCounts();
            return counts[augmentId] || 0;
        }

        // ë„ê° ëª¨ë‹¬ ì—´ê¸°
        function openCollectionModal() {
            // ëª¨ë“œ ì„ íƒ ì ‘ê¸°
            collapseModeSelection();
            
            const modal = document.getElementById('collectionModal');
            const content = document.getElementById('collectionContent');
            const seenAugments = getSeenAugments();
            const canvas = document.getElementById('gameCanvas');
            
            content.innerHTML = '';
            
            augmentations.forEach(aug => {
                const isSeen = seenAugments.includes(aug.id);
                const selectCount = getAugmentSelectCount(aug.id);
                const item = document.createElement('div');
                item.className = 'collection-item' + (isSeen ? '' : ' locked');
                item.innerHTML = `
                    ${selectCount > 0 ? `<span class="select-count">${selectCount}íšŒ ì„ íƒ</span>` : ''}
                    <h4>${isSeen ? aug.name : '???'}</h4>
                    <p>${isSeen ? aug.description : '??? (ì•„ì§ ë°œê²¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤)'}</p>
                `;
                content.appendChild(item);
            });
            
            // ê²Œì„ ìº”ë²„ìŠ¤ í´ë¦­ ì°¨ë‹¨
            if (canvas) {
                canvas.style.pointerEvents = 'none';
            }
            
            modal.style.display = 'block';
        }

        // ë„ê° ëª¨ë‹¬ ë‹«ê¸°
        function closeCollectionModal() {
            const modal = document.getElementById('collectionModal');
            const canvas = document.getElementById('gameCanvas');
            
            modal.style.display = 'none';
            
            // ê²Œì„ ìº”ë²„ìŠ¤ í´ë¦­ ë³µêµ¬
            if (canvas) {
                canvas.style.pointerEvents = 'auto';
            }
        }

        // ì¡°ì‘ë²• ëª¨ë‹¬ ì—´ê¸°
        function openControlsModal() {
            // ëª¨ë“œ ì„ íƒ ì ‘ê¸°
            collapseModeSelection();
            
            const modal = document.getElementById('controlsModal');
            modal.style.display = 'block';
            }

        // ì¡°ì‘ë²• ëª¨ë‹¬ ë‹«ê¸°
        function closeControlsModal() {
            const modal = document.getElementById('controlsModal');
            modal.style.display = 'none';
        }


        // ëª¨ë“œ ì„ íƒ ì ‘ê¸° í•¨ìˆ˜
        function collapseModeSelection() {
            const modeSelection = document.getElementById('modeSelection');
            if (modeSelection.classList.contains('expanded')) {
                modeSelection.classList.remove('expanded');
                // ë©€í‹° í”Œë ˆì´ ì›ë˜ ìœ„ì¹˜ë¡œ
                document.getElementById('multiPlayText').classList.remove('moved-down');
            }
        }

        function collapseMultiModeSelection() {
            const multiModeSelection = document.getElementById('multiModeSelection');
            if (multiModeSelection.classList.contains('expanded')) {
                multiModeSelection.classList.remove('expanded');
                // ë„ê°ë§Œ ì›ë˜ ìœ„ì¹˜ë¡œ
                document.getElementById('collectionText').classList.remove('moved-down');
            }
        }

        function showModeSelection() {
            const modeSelection = document.getElementById('modeSelection');
            const isExpanded = modeSelection.classList.contains('expanded');
            
            // ë©€í‹°í”Œë ˆì´ ì„ íƒì´ í¼ì³ì ¸ ìˆìœ¼ë©´ ì ‘ê¸°
            collapseMultiModeSelection();
            
            if (isExpanded) {
                // ì ‘ê¸°: ëª¨ë“œ ì„ íƒ í™”ë©´ ìˆ¨ê¸°ê¸°
                collapseModeSelection();
            } else {
                // í¼ì¹˜ê¸°: ëª¨ë“œ ì„ íƒ í™”ë©´ í‘œì‹œ
                modeSelection.classList.add('expanded');
                // ë©€í‹° í”Œë ˆì´ë§Œ ë‚´ë¦¬ê¸°
                document.getElementById('multiPlayText').classList.add('moved-down');
                // ë‚˜ë¨¸ì§€ ë©”ë‰´ëŠ” ì›ë˜ ìœ„ì¹˜ ìœ ì§€
                document.getElementById('collectionText').classList.remove('moved-down');
                document.getElementById('settingsText').classList.remove('moved-down');
                document.getElementById('controlsText').classList.remove('moved-down');
            }
        }

        function showMultiModeSelection() {
            const multiModeSelection = document.getElementById('multiModeSelection');
            const isExpanded = multiModeSelection.classList.contains('expanded');
            
            // ì†”ë¡œí”Œë ˆì´ ì„ íƒì´ í¼ì³ì ¸ ìˆìœ¼ë©´ ì ‘ê¸°
            collapseModeSelection();
            
            if (isExpanded) {
                // ì ‘ê¸°: ë©€í‹° ëª¨ë“œ ì„ íƒ í™”ë©´ ìˆ¨ê¸°ê¸°
                collapseMultiModeSelection();
            } else {
                // í¼ì¹˜ê¸°: ë©€í‹° ëª¨ë“œ ì„ íƒ í™”ë©´ í‘œì‹œ
                multiModeSelection.classList.add('expanded');
                // ë„ê°ë§Œ ë‚´ë¦¬ê¸° (ë©€í‹°í”Œë ˆì´ì™€ ë„ê° ì‚¬ì´ ê°„ê²©ë§Œ ë„“íˆê¸°)
                document.getElementById('collectionText').classList.add('moved-down');
            }
        }

        // ë‹‰ë„¤ì„ ë³€ìˆ˜
        let playerNickname = localStorage.getItem('playerNickname') || null;
        let opponentNickname = null;
        
        // ë©€í‹°í”Œë ˆì´ ë³€ìˆ˜
        let multiplayerPeer = null;
        let multiplayerConnection = null;
        let currentRoomCode = null;
        let isHost = false;
        let myTeam = null; // 'blue' ë˜ëŠ” 'red'
        let opponentTeam = null;
        let opponentReady = false; // ìƒëŒ€ë°© ì—°ê²° ë° íŒ€ ì„ íƒ ì™„ë£Œ
        let gameStarted = false; // ê²Œì„ ì‹œì‘ ì—¬ë¶€
        
        // ë‹‰ë„¤ì„ í™•ì¸ (ì²˜ìŒ ì ‘ì† ì‹œì—ë§Œ ë¬¼ì–´ë´„)
        function checkNickname() {
            if (!playerNickname || playerNickname.trim() === '') {
                document.getElementById('nicknameModal').style.display = 'block';
            } else {
                showNicknameDisplay();
            }
        }
        
        // ë‹‰ë„¤ì„ ì €ì¥
        function saveNickname() {
            const input = document.getElementById('nicknameInput');
            const nickname = input.value.trim();
            
            if (nickname.length < 1) {
                input.style.borderColor = '#e94560';
                return;
            }
            
            playerNickname = nickname;
            localStorage.setItem('playerNickname', nickname);
            document.getElementById('nicknameModal').style.display = 'none';
            showNicknameDisplay();
        }
        
        // ë‹‰ë„¤ì„ í‘œì‹œ
        function showNicknameDisplay() {
            const nicknameDisplay = document.getElementById('nicknameDisplay');
            const playerNicknameSpan = document.getElementById('playerNickname');
            
            if (playerNickname && nicknameDisplay && playerNicknameSpan) {
                playerNicknameSpan.textContent = playerNickname;
                nicknameDisplay.style.display = 'block';
            }
        }
        
        // ë‹‰ë„¤ì„ ìˆ¨ê¸°ê¸°
        function hideNicknameDisplay() {
            const nicknameDisplay = document.getElementById('nicknameDisplay');
            if (nicknameDisplay) {
                nicknameDisplay.style.display = 'none';
            }
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë‹‰ë„¤ì„ í™•ì¸
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                checkNickname();
            }, 100);
        });

        function generateRoomCode() {
            return Math.floor(10000 + Math.random() * 90000).toString();
        }

        function createRoom() {
            const modal = document.getElementById('roomModal');
            const title = document.getElementById('roomModalTitle');
            const roomCodeSection = document.getElementById('roomCodeSection');
            const joinInput = document.getElementById('roomJoinInput');
            const teamSelectUI = document.getElementById('teamSelectUI');
            const roomCodeElement = document.getElementById('roomCode');
            const waitingMessage = document.getElementById('waitingMessage');
            
            // ë°© ì½”ë“œ ìƒì„±
            currentRoomCode = generateRoomCode();
            isHost = true;
            
            // UI ì„¤ì •
            title.textContent = 'ë°© ìƒì„±';
            roomCodeSection.style.display = 'block';
            joinInput.style.display = 'none';
            teamSelectUI.style.display = 'none';
            roomCodeElement.textContent = currentRoomCode;
            waitingMessage.textContent = 'ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';
            waitingMessage.style.color = '#4a9eff';
            
            modal.style.display = 'block';
            
            // ë©€í‹° ë©”ë‰´ ì ‘ê¸°
            collapseMultiModeSelection();
            
            // PeerJS ì—°ê²° ì´ˆê¸°í™”
            initPeerConnection(currentRoomCode);
        }

        function showJoinRoom() {
            const modal = document.getElementById('roomModal');
            const title = document.getElementById('roomModalTitle');
            const roomCodeSection = document.getElementById('roomCodeSection');
            const joinInput = document.getElementById('roomJoinInput');
            const teamSelectUI = document.getElementById('teamSelectUI');
            const joinCodeInput = document.getElementById('joinCodeInput');
            const errorMessage = document.getElementById('joinErrorMessage');
            
            isHost = false;
            
            // UI ì„¤ì •
            title.textContent = 'ë°© ì…ì¥';
            roomCodeSection.style.display = 'none';
            joinInput.style.display = 'block';
            teamSelectUI.style.display = 'none';
            joinCodeInput.value = '';
            errorMessage.style.display = 'none';
            
            modal.style.display = 'block';
            
            // ë©€í‹° ë©”ë‰´ ì ‘ê¸°
            collapseMultiModeSelection();
            
            // ì…ë ¥ í•„ë“œì— í¬ì»¤ìŠ¤
            setTimeout(() => joinCodeInput.focus(), 100);
        }

        function joinRoom() {
            const joinCodeInput = document.getElementById('joinCodeInput');
            const errorMessage = document.getElementById('joinErrorMessage');
            const code = joinCodeInput.value.trim();
            
            if (code.length !== 5 || !/^\d+$/.test(code)) {
                errorMessage.textContent = '5ìë¦¬ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”';
                errorMessage.style.display = 'block';
                return;
            }
            
            currentRoomCode = code;
            errorMessage.style.display = 'none';
            
            // PeerJSë¡œ ë°©ì— ì—°ê²° ì‹œë„
            connectToRoom(code);
        }

        function closeRoomModal(keepConnection = false) {
            const modal = document.getElementById('roomModal');
            modal.style.display = 'none';
            
            // UI ì´ˆê¸°í™”
            document.getElementById('roomCodeSection').style.display = 'none';
            document.getElementById('roomJoinInput').style.display = 'none';
            document.getElementById('teamSelectUI').style.display = 'none';
            document.getElementById('startGameBtn').style.display = 'none';
            document.getElementById('guestWaitingMessage').style.display = 'none';
            document.getElementById('blueTeamPlayer').innerHTML = '';
            document.getElementById('redTeamPlayer').innerHTML = '';
            document.getElementById('joinCodeInput').value = '';
            document.getElementById('roomModalTitle').style.display = 'block';
            
            // keepConnectionì´ falseì¼ ë•Œë§Œ ì—°ê²° ì •ë¦¬ (ë‚˜ê°€ê¸° ë²„íŠ¼ ëˆ„ë¥¼ ë•Œ)
            if (!keepConnection) {
                // ìƒëŒ€ë°©ì—ê²Œ ë‚˜ê°€ê¸° ì•Œë¦¼
                if (multiplayerConnection && multiplayerConnection.open) {
                    sendMultiplayerData({ type: 'leave' });
                }
                
                myTeam = null;
                opponentTeam = null;
                opponentReady = false;
                opponentNickname = null;
                if (multiplayerPeer) {
                    multiplayerPeer.destroy();
                    multiplayerPeer = null;
                }
                multiplayerConnection = null;
                currentRoomCode = null;
            }
        }

        function initPeerConnection(roomCode) {
            const waitingMessage = document.getElementById('waitingMessage');
            
            // PeerJS ì¸ìŠ¤í„´ìŠ¤ ìƒì„± (ë°© ì½”ë“œë¥¼ IDë¡œ ì‚¬ìš©)
            const peerId = 'revolver-duel-' + roomCode;
            
            try {
                multiplayerPeer = new Peer(peerId);
                
                multiplayerPeer.on('open', (id) => {
                    console.log('PeerJS ì—°ê²°ë¨, ID:', id);
                    waitingMessage.textContent = 'ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';
                });
                
                multiplayerPeer.on('connection', (conn) => {
                    console.log('ìƒëŒ€ë°© ì—°ê²°ë¨!');
                    multiplayerConnection = conn;
                    
                    conn.on('open', () => {
                        // ë°© ì½”ë“œ ì„¹ì…˜ ìˆ¨ê¸°ê³  íŒ€ ì„ íƒ UI í‘œì‹œ
                        document.getElementById('roomCodeSection').style.display = 'none';
                        document.getElementById('teamSelectUI').style.display = 'block';
                        document.getElementById('roomModalTitle').style.display = 'none';
                        
                        // ë‚´ ë‹‰ë„¤ì„ ì „ì†¡
                        sendMultiplayerData({
                            type: 'nickname',
                            nickname: playerNickname
                        });
                    });
                    
                    conn.on('data', (data) => {
                        handleMultiplayerData(data);
                    });
                    
                    conn.on('close', () => {
                        console.log('ìƒëŒ€ë°© ì—°ê²° ëŠê¹€');
                        // ê²Œì„ ì¤‘ì¼ ë•Œë§Œ disconnect ì²˜ë¦¬
                        if (gameState.isMultiplayer && !gameState.isMenu) {
                            handleDisconnect();
                        }
                    });
                });
                
                multiplayerPeer.on('error', (err) => {
                    console.error('PeerJS ì—ëŸ¬:', err);
                    waitingMessage.textContent = 'ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤';
                    waitingMessage.style.color = '#e94560';
                });
            } catch (e) {
                console.error('PeerJS ì´ˆê¸°í™” ì‹¤íŒ¨:', e);
                waitingMessage.textContent = 'PeerJS ë¡œë“œ ì‹¤íŒ¨. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.';
                waitingMessage.style.color = '#e94560';
            }
        }

        function connectToRoom(roomCode) {
            const errorMessage = document.getElementById('joinErrorMessage');
            const joinInput = document.getElementById('roomJoinInput');
            
            const peerId = 'revolver-duel-' + roomCode;
            
            try {
                // ìƒˆ Peer ì¸ìŠ¤í„´ìŠ¤ ìƒì„± (ê³ ìœ  IDë¡œ)
                const myId = 'revolver-duel-guest-' + Math.random().toString(36).substr(2, 9);
                multiplayerPeer = new Peer(myId);
                
                multiplayerPeer.on('open', () => {
                    console.log('PeerJS ì—°ê²°ë¨, ë°©ì— ì ‘ì† ì‹œë„...');
                    
                    // í˜¸ìŠ¤íŠ¸ì— ì—°ê²°
                    multiplayerConnection = multiplayerPeer.connect(peerId);
                    
                    multiplayerConnection.on('open', () => {
                        console.log('ë°©ì— ì—°ê²°ë¨!');
                        
                        // ì½”ë“œ ì…ë ¥ UI ìˆ¨ê¸°ê³  íŒ€ ì„ íƒ UI í‘œì‹œ
                        document.getElementById('roomJoinInput').style.display = 'none';
                        document.getElementById('teamSelectUI').style.display = 'block';
                        document.getElementById('roomModalTitle').style.display = 'none';
                        
                        // ë‚´ ë‹‰ë„¤ì„ ì „ì†¡
                        sendMultiplayerData({
                            type: 'nickname',
                            nickname: playerNickname
                        });
                    });
                    
                    multiplayerConnection.on('data', (data) => {
                        handleMultiplayerData(data);
                    });
                    
                    multiplayerConnection.on('close', () => {
                        console.log('ì—°ê²° ëŠê¹€');
                        // ê²Œì„ ì¤‘ì¼ ë•Œë§Œ disconnect ì²˜ë¦¬
                        if (gameState.isMultiplayer && !gameState.isMenu) {
                            handleDisconnect();
                        }
                    });
                    
                    multiplayerConnection.on('error', (err) => {
                        console.error('ì—°ê²° ì—ëŸ¬:', err);
                        errorMessage.textContent = 'ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
                        errorMessage.style.display = 'block';
                    });
                    
                    // ì—°ê²° íƒ€ì„ì•„ì›ƒ (5ì´ˆ)
                    setTimeout(() => {
                        if (!multiplayerConnection || !multiplayerConnection.open) {
                            errorMessage.textContent = 'ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
                            errorMessage.style.display = 'block';
                            if (multiplayerPeer) {
                                multiplayerPeer.destroy();
                                multiplayerPeer = null;
                            }
                        }
                    }, 5000);
                });
                
                multiplayerPeer.on('error', (err) => {
                    console.error('PeerJS ì—ëŸ¬:', err);
                    errorMessage.textContent = 'ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤';
                    errorMessage.style.display = 'block';
                });
            } catch (e) {
                console.error('PeerJS ì´ˆê¸°í™” ì‹¤íŒ¨:', e);
                errorMessage.textContent = 'PeerJS ë¡œë“œ ì‹¤íŒ¨';
                errorMessage.style.display = 'block';
            }
        }

        function handleMultiplayerData(data) {
            if (!data || !data.type) return;
            
            switch (data.type) {
                case 'gameState':
                    // ê²Œì„ì´ ì‹œì‘ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ë¬´ì‹œ
                    if (!gameStarted) return;
                    
                    // ìƒëŒ€ë°©ì˜ í”Œë ˆì´ì–´ ìƒíƒœë¥¼ ìš°ë¦¬ì˜ enemyì— ì ìš©
                    if (data.player) {
                        enemy.x = data.player.x;
                        enemy.y = data.player.y;
                        enemy.angle = data.player.angle;
                        enemy.health = data.player.health;
                        enemy.displayHealth = data.player.displayHealth;
                        enemy.ammo = data.player.ammo;
                        enemy.maxAmmo = data.player.maxAmmo;
                        enemy.isReloading = data.player.isReloading;
                        enemy.reloadStartTime = data.player.reloadStartTime;
                        enemy.reloadTime = data.player.reloadTime;
                        enemy.isDodging = data.player.isDodging;
                        enemy.isInvincible = data.player.isInvincible;
                        enemy.isReviving = data.player.isReviving;
                        enemy.shieldReady = data.player.shieldReady;
                        enemy.reflectActive = data.player.reflectActive;
                        enemy.isFortified = data.player.isFortified;
                    }
                    
                    // ê²Œì„ ìƒíƒœ ë™ê¸°í™” (isPaused, countdown)
                    if (data.gameState) {
                        // í˜¸ìŠ¤íŠ¸ì˜ isPaused ìƒíƒœë¥¼ ë”°ë¦„
                        if (isHost === false) {
                            gameState.isPaused = data.gameState.isPaused;
                            gameState.countdown = data.gameState.countdown;
                        }
                    }
                    break;
                    
                case 'shoot':
                    // ìƒëŒ€ë°©ì´ ì´ì„ ìˆì„ ë•Œ
                    if (data.bullets) {
                        data.bullets.forEach(bulletData => {
                            const bullet = new Bullet(
                                bulletData.x,
                                bulletData.y,
                                bulletData.angle,
                                enemy,
                                false
                            );
                            bullet.damage = bulletData.damage || enemy.damage;
                            bullet.hasPoison = bulletData.hasPoison || false;
                            bullet.hasBouncy = bulletData.hasBouncy || false;
                            bullet.maxBounces = bulletData.maxBounces || 0;
                            enemy.bullets.push(bullet);
                        });
                    }
                    break;
                    
                case 'teamSelect':
                    // ìƒëŒ€ë°© íŒ€ ì„ íƒ
                    opponentTeam = data.team;
                    updateTeamUI();
                    break;
                    
                case 'nickname':
                    // ìƒëŒ€ë°© ë‹‰ë„¤ì„ ìˆ˜ì‹ 
                    opponentNickname = data.nickname;
                    opponentReady = true;
                    updateTeamUI();
                    break;
                
                case 'leave':
                    // ìƒëŒ€ë°©ì´ ë°©ì„ ë‚˜ê° (ë©”ì‹œì§€ ë³´ë‚´ì§€ ì•Šê³  ì •ë¦¬)
                    alert('ìƒëŒ€ë°©ì´ ë‚˜ê°”ìŠµë‹ˆë‹¤');
                    // ì—°ê²° ë¨¼ì € ì •ë¦¬ (leave ë©”ì‹œì§€ ì¤‘ë³µ ë°©ì§€)
                    if (multiplayerConnection) {
                        multiplayerConnection.close();
                        multiplayerConnection = null;
                    }
                    closeRoomModal(true); // keepConnection=trueë¡œ í•´ì„œ ë‹¤ì‹œ leave ë©”ì‹œì§€ ì•ˆ ë³´ëƒ„
                    // ì¶”ê°€ ì •ë¦¬
                    myTeam = null;
                    opponentTeam = null;
                    opponentReady = false;
                    opponentNickname = null;
                    if (multiplayerPeer) {
                        multiplayerPeer.destroy();
                        multiplayerPeer = null;
                    }
                    currentRoomCode = null;
                    break;
                    
                case 'startGame':
                    // í˜¸ìŠ¤íŠ¸ê°€ ê²Œì„ ì‹œì‘
                    if (!isHost) {
                        closeRoomModal(true);
                        startMultiplayerGame();
                    }
                    break;
                    
                case 'roundEnd':
                    // ë¼ìš´ë“œ ì¢…ë£Œ ë™ê¸°í™” - ê²ŒìŠ¤íŠ¸ë§Œ ì²˜ë¦¬
                    if (!isHost && data.winner) {
                        if (data.winner === 'host') {
                            // í˜¸ìŠ¤íŠ¸ê°€ ì´ê¹€ = ë‚˜(ê²ŒìŠ¤íŠ¸)ê°€ ì§
                            handleRoundEndFromHost('enemy');
                        } else {
                            // ê²ŒìŠ¤íŠ¸ê°€ ì´ê¹€ = ë‚˜(ê²ŒìŠ¤íŠ¸)ê°€ ì´ê¹€
                            handleRoundEndFromHost('player');
                        }
                    }
                    break;
                    
                case 'augmentSelected':
                    // ìƒëŒ€ë°© ì¦ê°• ì„ íƒ ì™„ë£Œ
                    if (data.augment) {
                        const aug = augmentations.find(a => a.id === data.augment.id);
                        if (aug) {
                            aug.effect(enemy);
                            enemy.augmentations.push(aug);
                        }
                    }
                    // ìƒëŒ€ ì„ íƒ ì™„ë£Œ - ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                    gameState.showOpponentSelecting = false;
                    setTimeout(() => {
                        nextRound();
                    }, 500);
                    break;
                    
                case 'nextRound':
                    // ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘
                    if (!isHost) {
                        nextRound();
                    }
                    break;
            }
        }
        
        // ê²ŒìŠ¤íŠ¸ìš©: í˜¸ìŠ¤íŠ¸ë¡œë¶€í„° ë¼ìš´ë“œ ì¢…ë£Œ ë°›ìŒ
        function handleRoundEndFromHost(winner) {
            gameState.isPaused = true;
            gameState.roundWins.push(winner);
            
            if (winner === 'player') {
                gameState.playerWins++;
            } else {
                gameState.enemyWins++;
            }
            
            // ìŠ¹ë¦¬ ì²´í¬
            if (gameState.playerWins >= gameState.winsNeeded || gameState.enemyWins >= gameState.winsNeeded) {
                endGame(winner);
                return;
            }
            
            // ì¦ê°• ì„ íƒ
            if (winner === 'player') {
                // ë‚´ê°€ ìŠ¹ë¦¬: ìƒëŒ€ê°€ ì¦ê°• ì„ íƒ ì¤‘ - 15ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ë§Œ í‘œì‹œ
                gameState.showOpponentSelecting = true;
                gameState.augmentCountdown = 15;
                startOpponentWaitCountdown();
            } else {
                // ë‚´ê°€ íŒ¨ë°°: ì¦ê°• ì„ íƒ
                showAugmentModal(player);
            }
        }
        
        // ìƒëŒ€ë°© ì¦ê°• ì„ íƒ ëŒ€ê¸° ì¹´ìš´íŠ¸ë‹¤ìš´
        function startOpponentWaitCountdown() {
            const countdownInterval = setInterval(() => {
                gameState.augmentCountdown--;
                if (gameState.augmentCountdown <= 0 || !gameState.showOpponentSelecting) {
                    clearInterval(countdownInterval);
                    gameState.augmentCountdown = 0;
                }
            }, 1000);
        }
        
        // íŒ€ ì„ íƒ
        function selectTeam(team) {
            // ìƒëŒ€ë°©ì´ ì´ë¯¸ ê·¸ íŒ€ì„ ì„ íƒí–ˆìœ¼ë©´ ì„ íƒ ë¶ˆê°€
            if (opponentTeam === team) {
                return;
            }
            
            myTeam = team;
            
            // ìƒëŒ€ë°©ì—ê²Œ íŒ€ ì„ íƒ ì•Œë¦¼
            sendMultiplayerData({
                type: 'teamSelect',
                team: team
            });
            
            updateTeamUI();
        }
        
        // íŒ€ UI ì—…ë°ì´íŠ¸
        function updateTeamUI() {
            const blueTeamPlayer = document.getElementById('blueTeamPlayer');
            const redTeamPlayer = document.getElementById('redTeamPlayer');
            const blueTeamBox = document.getElementById('blueTeamBox');
            const redTeamBox = document.getElementById('redTeamBox');
            const teamSelectStatus = document.getElementById('teamSelectStatus');
            
            // ì™•ê´€ ì•„ì´ì½˜ (í˜¸ìŠ¤íŠ¸ í‘œì‹œ) - ë…¸ë€ìƒ‰
            // í…Œë‘ë¦¬ ìŠ¤íƒ€ì¼ (ë‹‰ë„¤ì„ì´ ìˆì„ ë•Œë§Œ)
            const borderStyle = 'padding: 4px 15px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 5px; display: inline-block;';
            
            // íŒŒë€íŒ€ í‘œì‹œ
            if (myTeam === 'blue') {
                const name = playerNickname || 'ë‚˜';
                blueTeamPlayer.innerHTML = '<span style="' + borderStyle + '">' + name + '</span>';
                blueTeamBox.style.boxShadow = '0 0 20px rgba(74, 158, 255, 0.5)';
            } else if (opponentTeam === 'blue') {
                const name = opponentNickname || 'ìƒëŒ€ë°©';
                blueTeamPlayer.innerHTML = '<span style="' + borderStyle + '">' + name + '</span>';
                blueTeamBox.style.boxShadow = 'none';
            } else {
                blueTeamPlayer.innerHTML = '';
                blueTeamBox.style.boxShadow = 'none';
            }
            
            // ë¹¨ê°„íŒ€ í‘œì‹œ
            if (myTeam === 'red') {
                const name = playerNickname || 'ë‚˜';
                redTeamPlayer.innerHTML = '<span style="' + borderStyle + '">' + name + '</span>';
                redTeamBox.style.boxShadow = '0 0 20px rgba(233, 69, 96, 0.5)';
            } else if (opponentTeam === 'red') {
                const name = opponentNickname || 'ìƒëŒ€ë°©';
                redTeamPlayer.innerHTML = '<span style="' + borderStyle + '">' + name + '</span>';
                redTeamBox.style.boxShadow = 'none';
            } else {
                redTeamPlayer.innerHTML = '';
                redTeamBox.style.boxShadow = 'none';
            }
            
            // ìƒíƒœ ë©”ì‹œì§€
            if (myTeam && opponentTeam) {
                teamSelectStatus.textContent = 'ì–‘ìª½ ëª¨ë‘ íŒ€ ì„ íƒ ì™„ë£Œ!';
                teamSelectStatus.style.color = '#00ff00';
            } else if (myTeam) {
                teamSelectStatus.textContent = 'ìƒëŒ€ë°©ì´ íŒ€ì„ ì„ íƒí•˜ëŠ” ì¤‘...';
                teamSelectStatus.style.color = '#ffc107';
            } else {
                teamSelectStatus.textContent = 'íŒ€ì„ ì„ íƒí•´ì£¼ì„¸ìš”';
                teamSelectStatus.style.color = '#aaa';
            }
            
            // í˜¸ìŠ¤íŠ¸: ì–‘ìª½ ëª¨ë‘ íŒ€ ì„ íƒ ì™„ë£Œí•˜ë©´ ì‹œì‘ ë²„íŠ¼ í‘œì‹œ
            if (isHost && myTeam && opponentTeam) {
                document.getElementById('startGameBtn').style.display = 'block';
            }
            
            // ê²ŒìŠ¤íŠ¸: ëŒ€ê¸° ë©”ì‹œì§€ í‘œì‹œ
            if (!isHost && myTeam) {
                document.getElementById('guestWaitingMessage').style.display = 'block';
            }
        }
        
        // ê²Œì„ ì‹œì‘ ì‹ í˜¸ ì „ì†¡ (í˜¸ìŠ¤íŠ¸ë§Œ)
        function sendStartGame() {
            if (!isHost || !myTeam) return;
            
            // ìƒëŒ€ë°©ì—ê²Œ ê²Œì„ ì‹œì‘ ì•Œë¦¼
            sendMultiplayerData({ type: 'startGame' });
            
            // ìì‹ ë„ ê²Œì„ ì‹œì‘
            closeRoomModal(true);
            startMultiplayerGame();
        }
        
        // ì—°ê²° ëŠê¹€ í™•ì¸
        function confirmDisconnect() {
            document.getElementById('disconnectModal').style.display = 'none';
            restartGame();
        }

        function handleDisconnect() {
            // ì—°ê²° ëŠê¹€ ì²˜ë¦¬
            gameState.isMultiplayer = false;
            gameStarted = false;
            
            // ê²Œì„ ì¤‘ì´ì—ˆìœ¼ë©´ ëª¨ë‹¬ í‘œì‹œ
            if (!gameState.isMenu) {
                document.getElementById('disconnectModal').style.display = 'block';
            }
        }

        // ë©€í‹°í”Œë ˆì´ì–´ ë°ì´í„° ì „ì†¡
        function sendMultiplayerData(data) {
            if (multiplayerConnection && multiplayerConnection.open) {
                multiplayerConnection.send(data);
            }
        }

        // í”Œë ˆì´ì–´ ìƒíƒœ ì „ì†¡ (ê²Œì„ ë£¨í”„ì—ì„œ í˜¸ì¶œ)
        function sendPlayerState() {
            if (!gameState.isMultiplayer || !multiplayerConnection) return;
            
            const now = Date.now();
            // 30msë§ˆë‹¤ ì „ì†¡ (ì•½ 33fps)
            if (now - gameState.lastSyncTime < 30) return;
            gameState.lastSyncTime = now;
            
            sendMultiplayerData({
                type: 'gameState',
                player: {
                    x: player.x,
                    y: player.y,
                    angle: player.angle,
                    health: player.health,
                    displayHealth: player.displayHealth,
                    ammo: player.ammo,
                    maxAmmo: player.maxAmmo,
                    isReloading: player.isReloading,
                    reloadStartTime: player.reloadStartTime,
                    reloadTime: player.reloadTime,
                    isDodging: player.isDodging,
                    isInvincible: player.isInvincible,
                    isReviving: player.isReviving,
                    shieldReady: player.shieldReady,
                    reflectActive: player.reflectActive,
                    isFortified: player.isFortified
                },
                gameState: {
                    isPaused: gameState.isPaused,
                    countdown: gameState.countdown
                }
            });
        }

        // ì´ì•Œ ë°œì‚¬ ì „ì†¡
        function sendShootData(bullets) {
            if (!gameState.isMultiplayer) return;
            
            const bulletDataArray = bullets.map(b => ({
                x: b.x,
                y: b.y,
                angle: b.angle,
                damage: b.damage,
                hasPoison: b.hasPoison,
                hasBouncy: b.hasBouncy,
                maxBounces: b.maxBounces
            }));
            
            sendMultiplayerData({
                type: 'shoot',
                bullets: bulletDataArray
            });
        }

        function startMultiplayerGame() {
            console.log('ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ ì‹œì‘! í˜¸ìŠ¤íŠ¸:', isHost, 'íŒ€:', myTeam);
            
            gameStarted = true;
            
            // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
            gameState.isMultiplayer = true;
            gameState.isMenu = false;
            gameState.gameMode = 'classic'; // ë©€í‹°í”Œë ˆì´ëŠ” í´ë˜ì‹ ëª¨ë“œ
            gameState.round = 1;
            gameState.playerWins = 0;
            gameState.enemyWins = 0;
            gameState.roundWins = [];
            gameState.gameTime = 180;
            gameState.isGameOver = false;
            gameState.countdown = 3;
            gameState.isPaused = true;
            
            // ë©”ì¸ ë©”ë‰´ ìˆ¨ê¸°ê¸°
            document.getElementById('mainMenu').style.display = 'none';
            
            // ë‹‰ë„¤ì„ ìˆ¨ê¸°ê¸°
            hideNicknameDisplay();
            
            // ë§µ ê²½ê³„ ì„¤ì •
            gameState.mapBounds = {
                minX: 0,
                minY: 0,
                maxX: canvas.width,
                maxY: canvas.height
            };
            
            // íŒ€ì— ë”°ë¥¸ ìƒ‰ìƒ ë° ìœ„ì¹˜ ì„¤ì •
            const isBlueTeam = myTeam === 'blue';
            player.color = isBlueTeam ? '#4a9eff' : '#e94560';
            enemy.color = isBlueTeam ? '#e94560' : '#4a9eff';
            
            // íŒŒë€íŒ€ì€ ì™¼ìª½, ë¹¨ê°„íŒ€ì€ ì˜¤ë¥¸ìª½
            const leftX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            const rightX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            const centerY = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            
            player.x = isBlueTeam ? leftX : rightX;
            player.y = centerY;
            enemy.x = isBlueTeam ? rightX : leftX;
            enemy.y = centerY;
            
            // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.damage = 1;
            player.speed = 3;
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.reloadTime = 3000;
            player.baseReloadTime = 3000;
            player.shootCooldown = 1000;
            player.isReloading = false;
            player.isDodging = false;
            player.isReviving = false;
            player.isInvincible = false;
            player.hasRevived = 0;
            resetPlayerAugments(player);
            
            // ì (ìƒëŒ€ë°©) ì´ˆê¸°í™”
            enemy.health = 5;
            enemy.displayHealth = 5;
            enemy.maxHealth = 5;
            enemy.ammo = 6;
            enemy.maxAmmo = 6;
            enemy.bullets = [];
            enemy.augmentations = [];
            enemy.damage = 1;
            enemy.speed = 3;
            enemy.bulletSpeedMultiplier = 1;
            enemy.bulletSizeMultiplier = 1;
            enemy.reloadTime = 3000;
            enemy.baseReloadTime = 3000;
            enemy.shootCooldown = 1000;
            enemy.isReloading = false;
            enemy.isDodging = false;
            enemy.isReviving = false;
            enemy.isInvincible = false;
            enemy.hasRevived = 0;
            resetPlayerAugments(enemy);
            
            // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.isPaused = false;
                }
            }, 1000);
        }
        
        // í”Œë ˆì´ì–´ ì¦ê°• ìƒíƒœ ì´ˆê¸°í™” í—¬í¼ í•¨ìˆ˜
        function resetPlayerAugments(char) {
            char.hasCritical = false;
            char.hasDoubleShot = false;
            char.hasDodge = false;
            char.hasRevive = false;
            char.hasDeepWound = false;
            char.hasOneShotOneKill = false;
            char.hasPoisonBullet = false;
            char.hasReloadHeal = false;
            char.hasSurvivalInstinct = false;
            char.hasLastBullet = false;
            char.hasRecoveryContract = false;
            char.hasRecoveryContractUsed = false;
            char.hasFocusedFire = false;
            char.hasShotgun = false;
            char.hasRagged = false;
            char.hasGhost = false;
            char.hasFortify = false;
            char.isFortified = false;
            char.hasOverheat = false;
            char.hasGamble = false;
            char.hasWeaken = false;
            char.isWeakened = false;
            char.hasDamageBoost = false;
            char.hasLightning = false;
            char.isStunned = false;
            char.hasShield = false;
            char.shieldReady = false;
            char.hasRegeneration = false;
            char.hasEvasiveManeuver = false;
            char.hasCombatExperience = false;
            char.hasHallucination = false;
            char.hasTasteOfBlood = false;
            char.hasCannon = false;
            char.hasTimeBarrier = false;
            char.hasBouncyBullet = false;
            char.hasGamble2 = false;
            char.hasReflect = false;
            char.reflectActive = false;
            char.hasGatling = false;
            char.hasTimeStop = false;
            char.timeStopActive = false;
            char.hasScatter = false;
            char.hasRocket = false;
            char.hasTrinity = false;
            char.hasJudgment = false;
            char.hasBoomerang = false;
            char.poisonEffects = [];
            char.damageNumbers = [];
        }

        // ëœë¤ ëª¨ë“œ ì •ì˜
        const randomModes = [
            {
                id: 'doubleAugment',
                name: '2Xëª¨ë“œ',
                description: 'ì¦ê°•ì„ 2ê°œì”© ì„ íƒí•©ë‹ˆë‹¤'
            },
            {
                id: 'hp1',
                name: 'HP1ëª¨ë“œ',
                description: 'ì´ˆê¸° ìµœëŒ€ì²´ë ¥ì´ 1ì´ ë©ë‹ˆë‹¤'
            },
            {
                id: 'movingWork',
                name: 'ë¬´ë¹™ì›Œí¬ëª¨ë“œ',
                description: 'ëª¨ë“  í”Œë ˆì´ì–´ê°€ 5ì´ˆë§ˆë‹¤ ë°”ë€ŒëŠ” ë°©í–¥ìœ¼ë¡œ ì´ˆë‹¹ 25pxì”© ì´ë™í•©ë‹ˆë‹¤'
            },
            {
                id: 'turtle',
                name: 'ê±°ë¶ì´ëª¨ë“œ',
                description: 'ëª¨ë“  í”Œë ˆì´ì–´ì˜ ì´ë™ì†ë„ê°€ 50% ê°ì†Œí•©ë‹ˆë‹¤'
            },
            {
                id: 'flame',
                name: 'ìš©ì•”ëª¨ë“œ',
                description: 'ëª¨ë“  í”Œë ˆì´ì–´ê°€ 5ì´ˆë§ˆë‹¤ 0.5 ë°ë¯¸ì§€ë¥¼ ì…ìŠµë‹ˆë‹¤'
            },
            {
                id: 'noReload',
                name: 'ë¦¬ë¡œë“œ!ëª¨ë“œ',
                description: 'ì¬ì¥ì „ ì‹œê°„ì´ 0.3ì´ˆê°€ ë©ë‹ˆë‹¤'
            },
            {
                id: 'melee',
                name: 'ê·¼ì ‘ì „ëª¨ë“œ',
                description: 'ëª¨ë“  ì´ì•Œì´ 500pxê¹Œì§€ë§Œ ë°œì‚¬ë©ë‹ˆë‹¤'
            },
            {
                id: 'smallMap',
                name: '-25%ëª¨ë“œ',
                description: 'ë§µ í¬ê¸°ê°€ 25% ì¤„ì–´ë“­ë‹ˆë‹¤'
            },
            {
                id: 'ice',
                name: 'ë¹™íŒëª¨ë“œ',
                description: 'ëª¨ë“  í”Œë ˆì´ì–´ê°€ ì´ë™ë°©í–¥ìœ¼ë¡œ ë¯¸ë„ëŸ¬ì§‘ë‹ˆë‹¤'
            },
            {
                id: 'superAI',
                name: 'ìŠˆí¼AIëª¨ë“œ',
                description: 'AIê°€ ì¦ê°•ì„ ëœë¤ìœ¼ë¡œ 2ê°œ ì„ íƒí•˜ê³  ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤'
            }
        ];

        function startSoloGame(mode) {
            // ëª¨ë“œ ì„ íƒ ì ‘ê¸°
            collapseModeSelection();
            
            gameState.gameMode = mode || 'classic'; // 'classic' ë˜ëŠ” 'random'
            
            // ëœë¤ ëª¨ë“œì¸ ê²½ìš° ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ì‹œê°„ ë©ˆì¶”ê¸°)
            if (mode === 'random') {
                gameState.isPaused = true; // ìŠ¬ë¡¯ë¨¸ì‹  ì¤‘ ì‹œê°„ ë©ˆì¶”ê¸°
                gameState.isSlotMachine = true;
                gameState.slotMachineStartTime = Date.now();
                gameState.slotMachineCurrentIndex = 0;
                gameState.slotMachineSelectedMode = null;
                gameState.selectedRandomMode = null; // ì•„ì§ ì„ íƒë˜ì§€ ì•ŠìŒ
            } else {
                gameState.selectedRandomMode = null;
                gameState.isSlotMachine = false;
            }
            
            gameState.isMenu = false;
            document.getElementById('mainMenu').style.display = 'none';
            
            // ë‹‰ë„¤ì„ ìˆ¨ê¸°ê¸°
            hideNicknameDisplay();
            
            initGame();
        }

        // ëœë¤ ëª¨ë“œ ì ìš© í•¨ìˆ˜
        function applyRandomMode(modeId) {
            switch(modeId) {
                case 'hp1':
                    // HP1ëª¨ë“œ: ìµœëŒ€ì²´ë ¥ 1ë¡œ ì‹œì‘
                    player.maxHealth = 1;
                    player.health = 1;
                    player.displayHealth = 1;
                    enemy.maxHealth = 1;
                    enemy.health = 1;
                    break;
                case 'turtle':
                    // ê±°ë¶ì´ëª¨ë“œ: ì´ë™ì†ë„ 50% ê°ì†Œ
                    player.speed *= 0.5;
                    enemy.speed *= 0.5;
                    break;
                case 'noReload':
                    // ë…¸ë¦¬ë¡œë“œëª¨ë“œ: ì¬ì¥ì „ ì‹œê°„ 0.3ì´ˆ
                    player.reloadTime = 300;
                    player.baseReloadTime = 300; // Reload! ëª¨ë“œ: ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ 0.3ì´ˆ
                    enemy.reloadTime = 300;
                    enemy.baseReloadTime = 300; // Reload! ëª¨ë“œ: ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ 0.3ì´ˆ
                    break;
                case 'smallMap':
                    // -25%ëª¨ë“œ: ë§µ í¬ê¸° 25% ê°ì†Œ
                    const mapScale = 0.75;
                    const mapWidth = canvas.width * mapScale;
                    const mapHeight = canvas.height * mapScale;
                    const mapOffsetX = (canvas.width - mapWidth) / 2;
                    const mapOffsetY = (canvas.height - mapHeight) / 2;
                    
                    gameState.mapBounds.minX = mapOffsetX;
                    gameState.mapBounds.minY = mapOffsetY;
                    gameState.mapBounds.maxX = mapOffsetX + mapWidth;
                    gameState.mapBounds.maxY = mapOffsetY + mapHeight;
                    
                    // í”Œë ˆì´ì–´ì™€ ì  ìœ„ì¹˜ë¥¼ ì¤„ì–´ë“  ë§µ ì•ˆìœ¼ë¡œ ì¡°ì •
                    player.x = Math.max(gameState.mapBounds.minX + player.radius, 
                                      Math.min(gameState.mapBounds.maxX - player.radius, player.x));
                    player.y = Math.max(gameState.mapBounds.minY + player.radius, 
                                      Math.min(gameState.mapBounds.maxY - player.radius, player.y));
                    enemy.x = Math.max(gameState.mapBounds.minX + enemy.radius, 
                                     Math.min(gameState.mapBounds.maxX - enemy.radius, enemy.x));
                    enemy.y = Math.max(gameState.mapBounds.minY + enemy.radius, 
                                     Math.min(gameState.mapBounds.maxY - enemy.radius, enemy.y));
                    break;
                case 'superAI':
                    // ìŠˆí¼AIëª¨ë“œ: AIê°€ ì¦ê°• 2ê°œ ëœë¤ ì„ íƒ
                    const availableAugments = augmentations.filter(aug => aug.id !== 'dodge' && aug.id !== 'fortify' && aug.id !== 'timeStop');
                    const shuffled = [...availableAugments].sort(() => Math.random() - 0.5);
                    // 2ê°œ ì„ íƒ
                    for (let i = 0; i < 2 && i < shuffled.length; i++) {
                        const selectedAugment = shuffled[i];
                        selectedAugment.effect(enemy);
                        enemy.augmentations.push(selectedAugment);
                        incrementAugmentSelectCount(selectedAugment.id);
                    }
                    break;
            }
        }

        function initGame() {
            // ìº”ë²„ìŠ¤ í¬ê¸° ì¬í™•ì¸
            resizeCanvas();
            
            // ë§µ ê²½ê³„ ì´ˆê¸°í™” (ì „ì²´ ìº”ë²„ìŠ¤)
            gameState.mapBounds.minX = 0;
            gameState.mapBounds.minY = 0;
            gameState.mapBounds.maxX = canvas.width;
            gameState.mapBounds.maxY = canvas.height;
            
            // ë§µ ê²½ê³„ ì´ˆê¸°í™” (ì „ì²´ ìº”ë²„ìŠ¤)
            gameState.mapBounds.minX = 0;
            gameState.mapBounds.minY = 0;
            gameState.mapBounds.maxX = canvas.width;
            gameState.mapBounds.maxY = canvas.height;
            
            // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
            gameState.round = 1;
            gameState.playerWins = 0;
            gameState.enemyWins = 0;
            gameState.gameTime = 180;
            gameState.isGameOver = false;
            gameState.isPaused = true;
            gameState.countdown = 3;
            gameState.roundWins = [];
            gameState.augmentCountdown = 0;
            gameState.showOpponentSelecting = false;

            // ëœë¤ ëª¨ë“œ í‘œì‹œ ì—…ë°ì´íŠ¸ (ìŠ¬ë¡¯ë¨¸ì‹  ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
            if (!gameState.isSlotMachine) {
                const randomModeDisplay = document.getElementById('randomModeDisplay');
                const randomModeName = document.getElementById('randomModeName');
                const randomModeTooltip = document.getElementById('randomModeTooltip');
                
                if (gameState.selectedRandomMode) {
                    randomModeDisplay.style.display = 'block';
                    randomModeName.textContent = gameState.selectedRandomMode.name;
                    randomModeTooltip.textContent = gameState.selectedRandomMode.description;
                    
                } else {
                    randomModeDisplay.style.display = 'none';
                }
            }

            // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
            player.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            player.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.angle = 0;
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.speed = 3; // ê¸°ë³¸ ì†ë„ ì„¤ì •
            player.hasCritical = false;
            player.hasDoubleShot = false;
            player.hasDodge = false;
            player.hasRevive = false;
            player.hasRevived = false;
            player.hasDeepWound = false;
            player.hasOneShotOneKill = false;
            player.hasPoisonBullet = false;
            player.hasReloadHeal = false;
            player.hasSurvivalInstinct = false;
            player.hasLastBullet = false;
            player.hasRecoveryContract = false;
            player.hasRecoveryContractUsed = false;
            player.hasFocusedFire = false;
            player.hasShotgun = false;
            player.hasRagged = false;
            player.hasGhost = false;
            player.hasFortify = false;
            player.isFortified = false;
            player.fortifyStartTime = 0;
            player.lastPosition = { x: player.x, y: player.y };
            player.stationaryTime = 0;
            player.hasOverheat = false;
            player.overheatHitCount = 0;
            player.lastHitTime = 0;
            player.hasGamble = false;
            player.hasWeaken = false;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.hasDamageBoost = false;
            player.hasLightning = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.hasShield = false;
            player.shieldReady = false;
            player.shieldCooldown = 0;
            player.hasRegeneration = false;
            player.lastRegenTime = 0;
            player.hasEvasiveManeuver = false;
            player.hasCombatExperience = false;
            player.combatExperienceRounds = 0;
            player.hasHallucination = false;
            player.hasTasteOfBlood = false;
            player.hasCannon = false;
            player.hasTimeBarrier = false;
            player.timeBarrierRadius = 150;
            player.hasBouncyBullet = false;
            player.hasGatling = false;
            player.gatlingBullets = 0;
            player.gatlingNextShot = 0;
            player.hasReflect = false;
            player.reflectActive = false;
            player.reflectCooldown = 0;
            player.reflectEndTime = 0;
            player.hasTimeStop = false;
            player.timeStopCooldown = 0;
            player.timeStopActive = false;
            player.timeStopEndTime = 0;
            player.hasScatter = false;
            player.hasGamble2 = false;
            player.hasRocket = false;
            player.hasTrinity = false;
            player.hasJudgment = false;
            player.isJudgmentPushing = false;
            player.judgmentPushStartX = 0;
            player.judgmentPushStartY = 0;
            player.judgmentPushTargetX = 0;
            player.judgmentPushTargetY = 0;
            player.judgmentPushStartTime = 0;
            player.judgmentPushDuration = 0;
            player.hasBoomerang = false;
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.poisonEffects = [];
            player.isDodging = false;
            player.isReviving = false;
            player.isInvincible = false;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.damage = 1;
            player.speed = 3;
            player.reloadTime = 3000;
            player.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
            player.isReloading = false;
            player.reloadStartTime = 0;
            player.shootCooldown = 1000;
            player.lastShot = 0;

            // enemy ì´ˆê¸°í™”
                enemy.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
                enemy.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
                enemy.health = 5;
                enemy.displayHealth = 5;
                enemy.maxHealth = 5;
                enemy.ammo = 6;
                enemy.maxAmmo = 6;
                enemy.bullets = [];
                enemy.augmentations = [];
                enemy.angle = Math.PI;
                enemy.bulletSpeedMultiplier = 1;
                enemy.bulletSizeMultiplier = 1;
                enemy.hasCritical = false;
                enemy.hasDoubleShot = false;
                enemy.hasDodge = false;
                enemy.hasRevive = false;
                enemy.hasRevived = false;
                enemy.hasDeepWound = false;
                enemy.hasOneShotOneKill = false;
                enemy.hasPoisonBullet = false;
                enemy.hasReloadHeal = false;
                enemy.hasSurvivalInstinct = false;
                enemy.hasLastBullet = false;
                enemy.hasRecoveryContract = false;
                enemy.hasRecoveryContractUsed = false;
                enemy.hasFocusedFire = false;
            enemy.hasShotgun = false;
            enemy.hasRagged = false;
            enemy.hasGhost = false;
            enemy.hasFortify = false;
            enemy.isFortified = false;
            enemy.fortifyStartTime = 0;
            enemy.lastPosition = { x: enemy.x, y: enemy.y };
            enemy.stationaryTime = 0;
            enemy.hasOverheat = false;
            enemy.overheatHitCount = 0;
            enemy.lastHitTime = 0;
            enemy.hasGamble = false;
            enemy.hasWeaken = false;
            enemy.isWeakened = false;
            enemy.weakenEndTime = 0;
            enemy.hasDamageBoost = false;
            enemy.hasLightning = false;
            enemy.isStunned = false;
            enemy.stunEndTime = 0;
            enemy.hasShield = false;
            enemy.shieldReady = false;
            enemy.shieldCooldown = 0;
            enemy.hasRegeneration = false;
            enemy.lastRegenTime = 0;
            enemy.hasEvasiveManeuver = false;
            enemy.hasCombatExperience = false;
            enemy.combatExperienceRounds = 0;
            enemy.hasHallucination = false;
            enemy.hasTasteOfBlood = false;
            enemy.hasCannon = false;
            enemy.hasTimeBarrier = false;
            enemy.timeBarrierRadius = 150;
            enemy.hasBouncyBullet = false;
                enemy.isVulnerable = false;
                enemy.vulnerabilityUsed = false;
                enemy.poisonEffects = [];
                enemy.isDodging = false;
                enemy.isReviving = false;
                enemy.isInvincible = false;
                enemy.slowEndTime = 0;
                enemy.damageNumbers = [];
                enemy.usePrediction = false;
                enemy.lastPlayerX = 0;
                enemy.lastPlayerY = 0;
                enemy.playerVelocity = { x: 0, y: 0 };
                enemy.damage = 1;
                enemy.speed = 2.5; // ê¸°ë³¸ ì†ë„ ì„¤ì •
            enemy.reloadTime = 3000;
                enemy.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
                enemy.isReloading = false;
                enemy.reloadStartTime = 0;
                enemy.shootCooldown = 1000;
                enemy.lastShot = 0;
                
                // ëª¨ë“œë³„ ì´ˆê¸°í™” (ì†ë„ ì„¤ì • í›„ì— ì ìš©)
                if (gameState.selectedRandomMode) {
                    applyRandomMode(gameState.selectedRandomMode.id);
                }

            // ì²« ë¼ìš´ë“œ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (ëœë¤ ëª¨ë“œì´ê³  ìŠ¬ë¡¯ë¨¸ì‹  ì¤‘ì´ë©´ ìŠ¬ë¡¯ë¨¸ì‹ ì´ ëë‚œ í›„ ì‹œì‘)
            if (gameState.gameMode !== 'random' || !gameState.isSlotMachine) {
                const initialCountdown = setInterval(() => {
                    gameState.countdown--;
                    if (gameState.countdown <= 0) {
                        clearInterval(initialCountdown);
                        gameState.isPaused = false;
                    }
                }, 1000);
            }
        }

        function draw() {
            // ë©”ë‰´ í™”ë©´ í‘œì‹œ
            if (gameState.isMenu) {
                return; // ë©”ë‰´ëŠ” HTMLë¡œ í‘œì‹œë˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ê·¸ë¦¬ì§€ ì•ŠìŒ
            }

            // ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì¼ ë•ŒëŠ” ìŠ¬ë¡¯ë¨¸ì‹ ë§Œ ê·¸ë¦¬ê¸°
            if (gameState.isSlotMachine) {
                ctx.fillStyle = '#0f0f1e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ê·¸ë¦¬ê¸°
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // í˜„ì¬ í‘œì‹œí•  ëª¨ë“œ
                const currentMode = randomModes[gameState.slotMachineCurrentIndex];
                
                // ëª¨ë“œ ì´ë¦„ í‘œì‹œ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 64px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(currentMode.name, centerX, centerY);
                
                // ëª¨ë“œ ì„¤ëª… í‘œì‹œ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '32px Arial';
                ctx.fillText(currentMode.description, centerX, centerY + 60);
                
                return; // ìŠ¬ë¡¯ë¨¸ì‹  ì¤‘ì—ëŠ” ë‚˜ë¨¸ì§€ ê²Œì„ ìš”ì†Œ ê·¸ë¦¬ì§€ ì•ŠìŒ
            }

            // í˜¸ë²„ëœ ì¦ê°• ì´ˆê¸°í™”
            hoveredAugment = null;
            
            // í™”ë©´ í”ë“¤ë¦¼ ì ìš©
            let shakeX = 0;
            let shakeY = 0;
            if (gameState.shake.duration > 0) {
                shakeX = (Math.random() - 0.5) * gameState.shake.intensity;
                shakeY = (Math.random() - 0.5) * gameState.shake.intensity;
                gameState.shake.duration = Math.max(0, gameState.shake.duration - 16); // ì•½ 60fps ê¸°ì¤€
                gameState.shake.intensity *= 0.9; // ì ì§„ì ìœ¼ë¡œ ê°ì†Œ
            }

            // ë°°ê²½ í´ë¦¬ì–´ (í”ë“¤ë¦¼ ì „ì— ê·¸ë¦¬ê¸°)
            // ìš©ì•”ëª¨ë“œ: ë°°ê²½ì„ ë¶‰ì€ ê³„ì—´ë¡œ ë³€ê²½
            // ë¹™íŒëª¨ë“œ: ë°°ê²½ì„ í‘¸ë¥¸ ê³„ì—´ë¡œ ë³€ê²½
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'flame') {
                ctx.fillStyle = '#2a0f0f'; // ì–´ë‘ìš´ ë¶‰ì€ ê³„ì—´
            } else if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'ice') {
                ctx.fillStyle = '#0f1e3a'; // ë” íŒŒë€ìƒ‰ í‘¸ë¥¸ ê³„ì—´
            } else {
                ctx.fillStyle = '#0f0f1e';
            }
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // í™”ë©´ í”ë“¤ë¦¼ ì ìš©
            ctx.save();
            ctx.translate(shakeX, shakeY);

            // ê²©ì ê·¸ë¦¬ê¸° (ë§µ ê²½ê³„ ë‚´ë¶€ë§Œ, ê²½ê³„ì„  ì œì™¸)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const startX = gameState.mapBounds.minX;
            const startY = gameState.mapBounds.minY;
            const endX = gameState.mapBounds.maxX;
            const endY = gameState.mapBounds.maxY;
            
            // ê²©ì ì„ ì´ ë§µ ê²½ê³„ì„ ê³¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ê²½ê³„ì„ ì„ ì œì™¸í•˜ê³  ê·¸ë¦¬ê¸°
            const gridStartX = Math.ceil(startX / 50) * 50; // ê²½ê³„ì„  ë‹¤ìŒ ê²©ìë¶€í„°
            const gridStartY = Math.ceil(startY / 50) * 50;
            const gridEndX = Math.floor(endX / 50) * 50; // ê²½ê³„ì„  ì „ê¹Œì§€
            const gridEndY = Math.floor(endY / 50) * 50;
            
            for (let i = gridStartX; i <= gridEndX; i += 50) {
                if (i > startX && i < endX) { // ê²½ê³„ì„  ì œì™¸
                    ctx.beginPath();
                    ctx.moveTo(i, startY);
                    ctx.lineTo(i, endY);
                    ctx.stroke();
                }
            }
            for (let i = gridStartY; i <= gridEndY; i += 50) {
                if (i > startY && i < endY) { // ê²½ê³„ì„  ì œì™¸
                    ctx.beginPath();
                    ctx.moveTo(startX, i);
                    ctx.lineTo(endX, i);
                    ctx.stroke();
                }
            }

            // -25%ëª¨ë“œ: ì¤„ì–´ë“  ì˜ì—­ì„ ê²€ì€ìƒ‰ìœ¼ë¡œ í‘œì‹œ (ê²©ì ê·¸ë¦¬ê¸° í›„, ê²©ì ì„ ì„ ë®ê¸° ìœ„í•´)
            // í”ë“¤ë¦¼ìœ¼ë¡œ ì¸í•œ ì—¬ìœ  ê³µê°„ ì¶”ê°€ (ìµœëŒ€ í”ë“¤ë¦¼ ê°•ë„ ê³ ë ¤)
            const shakeMargin = 50; // í”ë“¤ë¦¼ ì—¬ìœ  ê³µê°„
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'smallMap') {
                ctx.fillStyle = '#000000'; // ê²€ì€ìƒ‰
                // ìœ„ìª½ ì˜ì—­ (ì—¬ìœ  ê³µê°„ ì¶”ê°€)
                ctx.fillRect(-shakeMargin, -shakeMargin, canvas.width + shakeMargin * 2, gameState.mapBounds.minY + shakeMargin);
                // ì•„ë˜ìª½ ì˜ì—­ (ì—¬ìœ  ê³µê°„ì€ ìœ„ìª½ë§Œ, ì•„ë˜ìª½ì€ ì •í™•íˆ ê²½ê³„ì—ì„œ ì‹œì‘)
                ctx.fillRect(-shakeMargin, gameState.mapBounds.maxY, canvas.width + shakeMargin * 2, canvas.height - gameState.mapBounds.maxY);
                // ì™¼ìª½ ì˜ì—­ (ì—¬ìœ  ê³µê°„ ì¶”ê°€)
                ctx.fillRect(-shakeMargin, gameState.mapBounds.minY - shakeMargin, gameState.mapBounds.minX + shakeMargin, gameState.mapBounds.maxY - gameState.mapBounds.minY + shakeMargin * 2);
                // ì˜¤ë¥¸ìª½ ì˜ì—­ (ì—¬ìœ  ê³µê°„ì€ ì™¼ìª½ë§Œ, ì˜¤ë¥¸ìª½ì€ ì •í™•íˆ ê²½ê³„ì—ì„œ ì‹œì‘)
                ctx.fillRect(gameState.mapBounds.maxX, gameState.mapBounds.minY - shakeMargin, canvas.width - gameState.mapBounds.maxX, gameState.mapBounds.maxY - gameState.mapBounds.minY + shakeMargin * 2);
            }

            // ì´ì•Œ ê·¸ë¦¬ê¸°
            player.bullets.forEach(bullet => bullet.draw());
            enemy.bullets.forEach(bullet => bullet.draw());

            // êµ¬ë¥´ê¸° ì”ìƒ ê·¸ë¦¬ê¸°
            function drawDodgeTrail(character) {
                if (character.isDodging && character.dodgeTrail && character.dodgeTrail.length > 0) {
                    // ì”ìƒ íš¨ê³¼ (ê³¼ê±° ìœ„ì¹˜ ê·¸ë¦¬ê¸°)
                    character.dodgeTrail.forEach((trail, index) => {
                        const fadeAlpha = trail.alpha * (1 - index * 0.2); // ì ì§„ì ìœ¼ë¡œ íˆ¬ëª…
                        ctx.globalAlpha = Math.max(0, fadeAlpha);
                        ctx.fillStyle = character.color;
                        ctx.beginPath();
                        ctx.arc(trail.x, trail.y, character.radius * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;
                }
            }

            // í´ë˜ì‹ ëª¨ë“œ ë˜ëŠ” ëœë¤ ëª¨ë“œì—ì„œ ë„¤ì˜¨ íš¨ê³¼ ì¶”ê°€ (ë§µ ê²½ê³„ì— ì˜ë¦¬ì§€ ì•Šë„ë¡ í”ë“¤ë¦¼ ë³€í™˜ ì „ì— ê·¸ë¦¬ê¸°)
            const isClassicOrRandom = gameState.gameMode === 'classic' || gameState.gameMode === 'random';
            
            // ë„¤ì˜¨ íš¨ê³¼ë¥¼ ë¨¼ì € ê·¸ë¦¬ê¸° (ë§µ ê²½ê³„ì— ì˜ë¦¬ì§€ ì•Šë„ë¡)
            if (isClassicOrRandom) {
                // ì  ë„¤ì˜¨ íš¨ê³¼
                if (enemy.x > -500 && enemy.y > -500) {
                    ctx.save();
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = enemy.color;
                    ctx.globalAlpha = 0.6; // ë„¤ì˜¨ íš¨ê³¼ëŠ” ì•½ê°„ íˆ¬ëª…í•˜ê²Œ
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    ctx.fillStyle = enemy.color;
                    ctx.fill();
                    ctx.restore();
                }
                
                // í”Œë ˆì´ì–´ ë„¤ì˜¨ íš¨ê³¼
                ctx.save();
                ctx.shadowBlur = 20;
                ctx.shadowColor = player.color;
                ctx.globalAlpha = 0.6; // ë„¤ì˜¨ íš¨ê³¼ëŠ” ì•½ê°„ íˆ¬ëª…í•˜ê²Œ
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.restore();
            }

            // ì  ê·¸ë¦¬ê¸°
            if (enemy.x > -500 && enemy.y > -500) {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                ctx.rotate(enemy.angle);
                
                // ê¸°ë³¸ alpha ì„¤ì •
                ctx.globalAlpha = 1.0;
                
                // ë¬´ì  ìƒíƒœë©´ ê¹œë¹¡ì„ íš¨ê³¼
                if (enemy.isInvincible) {
                    const blink = Math.floor(Date.now() / 100) % 2;
                    if (blink) {
                        ctx.globalAlpha = 0.5;
                    }
                }
                
                // êµ¬ë¥´ê¸° ì”ìƒ ê·¸ë¦¬ê¸°
                if (enemy.dodgeTrail && enemy.dodgeTrail.length > 0) {
                    enemy.dodgeTrail.forEach((trail, index) => {
                        ctx.save();
                        ctx.globalAlpha = trail.alpha * (index / enemy.dodgeTrail.length);
                        ctx.translate(trail.x - enemy.x, trail.y - enemy.y);
                        ctx.beginPath();
                        ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                        ctx.fillStyle = enemy.color;
                        ctx.fill();
                        ctx.restore();
                    });
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                ctx.fillStyle = enemy.color;
                ctx.fill();
                
                // ë°©ì–´ë§‰: ì§„í•œ íŒŒë€ìƒ‰ í…Œë‘ë¦¬
                if (enemy.hasShield && enemy.shieldReady) {
                    ctx.strokeStyle = '#0066ff'; // ì§„í•œ íŒŒë€ìƒ‰
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                // ë°˜ì‚¬ ë³´í˜¸ë§‰: í•˜ì–€ìƒ‰ í…Œë‘ë¦¬
                if (enemy.reflectActive) {
                    ctx.strokeStyle = '#ffffff'; // í•˜ì–€ìƒ‰
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                
                // ë¦¬ë³¼ë²„ ê·¸ë¦¬ê¸° (ë„¤ì˜¨ íš¨ê³¼ ì¶”ê°€)
                ctx.save();
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#333333';
                ctx.fillStyle = '#333'; // íŒŒìŠ¤í…” ê·¸ë ˆì´
                ctx.fillRect(enemy.radius - 7.5, -4.5, 22.5, 9); // 1.5ë°° ì¦ê°€
                ctx.restore();
                
                ctx.globalAlpha = 1.0; // ë³µì›
                ctx.restore();
                
                // ì  ì²´ë ¥ê³¼ íƒ„í™˜ìˆ˜ëŠ” UI ì˜ì—­ì—ì„œ í‘œì‹œë¨
                
                // ì  ì¬ì¥ì „ ë°” í‘œì‹œ (ì  ë°”ë¡œ ì˜¤ë¥¸ìª½ ìœ„) - ì  ìœ„ì¹˜ì— í”ë“¤ë¦¼ ì ìš©
                if (enemy.isReloading) {
                    drawReloadBar(enemy, enemy.x + 40 + shakeX, enemy.y - 40 + shakeY);
                }
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´: ìºë¦­í„° ìœ„ì— ë‹‰ë„¤ì„ í‘œì‹œ
            if (gameState.isMultiplayer) {
                ctx.save();
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = 0.6;
                
                // í”Œë ˆì´ì–´ ë‹‰ë„¤ì„
                ctx.fillStyle = player.color;
                ctx.fillText(playerNickname || 'ë‚˜', player.x + shakeX, player.y - player.radius - 10 + shakeY);
                
                // ìƒëŒ€ë°© ë‹‰ë„¤ì„
                if (enemy.x > -500 && enemy.y > -500) {
                    ctx.fillStyle = enemy.color;
                    ctx.fillText(opponentNickname || 'ìƒëŒ€', enemy.x + shakeX, enemy.y - enemy.radius - 10 + shakeY);
                }
                
                ctx.restore();
            }

            // ì‹œê°„ì¥ë§‰ ê·¸ë¦¬ê¸° (í”Œë ˆì´ì–´)
            if (player.hasTimeBarrier) {
                ctx.save();
                ctx.globalAlpha = 0.2; // íˆ¬ëª…ë„ê°€ ê°•í•œ ì´ˆë¡ìƒ‰
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x + shakeX, player.y + shakeY, player.timeBarrierRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // ì‹œê°„ì¥ë§‰ ê·¸ë¦¬ê¸° (ì )
            if (enemy.hasTimeBarrier && enemy.x > -500 && enemy.y > -500) {
                ctx.save();
                ctx.globalAlpha = 0.2; // íˆ¬ëª…ë„ê°€ ê°•í•œ ì´ˆë¡ìƒ‰
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(enemy.x + shakeX, enemy.y + shakeY, enemy.timeBarrierRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
            drawDodgeTrail(player);
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            
            // ë¬´ì  ìƒíƒœì¼ ë•Œ ë°˜íˆ¬ëª…
            ctx.globalAlpha = 1.0; // ê¸°ë³¸ê°’ ì„¤ì •
            if (player.isInvincible || player.isReviving) {
                ctx.globalAlpha = 0.5;
            } else if (player.hasGhost) {
                // ìœ ë ¹ ì¦ê°•: ì‚´ì§ íë ¤ì§€ê²Œ
                ctx.globalAlpha = 0.7;
            }
            
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
            ctx.fill();
            // ê±°ì í™•ë³´: í•˜ì–€ìƒ‰ í…Œë‘ë¦¬
            if (player.hasFortify && player.isFortified) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // ë°©ì–´ë§‰: ì§„í•œ íŒŒë€ìƒ‰ í…Œë‘ë¦¬
            if (player.hasShield && player.shieldReady) {
                ctx.strokeStyle = '#0066ff'; // ì§„í•œ íŒŒë€ìƒ‰
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            // ë°˜ì‚¬ ë³´í˜¸ë§‰: í•˜ì–€ìƒ‰ í…Œë‘ë¦¬
            if (player.reflectActive) {
                ctx.strokeStyle = '#ffffff'; // í•˜ì–€ìƒ‰
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            // ë¦¬ë³¼ë²„ ê·¸ë¦¬ê¸° (ë„¤ì˜¨ íš¨ê³¼ ì¶”ê°€)
            ctx.save();
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#333333';
            ctx.fillStyle = '#333'; // íŒŒìŠ¤í…” ê·¸ë ˆì´
            ctx.fillRect(player.radius - 7.5, -4.5, 22.5, 9); // 1.5ë°° ì¦ê°€
            ctx.restore();
            ctx.globalAlpha = 1.0;
            ctx.restore();

            // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼ ì¢…ë£Œ
            ctx.restore();
            
            // ë°ë¯¸ì§€ ìˆ«ì ê·¸ë¦¬ê¸° (í”ë“¤ë¦¼ ì˜í–¥ ë°›ìŒ)
            ctx.save();
            ctx.translate(shakeX, shakeY);
            drawDamageNumbers(player);
                drawDamageNumbers(enemy);
            
            // ë¬´ë¹™ì›Œí¬ ëª¨ë“œ: í™”ë©´ ì¤‘ì•™ì— ë°©í–¥ í™”ì‚´í‘œ ì•„ì´ì½˜ í‘œì‹œ (í”ë“¤ë¦¼ ì˜í–¥ ë°›ìŒ)
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'movingWork' && gameState.movingWorkDirection !== undefined) {
                const centerX = canvas.width / 2;
                let centerY = canvas.height / 2;
                
                // ì¦ê°•ì´ 5ê°œë¥¼ ë„˜ìœ¼ë©´ ì•„ë˜ë¡œ ë‚´ë¦¼
                const totalAugments = (player.augmentations ? player.augmentations.length : 0) + (enemy.augmentations ? enemy.augmentations.length : 0);
                if (totalAugments > 5) {
                    centerY = canvas.height / 2 + 100; // ì•„ë˜ë¡œ 100px ì´ë™
                }
                
                // í™”ì‚´í‘œ ë°©í–¥ì— ë”°ë¥¸ ìœ ë‹ˆì½”ë“œ í™”ì‚´í‘œ
                const angle = gameState.movingWorkDirection;
                let arrowChar;
                // 0 (ìš°), Ï€/2 (ì•„ë˜), Ï€ (ì¢Œ), 3Ï€/2 (ìœ„)
                if (Math.abs(angle - 0) < 0.1) {
                    arrowChar = 'â†’'; // ìš°
                } else if (Math.abs(angle - Math.PI / 2) < 0.1) {
                    arrowChar = 'â†“'; // ì•„ë˜
                } else if (Math.abs(angle - Math.PI) < 0.1) {
                    arrowChar = 'â†'; // ì¢Œ
                } else if (Math.abs(angle - 3 * Math.PI / 2) < 0.1) {
                    arrowChar = 'â†‘'; // ìœ„
                } else {
                    arrowChar = 'â†’'; // ê¸°ë³¸ê°’
                }
                
                // ë‘êº¼ìš´ í™”ì‚´í‘œ ì•„ì´ì½˜ í‘œì‹œ (í•˜ì–€ìƒ‰ ë‹¨ìƒ‰)
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // í•˜ì–€ìƒ‰ ë‹¨ìƒ‰, ì¡°ê¸ˆ ë” íˆ¬ëª…í•˜ê²Œ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillText(arrowChar, centerX, centerY);
            }
            
            ctx.restore();

            // UI ìš”ì†Œë“¤ (í”ë“¤ë¦¼ì˜ ì˜í–¥ì„ ë°›ì§€ ì•ŠìŒ)
            // ìŠ¹ë¦¬ í‘œì‹œ ë§ˆë¦„ëª¨ (í™”ë©´ ìœ„ìª½ ê°€ìš´ë°)
            drawWinIndicators();
            
            // ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ (ë§ˆë¦„ëª¨ ì•„ë˜)
            if (gameState.countdown > 0 || gameState.augmentCountdown > 0) {
                drawCountdown();
            }
            
            // ìƒëŒ€ ì„ íƒ ì¤‘ ë©”ì‹œì§€ í‘œì‹œ
            if (gameState.showOpponentSelecting) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const text = 'ìƒëŒ€ê°€ ì„ íƒì¤‘ì…ë‹ˆë‹¤';
                const textWidth = ctx.measureText(text).width;
                const padding = 40;
                const y = canvas.height / 2;
                
                // ë°°ê²½ ì‚¬ê°í˜•
                ctx.fillRect(
                    canvas.width / 2 - textWidth / 2 - padding,
                    y - 40,
                    textWidth + padding * 2,
                    80
                );
                
                // í…ìŠ¤íŠ¸
                ctx.fillStyle = '#ffffff';
                ctx.fillText(text, canvas.width / 2, y);
                ctx.restore();
            }
            
            // ì‹œê°„ ì •ì§€ í‘ë°± íš¨ê³¼: í”Œë ˆì´ì–´ì™€ í”Œë ˆì´ì–´ì˜ ì´ì•Œ ì œì™¸í•˜ê³  í‘ë°± ì²˜ë¦¬
            if (player.timeStopActive) {
                // í˜„ì¬ canvas ì´ë¯¸ì§€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // í”Œë ˆì´ì–´ì™€ í”Œë ˆì´ì–´ ì´ì•Œ ì˜ì—­ ì €ì¥ (ì»¬ëŸ¬ ìœ ì§€)
                const playerColorRegions = [];
                const playerRadius = player.radius + 5; // ì•½ê°„ì˜ ì—¬ìœ 
                for (let y = Math.max(0, Math.floor(player.y - playerRadius)); y < Math.min(canvas.height, Math.floor(player.y + playerRadius)); y++) {
                    for (let x = Math.max(0, Math.floor(player.x - playerRadius)); x < Math.min(canvas.width, Math.floor(player.x + playerRadius)); x++) {
                        const dx = x - player.x;
                        const dy = y - player.y;
                        if (dx * dx + dy * dy <= playerRadius * playerRadius) {
                            const idx = (y * canvas.width + x) * 4;
                            playerColorRegions.push({
                                x, y,
                                r: data[idx],
                                g: data[idx + 1],
                                b: data[idx + 2],
                                a: data[idx + 3]
                            });
                        }
                    }
                }
                
                // í”Œë ˆì´ì–´ ì´ì•Œ ì˜ì—­ ì €ì¥
                player.bullets.forEach(bullet => {
                    const bulletRadius = bullet.radius + 5;
                    for (let y = Math.max(0, Math.floor(bullet.y - bulletRadius)); y < Math.min(canvas.height, Math.floor(bullet.y + bulletRadius)); y++) {
                        for (let x = Math.max(0, Math.floor(bullet.x - bulletRadius)); x < Math.min(canvas.width, Math.floor(bullet.x + bulletRadius)); x++) {
                            const dx = x - bullet.x;
                            const dy = y - bullet.y;
                            if (dx * dx + dy * dy <= bulletRadius * bulletRadius) {
                                const idx = (y * canvas.width + x) * 4;
                                playerColorRegions.push({
                                    x, y,
                                    r: data[idx],
                                    g: data[idx + 1],
                                    b: data[idx + 2],
                                    a: data[idx + 3]
                                });
                            }
                        }
                    }
                });
                
                // ì „ì²´ë¥¼ í‘ë°±ìœ¼ë¡œ ë³€í™˜
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray;     // R
                    data[i + 1] = gray; // G
                    data[i + 2] = gray; // B
                }
                
                // í”Œë ˆì´ì–´ì™€ í”Œë ˆì´ì–´ ì´ì•Œ ì˜ì—­ ì›ë˜ ì»¬ëŸ¬ë¡œ ë³µì›
                playerColorRegions.forEach(region => {
                    const idx = (region.y * canvas.width + region.x) * 4;
                    data[idx] = region.r;
                    data[idx + 1] = region.g;
                    data[idx + 2] = region.b;
                    data[idx + 3] = region.a;
                });
                
                // ë³€í™˜ëœ ì´ë¯¸ì§€ ë°ì´í„° ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                ctx.putImageData(imageData, 0, 0);
            }

            // ë©€í‹°í”Œë ˆì´ì–´: íŒ€ ê¸°ì¤€ìœ¼ë¡œ UI í‘œì‹œ (íŒŒë€íŒ€ ì™¼ìª½, ë¹¨ê°„íŒ€ ì˜¤ë¥¸ìª½)
            // ì†”ë¡œ: í”Œë ˆì´ì–´ ì™¼ìª½, ì  ì˜¤ë¥¸ìª½
            let leftChar, rightChar;
            if (gameState.isMultiplayer && myTeam) {
                // ë©€í‹°í”Œë ˆì´ì–´: íŒŒë€íŒ€ì´ ì™¼ìª½, ë¹¨ê°„íŒ€ì´ ì˜¤ë¥¸ìª½
                if (myTeam === 'blue') {
                    leftChar = player;
                    rightChar = enemy;
                } else {
                    leftChar = enemy;
                    rightChar = player;
                }
            } else {
                // ì†”ë¡œ: í”Œë ˆì´ì–´ ì™¼ìª½, ì  ì˜¤ë¥¸ìª½
                leftChar = player;
                rightChar = enemy;
            }
            
            // ì™¼ìª½ UI (íŒŒë€íŒ€ / í”Œë ˆì´ì–´)
            const leftHealthY = 20;
            drawHealthHearts(leftChar, 20, leftHealthY, leftChar === player);
            const leftAmmoY = leftHealthY + 40;
            drawAmmoCount(leftChar, 20, leftAmmoY, 'left');
            drawAugmentIcons(leftChar, 20, leftAmmoY + 50, 'left');
            
            // ì˜¤ë¥¸ìª½ UI (ë¹¨ê°„íŒ€ / ì )
            {
                const fixedBarWidth = 150;
                const rightHealthX = canvas.width - fixedBarWidth - 20;
                const rightHealthY = 20;
                drawHealthHearts(rightChar, rightHealthX, rightHealthY, rightChar === player);
                const rightAmmoY = rightHealthY + 40;
                drawAmmoCount(rightChar, rightHealthX + fixedBarWidth, rightAmmoY, 'right');
                drawAugmentIcons(rightChar, rightHealthX + fixedBarWidth, rightAmmoY + 50, 'right');
            }
            
            // í”Œë ˆì´ì–´ ì¬ì¥ì „ ë°” í‘œì‹œ (í”Œë ˆì´ì–´ ë°”ë¡œ ì˜†) - í”Œë ˆì´ì–´ ìœ„ì¹˜ì— í”ë“¤ë¦¼ ì ìš©
            if (player.isReloading) {
                drawReloadBar(player, player.x - 40 + shakeX, player.y - 40 + shakeY);
            }
            // ì¦ê°• íˆ´íŒ í‘œì‹œ
            if (hoveredAugment) {
                drawAugmentTooltip(hoveredAugment.aug, hoveredAugment.x, hoveredAugment.y);
            }
            
        }
        
        // ì¦ê°• íˆ´íŒ ê·¸ë¦¬ê¸°
        function drawAugmentTooltip(aug, x, y) {
            ctx.save();
            
            const padding = 12;
            const lineHeight = 24;
            const fontSize = 18;
            ctx.font = `bold ${fontSize}px Arial`;
            
            // í…ìŠ¤íŠ¸ í¬ê¸° ì¸¡ì •
            const titleWidth = ctx.measureText(aug.name).width;
            ctx.font = `${fontSize - 2}px Arial`;
            const descWidth = ctx.measureText(aug.description).width;
            const tooltipWidth = Math.max(titleWidth, descWidth) + padding * 2;
            const tooltipHeight = lineHeight * 2 + padding * 2;
            
            // íˆ´íŒ ìœ„ì¹˜ (ì•„ì´ì½˜ ìœ„ìª½ ë˜ëŠ” ì•„ë˜ìª½)
            let tooltipX = x;
            let tooltipY = y - 50 - tooltipHeight; // ì•„ì´ì½˜ ìœ„ìª½
            
            // í™”ë©´ ê²½ê³„ ì²´í¬
            if (tooltipY < 0) {
                tooltipY = y + 50; // ì•„ì´ì½˜ ì•„ë˜ìª½
            }
            if (tooltipX + tooltipWidth / 2 > canvas.width) {
                tooltipX = canvas.width - tooltipWidth / 2;
            }
            if (tooltipX - tooltipWidth / 2 < 0) {
                tooltipX = tooltipWidth / 2;
            }
            
            // ë°°ê²½
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.strokeStyle = '#ffc107';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffc107';
            ctx.lineWidth = 2;
            drawRoundedRect(
                tooltipX - tooltipWidth / 2,
                tooltipY,
                tooltipWidth,
                tooltipHeight,
                8
            );
            ctx.fill();
            ctx.stroke();
            
            // ì œëª© (ë„¤ì˜¨ íš¨ê³¼)
            ctx.fillStyle = '#ffc107';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#ffc107';
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(aug.name, tooltipX, tooltipY + padding);
            
            // ì„¤ëª…
            ctx.fillStyle = '#ffffff';
            ctx.font = `${fontSize - 2}px Arial`;
            ctx.fillText(aug.description, tooltipX, tooltipY + padding + lineHeight);
            
            ctx.restore();
        }

        // UI ì—…ë°ì´íŠ¸ (ì²´ë ¥ ì• ë‹ˆë©”ì´ì…˜ ë° ë°ë¯¸ì§€ ìˆ«ì)
        function updateUI() {
            // í”Œë ˆì´ì–´ ì²´ë ¥ ì• ë‹ˆë©”ì´ì…˜
            if (player.displayHealth !== player.health) {
                const diff = player.health - player.displayHealth;
                const speed = 0.15; // ì• ë‹ˆë©”ì´ì…˜ ì†ë„
                player.displayHealth += diff * speed;
                // ê±°ì˜ ê°™ì•„ì§€ë©´ ë°”ë¡œ ë§ì¶¤
                if (Math.abs(diff) < 0.01) {
                    player.displayHealth = player.health;
                }
            }
            
            // ì  ì²´ë ¥ ì• ë‹ˆë©”ì´ì…˜
            if (enemy.displayHealth !== enemy.health) {
                const diff = enemy.health - enemy.displayHealth;
                const speed = 0.15; // ì• ë‹ˆë©”ì´ì…˜ ì†ë„
                enemy.displayHealth += diff * speed;
                // ê±°ì˜ ê°™ì•„ì§€ë©´ ë°”ë¡œ ë§ì¶¤
                if (Math.abs(diff) < 0.01) {
                    enemy.displayHealth = enemy.health;
                }
            }
            
            // ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸
            updateDamageNumbers(player);
            updateDamageNumbers(enemy);
            
            // ë… íš¨ê³¼ ì²˜ë¦¬
            updatePoisonEffects(player);
                updatePoisonEffects(enemy);
        }
        
        // ë… íš¨ê³¼ ì—…ë°ì´íŠ¸
        function updatePoisonEffects(character) {
            const now = Date.now();
            for (let i = character.poisonEffects.length - 1; i >= 0; i--) {
                const poison = character.poisonEffects[i];
                const elapsed = now - poison.startTime;
                
                // 2ì´ˆê°€ ì§€ë‚˜ê±°ë‚˜ ìµœëŒ€ íˆíŠ¸ íšŸìˆ˜ì— ë„ë‹¬í•˜ë©´ ì œê±°
                if (elapsed >= poison.duration || (poison.hitCount >= poison.maxHits)) {
                    character.poisonEffects.splice(i, 1);
                    continue;
                }
                
                // 1ì´ˆë§ˆë‹¤ 0.2 ë°ë¯¸ì§€ (ìµœëŒ€ 2ë²ˆ, ì •í™” ì¦ê°•ì´ ìˆìœ¼ë©´ ë¬´ì‹œ)
                // ê¸°ì¡´ ë… íš¨ê³¼ í˜¸í™˜ì„±ì„ ìœ„í•´ hitCountê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
                if (!poison.hasOwnProperty('hitCount')) {
                    poison.hitCount = 0;
                    poison.maxHits = 3;
                }
                if (now - poison.lastDamageTime >= 1000 && (poison.hitCount || 0) < (poison.maxHits || 3)) {
                    // ê²Œì„ì´ ì¼ì‹œì •ì§€ëœ ìƒíƒœë©´ ë°ë¯¸ì§€ ë¬´ì‹œ (ì¦ê°• ì„ íƒ ì‹œê°„ ë™ì•ˆ)
                    if (gameState.isPaused) {
                        continue;
                    }
                    // ìœ ë ¹ ì¦ê°•: í™•ë¥  ì¤‘ì²© (25% * count)
                    const ghostCount = poison.target.ghostCount || 1;
                    if (poison.target.hasGhost && Math.random() < (0.25 * ghostCount)) {
                        // "ë¬´ì‹œ" í…ìŠ¤íŠ¸ í‘œì‹œ
                        poison.target.damageNumbers.push({
                            x: poison.target.x,
                            y: poison.target.y,
                            damage: 0,
                            isCritical: false,
                            isGhost: true, // ìœ ë ¹ ë¬´ì‹œ ì—¬ë¶€
                            startTime: now,
                            duration: 1000,
                            offsetY: 0
                        });
                        poison.lastDamageTime = now; // ë‹¤ìŒ ë°ë¯¸ì§€ íƒ€ì´ë¨¸ ë¦¬ì…‹
                        continue; // ë°ë¯¸ì§€ ì ìš©í•˜ì§€ ì•ŠìŒ
                    }
                    
                    let poisonDamage = poison.damagePerSecond;
                    // ê±°ì í™•ë³´: ë°ë¯¸ì§€ *0.5
                    if (poison.target.hasFortify && poison.target.isFortified) {
                        poisonDamage *= 0.5;
                    }
                    // ì†Œìˆ˜ì  3ìë¦¬ ì´ìƒì´ë©´ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
                    poisonDamage = roundToMaxTwoDecimals(poisonDamage);
                    
                    poison.target.health -= poisonDamage;
                    poison.target.health = roundToMaxTwoDecimals(poison.target.health);
                    poison.lastDamageTime = now;
                    poison.hitCount = (poison.hitCount || 0) + 1; // íˆíŠ¸ íšŸìˆ˜ ì¦ê°€
                    
                    // ë… ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ (ì–´ë‘ìš´ ì´ˆë¡ìƒ‰)
                    poison.target.damageNumbers.push({
                        x: poison.target.x,
                        y: poison.target.y,
                        damage: poisonDamage,
                        isCritical: false,
                        isPoison: true, // ë… ë°ë¯¸ì§€ ì—¬ë¶€
                        startTime: now,
                        duration: 1000,
                        offsetY: 0
                    });
                    
                    // ì²´ë ¥ì´ 0 ì´í•˜ê°€ ë˜ë©´ ì²˜ë¦¬
                    if (poison.target.health <= 0) {
                        poison.target.health = 0;
                        // ë¶€í™œ ì²´í¬ (íšŸìˆ˜ ì¤‘ì²©)
                        const reviveCount = poison.target.reviveCount || 1;
                        const hasRevivedCount = (typeof poison.target.hasRevived === 'number' ? poison.target.hasRevived : (poison.target.hasRevived ? 1 : 0));
                        if (poison.target.hasRevive && hasRevivedCount < reviveCount && !poison.target.isReviving) {
                            poison.target.hasRevived = hasRevivedCount + 1;
                            poison.target.isReviving = true;
                            poison.target.reviveTime = now + 1000;
                        } else {
                            endRound(poison.target === player ? 'enemy' : 'player');
                        }
                    }
                }
            }
        }
        
        // ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸
        function updateDamageNumbers(character) {
            const now = Date.now();
            for (let i = character.damageNumbers.length - 1; i >= 0; i--) {
                const damageNum = character.damageNumbers[i];
                const elapsed = now - damageNum.startTime;
                
                // ì‹œê°„ì´ ì§€ë‚˜ë©´ ì œê±°
                if (elapsed >= damageNum.duration) {
                    character.damageNumbers.splice(i, 1);
                    continue;
                }
                
                // ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì• ë‹ˆë©”ì´ì…˜
                const progress = elapsed / damageNum.duration;
                damageNum.offsetY = -30 * progress; // ìœ„ë¡œ 30px ì´ë™
            }
        }
        
        // ë°ë¯¸ì§€ ìˆ«ì ê·¸ë¦¬ê¸°
        function drawDamageNumbers(character) {
            const now = Date.now();
            character.damageNumbers.forEach(damageNum => {
                const elapsed = now - damageNum.startTime;
                const progress = elapsed / damageNum.duration;
                
                // í˜ì´ë“œì•„ì›ƒ íš¨ê³¼
                const alpha = 1 - progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // ìƒ‰ìƒ ê²°ì •: íšŒë³µì´ë©´ ë¹¨ê°„ìƒ‰, ë°©ì–´ë§‰ ë¬´ì‹œë©´ ì§„í•œ íŒŒë€ìƒ‰, ìœ ë ¹ ë¬´ì‹œë©´ íšŒìƒ‰, ê¸°ì ˆì´ë©´ ë…¸ë€ìƒ‰, ë… ë°ë¯¸ì§€ë©´ ì–´ë‘ìš´ ì´ˆë¡ìƒ‰, í¬ë¦¬í‹°ì»¬ì´ë©´ ì–´ë‘ìš´ ë…¸ë€ìƒ‰, ì•„ë‹ˆë©´ í•˜ì–€ìƒ‰
                let shadowColor = '#ffffff';
                if (damageNum.isHeal) {
                    ctx.fillStyle = '#ff0000'; // ë¹¨ê°„ìƒ‰
                    shadowColor = '#ff0000';
                } else if (damageNum.isShield) {
                    ctx.fillStyle = '#0066ff'; // ì§„í•œ íŒŒë€ìƒ‰
                    shadowColor = '#0066ff';
                } else if (damageNum.isGhost) {
                    ctx.fillStyle = '#888888'; // íšŒìƒ‰
                    shadowColor = '#888888';
                } else if (damageNum.isStunned) {
                    ctx.fillStyle = '#ffffff'; // í•˜ì–€ìƒ‰
                    shadowColor = '#ffffff';
                } else if (damageNum.isPoison) {
                    ctx.fillStyle = '#006600'; // ì–´ë‘ìš´ ì´ˆë¡ìƒ‰
                    shadowColor = '#006600';
                } else if (damageNum.isCritical) {
                    ctx.fillStyle = '#CCAA00'; // ì–´ë‘ìš´ ë…¸ë€ìƒ‰
                    shadowColor = '#CCAA00';
                } else if (damageNum.isFlame) {
                    ctx.fillStyle = '#ff6600'; // ì£¼í™©/ë¹¨ê°• ê³„ì—´
                    shadowColor = '#ff6600';
                } else {
                    ctx.fillStyle = '#ffffff'; // í•˜ì–€ìƒ‰
                    shadowColor = '#ffffff';
                }
                ctx.shadowBlur = 10;
                ctx.shadowColor = shadowColor;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // ìºë¦­í„° ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ë°ë¯¸ì§€ ìˆ«ì ë˜ëŠ” íŠ¹ìˆ˜ í…ìŠ¤íŠ¸ í‘œì‹œ
                let displayText;
                if (damageNum.isShield || damageNum.isGhost) {
                    displayText = 'ë¬´ì‹œ';
                } else if (damageNum.isStunned) {
                    displayText = 'ê¸°ì ˆ';
                } else {
                    // ì†Œìˆ˜ì  3ìë¦¬ ì´ìƒì´ë©´ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼, 1~2ìë¦¬ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
                    let value = damageNum.damage;
                    // ì†Œìˆ˜ì  ìë¦¬ìˆ˜ í™•ì¸ (ë¬¸ìì—´ë¡œ ë³€í™˜í•´ì„œ í™•ì¸)
                    const strValue = value.toString();
                    const decimalIndex = strValue.indexOf('.');
                    if (decimalIndex !== -1) {
                        const decimalPart = strValue.substring(decimalIndex + 1);
                        if (decimalPart.length > 2) {
                            // 3ìë¦¬ ì´ìƒì´ë©´ 2ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
                            value = Math.round(value * 100) / 100;
                        }
                    }
                    // ë¶ˆí•„ìš”í•œ ì†Œìˆ˜ì  ì œê±° (ì •ìˆ˜ë©´ ì†Œìˆ˜ì  ì œê±°)
                    if (value % 1 === 0) {
                        displayText = value.toString();
                    } else {
                        // ì†Œìˆ˜ì  ìë¦¬ìˆ˜ì— ë§ê²Œ í‘œì‹œ
                        const strValue2 = value.toString();
                        const decimalIndex2 = strValue2.indexOf('.');
                        if (decimalIndex2 !== -1) {
                            const decimalPart2 = strValue2.substring(decimalIndex2 + 1);
                            displayText = value.toFixed(Math.min(decimalPart2.length, 2));
                        } else {
                            displayText = value.toString();
                        }
                    }
                }
                ctx.fillText(
                    displayText,
                    damageNum.x,
                    damageNum.y + damageNum.offsetY
                );
                
                ctx.restore();
            });
        }

        // ê²Œì„ ë£¨í”„
        let lastTime = 0;
        function gameLoop(currentTime) {
            // ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜ ì²˜ë¦¬
            if (gameState.isSlotMachine) {
                const elapsed = Date.now() - gameState.slotMachineStartTime;
                const slotSpeed = 80; // 80msë§ˆë‹¤ ëª¨ë“œ ë³€ê²½ (ë¹ ë¥¸ ìˆœí™˜)
                const spinningDuration = 1200; // 1.2ì´ˆ ë™ì•ˆ ìŠ¬ë¡¯ë¨¸ì‹  ì• ë‹ˆë©”ì´ì…˜
                const displayDuration = 2000; // ì„ íƒëœ ëª¨ë“œ í‘œì‹œ ì‹œê°„ 2ì´ˆ
                
                // ëª¨ë“œ ìˆœí™˜
                if (elapsed < spinningDuration) {
                    const newIndex = Math.floor(elapsed / slotSpeed) % randomModes.length;
                    gameState.slotMachineCurrentIndex = newIndex;
                } else if (elapsed < spinningDuration + displayDuration) {
                    // ì„ íƒëœ ëª¨ë“œì—ì„œ ë©ˆì¶¤ (ì„¤ëª… ì½ì„ ìˆ˜ ìˆê²Œ)
                    if (!gameState.slotMachineSelectedMode) {
                        // ëœë¤ ëª¨ë“œ ì„ íƒ
                        const randomIndex = Math.floor(Math.random() * randomModes.length);
                        gameState.selectedRandomMode = randomModes[randomIndex];
                        gameState.slotMachineSelectedMode = gameState.selectedRandomMode;
                        gameState.slotMachineCurrentIndex = randomIndex; // ì„ íƒëœ ëª¨ë“œë¡œ ê³ ì •
                        
                        // ëœë¤ ëª¨ë“œ í‘œì‹œ ì—…ë°ì´íŠ¸
                        const randomModeDisplay = document.getElementById('randomModeDisplay');
                        const randomModeName = document.getElementById('randomModeName');
                        const randomModeTooltip = document.getElementById('randomModeTooltip');
                        
                        randomModeDisplay.style.display = 'block';
                        randomModeName.textContent = gameState.selectedRandomMode.name;
                        randomModeTooltip.textContent = gameState.selectedRandomMode.description;
                        
                        // ëœë¤ ëª¨ë“œ ì ìš© (ì†ë„ ì´ˆê¸°í™” í›„ ì ìš©)
                        player.speed = 3;
                        enemy.speed = 2.5;
                        player.reloadTime = 3000;
                        player.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
                        enemy.reloadTime = 3000;
                        enemy.baseReloadTime = 3000; // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„ ì €ì¥
                        applyRandomMode(gameState.selectedRandomMode.id);
                    }
                } else {
                    // í‘œì‹œ ì‹œê°„ ì¢…ë£Œ, ìŠ¬ë¡¯ë¨¸ì‹  ì¢…ë£Œ í›„ 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                    gameState.isSlotMachine = false;
                    gameState.countdown = 3; // 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                    gameState.isPaused = true; // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¤‘ì´ë¯€ë¡œ ë©ˆì¶¤
                    
                    // ì¹´ìš´íŠ¸ë‹¤ìš´ ì²˜ë¦¬
                    const countdownInterval = setInterval(() => {
                        gameState.countdown--;
                        if (gameState.countdown <= 0) {
                            clearInterval(countdownInterval);
                            gameState.isPaused = false; // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¢…ë£Œ í›„ ê²Œì„ ì‹œì‘
                        }
                    }, 1000);
                }
            }
            
            // ë©”ë‰´ í™”ë©´ì´ ì•„ë‹ ë•Œë§Œ ê²Œì„ ë¡œì§ ì‹¤í–‰ (ìŠ¬ë¡¯ë¨¸ì‹  ì¤‘ì´ ì•„ë‹ ë•Œ)
            if (!gameState.isMenu && !gameState.isPaused && !gameState.isGameOver && !gameState.isSlotMachine) {
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                // íƒ€ì´ë¨¸ ê°ì†Œ (ì´ˆë‹¹ 1ì”©)
                if (deltaTime >= 1000) {
                    gameState.gameTime--;
                    lastTime = currentTime;

                    // ì‹œê°„ ì´ˆê³¼
                    if (gameState.gameTime <= 0) {
                        if (player.health > enemy.health) {
                            endRound('player');
                        } else if (enemy.health > player.health) {
                            endRound('enemy');
                        } else {
                            // ë¬´ìŠ¹ë¶€ - ì²´ë ¥ì´ ë” ë§ì€ ìª½ì´ ìŠ¹ë¦¬
                            endRound(player.health >= enemy.health ? 'player' : 'enemy');
                        }
                    }
                }

                // ìš©ì•”ëª¨ë“œ: 5ì´ˆë§ˆë‹¤ 0.5 ë°ë¯¸ì§€
                const now = Date.now();
                if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'flame') {
                    if (!gameState.flameLastDamage) {
                        gameState.flameLastDamage = now;
                    }
                    
                    if (now - gameState.flameLastDamage >= 5000) {
                        // í”Œë ˆì´ì–´ì™€ ì  ëª¨ë‘ ë°ë¯¸ì§€
                        if (player.health > 0) {
                            player.health = Math.max(0, player.health - 0.5);
                            // ìš©ì•” ë°ë¯¸ì§€ í‘œì‹œ (ì£¼í™©/ë¹¨ê°• ìƒ‰ìƒ)
                            player.damageNumbers.push({
                                damage: 0.5,
                                x: player.x,
                                y: player.y - player.radius - 20,
                                alpha: 1,
                                isFlame: true,
                                startTime: now,
                                duration: 1000
                            });
                        }
                        if (enemy.health > 0) {
                            enemy.health = Math.max(0, enemy.health - 0.5);
                            enemy.damageNumbers.push({
                                damage: 0.5,
                                x: enemy.x,
                                y: enemy.y - enemy.radius - 20,
                                alpha: 1,
                                isFlame: true,
                                startTime: now,
                                duration: 1000
                            });
                        }
                        gameState.flameLastDamage = now;
                        
                        // í™”ì—¼ ë°ë¯¸ì§€ë¡œ ì²´ë ¥ì´ 0 ì´í•˜ê°€ ë˜ë©´ ë¼ìš´ë“œ íŒ¨ë°° ì²˜ë¦¬
                        if (player.health <= 0 && !player.isReviving) {
                            // ë¶€í™œ ì²´í¬ (íšŸìˆ˜ ì¤‘ì²©)
                            const reviveCount = player.reviveCount || 1;
                            const hasRevivedCount = (typeof player.hasRevived === 'number' ? player.hasRevived : (player.hasRevived ? 1 : 0));
                            if (player.hasRevive && hasRevivedCount < reviveCount) {
                                player.hasRevived = hasRevivedCount + 1;
                                player.isReviving = true;
                                player.reviveTime = now + 1000;
                            } else {
                                endRound('enemy');
                            }
                        }
                        if (enemy.health <= 0 && !enemy.isReviving) {
                            // ë¶€í™œ ì²´í¬ (íšŸìˆ˜ ì¤‘ì²©)
                            const reviveCount = enemy.reviveCount || 1;
                            const hasRevivedCount = (typeof enemy.hasRevived === 'number' ? enemy.hasRevived : (enemy.hasRevived ? 1 : 0));
                            if (enemy.hasRevive && hasRevivedCount < reviveCount) {
                                enemy.hasRevived = hasRevivedCount + 1;
                                enemy.isReviving = true;
                                enemy.reviveTime = now + 1000;
                            } else {
                                endRound('player');
                            }
                        }
                    }
                }

                // ê²Œí‹€ë§ ë°œì‚¬ ì²˜ë¦¬
                if (player.hasGatling && player.gatlingBullets > 0 && now >= player.gatlingNextShot) {
                    // ë„ë°• ì¦ê°•: ê° ë°œì‚¬ë§ˆë‹¤ ëœë¤ ë°°ìœ¨ ì ìš©
                    let gatlingGambleMultiplier = 1;
                    // ì €ì¥ëœ ê²Œí‹€ë§ ê°ë„ ì‚¬ìš© (ë°œì‚¬ ì‹œì‘ ì‹œ ë°©í–¥ ê³ ì •)
                    let gatlingBaseAngle = player.gatlingAngle || player.angle;
                    if (player.hasGamble) {
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„
                        gatlingBaseAngle = (player.gatlingAngle || player.angle) + randomAngle;
                        gatlingGambleMultiplier = 1 + Math.random(); // 1~2ë°°
                    }
                    
                    if (player.hasScatter) {
                        // ê²Œí‹€ë§ + ë¹„ì‚°íƒ„: ê° ë°œì‚¬ë¥¼ ë¹„ì‚°íƒ„ìœ¼ë¡œ ë¶„ì‚°
                        const scatterAngles = [-4, -2, 0, 2];
                        scatterAngles.forEach(angleDeg => {
                            const angle = gatlingBaseAngle + (angleDeg * Math.PI / 180);
                            const bullet = new Bullet(
                                player.x + Math.cos(player.gatlingAngle || player.angle) * player.radius,
                                player.y + Math.sin(player.gatlingAngle || player.angle) * player.radius,
                                angle,
                                player,
                                false
                            );
                            // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                            if (player.hasGamble) {
                                bullet.damage = Math.round(bullet.damage * gatlingGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                            }
                            bullet.damage = bullet.damage * 0.25; // ë°ë¯¸ì§€ 0.25ë°°
                            player.bullets.push(bullet);
                        });
                    } else {
                        const bullet = new Bullet(
                            player.x + Math.cos(player.gatlingAngle || player.angle) * player.radius,
                            player.y + Math.sin(player.gatlingAngle || player.angle) * player.radius,
                            gatlingBaseAngle,
                            player,
                            false
                        );
                        // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                        if (player.hasGamble) {
                            bullet.damage = Math.round(bullet.damage * gatlingGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                        }
                        player.bullets.push(bullet);
                    }
                    player.gatlingBullets--;
                    player.gatlingNextShot = now + 100; // 0.1ì´ˆë§ˆë‹¤
                    
                    // ë©€í‹°í”Œë ˆì´ì–´: ê²Œí‹€ë§ ì´ì•Œ ì „ì†¡
                    if (gameState.isMultiplayer && player.bullets.length > 0) {
                        const newBullets = player.bullets.slice(-10);
                        sendShootData(newBullets);
                    }
                    
                    // ê²Œí‹€ë§ ë°œì‚¬ê°€ ëë‚˜ë©´ ìë™ ì¬ì¥ì „
                    if (player.gatlingBullets === 0 && !player.isReloading) {
                        reload(player);
                    }
                }
                if (enemy.hasGatling && enemy.gatlingBullets > 0 && now >= enemy.gatlingNextShot) {
                    // ë„ë°• ì¦ê°•: ê° ë°œì‚¬ë§ˆë‹¤ ëœë¤ ë°°ìœ¨ ì ìš©
                    let gatlingGambleMultiplier = 1;
                    // ì €ì¥ëœ ê²Œí‹€ë§ ê°ë„ ì‚¬ìš© (ë°œì‚¬ ì‹œì‘ ì‹œ ë°©í–¥ ê³ ì •)
                    let gatlingBaseAngle = enemy.gatlingAngle || enemy.angle;
                    if (enemy.hasGamble) {
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„
                        gatlingBaseAngle = (enemy.gatlingAngle || enemy.angle) + randomAngle;
                        gatlingGambleMultiplier = 1 + Math.random(); // 1~2ë°°
                    }
                    
                    if (enemy.hasScatter) {
                        // ê²Œí‹€ë§ + ë¹„ì‚°íƒ„: ê° ë°œì‚¬ë¥¼ ë¹„ì‚°íƒ„ìœ¼ë¡œ ë¶„ì‚°
                        const scatterAngles = [-4, -2, 0, 2];
                        scatterAngles.forEach(angleDeg => {
                            const angle = gatlingBaseAngle + (angleDeg * Math.PI / 180);
                            const bullet = new Bullet(
                                enemy.x + Math.cos(enemy.gatlingAngle || enemy.angle) * enemy.radius,
                                enemy.y + Math.sin(enemy.gatlingAngle || enemy.angle) * enemy.radius,
                                angle,
                                enemy,
                                false
                            );
                            // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                            if (enemy.hasGamble) {
                                bullet.damage = Math.round(bullet.damage * gatlingGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                            }
                            bullet.damage = bullet.damage * 0.25; // ë°ë¯¸ì§€ 0.25ë°°
                            enemy.bullets.push(bullet);
                        });
                    } else {
                        const bullet = new Bullet(
                            enemy.x + Math.cos(enemy.gatlingAngle || enemy.angle) * enemy.radius,
                            enemy.y + Math.sin(enemy.gatlingAngle || enemy.angle) * enemy.radius,
                            gatlingBaseAngle,
                            enemy,
                            false
                        );
                        // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš© (ë‹¤ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ íš¨ê³¼ë¥¼ ê³ ë ¤í•˜ì—¬ ê³±ì…ˆ ì ìš©)
                        if (enemy.hasGamble) {
                            bullet.damage = Math.round(bullet.damage * gatlingGambleMultiplier * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ ë°˜ì˜¬ë¦¼
                        }
                        enemy.bullets.push(bullet);
                    }
                    enemy.gatlingBullets--;
                    enemy.gatlingNextShot = now + 100; // 0.1ì´ˆë§ˆë‹¤
                    
                    // ê²Œí‹€ë§ ë°œì‚¬ê°€ ëë‚˜ë©´ ìë™ ì¬ì¥ì „
                    if (enemy.gatlingBullets === 0 && !enemy.isReloading) {
                        reload(enemy);
                    }
                }

                updatePlayer();
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ AI ì—…ë°ì´íŠ¸
                if (!gameState.isMultiplayer) {
                    updateEnemy();
                }
                
                updateBullets(enemy);
                updateBullets(player);
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì¼ ë•Œ í”Œë ˆì´ì–´ ìƒíƒœ ì „ì†¡
                if (gameState.isMultiplayer) {
                    sendPlayerState();
                }
            }

            draw();
            
            // ë©”ë‰´ í™”ë©´ì´ ì•„ë‹ ë•Œë§Œ UI ì—…ë°ì´íŠ¸
            if (!gameState.isMenu) {
            updateUI();
            }

            requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì‹œì‘ (ë©”ë‰´ì—ì„œ ì‹œì‘)
        gameLoop(0);
    </script>
</body>
</html>
