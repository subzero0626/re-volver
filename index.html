<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¦¬ë³¼ë²„ ë“€ì–¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #0f0f1e;
            color: #fff;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #0f0f1e;
        }


        #augmentModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #e94560;
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        #augmentModal h2 {
            color: #e94560;
            margin-bottom: 20px;
        }

        #augmentViewModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        #augmentViewModal h2 {
            color: #4a9eff;
            margin-bottom: 20px;
        }

        .augment-option {
            background: rgba(233, 69, 96, 0.2);
            border: 2px solid #e94560;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .augment-option:hover {
            background: rgba(233, 69, 96, 0.4);
            transform: scale(1.05);
        }

        .augment-option h4 {
            color: #ffc107;
            margin-bottom: 5px;
        }

        #gameOverModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #ffc107;
            border-radius: 15px;
            padding: 40px;
            z-index: 1001;
            text-align: center;
        }

        #gameOverModal h2 {
            color: #ffc107;
            font-size: 32px;
            margin-bottom: 20px;
        }

        #collectionModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 3000;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
            pointer-events: auto;
        }

        #collectionModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        #controlsModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 3001;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        #controlsModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        #controlsModal .control-item {
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        #controlsModal .control-item h3 {
            color: #4a9eff;
            font-size: 20px;
            margin-bottom: 10px;
        }

        #controlsModal .control-item p {
            color: #ffffff;
            font-size: 16px;
            line-height: 1.6;
            margin: 5px 0;
        }

        #controlsModal .key {
            display: inline-block;
            padding: 5px 10px;
            background: rgba(74, 158, 255, 0.3);
            border: 1px solid #4a9eff;
            border-radius: 5px;
            font-weight: bold;
            margin: 0 5px;
        }

        .collection-item {
            background: rgba(74, 158, 255, 0.1);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            transition: all 0.3s;
        }

        .collection-item.locked {
            background: rgba(100, 100, 100, 0.1);
            border-color: #666;
            filter: grayscale(100%);
            opacity: 0.5;
        }

        .collection-item h4 {
            color: #4a9eff;
            margin-bottom: 8px;
            font-size: 20px;
        }

        .collection-item.locked h4 {
            color: #666;
        }

        .collection-item p {
            color: #ccc;
            margin: 0;
            font-size: 16px;
        }

        .collection-item.locked p {
            color: #888;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s;
        }

        button:hover {
            background: #c7364d;
        }

        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 30, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 40px;
            padding-top: 60px;
            z-index: 2000;
        }

        #mainMenu h1 {
            font-size: 100px;
            color: #e94560;
            margin-bottom: 25px;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            animation: neonFlicker 1.67s ease-in-out;
            animation-fill-mode: forwards;
            opacity: 0;
        }

        @keyframes neonFlicker {
            0% {
                opacity: 0;
                text-shadow: 0 0 5px rgba(233, 69, 96, 0.2);
            }
            20% {
                opacity: 0.3;
                text-shadow: 0 0 10px rgba(233, 69, 96, 0.4);
            }
            40% {
                opacity: 0.1;
                text-shadow: 0 0 5px rgba(233, 69, 96, 0.2);
            }
            60% {
                opacity: 0.6;
                text-shadow: 0 0 18px rgba(233, 69, 96, 0.6);
            }
            80% {
                opacity: 0.3;
                text-shadow: 0 0 10px rgba(233, 69, 96, 0.4);
            }
            100% {
                opacity: 1;
                text-shadow: 0 0 20px rgba(233, 69, 96, 0.5),
                            0 0 40px rgba(233, 69, 96, 0.5),
                            0 0 60px rgba(233, 69, 96, 0.3);
            }
        }

        @keyframes neonFlickerLocked {
            0% {
                opacity: 0;
                text-shadow: 0 0 5px rgba(136, 136, 136, 0.1);
            }
            20% {
                opacity: 0.2;
                text-shadow: 0 0 8px rgba(136, 136, 136, 0.2);
            }
            40% {
                opacity: 0.1;
                text-shadow: 0 0 5px rgba(136, 136, 136, 0.1);
            }
            60% {
                opacity: 0.4;
                text-shadow: 0 0 12px rgba(136, 136, 136, 0.3);
            }
            80% {
                opacity: 0.2;
                text-shadow: 0 0 8px rgba(136, 136, 136, 0.2);
            }
            100% {
                opacity: 0.6;
                text-shadow: 0 0 10px rgba(136, 136, 136, 0.3),
                            0 0 20px rgba(136, 136, 136, 0.2),
                            0 0 30px rgba(136, 136, 136, 0.1);
            }
        }

        #soloPlayText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            margin-left: 12px;
            display: block;
            margin-top: 15px;
        }

        #soloPlayText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #multiPlayText {
            font-size: 42px;
            color: #888;
            cursor: not-allowed;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            opacity: 0.6;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3),
                        0 0 20px rgba(255, 255, 255, 0.2),
                        0 0 30px rgba(255, 255, 255, 0.1);
        }

        #settingsText {
            font-size: 42px;
            color: #888;
            cursor: not-allowed;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            opacity: 0.6;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3),
                        0 0 20px rgba(255, 255, 255, 0.2),
                        0 0 30px rgba(255, 255, 255, 0.1);
        }

        .lock-icon {
            filter: grayscale(100%);
            opacity: 0.6;
            margin-right: 4px;
        }

        .menu-text {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            margin-left: 12px;
            display: block;
            margin-top: 15px;
        }

        .menu-text:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        .menu-button {
            background: rgba(233, 69, 96, 0.3);
            border: 3px solid #e94560;
            color: #fff;
            padding: 20px 50px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            margin: 15px;
            transition: all 0.3s;
            min-width: 250px;
        }

        .menu-button:hover {
            background: rgba(233, 69, 96, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.7);
        }

        .menu-button:active {
            transform: scale(1.05);
        }

        #controlsInfo {
            margin-top: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            text-align: center;
            max-width: 600px;
        }

        #controlsInfo h3 {
            color: #4a9eff;
            margin-bottom: 15px;
        }

        #controlsInfo p {
            margin: 8px 0;
            color: #ccc;
        }


    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="augmentModal">
            <h2>ì¦ê°• ì„ íƒ</h2>
            <p style="margin-bottom: 20px;">íŒ¨ë°°í•˜ì…¨ìŠµë‹ˆë‹¤. ì¦ê°•ì„ ì„ íƒí•˜ì„¸ìš”:</p>
            <div id="enemySelection" style="margin-bottom: 20px; padding: 10px; background: rgba(233, 69, 96, 0.2); border-radius: 5px; display: none;">
                <p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>
            </div>
            <div id="augmentOptions"></div>
        </div>

        <div id="augmentViewModal">
            <h2>ì¦ê°• í™•ì¸</h2>
            <p style="margin-bottom: 20px;">ìŠ¹ë¦¬í•˜ì…¨ìŠµë‹ˆë‹¤! ìƒëŒ€ì˜ ì¦ê°• ì„ íƒì„ í™•ì¸í•˜ì„¸ìš”:</p>
            <div id="opponentSelection" style="margin-bottom: 20px; padding: 10px; background: rgba(233, 69, 96, 0.2); border-radius: 5px;">
                <p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>
            </div>
            <button onclick="closeAugmentViewModal()" style="margin-top: 20px;">í™•ì¸</button>
        </div>

        <div id="gameOverModal">
            <h2 id="gameOverTitle">ê²Œì„ ì¢…ë£Œ</h2>
            <p id="gameOverMessage" style="font-size: 20px; margin-bottom: 20px;"></p>
            <button onclick="restartGame()">ë©”ì¸ë©”ë‰´ë¡œ</button>
        </div>

        <div id="collectionModal">
            <h2>ë„ê°</h2>
            <div id="collectionContent" style="max-height: 70vh; overflow-y: auto; padding: 10px;"></div>
            <button onclick="closeCollectionModal()" style="margin-top: 20px;">ë‹«ê¸°</button>
        </div>

        <div id="controlsModal">
            <h2>ì¡°ì‘ë²•</h2>
            <div class="control-item">
                <h3>ì´ë™</h3>
                <p><span class="key">W</span> ìœ„ë¡œ ì´ë™</p>
                <p><span class="key">S</span> ì•„ë˜ë¡œ ì´ë™</p>
                <p><span class="key">A</span> ì™¼ìª½ìœ¼ë¡œ ì´ë™</p>
                <p><span class="key">D</span> ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™</p>
            </div>
            <div class="control-item">
                <h3>ì¡°ì¤€ ë° ë°œì‚¬</h3>
                <p>ë§ˆìš°ìŠ¤ë¥¼ ì›€ì§ì—¬ ì¡°ì¤€</p>
                <p><span class="key">ë§ˆìš°ìŠ¤ ì™¼ìª½ í´ë¦­</span> ë°œì‚¬</p>
            </div>
            <button onclick="closeControlsModal()" style="margin-top: 20px; padding: 10px 30px; background: #4a9eff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">ë‹«ê¸°</button>
        </div>

        <div id="mainMenu">
            <h1>ë¦¬ë³¼ë²„ ë“€ì–¼</h1>
            <span id="soloPlayText" onclick="startSoloGame()">ì†”ë¡œ í”Œë ˆì´</span>
            <span id="multiPlayText"><span class="lock-icon">ğŸ”’</span>ë©€í‹° í”Œë ˆì´</span>
            <span class="menu-text" id="collectionText" onclick="openCollectionModal()">ë„ê°</span>
            <span id="settingsText"><span class="lock-icon">ğŸ”’</span>ì„¤ì •</span>
            <span class="menu-text" id="controlsText" onclick="openControlsModal()">ì¡°ì‘ë²•</span>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ í™”ë©´ ì „ì²´ë¡œ ì„¤ì •
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ê²Œì„ ìƒíƒœ
        let gameState = {
            round: 1,
            maxRounds: 7, // 7íŒ
            playerWins: 0,
            enemyWins: 0,
            winsNeeded: 4, // 4ì„ ì œ
            gameTime: 180, // 3ë¶„ = 180ì´ˆ
            isGameOver: false,
            isPaused: false,
            isMenu: true, // ë©”ë‰´ í™”ë©´ í‘œì‹œ ì—¬ë¶€
            roundWins: [], // ê° ë¼ìš´ë“œì˜ ìŠ¹ì ê¸°ë¡ ('player' ë˜ëŠ” 'enemy')
            countdown: 3, // ë¼ìš´ë“œ ì‹œì‘ ì¹´ìš´íŠ¸ë‹¤ìš´
            augmentCountdown: 0, // ì¦ê°• ì„ íƒ ì¹´ìš´íŠ¸ë‹¤ìš´ (0ì´ë©´ í‘œì‹œ ì•ˆí•¨)
            showOpponentSelecting: false, // ìƒëŒ€ ì„ íƒ ì¤‘ ë©”ì‹œì§€ í‘œì‹œ ì—¬ë¶€
            shake: {
                intensity: 0,
                duration: 0
            }
        };

        // íŠœí† ë¦¬ì–¼ ìƒíƒœ

        // í”Œë ˆì´ì–´
        const player = {
            x: canvas.width * 0.2,
            y: canvas.height * 0.5,
            radius: 30, // 1.5ë°° ì¦ê°€ (20 -> 30)
            speed: 3,
            health: 5,
            displayHealth: 5, // í‘œì‹œë˜ëŠ” ì²´ë ¥ (ì• ë‹ˆë©”ì´ì…˜ìš©)
            maxHealth: 5,
            ammo: 6,
            maxAmmo: 6,
            reloadTime: 3000, // 3ì´ˆ
            isReloading: false,
            reloadStartTime: 0, // ì¬ì¥ì „ ì‹œì‘ ì‹œê°„
            angle: 0,
            color: '#4a9eff',
            bullets: [],
            lastShot: 0,
            shootCooldown: 1000, // 1ì´ˆë¡œ ê³ ì •
            damage: 1, // ê¸°ë³¸ ë°ë¯¸ì§€
            augmentations: [],
            // ì¦ê°• ê´€ë ¨ ìƒíƒœ
            bulletSpeedMultiplier: 1,
            bulletSizeMultiplier: 1, // íƒ„í™˜ í¬ê¸° ë°°ìœ¨
            hasCritical: false,
            hasDoubleShot: false,
            hasDodge: false,
            hasRevive: false,
            hasRevived: false, // ë¶€í™œ ì‚¬ìš© ì—¬ë¶€ (1ë²ˆë§Œ ë¶€í™œ)
            hasDeepWound: false,
            hasOneShotOneKill: false,
            hasPoisonBullet: false,
            hasReloadHeal: false,
            hasSurvivalInstinct: false, // ìƒì¡´ë³¸ëŠ¥
            hasLastBullet: false, // ë¹„ì¥ì˜ í•œë°œ
            hasRecoveryContract: false, // íšŒë³µê³„ì•½
            hasRecoveryContractUsed: false, // íšŒë³µê³„ì•½ ì‚¬ìš© ì—¬ë¶€ (ë¼ìš´ë“œë‹¹ í•œë²ˆ)
            hasFocusedFire: false, // ì§‘ì¤‘ ì‚¬ê²©
            hasShotgun: false, // ìƒ·ê±´
            hasRagged: false, // ë‹¤ë‹¤ìµì„ 
            hasGhost: false, // ìœ ë ¹
            hasFortify: false, // ê±°ì í™•ë³´
            isFortified: false, // ê±°ì  í™•ë³´ ìƒíƒœ
            fortifyStartTime: 0, // ê±°ì  í™•ë³´ ì‹œì‘ ì‹œê°„
            lastPosition: { x: 0, y: 0 }, // ë§ˆì§€ë§‰ ìœ„ì¹˜
            stationaryTime: 0, // ì •ì§€í•œ ì‹œê°„
            hasOverheat: false, // ê³¼ì—´
            overheatHitCount: 0, // ì—°ì† íˆíŠ¸ ì¹´ìš´íŠ¸
            lastHitTime: 0, // ë§ˆì§€ë§‰ íˆíŠ¸ ì‹œê°„
            hasGamble: false, // ë„ë°•
            hasWeaken: false, // ì•½í™”
            isWeakened: false, // ì•½í™” ìƒíƒœ
            weakenEndTime: 0, // ì•½í™” ì¢…ë£Œ ì‹œê°„
            hasDamageBoost: false, // ë°ë¯¸ì§€ 1.2ë°°
            hasLightning: false, // ë²ˆê°œ
            isStunned: false, // ê¸°ì ˆ ìƒíƒœ
            stunEndTime: 0, // ê¸°ì ˆ ì¢…ë£Œ ì‹œê°„
            hasShield: false, // ë°©ì–´ë§‰
            shieldReady: false, // ë°©ì–´ë§‰ ì¤€ë¹„ë¨
            shieldCooldown: 0, // ë°©ì–´ë§‰ ì¿¨íƒ€ì„
            hasRegeneration: false, // ì¬ìƒ
            lastRegenTime: 0, // ë§ˆì§€ë§‰ íšŒë³µ ì‹œê°„
            isVulnerable: false, // ì·¨ì•½ ìƒíƒœ
            vulnerabilityUsed: false, // ì·¨ì•½ ì‚¬ìš© ì—¬ë¶€
            poisonEffects: [], // ë… íš¨ê³¼ ë°°ì—´ {target, startTime, duration, damagePerSecond}
            isDodging: false,
            dodgeStartTime: 0, // êµ¬ë¥´ê¸° ì‹œì‘ ì‹œê°„
            dodgeEndTime: 0,
            dodgeStartX: 0,
            dodgeStartY: 0,
            dodgeTargetX: 0,
            dodgeTargetY: 0,
            dodgeTrail: [], // êµ¬ë¥´ê¸° ì”ìƒ ìœ„ì¹˜ ë°°ì—´
            lastDodgeTime: 0, // ë§ˆì§€ë§‰ êµ¬ë¥´ê¸° ì‹œê°„ (ì¿¨íƒ€ì„ìš©)
            isReviving: false,
            reviveTime: 0,
            isInvincible: false,
            invincibleEndTime: 0,
            slowEndTime: 0,
            damageNumbers: [] // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œìš©
        };

        // ì  (AI)
        const enemy = {
            x: canvas.width * 0.8,
            y: canvas.height * 0.5,
            radius: 30, // 1.5ë°° ì¦ê°€ (20 -> 30)
            speed: 2.5,
            health: 5,
            displayHealth: 5, // í‘œì‹œë˜ëŠ” ì²´ë ¥ (ì• ë‹ˆë©”ì´ì…˜ìš©)
            maxHealth: 5,
            ammo: 6,
            maxAmmo: 6,
            reloadTime: 3000, // 3ì´ˆ
            isReloading: false,
            reloadStartTime: 0, // ì¬ì¥ì „ ì‹œì‘ ì‹œê°„
            angle: Math.PI,
            color: '#e94560',
            bullets: [],
            lastShot: 0,
            shootCooldown: 1000, // 1ì´ˆë¡œ ê³ ì •
            damage: 1, // ê¸°ë³¸ ë°ë¯¸ì§€
            augmentations: [],
            // ì¦ê°• ê´€ë ¨ ìƒíƒœ
            bulletSpeedMultiplier: 1,
            bulletSizeMultiplier: 1, // íƒ„í™˜ í¬ê¸° ë°°ìœ¨
            hasCritical: false,
            hasDoubleShot: false,
            hasDodge: false,
            hasRevive: false,
            hasRevived: false, // ë¶€í™œ ì‚¬ìš© ì—¬ë¶€ (1ë²ˆë§Œ ë¶€í™œ)
            hasDeepWound: false,
            hasOneShotOneKill: false,
            hasPoisonBullet: false,
            hasReloadHeal: false,
            hasSurvivalInstinct: false, // ìƒì¡´ë³¸ëŠ¥
            hasLastBullet: false, // ë¹„ì¥ì˜ í•œë°œ
            hasRecoveryContract: false, // íšŒë³µê³„ì•½
            hasRecoveryContractUsed: false, // íšŒë³µê³„ì•½ ì‚¬ìš© ì—¬ë¶€ (ë¼ìš´ë“œë‹¹ í•œë²ˆ)
            hasFocusedFire: false, // ì§‘ì¤‘ ì‚¬ê²©
            hasShotgun: false, // ìƒ·ê±´
            hasRagged: false, // ë‹¤ë‹¤ìµì„ 
            hasGhost: false, // ìœ ë ¹
            hasFortify: false, // ê±°ì í™•ë³´
            isFortified: false, // ê±°ì  í™•ë³´ ìƒíƒœ
            fortifyStartTime: 0, // ê±°ì  í™•ë³´ ì‹œì‘ ì‹œê°„
            lastPosition: { x: 0, y: 0 }, // ë§ˆì§€ë§‰ ìœ„ì¹˜
            stationaryTime: 0, // ì •ì§€í•œ ì‹œê°„
            hasOverheat: false, // ê³¼ì—´
            overheatHitCount: 0, // ì—°ì† íˆíŠ¸ ì¹´ìš´íŠ¸
            lastHitTime: 0, // ë§ˆì§€ë§‰ íˆíŠ¸ ì‹œê°„
            hasGamble: false, // ë„ë°•
            hasWeaken: false, // ì•½í™”
            isWeakened: false, // ì•½í™” ìƒíƒœ
            weakenEndTime: 0, // ì•½í™” ì¢…ë£Œ ì‹œê°„
            hasDamageBoost: false, // ë°ë¯¸ì§€ 1.2ë°°
            hasLightning: false, // ë²ˆê°œ
            isStunned: false, // ê¸°ì ˆ ìƒíƒœ
            stunEndTime: 0, // ê¸°ì ˆ ì¢…ë£Œ ì‹œê°„
            hasShield: false, // ë°©ì–´ë§‰
            shieldReady: false, // ë°©ì–´ë§‰ ì¤€ë¹„ë¨
            shieldCooldown: 0, // ë°©ì–´ë§‰ ì¿¨íƒ€ì„
            hasRegeneration: false, // ì¬ìƒ
            lastRegenTime: 0, // ë§ˆì§€ë§‰ íšŒë³µ ì‹œê°„
            hasEvasiveManeuver: false, // íšŒí”¼ê¸°ë™
            hasCombatExperience: false, // ì „íˆ¬ ê²½í—˜
            combatExperienceRounds: 0, // ì „íˆ¬ ê²½í—˜ ë¼ìš´ë“œ ìˆ˜
            hasHallucination: false, // í™˜ê°
            hasTasteOfBlood: false, // í”¼ì˜ ë§›
            hasCannon: false, // ëŒ€í¬
            hasTimeBarrier: false, // ì‹œê°„ì¥ë§‰
            timeBarrierRadius: 150, // ì‹œê°„ì¥ë§‰ ë°˜ì§€ë¦„
            hasBouncyBullet: false, // í†µí†µíƒ„
            isVulnerable: false, // ì·¨ì•½ ìƒíƒœ
            vulnerabilityUsed: false, // ì·¨ì•½ ì‚¬ìš© ì—¬ë¶€
            poisonEffects: [], // ë… íš¨ê³¼ ë°°ì—´ {target, startTime, duration, damagePerSecond}
            isDodging: false,
            dodgeStartTime: 0, // êµ¬ë¥´ê¸° ì‹œì‘ ì‹œê°„
            dodgeEndTime: 0,
            dodgeStartX: 0,
            dodgeStartY: 0,
            dodgeTargetX: 0,
            dodgeTargetY: 0,
            dodgeTrail: [], // êµ¬ë¥´ê¸° ì”ìƒ ìœ„ì¹˜ ë°°ì—´
            lastDodgeTime: 0, // ë§ˆì§€ë§‰ êµ¬ë¥´ê¸° ì‹œê°„ (ì¿¨íƒ€ì„ìš©)
            isReviving: false,
            reviveTime: 0,
            isInvincible: false,
            invincibleEndTime: 0,
            slowEndTime: 0,
            aiTimer: 0,
            aiDirection: Math.random() * Math.PI * 2,
            usePrediction: false, // ë°œì‚¬ íŒ¨í„´: false=í˜„ì¬ ìœ„ì¹˜, true=ì˜ˆì¸¡ ìœ„ì¹˜
            lastPlayerX: 0, // í”Œë ˆì´ì–´ ì´ì „ ìœ„ì¹˜ (ì´ë™ ë°©í–¥ ê³„ì‚°ìš©)
            lastPlayerY: 0,
            playerVelocity: { x: 0, y: 0 }, // í”Œë ˆì´ì–´ ì´ë™ ì†ë„
            lastPlayerBulletCount: 0, // í”Œë ˆì´ì–´ ì´ì•Œ ê°œìˆ˜ ì¶”ì  (ë°œì‚¬ ê°ì§€ìš©)
            bulletDodgeTargetY: 0, // ì´ì•Œ íšŒí”¼ ëª©í‘œ Y ìœ„ì¹˜
            isDodgingBullet: false, // ì´ì•Œ íšŒí”¼ ì¤‘ì¸ì§€
            damageNumbers: [] // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œìš©
        };


        // ì¦ê°• ëª©ë¡
        const augmentations = [
            { 
                id: 'health', 
                name: 'ìµœëŒ€ì²´ë ¥ +2', 
                description: 'ìµœëŒ€ ì²´ë ¥ +2', 
                effect: (character) => { 
                    character.maxHealth += 2; 
                    character.health += 2; 
                } 
            },
            { 
                id: 'speed', 
                name: 'ì´ë™ì†ë„ +25%', 
                description: 'ì´ë™ ì†ë„ +25%', 
                effect: (character) => { 
                    character.speed *= 1.25; 
                } 
            },
            { 
                id: 'bulletSpeed', 
                name: 'ì´ì•Œ ì†ë„ +25%', 
                description: 'ì´ì•Œ ì†ë„ +25%', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 1.25; 
                } 
            },
            { 
                id: 'ammo', 
                name: 'íƒ„ì•½ +1', 
                description: 'ìµœëŒ€ íƒ„ì•½ +1', 
                effect: (character) => { 
                    character.maxAmmo += 1; 
                    character.ammo += 1; 
                } 
            },
            { 
                id: 'fireRate', 
                name: 'ë°œì‚¬ì†ë„ -25%', 
                description: 'ë°œì‚¬ì†ë„ -25%', 
                effect: (character) => { 
                    character.shootCooldown *= 0.75; 
                } 
            },
            { 
                id: 'reload', 
                name: 'ì¬ì¥ì „ ì†ë„ -1.5ì´ˆ', 
                description: 'ì¬ì¥ì „ ì‹œê°„ -1.5ì´ˆ', 
                effect: (character) => { 
                    character.reloadTime = Math.max(1000, character.reloadTime - 1500); 
                } 
            },
            { 
                id: 'critical', 
                name: 'í¬ë¦¬í‹°ì»¬', 
                description: 'í”¼ê²© ì‹œ 25% í™•ë¥ ë¡œ ë°ë¯¸ì§€ 2ë°°', 
                effect: (character) => { 
                    character.hasCritical = true; 
                } 
            },
            { 
                id: 'doubleShot', 
                name: 'ë”ë¸”ìƒ·', 
                description: 'ë°œì‚¬ ì‹œ 25% í™•ë¥ ë¡œ ì¶”ê°€ ë°œì‚¬ (íƒ„ì•½ ì†Œëª¨X)', 
                effect: (character) => { 
                    character.hasDoubleShot = true; 
                } 
            },
            { 
                id: 'dodge', 
                name: 'êµ¬ë¥´ê¸°', 
                description: 'ìš°í´ë¦­ìœ¼ë¡œ êµ¬ë¥´ê¸° (êµ¬ë¥´ëŠ” ë™ì•ˆ ë¬´ì )', 
                effect: (character) => { 
                    character.hasDodge = true; 
                } 
            },
            { 
                id: 'revive', 
                name: 'ë¶€í™œ', 
                description: 'ì£½ì—ˆì„ ë•Œ 2ì´ˆ í›„ ì²´ë ¥ 1ë¡œ ë¶€í™œ (1ì´ˆ ë¬´ì )', 
                effect: (character) => { 
                    character.hasRevive = true; 
                } 
            },
            { 
                id: 'deepWound', 
                name: 'ê¹Šì€ ìƒì²˜', 
                description: 'í”¼ê²© ì‹œ ìƒëŒ€ ì´ë™ì†ë„ -25% (0.5ì´ˆ)', 
                effect: (character) => { 
                    character.hasDeepWound = true; 
                } 
            },
            { 
                id: 'giant', 
                name: 'ê±°ëŒ€í™”', 
                description: 'ì²´ë ¥ +3, ì´ë™ì†ë„ -25%', 
                effect: (character) => { 
                    character.maxHealth += 3; 
                    character.health += 3; 
                    character.speed *= 0.75; 
                } 
            },
            { 
                id: 'sniper', 
                name: 'ì €ê²©ìˆ˜', 
                description: 'ì´ì•Œ ì†ë„ +75%, ìµœëŒ€ íƒ„ì•½ -3', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 1.75; 
                    character.maxAmmo = Math.max(1, character.maxAmmo - 3); 
                    character.ammo = Math.min(character.ammo, character.maxAmmo); 
                } 
            },
            { 
                id: 'oneShotOneKill', 
                name: 'ì›ìƒ·ì›í‚¬', 
                description: 'ìµœëŒ€ íƒ„ì•½ 1ê°œë¡œ ê³ ì •, ì´ì•Œ ë°ë¯¸ì§€ *3', 
                effect: (character) => { 
                    character.maxAmmo = 1; 
                    character.ammo = Math.min(character.ammo, 1); 
                    character.damage = (character.damage || 1) * 3; // ì´ì•Œ ë°ë¯¸ì§€ *3
                    character.hasOneShotOneKill = true; 
                } 
            },
            { 
                id: 'poisonBullet', 
                name: 'ë… íƒ„í™˜', 
                description: 'ì  í”¼ê²©ì‹œ 0.2ë°ë¯¸ì§€ë¥¼ 1ì´ˆê°„ê²©ìœ¼ë¡œ 2ë²ˆ ì¶”ê°€í”¼í•´', 
                effect: (character) => { 
                    character.hasPoisonBullet = true; 
                } 
            },
            { 
                id: 'reloadHeal', 
                name: 'ì¬ì¥ì „ íšŒë³µ', 
                description: 'ì¬ì¥ì „ ì‹œ ì²´ë ¥ 1íšŒë³µ', 
                effect: (character) => { 
                    character.hasReloadHeal = true; 
                } 
            },
            { 
                id: 'bigBullet', 
                name: 'í° íƒ„í™˜', 
                description: 'íƒ„í™˜ í¬ê¸° +50%', 
                effect: (character) => { 
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 1.5; 
                } 
            },
            { 
                id: 'survivalInstinct', 
                name: 'ìƒì¡´ë³¸ëŠ¥', 
                description: 'ì²´ë ¥ì´ 1ì¼ ë•Œ ì´ë™ì†ë„ +50%', 
                effect: (character) => { 
                    character.hasSurvivalInstinct = true; 
                } 
            },
            { 
                id: 'lastBullet', 
                name: 'ë¹„ì¥ì˜ í•œë°œ', 
                description: 'ë§ˆì§€ë§‰ íƒ„í™˜ì˜ ë°ë¯¸ì§€ +1.5', 
                effect: (character) => { 
                    character.hasLastBullet = true; 
                } 
            },
            { 
                id: 'recoveryContract', 
                name: 'íšŒë³µê³„ì•½', 
                description: 'ì²´ë ¥ì´ 1ì¼ ë•Œ ì²´ë ¥ 2íšŒë³µ (ë¼ìš´ë“œë‹¹ í•œë²ˆ)', 
                effect: (character) => { 
                    character.hasRecoveryContract = true; 
                } 
            },
            { 
                id: 'focusedFire', 
                name: 'ì§‘ì¤‘ ì‚¬ê²©', 
                description: 'í”¼ê²©ì‹œ 50% í™•ë¥ ë¡œ ìƒëŒ€ì—ê²Œ ì·¨ì•½ ë¶€ì—¬ (ë‹¤ìŒ ë°ë¯¸ì§€ *1.5ë°°)', 
                effect: (character) => { 
                    character.hasFocusedFire = true; 
                } 
            },
            { 
                id: 'shotgun', 
                name: 'ìƒ·ê±´', 
                description: 'ëª¨ë“  íƒ„ì•½ì„ Â±20ë„ ë²”ìœ„ì—ì„œ í•œë²ˆì— ë°œì‚¬', 
                effect: (character) => { 
                    character.hasShotgun = true; 
                } 
            },
            { 
                id: 'ragged', 
                name: 'ë‹¤ë‹¤ìµì„ ', 
                description: 'ìµœëŒ€ íƒ„ì•½ +3, ë°œì‚¬ì†ë„ -50%, ì´ì•Œ ë°ë¯¸ì§€ *0.5', 
                effect: (character) => { 
                    character.maxAmmo += 3; 
                    character.ammo += 3; 
                    character.shootCooldown *= 0.5; // ë°œì‚¬ì†ë„ -50% (ì¿¨íƒ€ì„ ì ˆë°˜)
                    character.damage = (character.damage || 1) * 0.5; // ì´ì•Œ ë°ë¯¸ì§€ *0.5
                    character.hasRagged = true; 
                } 
            },
            { 
                id: 'ghost', 
                name: 'ìœ ë ¹', 
                description: 'ìƒëŒ€ì˜ ê³µê²©ì„ 25% í™•ë¥ ë¡œ ë¬´ì‹œ', 
                effect: (character) => { 
                    character.hasGhost = true; 
                } 
            },
            { 
                id: 'fortify', 
                name: 'ê±°ì í™•ë³´', 
                description: '3ì´ˆë™ì•ˆ ê°€ë§Œíˆ ì„œìˆì„ ê²½ìš° ë‹¤ì‹œ ì›€ì§ì¼ë•Œê¹Œì§€ ë°›ëŠ” ë°ë¯¸ì§€ *0.5', 
                effect: (character) => { 
                    character.hasFortify = true; 
                    character.fortifyStartTime = 0; // ê±°ì  í™•ë³´ ì‹œì‘ ì‹œê°„
                    character.isFortified = false; // ê±°ì  í™•ë³´ ìƒíƒœ
                    character.lastPosition = { x: character.x, y: character.y }; // ë§ˆì§€ë§‰ ìœ„ì¹˜
                    character.stationaryTime = 0; // ì •ì§€í•œ ì‹œê°„
                } 
            },
            { 
                id: 'overheat', 
                name: 'ê³¼ì—´', 
                description: 'ìƒëŒ€ì—ê²Œ ì´ì•Œì„ ì—°ì†ìœ¼ë¡œ ë§ì¶œ ì‹œ ë§ì¶œë•Œë§ˆë‹¤ ë°ë¯¸ì§€ 0.5ë°°ì”© ìƒìŠ¹', 
                effect: (character) => { 
                    character.hasOverheat = true; 
                    character.overheatHitCount = 0; // ì—°ì† íˆíŠ¸ ì¹´ìš´íŠ¸
                    character.lastHitTime = 0; // ë§ˆì§€ë§‰ íˆíŠ¸ ì‹œê°„
                } 
            },
            { 
                id: 'gamble', 
                name: 'ë„ë°•', 
                description: 'ì´ì•Œì´ Â±10ë„ ë²”ìœ„ì—ì„œ ëœë¤í•˜ê²Œ ë‚˜ê°€ì§€ë§Œ ë°ë¯¸ì§€ëŠ” 1~2ë°° ì‚¬ì´ë¡œ ëœë¤', 
                effect: (character) => { 
                    character.hasGamble = true; 
                } 
            },
            { 
                id: 'weaken', 
                name: 'ì•½í™”', 
                description: 'ìƒëŒ€ì—ê²Œ ì´ì•Œì„ ë§ì¶œ ì‹œ 3ì´ˆë™ì•ˆ ìƒëŒ€ ë°ë¯¸ì§€ -0.25', 
                effect: (character) => { 
                    character.hasWeaken = true; 
                } 
            },
            { 
                id: 'damageBoost', 
                name: 'ë°ë¯¸ì§€ 1.2ë°°', 
                description: 'ì´ì•Œ ë°ë¯¸ì§€ *1.2', 
                effect: (character) => { 
                    character.damage = (character.damage || 1) * 1.2; 
                    character.hasDamageBoost = true; 
                } 
            },
            { 
                id: 'lightning', 
                name: 'ë²ˆê°œ', 
                description: 'ì ì—ê²Œ ì´ì•Œì„ ë§ì¶œ ì‹œ 25% í™•ë¥ ë¡œ ì  0.75ì´ˆ ê¸°ì ˆ', 
                effect: (character) => { 
                    character.hasLightning = true; 
                } 
            },
            { 
                id: 'shield', 
                name: 'ë°©ì–´ë§‰', 
                description: 'ë°›ëŠ” ë°ë¯¸ì§€ 1íšŒ ë¬´ì‹œ (ì¿¨íƒ€ì„ 5ì´ˆ)', 
                effect: (character) => { 
                    character.hasShield = true; 
                    character.shieldReady = true; // ë°©ì–´ë§‰ ì¤€ë¹„ë¨
                    character.shieldCooldown = 0; // ì¿¨íƒ€ì„
                } 
            },
            { 
                id: 'regeneration', 
                name: 'ì¬ìƒ', 
                description: '1ì´ˆë§ˆë‹¤ ì²´ë ¥ 0.1 íšŒë³µ', 
                effect: (character) => { 
                    character.hasRegeneration = true; 
                    character.lastRegenTime = 0; // ë§ˆì§€ë§‰ íšŒë³µ ì‹œê°„
                } 
            },
            { 
                id: 'evasiveManeuver', 
                name: 'íšŒí”¼ê¸°ë™', 
                description: 'ì¬ì¥ì „ ì¤‘ ì´ë™ì†ë„ +50%', 
                effect: (character) => { 
                    character.hasEvasiveManeuver = true; 
                } 
            },
            { 
                id: 'combatExperience', 
                name: 'ì „íˆ¬ ê²½í—˜', 
                description: 'ì§„ ë¼ìš´ë“œ ìˆ˜ë§ˆë‹¤ ìµœëŒ€ì²´ë ¥ 0.5, ë°ë¯¸ì§€ 0.1 ì¦ê°€', 
                effect: (character) => { 
                    character.hasCombatExperience = true; 
                    character.combatExperienceRounds = 0; // í˜„ì¬ ë¼ìš´ë“œ ìˆ˜
                } 
            },
            { 
                id: 'hallucination', 
                name: 'í™˜ê°', 
                description: 'ì´ì•Œì´ ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.1ì´ˆë§ˆë‹¤ ì†ë„ê°€ 0.75ë°°~2ë°° ì‚¬ì´ë¡œ ëœë¤ìœ¼ë¡œ ì¡°ì •ë¨', 
                effect: (character) => { 
                    character.hasHallucination = true; 
                } 
            },
            { 
                id: 'tasteOfBlood', 
                name: 'í”¼ì˜ ë§›', 
                description: 'ì ì—ê²Œ ì…íŒ í”¼í•´ì˜ 20%ë§Œí¼ íšŒë³µ', 
                effect: (character) => { 
                    character.hasTasteOfBlood = true; 
                } 
            },
            { 
                id: 'cannon', 
                name: 'ëŒ€í¬', 
                description: 'ì´ì•Œì˜ ì†ë„ -50% ëŒ€ì‹  ì´ì•Œì˜ í¬ê¸° +200%', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 0.5; 
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 3; // +200% = 3ë°°
                    character.hasCannon = true; 
                } 
            },
            { 
                id: 'timeBarrier', 
                name: 'ì‹œê°„ì¥ë§‰', 
                description: 'ìì‹  ì£¼ìœ„ì˜ ë°˜ì§€ë¦„ 150pxì§œë¦¬ ì› ìƒì„±, ì´ ì› ì•ˆì— ë“¤ì–´ì˜¤ëŠ” ì ì˜ ì´ì•Œ 35% ë‘”í™”', 
                effect: (character) => { 
                    character.hasTimeBarrier = true; 
                    character.timeBarrierRadius = 150; 
                } 
            },
            { 
                id: 'bouncyBullet', 
                name: 'í†µí†µíƒ„', 
                description: 'ì´ì•Œì´ ë²½ì— ë§ìœ¼ë©´ 1íšŒ íŠ•ê¹€ (íŠ•ê¸°ëŠ” ë°©í–¥ì€ ë§ì€ ë°©í–¥ì˜ ë°˜ëŒ€ë°©í–¥ì—ì„œ Â±25ë„)', 
                effect: (character) => { 
                    character.hasBouncyBullet = true; 
                } 
            },
        ];

        // í‚¤ ì…ë ¥ ìƒíƒœ
        const keys = {};
        let mouse = { x: 0, y: 0 };
        let hoveredAugment = null; // ë§ˆìš°ìŠ¤ í˜¸ë²„ëœ ì¦ê°• ì •ë³´

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        canvas.addEventListener('click', (e) => {
            if (!gameState.isPaused && !gameState.isGameOver && !player.isDodging) {
                shoot(player);
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // ìš°í´ë¦­ ë©”ë‰´ ë°©ì§€
            
            // í”Œë ˆì´ì–´ êµ¬ë¥´ê¸° (ìš°í´ë¦­)
                if (player.hasDodge && !player.isDodging && !gameState.isPaused && !gameState.isGameOver) {
                    dodge(player);
            }
        });

        // ì´ì•Œ í´ë˜ìŠ¤
        class Bullet {
            constructor(x, y, angle, owner, isFreeShot = false) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                const baseSpeed = 20;
                const speedMultiplier = owner.bulletSpeedMultiplier || 1;
                this.speed = baseSpeed * speedMultiplier;
                this.baseSpeed = this.speed; // ì›ë˜ ì†ë„ ì €ì¥ (ì‹œê°„ì¥ë§‰ìš©)
                // í™˜ê°: ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.1ì´ˆë§ˆë‹¤ ì†ë„ ë³€ê²½ì„ ìœ„í•œ ë³€ìˆ˜
                if (owner.hasHallucination) {
                    this.hallucinationLastChange = Date.now(); // ë§ˆì§€ë§‰ ì†ë„ ë³€ê²½ ì‹œê°„
                    // ì´ˆê¸° ì†ë„ë„ ëœë¤ìœ¼ë¡œ ì„¤ì • (0.75ë°°~2ë°°)
                    const randomMultiplier = 0.75 + Math.random() * 1.25; // 0.75 ~ 2.0
                    this.hallucinationSpeed = this.baseSpeed * randomMultiplier;
                    this.speed = this.hallucinationSpeed; // ì´ˆê¸° ì†ë„ëŠ” í™˜ê° ì†ë„ë¡œ
                }
                this.isInTimeBarrier = false; // ì‹œê°„ì¥ë§‰ ì•ˆì— ìˆëŠ”ì§€ ì—¬ë¶€
                const sizeMultiplier = owner.bulletSizeMultiplier || 1;
                this.radius = 9 * sizeMultiplier;
                this.owner = owner;
                this.damage = owner.damage || 1;
                // ë¹„ì¥ì˜ í•œë°œ: ë§ˆì§€ë§‰ íƒ„í™˜ì˜ ë°ë¯¸ì§€ +1.5
                if (owner.hasLastBullet && owner.ammo === 1) {
                    this.damage += 1.5;
                }
                // ì•½í™” ìƒíƒœ: ë°ë¯¸ì§€ -0.25 (ë„íŠ¸ë”œ ì œì™¸)
                if (owner.isWeakened) {
                    this.damage = Math.max(0.25, this.damage - 0.25);
                }
                this.isFreeShot = isFreeShot; // íƒ„ì•½ ì†Œëª¨ ì—†ëŠ” ì´ì•Œ (ë”ë¸”ìƒ·ìš©)
                this.hasPoison = owner.hasPoisonBullet || false; // ë… íƒ„í™˜ ì—¬ë¶€
                this.hasBouncy = owner.hasBouncyBullet || false; // í†µí†µíƒ„ ì—¬ë¶€
                this.bounceCount = 0; // íŠ•ê¹€ íšŸìˆ˜
                this.lastX = x; // ì´ì „ ìœ„ì¹˜ (ë²½ ì¶©ëŒ ê°ì§€ìš©)
                this.lastY = y;
            }

            update() {
                // í™˜ê°: ë‚ ì•„ê°€ëŠ” ë„ì¤‘ì— 0.1ì´ˆë§ˆë‹¤ ì´ì•Œ ì†ë„ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³€ê²½
                if (this.owner && this.owner.hasHallucination && this.hallucinationLastChange !== undefined) {
                    const now = Date.now();
                    if (now - this.hallucinationLastChange >= 100) { // 0.1ì´ˆ = 100ms
                        // 0.75ë°°~2ë°° ì‚¬ì´ë¡œ ëœë¤ ì¡°ì •
                        const randomMultiplier = 0.75 + Math.random() * 1.25; // 0.75 ~ 2.0
                        this.hallucinationSpeed = this.baseSpeed * randomMultiplier;
                        this.hallucinationLastChange = now;
                    }
                    // í™˜ê° ì†ë„ ì‚¬ìš© (ì‹œê°„ì¥ë§‰ì´ ì ìš©ë˜ë©´ ê·¸ê²Œ ìš°ì„ ì´ë¯€ë¡œ ì‹œê°„ì¥ë§‰ ë¡œì§ì—ì„œ ì²˜ë¦¬)
                    // ì‹œê°„ì¥ë§‰ì´ ì—†ê±°ë‚˜ ë°–ì— ìˆì„ ë•Œë§Œ í™˜ê° ì†ë„ ì ìš©
                    if (!this.isInTimeBarrier) {
                        this.speed = this.hallucinationSpeed;
                    }
                }
                
                // í†µí†µíƒ„: ë²½ì— ë§ìœ¼ë©´ íŠ•ê¹€
                if (this.hasBouncy && this.bounceCount < 1) {
                    const nextX = this.x + Math.cos(this.angle) * this.speed;
                    const nextY = this.y + Math.sin(this.angle) * this.speed;
                    
                    // ë²½ ì¶©ëŒ ê°ì§€
                    let hitWall = false;
                    let newAngle = this.angle;
                    
                    // ì™¼ìª½ ë²½ ë˜ëŠ” ì˜¤ë¥¸ìª½ ë²½ì— ì¶©ëŒ
                    if (nextX - this.radius < 0 || nextX + this.radius > canvas.width) {
                        hitWall = true;
                        // ë°˜ëŒ€ë°©í–¥ì—ì„œ Â±25ë„ (ìˆ˜í‰ ë°˜ì‚¬)
                        const reflectAngle = Math.PI - this.angle; // ë°˜ì‚¬ê°
                        const randomOffset = (Math.random() - 0.5) * 50 * Math.PI / 180; // Â±25ë„
                        newAngle = reflectAngle + randomOffset;
                    }
                    // ìœ„ìª½ ë²½ ë˜ëŠ” ì•„ë˜ìª½ ë²½ì— ì¶©ëŒ
                    if (nextY - this.radius < 0 || nextY + this.radius > canvas.height) {
                        hitWall = true;
                        // ë°˜ëŒ€ë°©í–¥ì—ì„œ Â±25ë„ (ìˆ˜ì§ ë°˜ì‚¬)
                        const reflectAngle = -this.angle; // ë°˜ì‚¬ê°
                        const randomOffset = (Math.random() - 0.5) * 50 * Math.PI / 180; // Â±25ë„
                        newAngle = reflectAngle + randomOffset;
                    }
                    
                    if (hitWall) {
                        this.bounceCount++;
                        this.angle = newAngle;
                        // ë²½ ê²½ê³„ë¡œ ìœ„ì¹˜ ì¡°ì •
                        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
                    } else {
                        this.x = nextX;
                        this.y = nextY;
                    }
                } else {
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // ì§ì‚¬ê°í˜• ì´ì•Œ ê·¸ë¦¬ê¸°
                // ë… íƒ„í™˜ì´ë©´ ì–´ë‘ìš´ ì´ˆë¡ìƒ‰, ì•„ë‹ˆë©´ í•˜ì–€ìƒ‰
                ctx.fillStyle = this.hasPoison ? '#006600' : '#ffffff';
                const sizeMultiplier = this.owner.bulletSizeMultiplier || 1;
                const bulletWidth = 24 * sizeMultiplier; // ì´ì•Œ ë„ˆë¹„
                const bulletHeight = 9 * sizeMultiplier; // ì´ì•Œ ë†’ì´
                ctx.fillRect(-bulletWidth / 2, -bulletHeight / 2, bulletWidth, bulletHeight);
                
                ctx.restore();
            }

            isOutOfBounds() {
                return this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height;
            }
        }

        // í™”ë©´ í”ë“¤ë¦¼ í•¨ìˆ˜
        function addScreenShake(intensity, duration) {
            gameState.shake.intensity = intensity;
            gameState.shake.duration = duration;
        }

        // ë°œì‚¬ í•¨ìˆ˜
        function shoot(character) {
            const now = Date.now();
            // ê¸°ì ˆ ìƒíƒœë©´ ë°œì‚¬ ë¶ˆê°€
            if (character.isStunned) return;
            if (character.ammo > 0 && !character.isReloading && 
                now - character.lastShot > character.shootCooldown) {
                
                // ìƒ·ê±´ ì¦ê°•: ëª¨ë“  íƒ„ì•½ì„ Â±20ë„ ë²”ìœ„ì—ì„œ í•œë²ˆì— ë°œì‚¬
                if (character.hasShotgun) {
                    const currentAmmo = character.ammo;
                    for (let i = 0; i < currentAmmo; i++) {
                        // Â±20ë„ ë²”ìœ„ ë‚´ ëœë¤ ê°ë„
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 40 / 180); // -20ë„ ~ +20ë„
                const bullet = new Bullet(
                    character.x + Math.cos(character.angle) * character.radius,
                    character.y + Math.sin(character.angle) * character.radius,
                            character.angle + randomAngle,
                    character,
                    false
                );
                        character.bullets.push(bullet);
                    }
                    character.ammo = 0; // ëª¨ë“  íƒ„ì•½ ì†Œëª¨
                    character.lastShot = now;
                } else {
                    // ì¼ë°˜ ë°œì‚¬
                    let bulletAngle = character.angle;
                    let bulletDamage = character.damage || 1;
                    
                    // ë„ë°• ì¦ê°•: Â±10ë„ ëœë¤ ê°ë„, ë°ë¯¸ì§€ 1~2ë°° ëœë¤
                    if (character.hasGamble) {
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // Â±10ë„
                        bulletAngle = character.angle + randomAngle;
                        bulletDamage = bulletDamage * (1 + Math.random()); // 1~2ë°°
                        bulletDamage = Math.round(bulletDamage * 10) / 10; // ì†Œìˆ˜ì  1ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
                    }
                    
                    const bullet = new Bullet(
                        character.x + Math.cos(character.angle) * character.radius,
                        character.y + Math.sin(character.angle) * character.radius,
                        bulletAngle,
                        character,
                        false
                    );
                    // ë„ë°• ì¦ê°•: ë°ë¯¸ì§€ ëœë¤ ì ìš©
                    if (character.hasGamble) {
                        bullet.damage = bulletDamage;
                    }
                    character.bullets.push(bullet);
                    character.ammo--;
                    character.lastShot = now;

                // ë”ë¸”ìƒ· (25% í™•ë¥ ë¡œ ë°œì‚¬í•œ ë°©í–¥ì— Â±15ë„ ì‚¬ì´ì— ì¶”ê°€ í•œë°œ ë°œì‚¬)
                if (character.hasDoubleShot && Math.random() < 0.25) {
                    // Â±15ë„ ì‚¬ì´ì˜ ëœë¤ ê°ë„
                    const randomAngle = (Math.random() - 0.5) * (Math.PI * 30 / 180); // -15ë„ ~ +15ë„
                    const doubleBullet = new Bullet(
                        character.x + Math.cos(character.angle) * character.radius,
                        character.y + Math.sin(character.angle) * character.radius,
                        character.angle + randomAngle,
                        character,
                        true // íƒ„ì•½ ì†Œëª¨ ì—†ìŒ
                    );
                    character.bullets.push(doubleBullet);
                    }
                }

                // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼ (í”Œë ˆì´ì–´ ë°œì‚¬ ì‹œì—ë§Œ)
                if (character === player) {
                    addScreenShake(18, 200);
                }

                // ìë™ ì¬ì¥ì „
                if (character.ammo === 0 && !character.isReloading) {
                    reload(character);
                }
            }
        }

        // ì¬ì¥ì „ í•¨ìˆ˜
        function reload(character) {
            if (character.ammo < character.maxAmmo && !character.isReloading) {
                character.isReloading = true;
                character.reloadStartTime = Date.now();
                
                setTimeout(() => {
                    character.ammo = character.maxAmmo;
                    character.isReloading = false;
                    character.reloadStartTime = 0;
                    
                    // ì¬ì¥ì „ íšŒë³µ ì¦ê°•
                    if (character.hasReloadHeal) {
                        character.health = Math.min(character.health + 1, character.maxHealth);
                    }
                }, character.reloadTime);
            }
        }

        // ì¶©ëŒ ê°ì§€
        function checkCollision(bullet, target) {
            const dx = bullet.x - target.x;
            const dy = bullet.y - target.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < bullet.radius + target.radius;
        }

        // êµ¬ë¥´ê¸° í•¨ìˆ˜
        function dodge(character) {
            const now = Date.now();
            // ê¸°ì ˆ ìƒíƒœë©´ êµ¬ë¥´ê¸° ë¶ˆê°€
            if (character.isStunned) return;
            // ì¿¨íƒ€ì„ ì²´í¬ (3ì´ˆ)
            if (character.isDodging || now - character.lastDodgeTime < 3000) return;
            
            character.isDodging = true;
            const dodgeDistance = character.radius * 6.4; // í”Œë ˆì´ì–´ í¬ê¸°ì˜ 3.2ë°° (20% ê°ì†Œ: 8 -> 6.4)
            const dodgeDuration = 300; // 0.3ì´ˆ
            character.dodgeStartTime = now; // êµ¬ë¥´ê¸° ì‹œì‘ ì‹œê°„
            character.dodgeEndTime = now + dodgeDuration;
            character.lastDodgeTime = now; // ì¿¨íƒ€ì„ ì‹œì‘
            character.dodgeTrail = []; // ì”ìƒ ì´ˆê¸°í™”
            
            // êµ¬ë¥´ê¸° ì‹œì‘ ìœ„ì¹˜ ì €ì¥
            character.dodgeStartX = character.x;
            character.dodgeStartY = character.y;
            character.dodgeTrail.push({ x: character.x, y: character.y, alpha: 0.5 });
            
            // êµ¬ë¥´ê¸° ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            const targetX = character.x + Math.cos(character.angle) * dodgeDistance;
            const targetY = character.y + Math.sin(character.angle) * dodgeDistance;
            
            // ê²½ê³„ ì²´í¬
            character.dodgeTargetX = Math.max(character.radius, Math.min(canvas.width - character.radius, targetX));
            character.dodgeTargetY = Math.max(character.radius, Math.min(canvas.height - character.radius, targetY));
        }

        // í”Œë ˆì´ì–´ ì´ë™
        function updatePlayer() {
            const now = Date.now();
            
            // êµ¬ë¥´ê¸° ìƒíƒœ ì²´í¬
            if (player.isDodging) {
                if (now >= player.dodgeEndTime) {
                    // êµ¬ë¥´ê¸° ì™„ë£Œ
                    player.x = player.dodgeTargetX;
                    player.y = player.dodgeTargetY;
                    player.isDodging = false;
                    player.dodgeTrail = [];
                } else {
                    // êµ¬ë¥´ëŠ” ë™ì•ˆ ë¹ ë¥¸ ì†ë„ë¡œ ì´ë™
                    const elapsed = now - player.dodgeStartTime; // ì‹œì‘ ì‹œê°„ìœ¼ë¡œë¶€í„°ì˜ ê²½ê³¼ ì‹œê°„
                    const progress = Math.min(elapsed / 300, 1); // 0~1 (300ms = 0.3ì´ˆ)
                    
                    // ì‹œì‘ ìœ„ì¹˜ì—ì„œ ëª©í‘œ ìœ„ì¹˜ë¡œ ì„ í˜• ë³´ê°„
                    player.x = player.dodgeStartX + (player.dodgeTargetX - player.dodgeStartX) * progress;
                    player.y = player.dodgeStartY + (player.dodgeTargetY - player.dodgeStartY) * progress;
                    
                    // ì”ìƒ ì—…ë°ì´íŠ¸ (ë§¤ í”„ë ˆì„ë§ˆë‹¤)
                    if (!player.dodgeTrail) player.dodgeTrail = [];
                    player.dodgeTrail.push({ x: player.x, y: player.y, alpha: 0.3 });
                    // ì”ìƒì´ ë„ˆë¬´ ë§ì•„ì§€ë©´ ì œê±°
                    if (player.dodgeTrail.length > 5) {
                        player.dodgeTrail.shift();
                    }
                }
                return; // êµ¬ë¥´ëŠ” ì¤‘ì—ëŠ” ì¼ë°˜ ì´ë™ ë¶ˆê°€
            }

            // ë¶€í™œ ì²˜ë¦¬
            if (player.isReviving) {
                if (now >= player.reviveTime) {
                    player.isReviving = false;
                    player.health = 1;
                    // displayHealthëŠ” ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ìë™ ì—…ë°ì´íŠ¸ë¨
                    player.isInvincible = true;
                    player.invincibleEndTime = now + 1000; // 1ì´ˆ ë¬´ì 
                }
                return; // ë¶€í™œ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            }

            // ë¬´ì  ìƒíƒœ ì²´í¬
            if (player.isInvincible && now >= player.invincibleEndTime) {
                player.isInvincible = false;
            }

            // ì•½í™” ìƒíƒœ ì²´í¬
            if (player.isWeakened && now >= player.weakenEndTime) {
                player.isWeakened = false;
                // ì•½í™”ëŠ” ì´ì•Œ ìƒì„± ì‹œì—ë§Œ ë°ë¯¸ì§€ë¥¼ ê°ì†Œì‹œí‚¤ë¯€ë¡œ, damage ìì²´ëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ
            }

            // ê¸°ì ˆ ìƒíƒœ ì²´í¬
            if (player.isStunned && now >= player.stunEndTime) {
                player.isStunned = false;
            }

            // ë°©ì–´ë§‰ ì¿¨íƒ€ì„ ì²´í¬
            if (player.hasShield && !player.shieldReady && now >= player.shieldCooldown) {
                player.shieldReady = true;
            }

            // ì¬ìƒ: 1ì´ˆë§ˆë‹¤ ì²´ë ¥ 0.1 íšŒë³µ
            if (player.hasRegeneration) {
                if (now - player.lastRegenTime >= 1000) {
                    player.health = Math.min(player.health + 0.1, player.maxHealth);
                    player.lastRegenTime = now;
                }
            }

            // ê¸°ì ˆ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            if (player.isStunned) {
                return;
            }

            // ì´ë™ì†ë„ ê°ì†Œ ì²˜ë¦¬ (ê¹Šì€ ìƒì²˜)
            let currentSpeed = player.speed;
            if (now < player.slowEndTime) {
                currentSpeed *= 0.75; // -25%
            }
            
            // íšŒí”¼ê¸°ë™: ì¬ì¥ì „ ì¤‘ ì´ë™ì†ë„ +50%
            if (player.hasEvasiveManeuver && player.isReloading) {
                currentSpeed *= 1.5;
            }
            
            // ìƒì¡´ë³¸ëŠ¥: ì²´ë ¥ì´ 1ì¼ ë•Œ ì´ë™ì†ë„ +50%
            if (player.hasSurvivalInstinct && player.health === 1) {
                currentSpeed *= 1.5;
            }
            
            // íšŒë³µê³„ì•½: ì²´ë ¥ì´ 1ì¼ ë•Œ ì²´ë ¥ 2íšŒë³µ (ë¼ìš´ë“œë‹¹ í•œë²ˆ)
            if (player.hasRecoveryContract && !player.hasRecoveryContractUsed && player.health === 1) {
                player.health = Math.min(player.health + 2, player.maxHealth);
                player.hasRecoveryContractUsed = true;
            }

            let dx = 0;
            let dy = 0;

            if (keys['w']) dy -= 1;
            if (keys['s']) dy += 1;
            if (keys['a']) dx -= 1;
            if (keys['d']) dx += 1;
            

            // ëŒ€ê°ì„  ì´ë™ ì •ê·œí™”
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            // ê±°ì í™•ë³´: ìœ„ì¹˜ ë³€í™” ì²´í¬
            if (player.hasFortify) {
                const moved = Math.abs(player.x - (player.lastPosition?.x || player.x)) > 0.1 || 
                             Math.abs(player.y - (player.lastPosition?.y || player.y)) > 0.1;
                
                if (moved) {
                    // ì›€ì§ì„: ê±°ì  í™•ë³´ í•´ì œ
                    player.isFortified = false;
                    player.stationaryTime = 0;
                    if (!player.lastPosition) player.lastPosition = { x: player.x, y: player.y };
                    player.lastPosition.x = player.x;
                    player.lastPosition.y = player.y;
                } else {
                    // ì •ì§€: ì‹œê°„ ëˆ„ì 
                    if (!player.lastPosition) player.lastPosition = { x: player.x, y: player.y };
                    player.stationaryTime += 16; // ì•½ 60fps ê¸°ì¤€
                    
                    // 3ì´ˆ(3000ms) ë™ì•ˆ ì •ì§€í•˜ë©´ ê±°ì  í™•ë³´
                    if (player.stationaryTime >= 3000 && !player.isFortified) {
                        player.isFortified = true;
                        player.fortifyStartTime = now;
                    }
                }
            }

            // ì´ë™
            const newX = player.x + dx * currentSpeed;
            const newY = player.y + dy * currentSpeed;

            // ê²½ê³„ ì²´í¬
            if (newX >= player.radius && newX <= canvas.width - player.radius) {
                player.x = newX;
            }
            if (newY >= player.radius && newY <= canvas.height - player.radius) {
                player.y = newY;
            }

            // ê°ë„ ê³„ì‚° (ë§ˆìš°ìŠ¤ ë°©í–¥)
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
        }


        // AI ì  ì—…ë°ì´íŠ¸
        function updateEnemy() {
            const now = Date.now();
            
            // ë¶€í™œ ì²˜ë¦¬
            if (enemy.isReviving) {
                if (now >= enemy.reviveTime) {
                    enemy.isReviving = false;
                    enemy.health = 1;
                    // displayHealthëŠ” ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ìë™ ì—…ë°ì´íŠ¸ë¨
                    enemy.isInvincible = true;
                    enemy.invincibleEndTime = now + 1000; // 1ì´ˆ ë¬´ì 
                }
                return; // ë¶€í™œ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            }

            // ë¬´ì  ìƒíƒœ ì²´í¬
            if (enemy.isInvincible && now >= enemy.invincibleEndTime) {
                enemy.isInvincible = false;
            }

            // ì•½í™” ìƒíƒœ ì²´í¬
            if (enemy.isWeakened && now >= enemy.weakenEndTime) {
                enemy.isWeakened = false;
                // ì•½í™”ëŠ” ì´ì•Œ ìƒì„± ì‹œì—ë§Œ ë°ë¯¸ì§€ë¥¼ ê°ì†Œì‹œí‚¤ë¯€ë¡œ, damage ìì²´ëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ
            }

            // ê¸°ì ˆ ìƒíƒœ ì²´í¬
            if (enemy.isStunned && now >= enemy.stunEndTime) {
                enemy.isStunned = false;
            }

            // ë°©ì–´ë§‰ ì¿¨íƒ€ì„ ì²´í¬
            if (enemy.hasShield && !enemy.shieldReady && now >= enemy.shieldCooldown) {
                enemy.shieldReady = true;
            }

            // ì¬ìƒ: 1ì´ˆë§ˆë‹¤ ì²´ë ¥ 0.1 íšŒë³µ
            if (enemy.hasRegeneration) {
                if (now - enemy.lastRegenTime >= 1000) {
                    enemy.health = Math.min(enemy.health + 0.1, enemy.maxHealth);
                    enemy.lastRegenTime = now;
                }
            }

            // ê¸°ì ˆ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
            if (enemy.isStunned) {
                return;
            }

            // ì´ë™ì†ë„ ê°ì†Œ ì²˜ë¦¬ (ê¹Šì€ ìƒì²˜)
            let currentSpeed = enemy.speed;
            if (now < enemy.slowEndTime) {
                currentSpeed *= 0.75; // -25%
            }
            
            // íšŒí”¼ê¸°ë™: ì¬ì¥ì „ ì¤‘ ì´ë™ì†ë„ +50%
            if (enemy.hasEvasiveManeuver && enemy.isReloading) {
                currentSpeed *= 1.5;
            }
            
            // ìƒì¡´ë³¸ëŠ¥: ì²´ë ¥ì´ 1ì¼ ë•Œ ì´ë™ì†ë„ +50%
            if (enemy.hasSurvivalInstinct && enemy.health === 1) {
                currentSpeed *= 1.5;
            }
            
            // íšŒë³µê³„ì•½: ì²´ë ¥ì´ 1ì¼ ë•Œ ì²´ë ¥ 2íšŒë³µ (ë¼ìš´ë“œë‹¹ í•œë²ˆ)
            if (enemy.hasRecoveryContract && !enemy.hasRecoveryContractUsed && enemy.health === 1) {
                enemy.health = Math.min(enemy.health + 2, enemy.maxHealth);
                enemy.hasRecoveryContractUsed = true;
            }

            enemy.aiTimer++;

            // í”Œë ˆì´ì–´ê°€ ì´ì„ ì˜ëŠ”ì§€ ê°ì§€
            const currentPlayerBulletCount = player.bullets.length;
            if (currentPlayerBulletCount > enemy.lastPlayerBulletCount) {
                // í”Œë ˆì´ì–´ê°€ ì´ì„ ìˆìŒ
                const dodgeProbability = 0.5;
                if (Math.random() < dodgeProbability) {
                    // 50% í™•ë¥ ë¡œ íšŒí”¼
                    enemy.isDodgingBullet = true;
                    // ìœ„ ë˜ëŠ” ì•„ë˜ ì¤‘ í•œ ë°©í–¥ ì„ íƒ
                    const dodgeDirection = Math.random() < 0.5 ? 1 : -1; // 1 = ì•„ë˜, -1 = ìœ„
                    const dodgeDistance = 50;
                    enemy.bulletDodgeTargetY = Math.max(
                        enemy.radius,
                        Math.min(
                            canvas.height - enemy.radius,
                            enemy.y + dodgeDirection * dodgeDistance
                        )
                    );
                    // í˜„ì¬ ì›€ì§ì„ ë©ˆì¶”ê¸°
                    enemy.aiTimer = 0;
                }
            }
            enemy.lastPlayerBulletCount = currentPlayerBulletCount;

            // ì´ì•Œ íšŒí”¼ ì¤‘ì´ë©´ ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
            if (enemy.isDodgingBullet) {
                const dyToTarget = enemy.bulletDodgeTargetY - enemy.y;
                if (Math.abs(dyToTarget) > 2) {
                    // ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
                    enemy.aiDirection = dyToTarget > 0 ? Math.PI / 2 : -Math.PI / 2; // ì•„ë˜ ë˜ëŠ” ìœ„
                } else {
                    // ëª©í‘œ ìœ„ì¹˜ì— ë„ë‹¬í–ˆìœ¼ë©´ íšŒí”¼ ì¢…ë£Œ
                    enemy.isDodgingBullet = false;
                    enemy.aiTimer = 0; // ìƒˆë¡œìš´ ë°©í–¥ ì„ íƒ
                }
            }

            // í”Œë ˆì´ì–´ ì´ë™ ë°©í–¥ ì¶”ì  (ì˜ˆì¸¡ ë°œì‚¬ìš©)
            if (enemy.lastPlayerX === 0 && enemy.lastPlayerY === 0) {
                enemy.lastPlayerX = player.x;
                enemy.lastPlayerY = player.y;
            }
            // í”Œë ˆì´ì–´ ì†ë„ ê³„ì‚° (í”„ë ˆì„ë‹¹ ì´ë™ëŸ‰)
            enemy.playerVelocity.x = player.x - enemy.lastPlayerX;
            enemy.playerVelocity.y = player.y - enemy.lastPlayerY;
            enemy.lastPlayerX = player.x;
            enemy.lastPlayerY = player.y;

            // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ê°ë„ ì„¤ì •
            const dxToPlayer = player.x - enemy.x;
            const dyToPlayer = player.y - enemy.y;
            enemy.angle = Math.atan2(dyToPlayer, dxToPlayer);

            // í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ ê³„ì‚°
            const distance = Math.sqrt(dxToPlayer * dxToPlayer + dyToPlayer * dyToPlayer);
            const safeDistance = 500; // ì•ˆì „ ê±°ë¦¬ (500px)

            const aiTimerThreshold = 30; // ì›ë˜ëŒ€ë¡œ ë³µêµ¬ (30í”„ë ˆì„ = ì•½ 0.5ì´ˆ)
            
            // ì  ì´ë™ íŒ¨í„´ ê°œì„  - ìœ„ì•„ë˜ë¡œ ë” ìì£¼ ì›€ì§ì„ (íšŒí”¼ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
            if (!enemy.isDodgingBullet && enemy.aiTimer > aiTimerThreshold) {
                let targetAngle;
                
                // ëœë¤í•˜ê²Œ ë‹¤ì–‘í•œ ì›€ì§ì„ íŒ¨í„´ ì‚¬ìš©
                const movementPattern = Math.random();
                
                if (movementPattern < 0.2) {
                    // 20% í™•ë¥ : í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ì´ë™
                    targetAngle = Math.atan2(dyToPlayer, dxToPlayer);
                } else if (movementPattern < 0.35) {
                    // 15% í™•ë¥ : í”Œë ˆì´ì–´ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì´ë™
                    targetAngle = Math.atan2(-dyToPlayer, -dxToPlayer);
                } else if (movementPattern < 0.45) {
                    // 10% í™•ë¥ : ì¸¡ë©´ ì´ë™ (ì™¼ìª½/ì˜¤ë¥¸ìª½)
                    targetAngle = Math.atan2(dyToPlayer, dxToPlayer) + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                } else if (movementPattern < 0.75) {
                    // 30% í™•ë¥ : ìœ„ì•„ë˜ ì´ë™ (í”Œë ˆì´ì–´ ë°©í–¥ ê¸°ì¤€ ìœ„/ì•„ë˜)
                    const playerAngle = Math.atan2(dyToPlayer, dxToPlayer);
                    targetAngle = playerAngle + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                } else {
                    // 25% í™•ë¥ : ì™„ì „ ëœë¤ ë°©í–¥
                    targetAngle = Math.random() * Math.PI * 2;
                }
                
                // ê±°ë¦¬ ê¸°ë°˜ ì¡°ì • (ì„ íƒì )
                if (distance < safeDistance * 0.7) {
                    // ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë©€ì–´ì§€ëŠ” ê²½í–¥
                    if (movementPattern < 0.5) {
                        targetAngle = Math.atan2(-dyToPlayer, -dxToPlayer);
                    }
                }
                
                // ëœë¤ ê°ë„ ì¶”ê°€ë¡œ ë” ìì—°ìŠ¤ëŸ¬ìš´ ì›€ì§ì„
                const randomAngle = (Math.random() - 0.5) * Math.PI * 0.5; // Â±45ë„ ëœë¤
                enemy.aiDirection = targetAngle + randomAngle;
                enemy.aiTimer = 0;
            }

            // ê²½ê³„ì— ë‹¿ìœ¼ë©´ ë°©í–¥ ë³€ê²½
            if (enemy.x < enemy.radius || enemy.x > canvas.width - enemy.radius ||
                enemy.y < enemy.radius || enemy.y > canvas.height - enemy.radius) {
                enemy.aiDirection = Math.random() * Math.PI * 2;
                enemy.aiTimer = 0;
            }

            // ì´ë™
            let dx = Math.cos(enemy.aiDirection) * currentSpeed;
            let dy = Math.sin(enemy.aiDirection) * currentSpeed;

            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x + dx));
            enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y + dy));


            // í”Œë ˆì´ì–´ê°€ ë²”ìœ„ ë‚´ì— ìˆê³  íƒ„ì•½ì´ ìˆìœ¼ë©´ ë°œì‚¬
            const maxDistance = Math.max(canvas.width, canvas.height) * 0.8; // í™”ë©´ í¬ê¸°ì˜ 80%ê¹Œì§€
            const shootProbability = 0.05;
            if (distance < maxDistance && enemy.ammo > 0 && !enemy.isReloading && Math.random() < shootProbability) {
                // í”Œë ˆì´ì–´ê°€ ì›€ì§ì´ê³  ìˆëŠ”ì§€ í™•ì¸
                const playerSpeed = Math.sqrt(enemy.playerVelocity.x * enemy.playerVelocity.x + enemy.playerVelocity.y * enemy.playerVelocity.y);
                const isPlayerMoving = playerSpeed > 0.1; // 0.1px ì´ìƒ ì›€ì§ì´ë©´ ì›€ì§ì´ëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼
                
                const originalAngle = enemy.angle;
                const currentAngle = Math.atan2(dyToPlayer, dxToPlayer);
                
                // í”Œë ˆì´ì–´ê°€ ë©ˆì¶°ìˆìœ¼ë©´ í•­ìƒ ì •í™•íˆ ì˜ê³ , ì›€ì§ì´ë©´ 70% ì •í™•íˆ, 30% Â±5ë„ ëœë¤
                if (!isPlayerMoving) {
                    // ë©ˆì¶°ìˆì„ ë•Œ: í•­ìƒ ì •í™•íˆ
                    enemy.angle = currentAngle;
                } else {
                    // ì›€ì§ì¼ ë•Œ: 70% ì •í™•íˆ, 30% Â±5ë„ ëœë¤
                    if (Math.random() < 0.7) {
                        // 70% í™•ë¥ : ì •í™•íˆ í”Œë ˆì´ì–´ ìœ„ì¹˜
                        enemy.angle = currentAngle;
                    } else {
                        // 30% í™•ë¥ : Â±5ë„ ëœë¤
                        const randomOffset = (Math.random() - 0.5) * 10 * Math.PI / 180; // Â±5ë„
                        enemy.angle = currentAngle + randomOffset;
                    }
                }
                
                shoot(enemy);
                // ë°œì‚¬ í›„ ê°ë„ ë³µì› (ì´ë™ ë°©í–¥ ìœ ì§€)
                enemy.angle = originalAngle;
            }

            // ìë™ ì¬ì¥ì „
            if (enemy.ammo === 0 && !enemy.isReloading) {
                reload(enemy);
            }
        }

        // ì´ì•Œ ì—…ë°ì´íŠ¸
        function updateBullets(character) {
            for (let i = character.bullets.length - 1; i >= 0; i--) {
                const bullet = character.bullets[i];
                
                // ì‹œê°„ì¥ë§‰: ì ì˜ ì´ì•Œì´ í”Œë ˆì´ì–´ì˜ ì‹œê°„ì¥ë§‰ ì•ˆì— ìˆìœ¼ë©´ ì†ë„ 35% ë‘”í™”
                if (character === enemy && player.hasTimeBarrier) {
                    const dx = bullet.x - player.x;
                    const dy = bullet.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= player.timeBarrierRadius) {
                        // ì†ë„ 65%ë¡œ ì„¤ì • (35% ê°ì†Œ) - í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„ ê¸°ì¤€ìœ¼ë¡œ
                        const baseSpeedForBarrier = bullet.hallucinationSpeed !== undefined ? bullet.hallucinationSpeed : (bullet.baseSpeed || bullet.speed);
                        bullet.speed = baseSpeedForBarrier * 0.65;
                        bullet.isInTimeBarrier = true;
                    } else {
                        // ì‹œê°„ì¥ë§‰ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì›ë˜ ì†ë„ë¡œ ë³µì› (í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„)
                        bullet.isInTimeBarrier = false;
                        if (bullet.hallucinationSpeed !== undefined) {
                            bullet.speed = bullet.hallucinationSpeed;
                        } else {
                            bullet.speed = bullet.baseSpeed || bullet.speed;
                        }
                    }
                }
                // ì‹œê°„ì¥ë§‰: í”Œë ˆì´ì–´ì˜ ì´ì•Œì´ ì ì˜ ì‹œê°„ì¥ë§‰ ì•ˆì— ìˆìœ¼ë©´ ì†ë„ 35% ë‘”í™”
                if (character === player && enemy.hasTimeBarrier) {
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= enemy.timeBarrierRadius) {
                        // ì†ë„ 65%ë¡œ ì„¤ì • (35% ê°ì†Œ) - í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„ ê¸°ì¤€ìœ¼ë¡œ
                        const baseSpeedForBarrier = bullet.hallucinationSpeed !== undefined ? bullet.hallucinationSpeed : (bullet.baseSpeed || bullet.speed);
                        bullet.speed = baseSpeedForBarrier * 0.65;
                        bullet.isInTimeBarrier = true;
                    } else {
                        // ì‹œê°„ì¥ë§‰ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì›ë˜ ì†ë„ë¡œ ë³µì› (í™˜ê°ì´ ìˆìœ¼ë©´ í™˜ê° ì†ë„)
                        bullet.isInTimeBarrier = false;
                        if (bullet.hallucinationSpeed !== undefined) {
                            bullet.speed = bullet.hallucinationSpeed;
                        } else {
                            bullet.speed = bullet.baseSpeed || bullet.speed;
                        }
                    }
                }
                
                bullet.update();

                // ê²½ê³„ ì²´í¬
                if (bullet.isOutOfBounds()) {
                    character.bullets.splice(i, 1);
                    continue;
                }

                // ì¶©ëŒ ì²´í¬
                let target = character === player ? enemy : player;
                if (checkCollision(bullet, target)) {
                    // êµ¬ë¥´ëŠ” ì¤‘ì´ê±°ë‚˜ ë¬´ì  ìƒíƒœë©´ ë°ë¯¸ì§€ ë¬´ì‹œ
                    if (target.isDodging || target.isInvincible || target.isReviving) {
                        character.bullets.splice(i, 1);
                        continue;
                    }

                    // ë°©ì–´ë§‰: ë°ë¯¸ì§€ 1íšŒ ë¬´ì‹œ (ì¿¨íƒ€ì„ 5ì´ˆ)
                    if (target.hasShield && target.shieldReady) {
                        target.shieldReady = false;
                        target.shieldCooldown = Date.now() + 5000; // 5ì´ˆ ì¿¨íƒ€ì„
                        character.bullets.splice(i, 1);
                        // "ë¬´ì‹œ" í…ìŠ¤íŠ¸ í‘œì‹œ
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isShield: true, // ë°©ì–´ë§‰ ë¬´ì‹œ ì—¬ë¶€
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: 0
                        });
                        continue; // ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                    }

                    // ìœ ë ¹ ì¦ê°•: 25% í™•ë¥ ë¡œ ê³µê²© ë¬´ì‹œ
                    if (target.hasGhost && Math.random() < 0.25) {
                        // "ë¬´ì‹œ" í…ìŠ¤íŠ¸ í‘œì‹œ
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isGhost: true, // ìœ ë ¹ ë¬´ì‹œ ì—¬ë¶€
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: 0
                        });
                        // ì´ì•Œ ì œê±°í•˜ê³  ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                        character.bullets.splice(i, 1);
                        i--; // ì¸ë±ìŠ¤ ì¡°ì •
                        continue; // ë°ë¯¸ì§€ ì ìš© ì•ˆ í•¨
                    }

                    // í¬ë¦¬í‹°ì»¬ ê³„ì‚° (25% í™•ë¥ ë¡œ ë°ë¯¸ì§€ 2ë°°)
                    let finalDamage = bullet.damage;
                    let isCritical = false;
                    if (character.hasCritical && Math.random() < 0.25) {
                        finalDamage *= 2;
                        isCritical = true;
                    }
                    
                    // ì·¨ì•½ ìƒíƒœ: ë‹¤ìŒ ë°ë¯¸ì§€ 1.5ë°°
                    if (target.isVulnerable && !target.vulnerabilityUsed) {
                        finalDamage *= 1.5;
                        target.vulnerabilityUsed = true; // ì·¨ì•½ ì‚¬ìš©ë¨
                        target.isVulnerable = false; // ì·¨ì•½ ìƒíƒœ í•´ì œ
                    }

                    // ê±°ì í™•ë³´: ë°ë¯¸ì§€ *0.5
                    if (target.hasFortify && target.isFortified) {
                        finalDamage *= 0.5;
                    }

                    // ê³¼ì—´: ì—°ì† íˆíŠ¸ ì‹œ ë°ë¯¸ì§€ ë°°ìœ¨ ì ìš©
                    if (character.hasOverheat) {
                        const now = Date.now();
                        // 2ì´ˆ ì´ë‚´ì— íˆíŠ¸í•˜ë©´ ì—°ì† íˆíŠ¸ë¡œ ê°„ì£¼
                        if (now - character.lastHitTime < 2000) {
                            character.overheatHitCount++;
                        } else {
                            // 2ì´ˆ ì´ìƒ ì§€ë‚˜ë©´ ì´ˆê¸°í™”
                            character.overheatHitCount = 0;
                        }
                        // ë°ë¯¸ì§€ ë°°ìœ¨: 1 + hitCount * 0.5 (ì²«ë²ˆì§¸ëŠ” 1ë°°, ë‘ë²ˆì§¸ëŠ” 1.5ë°°, ì„¸ë²ˆì§¸ëŠ” 2ë°°...)
                        finalDamage *= (1 + character.overheatHitCount * 0.5);
                        character.lastHitTime = now;
                    }

                    // ì•½í™”: ìƒëŒ€ì—ê²Œ ì•½í™” ìƒíƒœ ë¶€ì—¬ (3ì´ˆ ë™ì•ˆ ë°ë¯¸ì§€ -0.25, ì¤‘ì²© ì•ˆë¨)
                    if (character.hasWeaken && !target.isWeakened) {
                        target.isWeakened = true;
                        target.weakenEndTime = Date.now() + 3000;
                        // ë°ë¯¸ì§€ ê°ì†Œ ì ìš© (ì›ë˜ ë°ë¯¸ì§€ ì €ì¥ í•„ìš” ì—†ìŒ, ë°œì‚¬ ì‹œ ì ìš©)
                    }

                    target.health -= finalDamage;
                    
                    // í”¼ì˜ ë§›: ì ì—ê²Œ ì…íŒ í”¼í•´ì˜ 20%ë§Œí¼ íšŒë³µ
                    if (character.hasTasteOfBlood) {
                        const healAmount = finalDamage * 0.2;
                        const oldHealth = character.health;
                        character.health = Math.min(character.health + healAmount, character.maxHealth);
                        const actualHeal = character.health - oldHealth;
                        if (actualHeal > 0) {
                            // íšŒë³µ ìˆ«ì í‘œì‹œ (ë¹¨ê°„ìƒ‰) - ì†Œìˆ˜ì  1ìë¦¬ê¹Œì§€ë§Œ
                            character.damageNumbers.push({
                                x: character.x,
                                y: character.y,
                                damage: Math.round(actualHeal * 10) / 10, // ì†Œìˆ˜ì  1ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
                                isCritical: false,
                                isHeal: true, // íšŒë³µ ì—¬ë¶€
                                startTime: Date.now(),
                                duration: 1000,
                                offsetY: 0
                            });
                        }
                    }
                    
                    character.bullets.splice(i, 1);

                    // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ ì¶”ê°€
                    target.damageNumbers.push({
                        x: target.x,
                        y: target.y,
                        damage: finalDamage,
                        isCritical: isCritical, // í¬ë¦¬í‹°ì»¬ ì—¬ë¶€
                        startTime: Date.now(),
                        duration: 1000, // 1ì´ˆ ë™ì•ˆ í‘œì‹œ
                        offsetY: 0 // ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì˜¤í”„ì…‹
                    });

                    // ë²ˆê°œ: 25% í™•ë¥ ë¡œ ì  0.75ì´ˆ ê¸°ì ˆ
                    if (character.hasLightning && Math.random() < 0.25) {
                        target.isStunned = true;
                        target.stunEndTime = Date.now() + 750; // 0.75ì´ˆ
                        // ê¸°ì ˆ í…ìŠ¤íŠ¸ í‘œì‹œ (ë°ë¯¸ì§€ ìˆ«ì ìœ„ì— í‘œì‹œ)
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isStunned: true, // ê¸°ì ˆ ì—¬ë¶€
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: -40 // ë°ë¯¸ì§€ ìˆ«ì ìœ„ì— í‘œì‹œ
                        });
                    }

                    // ê¹Šì€ ìƒì²˜ (í”¼ê²© ì‹œ ìƒëŒ€ ì´ë™ì†ë„ -25% (0.5ì´ˆ))
                    if (character.hasDeepWound) {
                        target.slowEndTime = Date.now() + 500;
                    }
                    
                    // ë… íƒ„í™˜ íš¨ê³¼ (1ì´ˆê°„ê²©ìœ¼ë¡œ 3ë²ˆ 0.2ë°ë¯¸ì§€)
                    if (bullet.hasPoison) {
                        character.poisonEffects.push({
                            target: target,
                            startTime: Date.now(),
                            duration: 3000, // 3ì´ˆ (1ì´ˆê°„ê²©ìœ¼ë¡œ 3ë²ˆ)
                            damagePerSecond: 0.2,
                            lastDamageTime: Date.now(),
                            hitCount: 0, // íˆíŠ¸ íšŸìˆ˜
                            maxHits: 3 // ìµœëŒ€ íˆíŠ¸ íšŸìˆ˜
                        });
                    }
                    
                    // ì§‘ì¤‘ ì‚¬ê²©: í”¼ê²©ì‹œ 50% í™•ë¥ ë¡œ ìƒëŒ€ì—ê²Œ ì·¨ì•½ ë¶€ì—¬
                    if (target.hasFocusedFire && Math.random() < 0.5) {
                        character.isVulnerable = true;
                        character.vulnerabilityUsed = false;
                    }

                    if (target.health <= 0) {
                        target.health = 0;
                        
                        // ë¶€í™œ ì²´í¬ (1ë²ˆë§Œ ë¶€í™œ)
                        if (target.hasRevive && !target.hasRevived && !target.isReviving) {
                            target.hasRevived = true; // ë¶€í™œ ì‚¬ìš© í‘œì‹œ
                            target.isReviving = true;
                            target.reviveTime = Date.now() + 1000;
                        } else {
                            endRound(character === player ? 'player' : 'enemy');
                        }
                    }
                    // ì²´ë ¥ì´ ìŒìˆ˜ê°€ ë˜ì§€ ì•Šë„ë¡
                    if (target.health < 0) target.health = 0;
                }
            }
        }

        // ë¼ìš´ë“œ ì¢…ë£Œ
        function endRound(winner) {
            gameState.isPaused = true;


            // ë¼ìš´ë“œ ìŠ¹ë¦¬ ê¸°ë¡ì— ì¶”ê°€ (ìˆœì„œëŒ€ë¡œ)
            gameState.roundWins.push(winner);

            if (winner === 'player') {
                gameState.playerWins++;
            } else {
                gameState.enemyWins++;
            }

            // ìŠ¹ë¦¬ ì²´í¬
            if (gameState.playerWins >= gameState.winsNeeded || gameState.enemyWins >= gameState.winsNeeded) {
                const finalWinner = winner === 'player' ? 'player' : 'enemy';
                endGame(finalWinner);
                return;
            }

            // ë¼ìš´ë“œ ì¢…ë£Œ ì²´í¬
            if (gameState.round >= gameState.maxRounds) {
                const finalWinner = gameState.playerWins > gameState.enemyWins ? 'player' : 'enemy';
                endGame(finalWinner);
                return;
            }

            // íŒ¨ë°°ìê°€ ì¦ê°• ì„ íƒ, ìŠ¹ë¦¬ìëŠ” í™•ì¸ë§Œ
            if (winner === 'player') {
                // í”Œë ˆì´ì–´ ìŠ¹ë¦¬: AIê°€ ì„ íƒ
                    gameState.showOpponentSelecting = true;
            selectAugmentForEnemy();
            } else {
                // enemy ìŠ¹ë¦¬: í”Œë ˆì´ì–´ëŠ” ì„ íƒ
                showAugmentModal(player);
            }
        }

        // ì ì„ ìœ„í•œ ì¦ê°• ìë™ ì„ íƒ
        function selectAugmentForEnemy() {
            const enemySelectionDiv = document.getElementById('enemySelection');
            const opponentSelectionDiv = document.getElementById('opponentSelection');
            
            if (enemySelectionDiv) {
            enemySelectionDiv.style.display = 'block';
            enemySelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>';
            }
            
            if (opponentSelectionDiv) {
                opponentSelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>';
            }
            
            // 3ì´ˆ ëŒ€ê¸° í›„ ì„ íƒ
            setTimeout(() => {
                // AIëŠ” êµ¬ë¥´ê¸°ì™€ ê±°ì í™•ë³´ ì¦ê°•ì„ ë½‘ì§€ ì•ŠìŒ
                const availableAugments = augmentations.filter(aug => aug.id !== 'dodge' && aug.id !== 'fortify');
                const shuffled = [...availableAugments].sort(() => Math.random() - 0.5);
                const selectedAugment = shuffled[0]; // ëœë¤ìœ¼ë¡œ í•˜ë‚˜ ì„ íƒ
                selectedAugment.effect(enemy);
                enemy.augmentations.push(selectedAugment);
                
                // ì„ íƒí•œ ì¦ê°• í‘œì‹œ
                if (enemySelectionDiv) {
                enemySelectionDiv.innerHTML = `<p style="color: #e94560; margin: 0;">ìƒëŒ€ ì„ íƒ: <strong style="color: #ffc107;">${selectedAugment.name}</strong></p>`;
                }
                if (opponentSelectionDiv) {
                    opponentSelectionDiv.innerHTML = `<p style="color: #e94560; margin: 0;">ìƒëŒ€ ì„ íƒ: <strong style="color: #ffc107;">${selectedAugment.name}</strong></p>`;
                }
                
                // ë³¸ ì¦ê°• ëª©ë¡ì— ì¶”ê°€ (ì ì´ ì„ íƒí•œ ì¦ê°•ë„)
                markAugmentAsSeen(selectedAugment.id);
                
                // í”Œë ˆì´ì–´ê°€ ìŠ¹ë¦¬í•œ ê²½ìš°: ìƒëŒ€ ì„ íƒ ì™„ë£Œ í›„ ìë™ìœ¼ë¡œ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                if (gameState.showOpponentSelecting) {
                    gameState.showOpponentSelecting = false;
                    // ì•½ê°„ì˜ ë”œë ˆì´ í›„ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                    setTimeout(() => {
                        nextRound();
                    }, 500);
                }
            }, 3000);
        }

        // ì¦ê°• ëª¨ë‹¬ í‘œì‹œ (í”Œë ˆì´ì–´ìš© - ì„ íƒ ê°€ëŠ¥)
        function showAugmentModal(character) {
            const modal = document.getElementById('augmentModal');
            const optionsDiv = document.getElementById('augmentOptions');
            optionsDiv.innerHTML = '';

            // ëœë¤ ì¦ê°• 3ê°œ ì„ íƒ (í”Œë ˆì´ì–´ê°€ ì´ë¯¸ ì„ íƒí•œ ì¦ê°• ì œì™¸)
            const selectedAugmentIds = character.augmentations.map(aug => aug.id);
            const availableAugments = augmentations.filter(aug => !selectedAugmentIds.includes(aug.id));
            const shuffled = [...availableAugments].sort(() => Math.random() - 0.5);
            const selectedAugments = shuffled.slice(0, 3);

            // ì„ íƒ ê°€ëŠ¥í•œ 3ê°œ ì¦ê°• ëª¨ë‘ ë„ê°ì— ì €ì¥
            selectedAugments.forEach(aug => {
                markAugmentAsSeen(aug.id);
            });

            let timeLeft = 15;
            let isSelected = false;
            let timerInterval;

            // ì¦ê°• ì„ íƒ í•¨ìˆ˜
            const selectAugment = (aug) => {
                if (isSelected) return;
                isSelected = true;
                clearInterval(timerInterval);
                aug.effect(character);
                character.augmentations.push(aug);
                gameState.augmentCountdown = 0;
                // í”Œë ˆì´ì–´ê°€ íŒ¨ë°°í•œ ê²½ìš°: í”Œë ˆì´ì–´ë§Œ ì„ íƒí•˜ë¯€ë¡œ ë°”ë¡œ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                        modal.style.display = 'none';
                // í™•ì¸ ëª¨ë‹¬ë„ ë‹«ê¸°
                const viewModal = document.getElementById('augmentViewModal');
                if (viewModal) {
                    viewModal.style.display = 'none';
                    }
                nextRound();
            };

            // ì¦ê°• ì˜µì…˜ ìƒì„±
            selectedAugments.forEach(aug => {
                const option = document.createElement('div');
                option.className = 'augment-option';
                option.innerHTML = `
                    <h4>${aug.name}</h4>
                    <p>${aug.description}</p>
                `;
                option.onclick = () => selectAugment(aug);
                optionsDiv.appendChild(option);
            });

            // ëª¨ë‹¬ í‘œì‹œ
            modal.style.display = 'block';
            const enemySelectionDiv = document.getElementById('enemySelection');
            // í”Œë ˆì´ì–´ê°€ íŒ¨ë°°í•œ ê²½ìš°: ì ì€ ìŠ¹ë¦¬ìì´ë¯€ë¡œ ì¦ê°•ì„ ì„ íƒí•˜ì§€ ì•ŠìŒ, ë©”ì‹œì§€ í‘œì‹œ ì•ˆí•¨
            enemySelectionDiv.style.display = 'none';
            
            // í™”ë©´ ê°€ìš´ë° ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
            gameState.augmentCountdown = 15;
            timerInterval = setInterval(() => {
                timeLeft--;
                gameState.augmentCountdown = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    if (!isSelected) {
                        // ì‹œê°„ ì´ˆê³¼ ì‹œ ëœë¤ ì„ íƒ
                        const randomAug = selectedAugments[Math.floor(Math.random() * selectedAugments.length)];
                        selectAugment(randomAug);
                    }
                }
            }, 1000);
        }

        // ì¦ê°• í™•ì¸ ëª¨ë‹¬ í‘œì‹œ (ìŠ¹ë¦¬ììš© - í™•ì¸ë§Œ ê°€ëŠ¥)
        function showAugmentViewModal(winnerCharacter, loserType) {
            const modal = document.getElementById('augmentViewModal');
            const opponentSelectionDiv = document.getElementById('opponentSelection');
            
            // ëª¨ë‹¬ í‘œì‹œ
            modal.style.display = 'block';
            opponentSelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ìƒëŒ€ê°€ ì„ íƒ ì¤‘...</p>';
        }

        // ì¦ê°• í™•ì¸ ëª¨ë‹¬ ë‹«ê¸°
        function closeAugmentViewModal() {
            const modal = document.getElementById('augmentViewModal');
            modal.style.display = 'none';
            
            // ìƒëŒ€ ì„ íƒì´ ì™„ë£Œë˜ì—ˆìœ¼ë©´ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
            if (enemy.augmentations.length > 0) {
                nextRound();
            } else {
                // ì•„ì§ ì ì´ ì„ íƒ ì¤‘ì´ë©´ ëŒ€ê¸°
                const checkEnemySelection = setInterval(() => {
                    if (enemy.augmentations.length > 0) {
                        clearInterval(checkEnemySelection);
                        nextRound();
                    }
                }, 100);
            }
        }

        // ë‹¤ìŒ ë¼ìš´ë“œ
        function nextRound() {
            resizeCanvas();
            gameState.round++;
            gameState.gameTime = 180;
            gameState.showOpponentSelecting = false;
            
            // ì „íˆ¬ ê²½í—˜: ì§„ ë¼ìš´ë“œ ìˆ˜ë§ˆë‹¤ ìµœëŒ€ì²´ë ¥ 0.5, ë°ë¯¸ì§€ 0.1 ì¦ê°€
            if (player.hasCombatExperience) {
                player.combatExperienceRounds = gameState.playerWins; // ì§„ ë¼ìš´ë“œ ìˆ˜
                player.maxHealth = 5 + player.combatExperienceRounds * 0.5;
                player.damage = 1 + player.combatExperienceRounds * 0.1;
            }
            if (enemy.hasCombatExperience) {
                enemy.combatExperienceRounds = gameState.enemyWins; // ì§„ ë¼ìš´ë“œ ìˆ˜
                enemy.maxHealth = 5 + enemy.combatExperienceRounds * 0.5;
                enemy.damage = 1 + enemy.combatExperienceRounds * 0.1;
            }

            // í”Œë ˆì´ì–´ ìƒíƒœ ì´ˆê¸°í™”
            player.x = canvas.width * 0.2;
            player.y = canvas.height * 0.5;
            player.health = player.maxHealth;
            player.displayHealth = player.maxHealth;
            player.ammo = player.maxAmmo;
            player.bullets = [];
            player.isReloading = false;
            player.isDodging = false;
            player.dodgeStartTime = 0;
            player.dodgeEndTime = 0;
            player.dodgeStartX = 0;
            player.dodgeStartY = 0;
            player.dodgeTargetX = 0;
            player.dodgeTargetY = 0;
            player.dodgeTrail = [];
            player.lastDodgeTime = 0;
            player.isReviving = false;
            player.reviveTime = 0;
            player.hasRevived = false; // ë¶€í™œ ì‚¬ìš© ì—¬ë¶€ ì´ˆê¸°í™”
            player.isInvincible = false;
            player.invincibleEndTime = 0;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.poisonEffects = [];
            player.hasRecoveryContractUsed = false; // íšŒë³µê³„ì•½ ì´ˆê¸°í™”
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.shieldReady = true; // ë°©ì–´ë§‰ ì¤€ë¹„ ìƒíƒœë¡œ ì´ˆê¸°í™”
            player.shieldCooldown = 0;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.lastRegenTime = Date.now(); // ì¬ìƒ ì‹œì‘ ì‹œê°„

            // ì  ìƒíƒœ ì´ˆê¸°í™”
            enemy.x = canvas.width * 0.8;
            enemy.y = canvas.height * 0.5;
            enemy.health = enemy.maxHealth;
            enemy.displayHealth = enemy.maxHealth;
            enemy.ammo = enemy.maxAmmo;
            enemy.bullets = [];
            enemy.isReloading = false;
            enemy.isDodging = false;
            enemy.dodgeStartTime = 0;
            enemy.dodgeEndTime = 0;
            enemy.dodgeStartX = 0;
            enemy.dodgeStartY = 0;
            enemy.dodgeTargetX = 0;
            enemy.dodgeTargetY = 0;
            enemy.bulletDodgeTargetY = 0;
            enemy.isDodgingBullet = false;
            enemy.lastPlayerBulletCount = 0;
            enemy.dodgeTrail = [];
            enemy.lastDodgeTime = 0;
            enemy.isReviving = false;
            enemy.reviveTime = 0;
            enemy.hasRevived = false; // ë¶€í™œ ì‚¬ìš© ì—¬ë¶€ ì´ˆê¸°í™”
            enemy.isInvincible = false;
            enemy.invincibleEndTime = 0;
            enemy.slowEndTime = 0;
            enemy.damageNumbers = [];
            enemy.usePrediction = false;
            enemy.lastPlayerX = 0;
            enemy.lastPlayerY = 0;
            enemy.playerVelocity = { x: 0, y: 0 };
            enemy.poisonEffects = [];
            enemy.hasRecoveryContractUsed = false; // íšŒë³µê³„ì•½ ì´ˆê¸°í™”
            enemy.isVulnerable = false;
            enemy.vulnerabilityUsed = false;
            enemy.isStunned = false;
            enemy.stunEndTime = 0;
            enemy.shieldReady = true; // ë°©ì–´ë§‰ ì¤€ë¹„ ìƒíƒœë¡œ ì´ˆê¸°í™”
            enemy.shieldCooldown = 0;
            enemy.isWeakened = false;
            enemy.weakenEndTime = 0;
            enemy.lastRegenTime = Date.now(); // ì¬ìƒ ì‹œì‘ ì‹œê°„

            // 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (ê²Œì„ ì™„ì „íˆ ë©ˆì¶¤)
            gameState.countdown = 3;
            gameState.isPaused = true;
            
            // ì¹´ìš´íŠ¸ë‹¤ìš´ ì²˜ë¦¬
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.isPaused = false;
                }
            }, 1000);
        }

        // ê²Œì„ ì¢…ë£Œ
        function endGame(winner) {
            gameState.isGameOver = true;
            const modal = document.getElementById('gameOverModal');
            const title = document.getElementById('gameOverTitle');
            const message = document.getElementById('gameOverMessage');

            if (winner === 'player') {
                title.textContent = 'ìŠ¹ë¦¬';
                title.style.color = '#4a9eff'; // íŒŒë€ìƒ‰
                message.textContent = 'ìŠ¹ë¦¬';
                message.style.color = '#4a9eff'; // íŒŒë€ìƒ‰
            } else {
                title.textContent = 'íŒ¨ë°°';
                title.style.color = '#e94560'; // ë¹¨ê°„ìƒ‰
                message.textContent = 'íŒ¨ë°°';
                message.style.color = '#e94560'; // ë¹¨ê°„ìƒ‰
            }

            modal.style.display = 'block';
            
            // 10ì´ˆ í›„ ë©”ì¸í™”ë©´ìœ¼ë¡œ ì´ë™
            setTimeout(() => {
                gameState.isMenu = true;
                gameState.isGameOver = false;
                modal.style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
                gameState.round = 1;
                gameState.playerWins = 0;
                gameState.enemyWins = 0;
                gameState.gameTime = 180;
                gameState.roundWins = [];
            }, 10000);
        }

        // ê²Œì„ ì¬ì‹œì‘
        function restartGame() {
            // ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
            gameState.isMenu = true;
            gameState.isGameOver = false;
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            
            // ì²« ë¼ìš´ë“œ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
            gameState.isPaused = true;
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.isPaused = false;
                }
            }, 1000);

            player.x = canvas.width * 0.2;
            player.y = canvas.height * 0.5;
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.hasCritical = false;
            player.hasDoubleShot = false;
            player.hasDodge = false;
            player.hasRevive = false;
            player.hasDeepWound = false;
            player.hasOneShotOneKill = false;
            player.hasPoisonBullet = false;
            player.hasReloadHeal = false;
            player.hasSurvivalInstinct = false;
            player.hasLastBullet = false;
            player.hasRecoveryContract = false;
            player.hasRecoveryContractUsed = false;
            player.hasFocusedFire = false;
            player.hasShotgun = false;
            player.hasRagged = false;
            player.hasGhost = false;
            player.hasFortify = false;
            player.isFortified = false;
            player.fortifyStartTime = 0;
            player.lastPosition = { x: player.x, y: player.y };
            player.stationaryTime = 0;
            player.hasOverheat = false;
            player.overheatHitCount = 0;
            player.lastHitTime = 0;
            player.hasGamble = false;
            player.hasWeaken = false;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.hasDamageBoost = false;
            player.hasLightning = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.hasShield = false;
            player.shieldReady = false;
            player.shieldCooldown = 0;
            player.hasRegeneration = false;
            player.lastRegenTime = 0;
            player.hasEvasiveManeuver = false;
            player.hasCombatExperience = false;
            player.combatExperienceRounds = 0;
            player.hasHallucination = false;
            player.hasTasteOfBlood = false;
            player.hasCannon = false;
            player.hasTimeBarrier = false;
            player.timeBarrierRadius = 150;
            player.hasBouncyBullet = false;
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.poisonEffects = [];
            player.isDodging = false;
            player.dodgeStartTime = 0;
            player.dodgeEndTime = 0;
            player.dodgeStartX = 0;
            player.dodgeStartY = 0;
            player.dodgeTargetX = 0;
            player.dodgeTargetY = 0;
            player.dodgeTrail = [];
            player.lastDodgeTime = 0;
            player.isReviving = false;
            player.reviveTime = 0;
            player.hasRevived = false; // ë¶€í™œ ì‚¬ìš© ì—¬ë¶€ ì´ˆê¸°í™”
            player.isInvincible = false;
            player.invincibleEndTime = 0;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.damage = 1;
            player.speed = 3;
            player.reloadTime = 3000;
            player.reloadStartTime = 0;
            player.shootCooldown = 1000;

            enemy.x = canvas.width * 0.8;
            enemy.y = canvas.height * 0.5;
            enemy.health = 5;
            enemy.displayHealth = 5;
            enemy.maxHealth = 5;
            enemy.ammo = 6;
            enemy.maxAmmo = 6;
            enemy.bullets = [];
            enemy.augmentations = [];
            enemy.bulletSpeedMultiplier = 1;
            enemy.bulletSizeMultiplier = 1;
            enemy.hasCritical = false;
            enemy.hasDoubleShot = false;
            enemy.hasDodge = false;
            enemy.hasRevive = false;
            enemy.hasRevived = false; // ë¶€í™œ ì‚¬ìš© ì—¬ë¶€ ì´ˆê¸°í™”
            enemy.hasDeepWound = false;
            enemy.hasOneShotOneKill = false;
            enemy.hasPoisonBullet = false;
            enemy.hasReloadHeal = false;
            enemy.hasSurvivalInstinct = false;
            enemy.hasLastBullet = false;
            enemy.hasRecoveryContract = false;
            enemy.hasRecoveryContractUsed = false;
            enemy.hasFocusedFire = false;
            enemy.hasEvasiveManeuver = false;
            enemy.hasCombatExperience = false;
            enemy.combatExperienceRounds = 0;
            enemy.hasHallucination = false;
            enemy.hasTasteOfBlood = false;
            enemy.hasCannon = false;
            enemy.hasTimeBarrier = false;
            enemy.timeBarrierRadius = 150;
            enemy.hasBouncyBullet = false;
            enemy.isVulnerable = false;
            enemy.vulnerabilityUsed = false;
            enemy.poisonEffects = [];
            enemy.isDodging = false;
            enemy.dodgeStartTime = 0;
            enemy.dodgeEndTime = 0;
            enemy.dodgeStartX = 0;
            enemy.dodgeStartY = 0;
            enemy.dodgeTargetX = 0;
            enemy.dodgeTargetY = 0;
            enemy.bulletDodgeTargetY = 0;
            enemy.isDodgingBullet = false;
            enemy.lastPlayerBulletCount = 0;
            enemy.dodgeTrail = [];
            enemy.lastDodgeTime = 0;
            enemy.isReviving = false;
            enemy.reviveTime = 0;
            enemy.hasRevived = false; // ë¶€í™œ ì‚¬ìš© ì—¬ë¶€ ì´ˆê¸°í™”
            enemy.isInvincible = false;
            enemy.invincibleEndTime = 0;
            enemy.slowEndTime = 0;
            enemy.damageNumbers = [];
            enemy.usePrediction = false;
            enemy.lastPlayerX = 0;
            enemy.lastPlayerY = 0;
            enemy.playerVelocity = { x: 0, y: 0 };
            enemy.damage = 1;
            enemy.reloadTime = 3000;
            enemy.reloadStartTime = 0;
            enemy.shootCooldown = 1000;

            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('augmentModal').style.display = 'none';
        }

        // ë‘¥ê·¼ ì‚¬ê°í˜• ê·¸ë¦¬ê¸° í—¬í¼ í•¨ìˆ˜
        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            // ìƒë‹¨ ì™¼ìª½
            ctx.moveTo(x + radius, y);
            // ìƒë‹¨ ì˜¤ë¥¸ìª½
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            // ì˜¤ë¥¸ìª½ ì•„ë˜
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            // ì•„ë˜ ì™¼ìª½
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            // ì™¼ìª½ ìœ„
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
        }

        // ì²´ë ¥ í‘œì‹œ ê·¸ë¦¬ê¸° (ì§ì‚¬ê°í˜• ë°”)
        function drawHealthHearts(character, x, y, isPlayer) {
            const fixedBarWidth = 150; // ê³ ì •ëœ ë°” ê¸¸ì´ (200 -> 150)
            const barHeight = 20;
            const borderRadius = 4;
            const color = isPlayer ? '#4a9eff' : '#e94560';
            
            // ë°°ê²½ (ë¹ˆ ë°”)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
            ctx.fill();
            
            // ì±„ì›Œì§„ ë¶€ë¶„ (ì• ë‹ˆë©”ì´ì…˜)
            const fillRatio = Math.max(0, Math.min(1, character.displayHealth / character.maxHealth));
            const fillWidth = fixedBarWidth * fillRatio;
            
            if (fillWidth > 0) {
                ctx.fillStyle = color;
                // ë¶€ë¶„ ì±„ìš°ê¸°ë¥¼ ìœ„í•´ í´ë¦¬í•‘ ì‚¬ìš©
                if (fillWidth < fixedBarWidth) {
                    ctx.save();
                    ctx.beginPath();
                    drawRoundedRect(x, y, fillWidth, barHeight, borderRadius);
                    ctx.clip();
                    drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                ctx.fill();
                    ctx.restore();
                } else {
                    drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                    ctx.fill();
                }
            }
                
                // í…Œë‘ë¦¬
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
            drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                ctx.stroke();
        }

        // ì¦ê°• ì•„ì´ì½˜ ê·¸ë¦¬ê¸°
        function drawAugmentIcon(ctx, x, y, size, augId) {
            ctx.save();
            ctx.translate(x, y);
            
            switch(augId) {
                case 'health':
                    // ì²´ë ¥: í•˜íŠ¸ ëª¨ì–‘ (ì¤‘ì•™ ì •ë ¬, ì¡°ê¸ˆ ë” ìœ„ë¡œ)
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * -0.05);
                    ctx.bezierCurveTo(0, -size * 0.35, -size * 0.4, -size * 0.35, -size * 0.4, size * -0.05);
                    ctx.bezierCurveTo(-size * 0.4, size * 0.2, 0, size * 0.45, 0, size * 0.45);
                    ctx.bezierCurveTo(0, size * 0.45, size * 0.4, size * 0.2, size * 0.4, size * -0.05);
                    ctx.bezierCurveTo(size * 0.4, -size * 0.35, 0, -size * 0.35, 0, size * -0.05);
                    ctx.fill();
                    break;
                case 'speed':
                    // ì†ë„: í™”ì‚´í‘œ
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, 0);
                    ctx.lineTo(size * 0.3, 0);
                    ctx.lineTo(0, -size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, 0);
                    ctx.lineTo(0, size * 0.4);
                    ctx.lineTo(size * 0.3, 0);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bulletSpeed':
                    // ì´ì•Œ ì†ë„: ë²ˆê°œ
                    ctx.fillStyle = '#ffaa00'; // íŒŒìŠ¤í…” ì˜¤ë Œì§€
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.4);
                    ctx.lineTo(size * 0.1, 0);
                    ctx.lineTo(-size * 0.1, 0);
                    ctx.lineTo(size * 0.2, size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'ammo':
                    // íƒ„ì•½: ì›
                    ctx.fillStyle = '#ffffff'; // íŒŒìŠ¤í…” í™”ì´íŠ¸
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'fireRate':
                    // ë°œì‚¬ ì†ë„: ë³„
                    ctx.fillStyle = '#ff00ff'; // íŒŒìŠ¤í…” ë§ˆì  íƒ€
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.4 : size * 0.2;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'reload':
                    // ì¬ì¥ì „: ì‹œê³„
                    ctx.strokeStyle = '#00ffff'; // íŒŒìŠ¤í…” ì‹œì•ˆ
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -size * 0.3);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.2, 0);
                    ctx.stroke();
                    break;
                case 'critical':
                    // í¬ë¦¬í‹°ì»¬: X í‘œì‹œ
                    ctx.strokeStyle = '#ff0000'; // íŒŒìŠ¤í…” ë ˆë“œ
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, -size * 0.3);
                    ctx.lineTo(size * 0.3, size * 0.3);
                    ctx.moveTo(size * 0.3, -size * 0.3);
                    ctx.lineTo(-size * 0.3, size * 0.3);
                    ctx.stroke();
                    break;
                case 'doubleShot':
                    // ë”ë¸”ìƒ·: ë‘ ê°œì˜ ì›
                    ctx.fillStyle = '#ffc107'; // íŒŒìŠ¤í…” ì˜ë¡œìš°
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.2, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'dodge':
                    // êµ¬ë¥´ê¸°: ëŒ€ì‹œì„ 
                    ctx.strokeStyle = '#8888ff'; // íŒŒìŠ¤í…” ë¸”ë£¨
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.4, 0);
                    ctx.lineTo(size * 0.4, 0);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    break;
                case 'revive':
                    // ë¶€í™œ: ì‹­ìê°€
                    ctx.fillStyle = '#00ff88'; // íŒŒìŠ¤í…” ê·¸ë¦°
                    ctx.fillRect(-size * 0.15, -size * 0.4, size * 0.3, size * 0.8);
                    ctx.fillRect(-size * 0.4, -size * 0.15, size * 0.8, size * 0.3);
                    break;
                case 'deepWound':
                    // ê¹Šì€ ìƒì²˜: ì¹¼
                    ctx.fillStyle = '#880000';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.1, size * 0.2);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.1, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'giant':
                    // ê±°ëŒ€í™”: í° ì‚¬ê°í˜•
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-size * 0.4, -size * 0.4, size * 0.8, size * 0.8);
                    // ë‚´ë¶€ ì‘ì€ ì‚¬ê°í˜•
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(-size * 0.25, -size * 0.25, size * 0.5, size * 0.5);
                    break;
                case 'sniper':
                    // ì €ê²©ìˆ˜: ìŠ¤ì½”í”„
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    // ì™¸ë¶€ ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    // ì‹­ìì„ 
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.4, 0);
                    ctx.lineTo(size * 0.4, 0);
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(0, size * 0.4);
                    ctx.stroke();
                    // ì¤‘ì•™ ì 
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'oneShotOneKill':
                    // ì›ìƒ·ì›í‚¬: í° ì´ì•Œ
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    // ì¤‘ì•™ X
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.2);
                    ctx.lineTo(size * 0.2, size * 0.2);
                    ctx.moveTo(size * 0.2, -size * 0.2);
                    ctx.lineTo(-size * 0.2, size * 0.2);
                    ctx.stroke();
                    break;
                case 'poisonBullet':
                    // ë… íƒ„í™˜: ë… ë°©ìš¸
                    ctx.fillStyle = '#006600';
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.1, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // ì‘ì€ ë°©ìš¸
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, size * 0.15, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, size * 0.15, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'reloadHeal':
                    // ì¬ì¥ì „ íšŒë³µ: í•˜íŠ¸ + í™”ì‚´í‘œ
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.3, -size * 0.1, -size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.3, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.3, size * 0.3, size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(size * 0.3, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    // í™”ì‚´í‘œ
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(size * 0.2, 0);
                    ctx.lineTo(0, -size * 0.2);
                    ctx.lineTo(0, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bigBullet':
                    // í° íƒ„í™˜: í° ì›
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // ë‚´ë¶€ ì‘ì€ ì›
                    ctx.fillStyle = '#888888';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'survivalInstinct':
                    // ìƒì¡´ë³¸ëŠ¥: ë²ˆê°œ + í•˜íŠ¸
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.3);
                    ctx.lineTo(size * 0.1, 0);
                    ctx.lineTo(-size * 0.1, 0);
                    ctx.lineTo(size * 0.2, size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.25, -size * 0.1, -size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.25, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.25, size * 0.3, size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(size * 0.25, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    break;
                case 'lastBullet':
                    // ë¹„ì¥ì˜ í•œë°œ: í° ì´ì•Œ + ë³„
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-size * 0.3, -size * 0.15, size * 0.6, size * 0.3);
                    ctx.fillStyle = '#ffc107';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.2 : size * 0.1;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'recoveryContract':
                    // íšŒë³µê³„ì•½: í•˜íŠ¸ + í™”ì‚´í‘œ ìœ„
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.3, -size * 0.1, -size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.3, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.3, size * 0.3, size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(size * 0.3, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(-size * 0.15, -size * 0.1);
                    ctx.lineTo(size * 0.15, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'focusedFire':
                    // ì§‘ì¤‘ ì‚¬ê²©: ëˆˆ ëª¨ì–‘
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, 0, size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, 0, size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, 0, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, 0, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'ghost':
                    // ìœ ë ¹: ë°˜íˆ¬ëª… ì› + ì‘ì€ ì›ë“¤
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#cccccc';
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.1, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // ì‘ì€ ì›ë“¤ (ìœ ë ¹ ëŠë‚Œ)
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, size * 0.1, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, size * 0.1, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    break;
                case 'fortify':
                    // ê±°ì í™•ë³´: ë°©íŒ¨ ëª¨ì–‘
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    // ë°©íŒ¨ ë³¸ì²´
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.3, -size * 0.2);
                    ctx.lineTo(-size * 0.3, size * 0.2);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.3, size * 0.2);
                    ctx.lineTo(size * 0.3, -size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // ì‹­ìê°€
                    ctx.strokeStyle = '#000000';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.2);
                    ctx.lineTo(0, size * 0.1);
                    ctx.moveTo(-size * 0.15, -size * 0.05);
                    ctx.lineTo(size * 0.15, -size * 0.05);
                    ctx.stroke();
                    break;
                case 'overheat':
                    // ê³¼ì—´: ë¶ˆê½ƒ ëª¨ì–‘
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.2, -size * 0.1);
                    ctx.lineTo(-size * 0.15, size * 0.1);
                    ctx.lineTo(0, size * 0.2);
                    ctx.lineTo(size * 0.15, size * 0.1);
                    ctx.lineTo(size * 0.2, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ì‘ì€ ë¶ˆê½ƒë“¤
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.2);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.lineTo(0, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(size * 0.1, -size * 0.2);
                    ctx.lineTo(size * 0.05, 0);
                    ctx.lineTo(0, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'gamble':
                    // ë„ë°•: ì£¼ì‚¬ìœ„ ëª¨ì–‘
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
                    // ì£¼ì‚¬ìœ„ ëˆˆ
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, -size * 0.15, size * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, size * 0.15, size * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'weaken':
                    // ì•½í™”: ì•„ë˜ í™”ì‚´í‘œ
                    ctx.fillStyle = '#888888';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(-size * 0.2, size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.2, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ê°ì†Œ í‘œì‹œ
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, size * 0.2);
                    ctx.lineTo(size * 0.15, size * 0.2);
                    ctx.stroke();
                    break;
                case 'damageBoost':
                    // ë°ë¯¸ì§€ 1.2ë°°: ìœ„ í™”ì‚´í‘œ
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(-size * 0.2, -size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.2, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ì¦ê°€ í‘œì‹œ
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, -size * 0.2);
                    ctx.lineTo(size * 0.15, -size * 0.2);
                    ctx.stroke();
                    break;
                case 'lightning':
                    // ë²ˆê°œ: ë²ˆê°œ ëª¨ì–‘
                    ctx.fillStyle = '#ffff00';
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.4);
                    ctx.lineTo(size * 0.1, -size * 0.2);
                    ctx.lineTo(-size * 0.05, -size * 0.1);
                    ctx.lineTo(size * 0.15, size * 0.2);
                    ctx.lineTo(-size * 0.1, size * 0.3);
                    ctx.lineTo(0, size * 0.1);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'shield':
                    // ë°©ì–´ë§‰: ë°©íŒ¨ ëª¨ì–‘
                    ctx.fillStyle = '#0066ff';
                    ctx.strokeStyle = '#0044cc';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.3, -size * 0.2);
                    ctx.lineTo(-size * 0.3, size * 0.1);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.3, size * 0.1);
                    ctx.lineTo(size * 0.3, -size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'regeneration':
                    // ì¬ìƒ: í•˜íŠ¸ + í”ŒëŸ¬ìŠ¤
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.25, -size * 0.1, -size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.25, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.25, size * 0.3, size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(size * 0.25, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    // í”ŒëŸ¬ìŠ¤ í‘œì‹œ
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-size * 0.1, -size * 0.05, size * 0.2, size * 0.03);
                    ctx.fillRect(-size * 0.05, -size * 0.1, size * 0.03, size * 0.2);
                    break;
                case 'shotgun':
                    // ìƒ·ê±´: ì‚°íƒ„ì´ ëª¨ì–‘
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-size * 0.4, -size * 0.1, size * 0.8, size * 0.2);
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(-size * 0.35, -size * 0.05, size * 0.7, size * 0.1);
                    break;
                case 'ragged':
                    // ë‹¤ë‹¤ìµì„ : ê¹¨ì§„ ì´ì•Œ
                    ctx.fillStyle = '#888888';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.2);
                    ctx.lineTo(size * 0.2, size * 0.2);
                    ctx.stroke();
                    break;
                case 'evasiveManeuver':
                    // íšŒí”¼ê¸°ë™: í™”ì‚´í‘œ + ë²ˆê°œ
                    ctx.fillStyle = '#4a9eff';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(-size * 0.2, size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.2, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.1);
                    ctx.lineTo(size * 0.1, size * 0.1);
                    ctx.moveTo(size * 0.1, -size * 0.1);
                    ctx.lineTo(-size * 0.1, size * 0.1);
                    ctx.stroke();
                    break;
                case 'combatExperience':
                    // ì „íˆ¬ ê²½í—˜: ë³„
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.3 : size * 0.15;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'hallucination':
                    // í™˜ê°: ë¬¼ê²° ëª¨ì–‘
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = -size * 0.4; i <= size * 0.4; i += 5) {
                        const y = Math.sin(i * 0.2) * size * 0.2;
                        if (i === -size * 0.4) ctx.moveTo(i, y);
                        else ctx.lineTo(i, y);
                    }
                    ctx.stroke();
                    break;
                case 'tasteOfBlood':
                    // í”¼ì˜ ë§›: ë¹¨ê°„ í•˜íŠ¸
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.25, -size * 0.1, -size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.25, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.25, size * 0.3, size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(size * 0.25, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    break;
                case 'cannon':
                    // ëŒ€í¬: í° ì›
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
                case 'timeBarrier':
                    // ì‹œê°„ì¥ë§‰: ì› + ì‹œê³„
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    // ì‹œê³„ ë°”ëŠ˜
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -size * 0.2);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.15, size * 0.1);
                    ctx.stroke();
                    break;
                case 'bouncyBullet':
                    // í†µí†µíƒ„: íŠ•ê¸°ëŠ” í™”ì‚´í‘œ
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    // ìœ„ìª½ í™”ì‚´í‘œ
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(-size * 0.15, -size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.15, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ì•„ë˜ìª½ í™”ì‚´í‘œ (ë°˜ëŒ€ ë°©í–¥)
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(-size * 0.15, size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.15, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                default:
                    // ê¸°ë³¸: ì‚¬ê°í˜•
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
            }
            
            ctx.restore();
        }

        // ì¦ê°• ì•„ì´ì½˜ ëª©ë¡ ê·¸ë¦¬ê¸°
        function drawAugmentIcons(character, x, y, align = 'left') {
            const iconSize = 32; // 2ë°° ì¦ê°€ (16 -> 32)
            const spacing = 8; // ê°„ê²©ë„ 2ë°° ì¦ê°€
            const bgSize = iconSize + 4; // ë°°ê²½ í¬ê¸°
            
            // ë§ˆìš°ìŠ¤ í˜¸ë²„ ê°ì§€
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseCanvasX = (mouse.x - rect.left) * scaleX;
            const mouseCanvasY = (mouse.y - rect.top) * scaleY;
            
            character.augmentations.forEach((aug, index) => {
                let iconX;
                if (align === 'right') {
                    iconX = x - (character.augmentations.length - index - 1) * (iconSize + spacing) - iconSize / 2;
                } else {
                    iconX = x + index * (iconSize + spacing) + iconSize / 2;
                }
                
                // ë§ˆìš°ìŠ¤ í˜¸ë²„ ì²´í¬
                const iconLeft = iconX - bgSize / 2;
                const iconRight = iconX + bgSize / 2;
                const iconTop = y - bgSize / 2;
                const iconBottom = y + bgSize / 2;
                
                if (mouseCanvasX >= iconLeft && mouseCanvasX <= iconRight &&
                    mouseCanvasY >= iconTop && mouseCanvasY <= iconBottom) {
                    hoveredAugment = {
                        aug: aug,
                        x: iconX,
                        y: y
                    };
                }
                
                // ë°°ê²½ ì‚¬ê°í˜• (í˜¸ë²„ ì‹œ ê°•ì¡°)
                if (hoveredAugment && hoveredAugment.aug === aug) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                }
                ctx.fillRect(iconX - bgSize / 2, y - bgSize / 2, bgSize, bgSize);
                
                // ì•„ì´ì½˜ ê·¸ë¦¬ê¸°
                drawAugmentIcon(ctx, iconX, y, iconSize, aug.id);
            });
        }

        // íƒ„í™˜ìˆ˜ í‘œì‹œ (ì²´ë ¥ ì•„ë˜ - í•˜ì–€ìƒ‰ ì›)
        function drawAmmoCount(character, x, y, align = 'left') {
            const circleSize = 12; // ì²´ë ¥ë°”(30px)ë³´ë‹¤ ë” ì‘ì€ ì›
            const spacing = 4;
            const radius = circleSize / 2;
            const centerY = y + radius; // ì›ì˜ ì¤‘ì‹¬ Y ì¢Œí‘œ
            
            // ì´ íƒ„í™˜ìˆ˜ë§Œí¼ ì› ê·¸ë¦¬ê¸° (ì‚¬ìš©í•œ íƒ„í™˜ì€ ë°˜íˆ¬ëª…)
            for (let i = 0; i < character.maxAmmo; i++) {
                if (i < character.ammo) {
                    // ë‚¨ì€ íƒ„í™˜: ë¶ˆíˆ¬ëª… í•˜ì–€ìƒ‰
                    ctx.fillStyle = '#ffffff'; // íŒŒìŠ¤í…” í™”ì´íŠ¸
                } else {
                    // ì‚¬ìš©í•œ íƒ„í™˜: ë°˜íˆ¬ëª…
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                }
                
                let centerX;
                if (align === 'right') {
                    // ì˜¤ë¥¸ìª½ ì •ë ¬: ì˜¤ë¥¸ìª½ë¶€í„° ì™¼ìª½ìœ¼ë¡œ
                    centerX = x - (character.maxAmmo - i - 1) * (circleSize + spacing) - radius;
                } else {
                    // ì™¼ìª½ ì •ë ¬: ì™¼ìª½ë¶€í„° ì˜¤ë¥¸ìª½ìœ¼ë¡œ
                    centerX = x + i * (circleSize + spacing) + radius;
                }
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ë§ˆë¦„ëª¨ ê·¸ë¦¬ê¸° í•¨ìˆ˜
        function drawDiamond(x, y, size, color) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2); // ìœ„
            ctx.lineTo(x + size / 2, y); // ì˜¤ë¥¸ìª½
            ctx.lineTo(x, y + size / 2); // ì•„ë˜
            ctx.lineTo(x - size / 2, y); // ì™¼ìª½
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ (ë§ˆë¦„ëª¨ ì•„ë˜)
        function drawCountdown() {
            const countdownValue = gameState.countdown > 0 ? gameState.countdown : gameState.augmentCountdown;
            if (countdownValue <= 0) return;
            
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const y = 100; // ë§ˆë¦„ëª¨ ì•„ë˜
            
            // ë°˜íˆ¬ëª… ë°°ê²½
            const textWidth = ctx.measureText(countdownValue).width;
            const padding = 30;
            ctx.fillRect(
                canvas.width / 2 - textWidth / 2 - padding,
                y - 50,
                textWidth + padding * 2,
                100
            );
            
            // ìˆ«ì í‘œì‹œ
            ctx.fillStyle = '#ffffff';
            ctx.fillText(countdownValue, canvas.width / 2, y);
            ctx.restore();
        }

        // ìŠ¹ë¦¬ í‘œì‹œ ë§ˆë¦„ëª¨ ê·¸ë¦¬ê¸° (í™”ë©´ ìœ„ìª½ ê°€ìš´ë°)
        function drawWinIndicators() {
            const totalRounds = 7;
            const diamondSize = 20;
            const spacing = 5;
            const totalWidth = (totalRounds * diamondSize) + ((totalRounds - 1) * spacing);
            const startX = (canvas.width - totalWidth) / 2;
            const y = 35; // ì‚´ì§ ì•„ë˜ë¡œ ë‚´ë¦¼

            for (let i = 0; i < totalRounds; i++) {
                let color;
                // ë¼ìš´ë“œ ìˆœì„œëŒ€ë¡œ ìŠ¹ìë¥¼ í‘œì‹œ
                if (i < gameState.roundWins.length) {
                    if (gameState.roundWins[i] === 'player') {
                        // í”Œë ˆì´ì–´ ìŠ¹ë¦¬: íŒŒë€ìƒ‰
                        color = 'rgba(74, 158, 255, 0.8)';
                    } else {
                        // ì  ìŠ¹ë¦¬: ë¹¨ê°„ìƒ‰
                        color = 'rgba(233, 69, 96, 0.8)';
                    }
                } else {
                    // ì•„ì§ ì§„í–‰ë˜ì§€ ì•Šì€ ë¼ìš´ë“œ: ë°˜íˆ¬ëª… íšŒìƒ‰
                    color = 'rgba(255, 255, 255, 0.2)';
                }
                
                const x = startX + i * (diamondSize + spacing) + diamondSize / 2;
                drawDiamond(x, y, diamondSize, color);
            }
        }

        // ì¬ì¥ì „ ì§„í–‰ë¥  ë°” ê·¸ë¦¬ê¸° (ë™ê·¸ë€ ë°”ë¡œ)
        function drawReloadBar(character, x, y) {
            if (!character.isReloading) return;
            
            const now = Date.now();
            const elapsed = now - character.reloadStartTime;
            const progress = Math.min(elapsed / character.reloadTime, 1); // 0~1 ì‚¬ì´ ê°’
            
            const radius = 8; // ì›ì˜ ë°˜ì§€ë¦„ (20% ì¤„ì„: 10 -> 8)
            const lineWidth = 4; // ì„  ë‘ê»˜ (30% ëŠ˜ë¦¼: 3 -> 4)
            
            // ë°°ê²½ ì› (íšŒìƒ‰)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ì§„í–‰ë¥  ì› (í•˜ì–€ìƒ‰)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(x, y, radius, -Math.PI / 2, -Math.PI / 2 + (progress * Math.PI * 2));
            ctx.stroke();
        }

        // ê·¸ë¦¬ê¸° í•¨ìˆ˜
        // ê²Œì„ ì‹œì‘ í•¨ìˆ˜ë“¤
        // ë³¸ ì¦ê°• ëª©ë¡ ê´€ë¦¬ (localStorage ì‚¬ìš©)
        function getSeenAugments() {
            const seen = localStorage.getItem('seenAugments');
            return seen ? JSON.parse(seen) : [];
        }

        function markAugmentAsSeen(augmentId) {
            const seen = getSeenAugments();
            if (!seen.includes(augmentId)) {
                seen.push(augmentId);
                localStorage.setItem('seenAugments', JSON.stringify(seen));
            }
        }

        // ë„ê° ëª¨ë‹¬ ì—´ê¸°
        function openCollectionModal() {
            const modal = document.getElementById('collectionModal');
            const content = document.getElementById('collectionContent');
            const seenAugments = getSeenAugments();
            const canvas = document.getElementById('gameCanvas');
            
            content.innerHTML = '';
            
            augmentations.forEach(aug => {
                const isSeen = seenAugments.includes(aug.id);
                const item = document.createElement('div');
                item.className = 'collection-item' + (isSeen ? '' : ' locked');
                item.innerHTML = `
                    <h4>${isSeen ? aug.name : '???'}</h4>
                    <p>${isSeen ? aug.description : '??? (ì•„ì§ ë°œê²¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤)'}</p>
                `;
                content.appendChild(item);
            });
            
            // ê²Œì„ ìº”ë²„ìŠ¤ í´ë¦­ ì°¨ë‹¨
            if (canvas) {
                canvas.style.pointerEvents = 'none';
            }
            
            modal.style.display = 'block';
        }

        // ë„ê° ëª¨ë‹¬ ë‹«ê¸°
        function closeCollectionModal() {
            const modal = document.getElementById('collectionModal');
            const canvas = document.getElementById('gameCanvas');
            
            modal.style.display = 'none';
            
            // ê²Œì„ ìº”ë²„ìŠ¤ í´ë¦­ ë³µêµ¬
            if (canvas) {
                canvas.style.pointerEvents = 'auto';
            }
        }

        // ì¡°ì‘ë²• ëª¨ë‹¬ ì—´ê¸°
        function openControlsModal() {
            const modal = document.getElementById('controlsModal');
            modal.style.display = 'block';
        }

        // ì¡°ì‘ë²• ëª¨ë‹¬ ë‹«ê¸°
        function closeControlsModal() {
            const modal = document.getElementById('controlsModal');
            modal.style.display = 'none';
        }


        function startSoloGame() {
            gameState.isMenu = false;
            document.getElementById('mainMenu').style.display = 'none';
            initGame();
        }

        function initGame() {
            // ìº”ë²„ìŠ¤ í¬ê¸° ì¬í™•ì¸
            resizeCanvas();
            
            // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
            gameState.round = 1;
            gameState.playerWins = 0;
            gameState.enemyWins = 0;
            gameState.gameTime = 180;
            gameState.isGameOver = false;
            gameState.isPaused = true;
            gameState.roundWins = [];
            gameState.countdown = 3;
            gameState.augmentCountdown = 0;
            gameState.showOpponentSelecting = false;

            // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
            player.x = canvas.width * 0.2;
            player.y = canvas.height * 0.5;
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.angle = 0;
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.hasCritical = false;
            player.hasDoubleShot = false;
            player.hasDodge = false;
            player.hasRevive = false;
            player.hasRevived = false;
            player.hasDeepWound = false;
            player.hasOneShotOneKill = false;
            player.hasPoisonBullet = false;
            player.hasReloadHeal = false;
            player.hasSurvivalInstinct = false;
            player.hasLastBullet = false;
            player.hasRecoveryContract = false;
            player.hasRecoveryContractUsed = false;
            player.hasFocusedFire = false;
            player.hasShotgun = false;
            player.hasRagged = false;
            player.hasGhost = false;
            player.hasFortify = false;
            player.isFortified = false;
            player.fortifyStartTime = 0;
            player.lastPosition = { x: player.x, y: player.y };
            player.stationaryTime = 0;
            player.hasOverheat = false;
            player.overheatHitCount = 0;
            player.lastHitTime = 0;
            player.hasGamble = false;
            player.hasWeaken = false;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.hasDamageBoost = false;
            player.hasLightning = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.hasShield = false;
            player.shieldReady = false;
            player.shieldCooldown = 0;
            player.hasRegeneration = false;
            player.lastRegenTime = 0;
            player.hasEvasiveManeuver = false;
            player.hasCombatExperience = false;
            player.combatExperienceRounds = 0;
            player.hasHallucination = false;
            player.hasTasteOfBlood = false;
            player.hasCannon = false;
            player.hasTimeBarrier = false;
            player.timeBarrierRadius = 150;
            player.hasBouncyBullet = false;
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.poisonEffects = [];
            player.isDodging = false;
            player.isReviving = false;
            player.isInvincible = false;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.damage = 1;
            player.speed = 3;
            player.reloadTime = 3000;
            player.isReloading = false;
            player.reloadStartTime = 0;
            player.shootCooldown = 1000;
            player.lastShot = 0;

            // enemy ì´ˆê¸°í™”
                enemy.x = canvas.width * 0.8;
                enemy.y = canvas.height * 0.5;
                enemy.health = 5;
                enemy.displayHealth = 5;
                enemy.maxHealth = 5;
                enemy.ammo = 6;
                enemy.maxAmmo = 6;
                enemy.bullets = [];
                enemy.augmentations = [];
                enemy.angle = Math.PI;
                enemy.bulletSpeedMultiplier = 1;
                enemy.bulletSizeMultiplier = 1;
                enemy.hasCritical = false;
                enemy.hasDoubleShot = false;
                enemy.hasDodge = false;
                enemy.hasRevive = false;
                enemy.hasRevived = false;
                enemy.hasDeepWound = false;
                enemy.hasOneShotOneKill = false;
                enemy.hasPoisonBullet = false;
                enemy.hasReloadHeal = false;
                enemy.hasSurvivalInstinct = false;
                enemy.hasLastBullet = false;
                enemy.hasRecoveryContract = false;
                enemy.hasRecoveryContractUsed = false;
                enemy.hasFocusedFire = false;
            enemy.hasShotgun = false;
            enemy.hasRagged = false;
            enemy.hasGhost = false;
            enemy.hasFortify = false;
            enemy.isFortified = false;
            enemy.fortifyStartTime = 0;
            enemy.lastPosition = { x: enemy.x, y: enemy.y };
            enemy.stationaryTime = 0;
            enemy.hasOverheat = false;
            enemy.overheatHitCount = 0;
            enemy.lastHitTime = 0;
            enemy.hasGamble = false;
            enemy.hasWeaken = false;
            enemy.isWeakened = false;
            enemy.weakenEndTime = 0;
            enemy.hasDamageBoost = false;
            enemy.hasLightning = false;
            enemy.isStunned = false;
            enemy.stunEndTime = 0;
            enemy.hasShield = false;
            enemy.shieldReady = false;
            enemy.shieldCooldown = 0;
            enemy.hasRegeneration = false;
            enemy.lastRegenTime = 0;
            enemy.hasEvasiveManeuver = false;
            enemy.hasCombatExperience = false;
            enemy.combatExperienceRounds = 0;
            enemy.hasHallucination = false;
            enemy.hasTasteOfBlood = false;
            enemy.hasCannon = false;
            enemy.hasTimeBarrier = false;
            enemy.timeBarrierRadius = 150;
            enemy.hasBouncyBullet = false;
            enemy.isVulnerable = false;
                enemy.vulnerabilityUsed = false;
                enemy.poisonEffects = [];
                enemy.isDodging = false;
                enemy.isReviving = false;
                enemy.isInvincible = false;
                enemy.slowEndTime = 0;
                enemy.damageNumbers = [];
                enemy.usePrediction = false;
                enemy.lastPlayerX = 0;
                enemy.lastPlayerY = 0;
                enemy.playerVelocity = { x: 0, y: 0 };
                enemy.damage = 1;
                enemy.speed = 2.5;
                enemy.reloadTime = 3000;
                enemy.isReloading = false;
                enemy.reloadStartTime = 0;
                enemy.shootCooldown = 1000;
                enemy.lastShot = 0;

            // ì²« ë¼ìš´ë“œ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
            const initialCountdown = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(initialCountdown);
                    gameState.isPaused = false;
                }
            }, 1000);
        }

        function draw() {
            // ë©”ë‰´ í™”ë©´ í‘œì‹œ
            if (gameState.isMenu) {
                return; // ë©”ë‰´ëŠ” HTMLë¡œ í‘œì‹œë˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ê·¸ë¦¬ì§€ ì•ŠìŒ
            }

            // í˜¸ë²„ëœ ì¦ê°• ì´ˆê¸°í™”
            hoveredAugment = null;
            
            // í™”ë©´ í”ë“¤ë¦¼ ì ìš©
            let shakeX = 0;
            let shakeY = 0;
            if (gameState.shake.duration > 0) {
                shakeX = (Math.random() - 0.5) * gameState.shake.intensity;
                shakeY = (Math.random() - 0.5) * gameState.shake.intensity;
                gameState.shake.duration = Math.max(0, gameState.shake.duration - 16); // ì•½ 60fps ê¸°ì¤€
                gameState.shake.intensity *= 0.9; // ì ì§„ì ìœ¼ë¡œ ê°ì†Œ
            }

            // ë°°ê²½ í´ë¦¬ì–´ (í”ë“¤ë¦¼ ì „ì— ê·¸ë¦¬ê¸°)
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // í™”ë©´ í”ë“¤ë¦¼ ì ìš©
            ctx.save();
            ctx.translate(shakeX, shakeY);

            // ê²©ì ê·¸ë¦¬ê¸°
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // ì´ì•Œ ê·¸ë¦¬ê¸°
            player.bullets.forEach(bullet => bullet.draw());
            enemy.bullets.forEach(bullet => bullet.draw());

            // êµ¬ë¥´ê¸° ì”ìƒ ê·¸ë¦¬ê¸°
            function drawDodgeTrail(character) {
                if (character.isDodging && character.dodgeTrail && character.dodgeTrail.length > 0) {
                    // ì”ìƒ íš¨ê³¼ (ê³¼ê±° ìœ„ì¹˜ ê·¸ë¦¬ê¸°)
                    character.dodgeTrail.forEach((trail, index) => {
                        const fadeAlpha = trail.alpha * (1 - index * 0.2); // ì ì§„ì ìœ¼ë¡œ íˆ¬ëª…
                        ctx.globalAlpha = Math.max(0, fadeAlpha);
                        ctx.fillStyle = character.color;
                        ctx.beginPath();
                        ctx.arc(trail.x, trail.y, character.radius * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;
                }
            }

            // ì  ê·¸ë¦¬ê¸°
            if (enemy.x > -500 && enemy.y > -500) {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                ctx.rotate(enemy.angle);
                
                // ê¸°ë³¸ alpha ì„¤ì •
                ctx.globalAlpha = 1.0;
                
                // ë¬´ì  ìƒíƒœë©´ ê¹œë¹¡ì„ íš¨ê³¼
                if (enemy.isInvincible) {
                    const blink = Math.floor(Date.now() / 100) % 2;
                    if (blink) {
                        ctx.globalAlpha = 0.5;
                    }
                }
                
                // êµ¬ë¥´ê¸° ì”ìƒ ê·¸ë¦¬ê¸°
                if (enemy.dodgeTrail && enemy.dodgeTrail.length > 0) {
                    enemy.dodgeTrail.forEach((trail, index) => {
                        ctx.save();
                        ctx.globalAlpha = trail.alpha * (index / enemy.dodgeTrail.length);
                        ctx.translate(trail.x - enemy.x, trail.y - enemy.y);
                        ctx.beginPath();
                        ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                        ctx.fillStyle = enemy.color;
                        ctx.fill();
                        ctx.restore();
                    });
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                ctx.fillStyle = enemy.color;
                ctx.fill();
                
                // ë¦¬ë³¼ë²„ ê·¸ë¦¬ê¸°
                ctx.fillStyle = '#333'; // íŒŒìŠ¤í…” ê·¸ë ˆì´
                ctx.fillRect(enemy.radius - 7.5, -4.5, 22.5, 9); // 1.5ë°° ì¦ê°€
                
                ctx.globalAlpha = 1.0; // ë³µì›
                ctx.restore();
                
                // ì  ì²´ë ¥ê³¼ íƒ„í™˜ìˆ˜ëŠ” UI ì˜ì—­ì—ì„œ í‘œì‹œë¨
                
                // ì  ì¬ì¥ì „ ë°” í‘œì‹œ (ì  ë°”ë¡œ ì˜¤ë¥¸ìª½ ìœ„) - ì  ìœ„ì¹˜ì— í”ë“¤ë¦¼ ì ìš©
                if (enemy.isReloading) {
                    drawReloadBar(enemy, enemy.x + 40 + shakeX, enemy.y - 40 + shakeY);
                }
            }

            // ì‹œê°„ì¥ë§‰ ê·¸ë¦¬ê¸° (í”Œë ˆì´ì–´)
            if (player.hasTimeBarrier) {
                ctx.save();
                ctx.globalAlpha = 0.2; // íˆ¬ëª…ë„ê°€ ê°•í•œ ì´ˆë¡ìƒ‰
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x + shakeX, player.y + shakeY, player.timeBarrierRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // ì‹œê°„ì¥ë§‰ ê·¸ë¦¬ê¸° (ì )
            if (enemy.hasTimeBarrier && enemy.x > -500 && enemy.y > -500) {
                ctx.save();
                ctx.globalAlpha = 0.2; // íˆ¬ëª…ë„ê°€ ê°•í•œ ì´ˆë¡ìƒ‰
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(enemy.x + shakeX, enemy.y + shakeY, enemy.timeBarrierRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
            drawDodgeTrail(player);
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            
            // ë¬´ì  ìƒíƒœì¼ ë•Œ ë°˜íˆ¬ëª…
            ctx.globalAlpha = 1.0; // ê¸°ë³¸ê°’ ì„¤ì •
            if (player.isInvincible || player.isReviving) {
                ctx.globalAlpha = 0.5;
            } else if (player.hasGhost) {
                // ìœ ë ¹ ì¦ê°•: ì‚´ì§ íë ¤ì§€ê²Œ
                ctx.globalAlpha = 0.7;
            }
            
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
            ctx.fill();
            // ê±°ì í™•ë³´: í•˜ì–€ìƒ‰ í…Œë‘ë¦¬
            if (player.hasFortify && player.isFortified) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // ë°©ì–´ë§‰: ì§„í•œ íŒŒë€ìƒ‰ í…Œë‘ë¦¬
            if (player.hasShield && player.shieldReady) {
                ctx.strokeStyle = '#0066ff'; // ì§„í•œ íŒŒë€ìƒ‰
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            // ë¦¬ë³¼ë²„ ê·¸ë¦¬ê¸°
            ctx.fillStyle = '#333'; // íŒŒìŠ¤í…” ê·¸ë ˆì´
            ctx.fillRect(player.radius - 7.5, -4.5, 22.5, 9); // 1.5ë°° ì¦ê°€
            ctx.globalAlpha = 1.0;
            ctx.restore();

            // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼ ì¢…ë£Œ
            ctx.restore();
            
            // ë°ë¯¸ì§€ ìˆ«ì ê·¸ë¦¬ê¸° (í”ë“¤ë¦¼ ì˜í–¥ ë°›ìŒ)
            ctx.save();
            ctx.translate(shakeX, shakeY);
            drawDamageNumbers(player);
                drawDamageNumbers(enemy);
            ctx.restore();

            // UI ìš”ì†Œë“¤ (í”ë“¤ë¦¼ì˜ ì˜í–¥ì„ ë°›ì§€ ì•ŠìŒ)
            // ìŠ¹ë¦¬ í‘œì‹œ ë§ˆë¦„ëª¨ (í™”ë©´ ìœ„ìª½ ê°€ìš´ë°)
            drawWinIndicators();
            
            // ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ (ë§ˆë¦„ëª¨ ì•„ë˜)
            if (gameState.countdown > 0 || gameState.augmentCountdown > 0) {
                drawCountdown();
            }
            
            // ìƒëŒ€ ì„ íƒ ì¤‘ ë©”ì‹œì§€ í‘œì‹œ
            if (gameState.showOpponentSelecting) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const text = 'ìƒëŒ€ê°€ ì„ íƒì¤‘ì…ë‹ˆë‹¤';
                const textWidth = ctx.measureText(text).width;
                const padding = 40;
                const y = canvas.height / 2;
                
                // ë°°ê²½ ì‚¬ê°í˜•
                ctx.fillRect(
                    canvas.width / 2 - textWidth / 2 - padding,
                    y - 40,
                    textWidth + padding * 2,
                    80
                );
                
                // í…ìŠ¤íŠ¸
                ctx.fillStyle = '#ffffff';
                ctx.fillText(text, canvas.width / 2, y);
                ctx.restore();
            }
            
            // í”Œë ˆì´ì–´ ì²´ë ¥ í‘œì‹œ (ì™¼ìª½ ìœ„)
            const playerHealthY = 20;
            drawHealthHearts(player, 20, playerHealthY, true);
            // í”Œë ˆì´ì–´ íƒ„í™˜ìˆ˜ í‘œì‹œ (ì²´ë ¥ ì•„ë˜ - ì›ìœ¼ë¡œ)
            const playerAmmoY = playerHealthY + 40;
            drawAmmoCount(player, 20, playerAmmoY, 'left');
            // í”Œë ˆì´ì–´ ì¦ê°• ì•„ì´ì½˜ í‘œì‹œ (íƒ„í™˜ ì•„ë˜)
            drawAugmentIcons(player, 20, playerAmmoY + 50, 'left');
            // í”Œë ˆì´ì–´ ì¬ì¥ì „ ë°” í‘œì‹œ (í”Œë ˆì´ì–´ ë°”ë¡œ ì™¼ìª½ ìœ„) - í”Œë ˆì´ì–´ ìœ„ì¹˜ì— í”ë“¤ë¦¼ ì ìš©
            if (player.isReloading) {
                drawReloadBar(player, player.x - 40 + shakeX, player.y - 40 + shakeY); // ìºë¦­í„° í¬ê¸° ì¦ê°€ì— ë§ì¶° ì¡°ì •
            }
            
            // ì  ì²´ë ¥ í‘œì‹œ (ì˜¤ë¥¸ìª½ ìœ„)
            {
                const fixedBarWidth = 150; // ê³ ì •ëœ ë°” ê¸¸ì´
                const enemyHealthX = canvas.width - fixedBarWidth - 20;
                const enemyHealthY = 20;
                drawHealthHearts(enemy, enemyHealthX, enemyHealthY, false);
                // ì  íƒ„í™˜ìˆ˜ í‘œì‹œ (ì²´ë ¥ ì•„ë˜, ì˜¤ë¥¸ìª½ ì •ë ¬ - ì›ìœ¼ë¡œ)
                const enemyAmmoY = enemyHealthY + 40;
                drawAmmoCount(enemy, enemyHealthX + fixedBarWidth, enemyAmmoY, 'right');
                // ì  ì¦ê°• ì•„ì´ì½˜ í‘œì‹œ (íƒ„í™˜ ì•„ë˜)
                drawAugmentIcons(enemy, enemyHealthX + fixedBarWidth, enemyAmmoY + 50, 'right');
            }
            // ì¦ê°• íˆ´íŒ í‘œì‹œ
            if (hoveredAugment) {
                drawAugmentTooltip(hoveredAugment.aug, hoveredAugment.x, hoveredAugment.y);
            }
            
        }
        
        // ì¦ê°• íˆ´íŒ ê·¸ë¦¬ê¸°
        function drawAugmentTooltip(aug, x, y) {
            ctx.save();
            
            const padding = 12;
            const lineHeight = 24;
            const fontSize = 18;
            ctx.font = `bold ${fontSize}px Arial`;
            
            // í…ìŠ¤íŠ¸ í¬ê¸° ì¸¡ì •
            const titleWidth = ctx.measureText(aug.name).width;
            ctx.font = `${fontSize - 2}px Arial`;
            const descWidth = ctx.measureText(aug.description).width;
            const tooltipWidth = Math.max(titleWidth, descWidth) + padding * 2;
            const tooltipHeight = lineHeight * 2 + padding * 2;
            
            // íˆ´íŒ ìœ„ì¹˜ (ì•„ì´ì½˜ ìœ„ìª½ ë˜ëŠ” ì•„ë˜ìª½)
            let tooltipX = x;
            let tooltipY = y - 50 - tooltipHeight; // ì•„ì´ì½˜ ìœ„ìª½
            
            // í™”ë©´ ê²½ê³„ ì²´í¬
            if (tooltipY < 0) {
                tooltipY = y + 50; // ì•„ì´ì½˜ ì•„ë˜ìª½
            }
            if (tooltipX + tooltipWidth / 2 > canvas.width) {
                tooltipX = canvas.width - tooltipWidth / 2;
            }
            if (tooltipX - tooltipWidth / 2 < 0) {
                tooltipX = tooltipWidth / 2;
            }
            
            // ë°°ê²½
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            drawRoundedRect(
                tooltipX - tooltipWidth / 2,
                tooltipY,
                tooltipWidth,
                tooltipHeight,
                8
            );
            ctx.fill();
            ctx.stroke();
            
            // ì œëª©
            ctx.fillStyle = '#ffc107';
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(aug.name, tooltipX, tooltipY + padding);
            
            // ì„¤ëª…
            ctx.fillStyle = '#ffffff';
            ctx.font = `${fontSize - 2}px Arial`;
            ctx.fillText(aug.description, tooltipX, tooltipY + padding + lineHeight);
            
            ctx.restore();
        }

        // UI ì—…ë°ì´íŠ¸ (ì²´ë ¥ ì• ë‹ˆë©”ì´ì…˜ ë° ë°ë¯¸ì§€ ìˆ«ì)
        function updateUI() {
            // í”Œë ˆì´ì–´ ì²´ë ¥ ì• ë‹ˆë©”ì´ì…˜
            if (player.displayHealth !== player.health) {
                const diff = player.health - player.displayHealth;
                const speed = 0.15; // ì• ë‹ˆë©”ì´ì…˜ ì†ë„
                player.displayHealth += diff * speed;
                // ê±°ì˜ ê°™ì•„ì§€ë©´ ë°”ë¡œ ë§ì¶¤
                if (Math.abs(diff) < 0.01) {
                    player.displayHealth = player.health;
                }
            }
            
            // ì  ì²´ë ¥ ì• ë‹ˆë©”ì´ì…˜
            if (enemy.displayHealth !== enemy.health) {
                const diff = enemy.health - enemy.displayHealth;
                const speed = 0.15; // ì• ë‹ˆë©”ì´ì…˜ ì†ë„
                enemy.displayHealth += diff * speed;
                // ê±°ì˜ ê°™ì•„ì§€ë©´ ë°”ë¡œ ë§ì¶¤
                if (Math.abs(diff) < 0.01) {
                    enemy.displayHealth = enemy.health;
                }
            }
            
            // ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸
            updateDamageNumbers(player);
            updateDamageNumbers(enemy);
            
            // ë… íš¨ê³¼ ì²˜ë¦¬
            updatePoisonEffects(player);
                updatePoisonEffects(enemy);
        }
        
        // ë… íš¨ê³¼ ì—…ë°ì´íŠ¸
        function updatePoisonEffects(character) {
            const now = Date.now();
            for (let i = character.poisonEffects.length - 1; i >= 0; i--) {
                const poison = character.poisonEffects[i];
                const elapsed = now - poison.startTime;
                
                // 2ì´ˆê°€ ì§€ë‚˜ê±°ë‚˜ ìµœëŒ€ íˆíŠ¸ íšŸìˆ˜ì— ë„ë‹¬í•˜ë©´ ì œê±°
                if (elapsed >= poison.duration || (poison.hitCount >= poison.maxHits)) {
                    character.poisonEffects.splice(i, 1);
                    continue;
                }
                
                // 1ì´ˆë§ˆë‹¤ 0.2 ë°ë¯¸ì§€ (ìµœëŒ€ 2ë²ˆ, ì •í™” ì¦ê°•ì´ ìˆìœ¼ë©´ ë¬´ì‹œ)
                // ê¸°ì¡´ ë… íš¨ê³¼ í˜¸í™˜ì„±ì„ ìœ„í•´ hitCountê°€ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
                if (!poison.hasOwnProperty('hitCount')) {
                    poison.hitCount = 0;
                    poison.maxHits = 3;
                }
                if (now - poison.lastDamageTime >= 1000 && (poison.hitCount || 0) < (poison.maxHits || 3)) {
                    // ìœ ë ¹ ì¦ê°•: 25% í™•ë¥ ë¡œ ë… ë°ë¯¸ì§€ ë¬´ì‹œ
                    if (poison.target.hasGhost && Math.random() < 0.25) {
                        // "ë¬´ì‹œ" í…ìŠ¤íŠ¸ í‘œì‹œ
                        poison.target.damageNumbers.push({
                            x: poison.target.x,
                            y: poison.target.y,
                            damage: 0,
                            isCritical: false,
                            isGhost: true, // ìœ ë ¹ ë¬´ì‹œ ì—¬ë¶€
                            startTime: now,
                            duration: 1000,
                            offsetY: 0
                        });
                        poison.lastDamageTime = now; // ë‹¤ìŒ ë°ë¯¸ì§€ íƒ€ì´ë¨¸ ë¦¬ì…‹
                        continue; // ë°ë¯¸ì§€ ì ìš©í•˜ì§€ ì•ŠìŒ
                    }
                    
                    let poisonDamage = poison.damagePerSecond;
                    // ê±°ì í™•ë³´: ë°ë¯¸ì§€ *0.5
                    if (poison.target.hasFortify && poison.target.isFortified) {
                        poisonDamage *= 0.5;
                    }
                    
                    poison.target.health -= poisonDamage;
                    poison.lastDamageTime = now;
                    poison.hitCount = (poison.hitCount || 0) + 1; // íˆíŠ¸ íšŸìˆ˜ ì¦ê°€
                    
                    // ë… ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ (ì–´ë‘ìš´ ì´ˆë¡ìƒ‰)
                    poison.target.damageNumbers.push({
                        x: poison.target.x,
                        y: poison.target.y,
                        damage: poison.damagePerSecond,
                        isCritical: false,
                        isPoison: true, // ë… ë°ë¯¸ì§€ ì—¬ë¶€
                        startTime: now,
                        duration: 1000,
                        offsetY: 0
                    });
                    
                    // ì²´ë ¥ì´ 0 ì´í•˜ê°€ ë˜ë©´ ì²˜ë¦¬
                    if (poison.target.health <= 0) {
                        poison.target.health = 0;
                        // ë¶€í™œ ì²´í¬
                        if (poison.target.hasRevive && !poison.target.hasRevived && !poison.target.isReviving) {
                            poison.target.hasRevived = true;
                            poison.target.isReviving = true;
                            poison.target.reviveTime = now + 1000;
                        } else {
                            endRound(poison.target === player ? 'enemy' : 'player');
                        }
                    }
                }
            }
        }
        
        // ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸
        function updateDamageNumbers(character) {
            const now = Date.now();
            for (let i = character.damageNumbers.length - 1; i >= 0; i--) {
                const damageNum = character.damageNumbers[i];
                const elapsed = now - damageNum.startTime;
                
                // ì‹œê°„ì´ ì§€ë‚˜ë©´ ì œê±°
                if (elapsed >= damageNum.duration) {
                    character.damageNumbers.splice(i, 1);
                    continue;
                }
                
                // ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì• ë‹ˆë©”ì´ì…˜
                const progress = elapsed / damageNum.duration;
                damageNum.offsetY = -30 * progress; // ìœ„ë¡œ 30px ì´ë™
            }
        }
        
        // ë°ë¯¸ì§€ ìˆ«ì ê·¸ë¦¬ê¸°
        function drawDamageNumbers(character) {
            const now = Date.now();
            character.damageNumbers.forEach(damageNum => {
                const elapsed = now - damageNum.startTime;
                const progress = elapsed / damageNum.duration;
                
                // í˜ì´ë“œì•„ì›ƒ íš¨ê³¼
                const alpha = 1 - progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // ìƒ‰ìƒ ê²°ì •: íšŒë³µì´ë©´ ë¹¨ê°„ìƒ‰, ë°©ì–´ë§‰ ë¬´ì‹œë©´ ì§„í•œ íŒŒë€ìƒ‰, ìœ ë ¹ ë¬´ì‹œë©´ íšŒìƒ‰, ê¸°ì ˆì´ë©´ ë…¸ë€ìƒ‰, ë… ë°ë¯¸ì§€ë©´ ì–´ë‘ìš´ ì´ˆë¡ìƒ‰, í¬ë¦¬í‹°ì»¬ì´ë©´ ì–´ë‘ìš´ ë…¸ë€ìƒ‰, ì•„ë‹ˆë©´ í•˜ì–€ìƒ‰
                if (damageNum.isHeal) {
                    ctx.fillStyle = '#ff0000'; // ë¹¨ê°„ìƒ‰
                } else if (damageNum.isShield) {
                    ctx.fillStyle = '#0066ff'; // ì§„í•œ íŒŒë€ìƒ‰
                } else if (damageNum.isGhost) {
                    ctx.fillStyle = '#888888'; // íšŒìƒ‰
                } else if (damageNum.isStunned) {
                    ctx.fillStyle = '#ffffff'; // í•˜ì–€ìƒ‰
                } else if (damageNum.isPoison) {
                    ctx.fillStyle = '#006600'; // ì–´ë‘ìš´ ì´ˆë¡ìƒ‰
                } else if (damageNum.isCritical) {
                    ctx.fillStyle = '#CCAA00'; // ì–´ë‘ìš´ ë…¸ë€ìƒ‰
                } else {
                    ctx.fillStyle = '#ffffff'; // í•˜ì–€ìƒ‰
                }
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // ìºë¦­í„° ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ë°ë¯¸ì§€ ìˆ«ì ë˜ëŠ” íŠ¹ìˆ˜ í…ìŠ¤íŠ¸ í‘œì‹œ
                let displayText;
                if (damageNum.isShield || damageNum.isGhost) {
                    displayText = 'ë¬´ì‹œ';
                } else if (damageNum.isStunned) {
                    displayText = 'ê¸°ì ˆ';
                } else {
                    displayText = damageNum.damage.toString();
                }
                ctx.fillText(
                    displayText,
                    damageNum.x,
                    damageNum.y + damageNum.offsetY
                );
                
                ctx.restore();
            });
        }

        // ê²Œì„ ë£¨í”„
        let lastTime = 0;
        function gameLoop(currentTime) {
            // ë©”ë‰´ í™”ë©´ì´ ì•„ë‹ ë•Œë§Œ ê²Œì„ ë¡œì§ ì‹¤í–‰
            if (!gameState.isMenu && !gameState.isPaused && !gameState.isGameOver) {
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                // íƒ€ì´ë¨¸ ê°ì†Œ (ì´ˆë‹¹ 1ì”©)
                if (deltaTime >= 1000) {
                    gameState.gameTime--;
                    lastTime = currentTime;

                    // ì‹œê°„ ì´ˆê³¼
                    if (gameState.gameTime <= 0) {
                        if (player.health > enemy.health) {
                            endRound('player');
                        } else if (enemy.health > player.health) {
                            endRound('enemy');
                        } else {
                            // ë¬´ìŠ¹ë¶€ - ì²´ë ¥ì´ ë” ë§ì€ ìª½ì´ ìŠ¹ë¦¬
                            endRound(player.health >= enemy.health ? 'player' : 'enemy');
                        }
                    }
                }

                updatePlayer();
                updateEnemy();
                updateBullets(enemy);
                updateBullets(player);
            }

            draw();
            
            // ë©”ë‰´ í™”ë©´ì´ ì•„ë‹ ë•Œë§Œ UI ì—…ë°ì´íŠ¸
            if (!gameState.isMenu) {
            updateUI();
            }

            requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì‹œì‘ (ë©”ë‰´ì—ì„œ ì‹œì‘)
        gameLoop(0);
    </script>
</body>
</html>
