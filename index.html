<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>리볼버 듀얼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #0f0f1e;
            color: #fff;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #0f0f1e;
        }


        #augmentModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #e94560;
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        #augmentModal h2 {
            color: #e94560;
            margin-bottom: 20px;
        }

        #augmentViewModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        #augmentViewModal h2 {
            color: #4a9eff;
            margin-bottom: 20px;
        }

        .augment-option {
            background: rgba(233, 69, 96, 0.2);
            border: 2px solid #e94560;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .augment-option:hover {
            background: rgba(233, 69, 96, 0.4);
            transform: scale(1.05);
        }

        .augment-option h4 {
            color: #ffc107;
            margin-bottom: 5px;
        }

        #gameOverModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #ffc107;
            border-radius: 15px;
            padding: 40px;
            z-index: 1001;
            text-align: center;
        }

        #gameOverModal h2 {
            color: #ffc107;
            font-size: 32px;
            margin-bottom: 20px;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s;
        }

        button:hover {
            background: #c7364d;
        }

        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 30, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        #mainMenu h1 {
            font-size: 48px;
            color: #e94560;
            margin-bottom: 50px;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }

        .menu-button {
            background: rgba(233, 69, 96, 0.3);
            border: 3px solid #e94560;
            color: #fff;
            padding: 20px 50px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            margin: 15px;
            transition: all 0.3s;
            min-width: 250px;
        }

        .menu-button:hover {
            background: rgba(233, 69, 96, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.7);
        }

        .menu-button:active {
            transform: scale(1.05);
        }

        #controlsInfo {
            margin-top: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            text-align: center;
            max-width: 600px;
        }

        #controlsInfo h3 {
            color: #4a9eff;
            margin-bottom: 15px;
        }

        #controlsInfo p {
            margin: 8px 0;
            color: #ccc;
        }


    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="augmentModal">
            <h2>증강 선택</h2>
            <p style="margin-bottom: 20px;">패배하셨습니다. 증강을 선택하세요:</p>
            <div id="enemySelection" style="margin-bottom: 20px; padding: 10px; background: rgba(233, 69, 96, 0.2); border-radius: 5px; display: none;">
                <p style="color: #e94560; margin: 0;">상대가 선택 중...</p>
            </div>
            <div id="augmentOptions"></div>
        </div>

        <div id="augmentViewModal">
            <h2>증강 확인</h2>
            <p style="margin-bottom: 20px;">승리하셨습니다! 상대의 증강 선택을 확인하세요:</p>
            <div id="opponentSelection" style="margin-bottom: 20px; padding: 10px; background: rgba(233, 69, 96, 0.2); border-radius: 5px;">
                <p style="color: #e94560; margin: 0;">상대가 선택 중...</p>
            </div>
            <button onclick="closeAugmentViewModal()" style="margin-top: 20px;">확인</button>
        </div>

        <div id="gameOverModal">
            <h2 id="gameOverTitle">게임 종료</h2>
            <p id="gameOverMessage" style="font-size: 20px; margin-bottom: 20px;"></p>
            <button onclick="restartGame()">다시 시작</button>
        </div>

        <div id="mainMenu">
            <h1>리볼버 듀얼</h1>
            <button class="menu-button" onclick="startSoloGame()">솔로 플레이</button>
            <div id="controlsInfo">
                <h3>조작법</h3>
                <p><strong>플레이어:</strong> WASD 이동, 마우스 조준, 좌클릭 발사, 우클릭 구르기</p>
            </div>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 캔버스 크기를 화면 전체로 설정
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 게임 상태
        let gameState = {
            round: 1,
            maxRounds: 7, // 7판
            playerWins: 0,
            enemyWins: 0,
            winsNeeded: 4, // 4선제
            gameTime: 180, // 3분 = 180초
            isGameOver: false,
            isPaused: false,
            isMenu: true, // 메뉴 화면 표시 여부
            roundWins: [], // 각 라운드의 승자 기록 ('player' 또는 'enemy')
            countdown: 3, // 라운드 시작 카운트다운
            augmentCountdown: 0, // 증강 선택 카운트다운 (0이면 표시 안함)
            showOpponentSelecting: false, // 상대 선택 중 메시지 표시 여부
            shake: {
                intensity: 0,
                duration: 0
            }
        };

        // 플레이어
        const player = {
            x: canvas.width * 0.2,
            y: canvas.height * 0.5,
            radius: 30, // 1.5배 증가 (20 -> 30)
            speed: 3,
            health: 5,
            displayHealth: 5, // 표시되는 체력 (애니메이션용)
            maxHealth: 5,
            ammo: 6,
            maxAmmo: 6,
            reloadTime: 3000, // 3초
            isReloading: false,
            reloadStartTime: 0, // 재장전 시작 시간
            angle: 0,
            color: '#4a9eff',
            bullets: [],
            lastShot: 0,
            shootCooldown: 1000, // 1초로 고정
            damage: 1, // 기본 데미지
            augmentations: [],
            // 증강 관련 상태
            bulletSpeedMultiplier: 1,
            bulletSizeMultiplier: 1, // 탄환 크기 배율
            hasCritical: false,
            hasDoubleShot: false,
            hasDodge: false,
            hasRevive: false,
            hasRevived: false, // 부활 사용 여부 (1번만 부활)
            hasDeepWound: false,
            hasOneShotOneKill: false,
            hasPoisonBullet: false,
            hasReloadHeal: false,
            hasSurvivalInstinct: false, // 생존본능
            hasLastBullet: false, // 비장의 한발
            hasRecoveryContract: false, // 회복계약
            hasRecoveryContractUsed: false, // 회복계약 사용 여부 (라운드당 한번)
            hasPurify: false, // 정화
            hasFocusedFire: false, // 집중 사격
            hasShotgun: false, // 샷건
            hasRagged: false, // 오합지졸
            hasGhost: false, // 유령
            hasFortify: false, // 거점확보
            isFortified: false, // 거점 확보 상태
            fortifyStartTime: 0, // 거점 확보 시작 시간
            lastPosition: { x: 0, y: 0 }, // 마지막 위치
            stationaryTime: 0, // 정지한 시간
            hasOverheat: false, // 과열
            overheatHitCount: 0, // 연속 히트 카운트
            lastHitTime: 0, // 마지막 히트 시간
            hasGamble: false, // 도박
            hasWeaken: false, // 약화
            isWeakened: false, // 약화 상태
            weakenEndTime: 0, // 약화 종료 시간
            hasDamageBoost: false, // 데미지 1.2배
            hasLightning: false, // 번개
            isStunned: false, // 기절 상태
            stunEndTime: 0, // 기절 종료 시간
            hasShield: false, // 방어막
            shieldReady: false, // 방어막 준비됨
            shieldCooldown: 0, // 방어막 쿨타임
            hasRegeneration: false, // 재생
            lastRegenTime: 0, // 마지막 회복 시간
            isVulnerable: false, // 취약 상태
            vulnerabilityUsed: false, // 취약 사용 여부
            poisonEffects: [], // 독 효과 배열 {target, startTime, duration, damagePerSecond}
            isDodging: false,
            dodgeStartTime: 0, // 구르기 시작 시간
            dodgeEndTime: 0,
            dodgeStartX: 0,
            dodgeStartY: 0,
            dodgeTargetX: 0,
            dodgeTargetY: 0,
            dodgeTrail: [], // 구르기 잔상 위치 배열
            lastDodgeTime: 0, // 마지막 구르기 시간 (쿨타임용)
            isReviving: false,
            reviveTime: 0,
            isInvincible: false,
            invincibleEndTime: 0,
            slowEndTime: 0,
            damageNumbers: [] // 데미지 숫자 표시용
        };

        // 적 (AI)
        const enemy = {
            x: canvas.width * 0.8,
            y: canvas.height * 0.5,
            radius: 30, // 1.5배 증가 (20 -> 30)
            speed: 2.5,
            health: 5,
            displayHealth: 5, // 표시되는 체력 (애니메이션용)
            maxHealth: 5,
            ammo: 6,
            maxAmmo: 6,
            reloadTime: 3000, // 3초
            isReloading: false,
            reloadStartTime: 0, // 재장전 시작 시간
            angle: Math.PI,
            color: '#e94560',
            bullets: [],
            lastShot: 0,
            shootCooldown: 1000, // 1초로 고정
            damage: 1, // 기본 데미지
            augmentations: [],
            // 증강 관련 상태
            bulletSpeedMultiplier: 1,
            bulletSizeMultiplier: 1, // 탄환 크기 배율
            hasCritical: false,
            hasDoubleShot: false,
            hasDodge: false,
            hasRevive: false,
            hasRevived: false, // 부활 사용 여부 (1번만 부활)
            hasDeepWound: false,
            hasOneShotOneKill: false,
            hasPoisonBullet: false,
            hasReloadHeal: false,
            hasSurvivalInstinct: false, // 생존본능
            hasLastBullet: false, // 비장의 한발
            hasRecoveryContract: false, // 회복계약
            hasRecoveryContractUsed: false, // 회복계약 사용 여부 (라운드당 한번)
            hasPurify: false, // 정화
            hasFocusedFire: false, // 집중 사격
            hasShotgun: false, // 샷건
            hasRagged: false, // 오합지졸
            hasGhost: false, // 유령
            hasFortify: false, // 거점확보
            isFortified: false, // 거점 확보 상태
            fortifyStartTime: 0, // 거점 확보 시작 시간
            lastPosition: { x: 0, y: 0 }, // 마지막 위치
            stationaryTime: 0, // 정지한 시간
            hasOverheat: false, // 과열
            overheatHitCount: 0, // 연속 히트 카운트
            lastHitTime: 0, // 마지막 히트 시간
            hasGamble: false, // 도박
            hasWeaken: false, // 약화
            isWeakened: false, // 약화 상태
            weakenEndTime: 0, // 약화 종료 시간
            hasDamageBoost: false, // 데미지 1.2배
            hasLightning: false, // 번개
            isStunned: false, // 기절 상태
            stunEndTime: 0, // 기절 종료 시간
            hasShield: false, // 방어막
            shieldReady: false, // 방어막 준비됨
            shieldCooldown: 0, // 방어막 쿨타임
            hasRegeneration: false, // 재생
            lastRegenTime: 0, // 마지막 회복 시간
            isVulnerable: false, // 취약 상태
            vulnerabilityUsed: false, // 취약 사용 여부
            poisonEffects: [], // 독 효과 배열 {target, startTime, duration, damagePerSecond}
            isDodging: false,
            dodgeStartTime: 0, // 구르기 시작 시간
            dodgeEndTime: 0,
            dodgeStartX: 0,
            dodgeStartY: 0,
            dodgeTargetX: 0,
            dodgeTargetY: 0,
            dodgeTrail: [], // 구르기 잔상 위치 배열
            lastDodgeTime: 0, // 마지막 구르기 시간 (쿨타임용)
            isReviving: false,
            reviveTime: 0,
            isInvincible: false,
            invincibleEndTime: 0,
            slowEndTime: 0,
            aiTimer: 0,
            aiDirection: Math.random() * Math.PI * 2,
            damageNumbers: [] // 데미지 숫자 표시용
        };


        // 증강 목록
        const augmentations = [
            { 
                id: 'health', 
                name: '최대체력 +2', 
                description: '최대 체력 +2', 
                effect: (character) => { 
                    character.maxHealth += 2; 
                    character.health += 2; 
                } 
            },
            { 
                id: 'speed', 
                name: '이동속도 +25%', 
                description: '이동 속도 +25%', 
                effect: (character) => { 
                    character.speed *= 1.25; 
                } 
            },
            { 
                id: 'bulletSpeed', 
                name: '총알 속도 +25%', 
                description: '총알 속도 +25%', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 1.25; 
                } 
            },
            { 
                id: 'ammo', 
                name: '탄약 +1', 
                description: '최대 탄약 +1', 
                effect: (character) => { 
                    character.maxAmmo += 1; 
                    character.ammo += 1; 
                } 
            },
            { 
                id: 'fireRate', 
                name: '발사속도 -25%', 
                description: '발사속도 -25%', 
                effect: (character) => { 
                    character.shootCooldown *= 0.75; 
                } 
            },
            { 
                id: 'reload', 
                name: '재장전 속도 -1초', 
                description: '재장전 시간 -1초', 
                effect: (character) => { 
                    character.reloadTime = Math.max(1000, character.reloadTime - 1000); 
                } 
            },
            { 
                id: 'critical', 
                name: '크리티컬', 
                description: '피격 시 25% 확률로 데미지 2배', 
                effect: (character) => { 
                    character.hasCritical = true; 
                } 
            },
            { 
                id: 'doubleShot', 
                name: '더블샷', 
                description: '발사 시 25% 확률로 추가 발사 (탄약 소모X)', 
                effect: (character) => { 
                    character.hasDoubleShot = true; 
                } 
            },
            { 
                id: 'dodge', 
                name: '구르기', 
                description: '우클릭으로 구르기 (구르는 동안 무적)', 
                effect: (character) => { 
                    character.hasDodge = true; 
                } 
            },
            { 
                id: 'revive', 
                name: '부활', 
                description: '죽었을 때 2초 후 체력 1로 부활 (2초 무적)', 
                effect: (character) => { 
                    character.hasRevive = true; 
                } 
            },
            { 
                id: 'deepWound', 
                name: '깊은 상처', 
                description: '피격 시 상대 이동속도 -25% (0.5초)', 
                effect: (character) => { 
                    character.hasDeepWound = true; 
                } 
            },
            { 
                id: 'giant', 
                name: '거대화', 
                description: '체력 +3, 이동속도 -25%', 
                effect: (character) => { 
                    character.maxHealth += 3; 
                    character.health += 3; 
                    character.speed *= 0.75; 
                } 
            },
            { 
                id: 'sniper', 
                name: '저격수', 
                description: '총알 속도 +75%, 최대 탄약 -3', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 1.75; 
                    character.maxAmmo = Math.max(1, character.maxAmmo - 3); 
                    character.ammo = Math.min(character.ammo, character.maxAmmo); 
                } 
            },
            { 
                id: 'oneShotOneKill', 
                name: '원샷원킬', 
                description: '최대 탄약 1개로 고정, 총알 데미지 *3', 
                effect: (character) => { 
                    character.maxAmmo = 1; 
                    character.ammo = Math.min(character.ammo, 1); 
                    character.damage = (character.damage || 1) * 3; // 총알 데미지 *3
                    character.hasOneShotOneKill = true; 
                } 
            },
            { 
                id: 'poisonBullet', 
                name: '독 탄환', 
                description: '적 피격시 3초동안 1초마다 0.2데미지', 
                effect: (character) => { 
                    character.hasPoisonBullet = true; 
                } 
            },
            { 
                id: 'reloadHeal', 
                name: '재장전 회복', 
                description: '재장전 시 체력 1회복', 
                effect: (character) => { 
                    character.hasReloadHeal = true; 
                } 
            },
            { 
                id: 'bigBullet', 
                name: '큰 탄환', 
                description: '탄환 크기 +50%', 
                effect: (character) => { 
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 1.5; 
                } 
            },
            { 
                id: 'survivalInstinct', 
                name: '생존본능', 
                description: '체력이 1일 때 이동속도 +50%', 
                effect: (character) => { 
                    character.hasSurvivalInstinct = true; 
                } 
            },
            { 
                id: 'lastBullet', 
                name: '비장의 한발', 
                description: '마지막 탄환의 데미지 +1.5', 
                effect: (character) => { 
                    character.hasLastBullet = true; 
                } 
            },
            { 
                id: 'recoveryContract', 
                name: '회복계약', 
                description: '체력이 1일 때 체력 2회복 (라운드당 한번)', 
                effect: (character) => { 
                    character.hasRecoveryContract = true; 
                } 
            },
            { 
                id: 'purify', 
                name: '정화', 
                description: '모든 상태이상 효과 무시', 
                effect: (character) => { 
                    character.hasPurify = true; 
                } 
            },
            { 
                id: 'focusedFire', 
                name: '집중 사격', 
                description: '피격시 25% 확률로 상대에게 취약 부여 (다음 데미지 *1.5배)', 
                effect: (character) => { 
                    character.hasFocusedFire = true; 
                } 
            },
            { 
                id: 'shotgun', 
                name: '샷건', 
                description: '모든 탄약을 ±20도 범위에서 한번에 발사', 
                effect: (character) => { 
                    character.hasShotgun = true; 
                } 
            },
            { 
                id: 'ragged', 
                name: '오합지졸', 
                description: '최대 탄약 +3, 발사속도 -50%, 총알 데미지 *0.5', 
                effect: (character) => { 
                    character.maxAmmo += 3; 
                    character.ammo += 3; 
                    character.shootCooldown *= 0.5; // 발사속도 -50% (쿨타임 절반)
                    character.damage = (character.damage || 1) * 0.5; // 총알 데미지 *0.5
                    character.hasRagged = true; 
                } 
            },
            { 
                id: 'ghost', 
                name: '유령', 
                description: '상대의 공격을 25% 확률로 무시', 
                effect: (character) => { 
                    character.hasGhost = true; 
                } 
            },
            { 
                id: 'fortify', 
                name: '거점확보', 
                description: '3초동안 가만히 서있을 경우 다시 움직일때까지 받는 데미지 *0.5', 
                effect: (character) => { 
                    character.hasFortify = true; 
                    character.fortifyStartTime = 0; // 거점 확보 시작 시간
                    character.isFortified = false; // 거점 확보 상태
                    character.lastPosition = { x: character.x, y: character.y }; // 마지막 위치
                    character.stationaryTime = 0; // 정지한 시간
                } 
            },
            { 
                id: 'overheat', 
                name: '과열', 
                description: '상대에게 총알을 연속으로 맞출 시 맞출때마다 데미지 0.5배씩 상승', 
                effect: (character) => { 
                    character.hasOverheat = true; 
                    character.overheatHitCount = 0; // 연속 히트 카운트
                    character.lastHitTime = 0; // 마지막 히트 시간
                } 
            },
            { 
                id: 'gamble', 
                name: '도박', 
                description: '총알이 ±10도 범위에서 랜덤하게 나가지만 데미지는 1~2배 사이로 랜덤', 
                effect: (character) => { 
                    character.hasGamble = true; 
                } 
            },
            { 
                id: 'weaken', 
                name: '약화', 
                description: '상대에게 총알을 맞출 시 3초동안 상대 데미지 -0.25', 
                effect: (character) => { 
                    character.hasWeaken = true; 
                } 
            },
            { 
                id: 'damageBoost', 
                name: '데미지 1.2배', 
                description: '총알 데미지 *1.2', 
                effect: (character) => { 
                    character.damage = (character.damage || 1) * 1.2; 
                    character.hasDamageBoost = true; 
                } 
            },
            { 
                id: 'lightning', 
                name: '번개', 
                description: '적에게 총알을 맞출 시 25% 확률로 적 0.75초 기절', 
                effect: (character) => { 
                    character.hasLightning = true; 
                } 
            },
            { 
                id: 'shield', 
                name: '방어막', 
                description: '받는 데미지 1회 무시 (쿨타임 5초)', 
                effect: (character) => { 
                    character.hasShield = true; 
                    character.shieldReady = true; // 방어막 준비됨
                    character.shieldCooldown = 0; // 쿨타임
                } 
            },
            { 
                id: 'regeneration', 
                name: '재생', 
                description: '1초마다 체력 0.1 회복', 
                effect: (character) => { 
                    character.hasRegeneration = true; 
                    character.lastRegenTime = 0; // 마지막 회복 시간
                } 
            },
        ];

        // 키 입력 상태
        const keys = {};
        let mouse = { x: 0, y: 0 };
        let hoveredAugment = null; // 마우스 호버된 증강 정보

        // 이벤트 리스너
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        canvas.addEventListener('click', (e) => {
            if (!gameState.isPaused && !gameState.isGameOver && !player.isDodging) {
                shoot(player);
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // 우클릭 메뉴 방지
            
            // 플레이어 구르기 (우클릭)
                if (player.hasDodge && !player.isDodging && !gameState.isPaused && !gameState.isGameOver) {
                    dodge(player);
            }
        });

        // 총알 클래스
        class Bullet {
            constructor(x, y, angle, owner, isFreeShot = false) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                const baseSpeed = 20;
                const speedMultiplier = owner.bulletSpeedMultiplier || 1;
                this.speed = baseSpeed * speedMultiplier;
                const sizeMultiplier = owner.bulletSizeMultiplier || 1;
                this.radius = 9 * sizeMultiplier;
                this.owner = owner;
                this.damage = owner.damage || 1;
                // 비장의 한발: 마지막 탄환의 데미지 +1.5
                if (owner.hasLastBullet && owner.ammo === 1) {
                    this.damage += 1.5;
                }
                // 약화 상태: 데미지 -0.25 (도트딜 제외)
                if (owner.isWeakened) {
                    this.damage = Math.max(0.25, this.damage - 0.25);
                }
                this.isFreeShot = isFreeShot; // 탄약 소모 없는 총알 (더블샷용)
                this.hasPoison = owner.hasPoisonBullet || false; // 독 탄환 여부
            }

            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // 직사각형 총알 그리기
                // 독 탄환이면 어두운 초록색, 아니면 하얀색
                ctx.fillStyle = this.hasPoison ? '#006600' : '#ffffff';
                const sizeMultiplier = this.owner.bulletSizeMultiplier || 1;
                const bulletWidth = 24 * sizeMultiplier; // 총알 너비
                const bulletHeight = 9 * sizeMultiplier; // 총알 높이
                ctx.fillRect(-bulletWidth / 2, -bulletHeight / 2, bulletWidth, bulletHeight);
                
                ctx.restore();
            }

            isOutOfBounds() {
                return this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height;
            }
        }

        // 화면 흔들림 함수
        function addScreenShake(intensity, duration) {
            gameState.shake.intensity = intensity;
            gameState.shake.duration = duration;
        }

        // 발사 함수
        function shoot(character) {
            const now = Date.now();
            // 기절 상태면 발사 불가
            if (character.isStunned) return;
            if (character.ammo > 0 && !character.isReloading && 
                now - character.lastShot > character.shootCooldown) {
                
                // 샷건 증강: 모든 탄약을 ±20도 범위에서 한번에 발사
                if (character.hasShotgun) {
                    const currentAmmo = character.ammo;
                    for (let i = 0; i < currentAmmo; i++) {
                        // ±20도 범위 내 랜덤 각도
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 40 / 180); // -20도 ~ +20도
                const bullet = new Bullet(
                    character.x + Math.cos(character.angle) * character.radius,
                    character.y + Math.sin(character.angle) * character.radius,
                            character.angle + randomAngle,
                    character,
                    false
                );
                        character.bullets.push(bullet);
                    }
                    character.ammo = 0; // 모든 탄약 소모
                    character.lastShot = now;
                } else {
                    // 일반 발사
                    let bulletAngle = character.angle;
                    let bulletDamage = character.damage || 1;
                    
                    // 도박 증강: ±10도 랜덤 각도, 데미지 1~2배 랜덤
                    if (character.hasGamble) {
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // ±10도
                        bulletAngle = character.angle + randomAngle;
                        bulletDamage = bulletDamage * (1 + Math.random()); // 1~2배
                        bulletDamage = Math.round(bulletDamage * 10) / 10; // 소수점 1자리로 반올림
                    }
                    
                    const bullet = new Bullet(
                        character.x + Math.cos(character.angle) * character.radius,
                        character.y + Math.sin(character.angle) * character.radius,
                        bulletAngle,
                        character,
                        false
                    );
                    // 도박 증강: 데미지 랜덤 적용
                    if (character.hasGamble) {
                        bullet.damage = bulletDamage;
                    }
                character.bullets.push(bullet);
                character.ammo--;
                character.lastShot = now;

                // 더블샷 (25% 확률로 발사한 방향에 ±15도 사이에 추가 한발 발사)
                if (character.hasDoubleShot && Math.random() < 0.25) {
                    // ±15도 사이의 랜덤 각도
                    const randomAngle = (Math.random() - 0.5) * (Math.PI * 30 / 180); // -15도 ~ +15도
                    const doubleBullet = new Bullet(
                        character.x + Math.cos(character.angle) * character.radius,
                        character.y + Math.sin(character.angle) * character.radius,
                        character.angle + randomAngle,
                        character,
                        true // 탄약 소모 없음
                    );
                    character.bullets.push(doubleBullet);
                    }
                }

                // 화면 흔들림 효과 (플레이어 발사 시에만)
                if (character === player) {
                    addScreenShake(12, 200);
                }

                // 자동 재장전
                if (character.ammo === 0 && !character.isReloading) {
                    reload(character);
                }
            }
        }

        // 재장전 함수
        function reload(character) {
            if (character.ammo < character.maxAmmo && !character.isReloading) {
                character.isReloading = true;
                character.reloadStartTime = Date.now();
                
                setTimeout(() => {
                    character.ammo = character.maxAmmo;
                    character.isReloading = false;
                    character.reloadStartTime = 0;
                    
                    // 재장전 회복 증강
                    if (character.hasReloadHeal) {
                        character.health = Math.min(character.health + 1, character.maxHealth);
                    }
                }, character.reloadTime);
            }
        }

        // 충돌 감지
        function checkCollision(bullet, target) {
            const dx = bullet.x - target.x;
            const dy = bullet.y - target.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < bullet.radius + target.radius;
        }

        // 구르기 함수
        function dodge(character) {
            const now = Date.now();
            // 기절 상태면 구르기 불가
            if (character.isStunned) return;
            // 쿨타임 체크 (3초)
            if (character.isDodging || now - character.lastDodgeTime < 3000) return;
            
            character.isDodging = true;
            const dodgeDistance = character.radius * 6.4; // 플레이어 크기의 3.2배 (20% 감소: 8 -> 6.4)
            const dodgeDuration = 300; // 0.3초
            character.dodgeStartTime = now; // 구르기 시작 시간
            character.dodgeEndTime = now + dodgeDuration;
            character.lastDodgeTime = now; // 쿨타임 시작
            character.dodgeTrail = []; // 잔상 초기화
            
            // 구르기 시작 위치 저장
            character.dodgeStartX = character.x;
            character.dodgeStartY = character.y;
            character.dodgeTrail.push({ x: character.x, y: character.y, alpha: 0.5 });
            
            // 구르기 목표 위치 계산
            const targetX = character.x + Math.cos(character.angle) * dodgeDistance;
            const targetY = character.y + Math.sin(character.angle) * dodgeDistance;
            
            // 경계 체크
            character.dodgeTargetX = Math.max(character.radius, Math.min(canvas.width - character.radius, targetX));
            character.dodgeTargetY = Math.max(character.radius, Math.min(canvas.height - character.radius, targetY));
        }

        // 플레이어 이동
        function updatePlayer() {
            const now = Date.now();
            
            // 구르기 상태 체크
            if (player.isDodging) {
                if (now >= player.dodgeEndTime) {
                    // 구르기 완료
                    player.x = player.dodgeTargetX;
                    player.y = player.dodgeTargetY;
                    player.isDodging = false;
                    player.dodgeTrail = [];
                } else {
                    // 구르는 동안 빠른 속도로 이동
                    const elapsed = now - player.dodgeStartTime; // 시작 시간으로부터의 경과 시간
                    const progress = Math.min(elapsed / 300, 1); // 0~1 (300ms = 0.3초)
                    
                    // 시작 위치에서 목표 위치로 선형 보간
                    player.x = player.dodgeStartX + (player.dodgeTargetX - player.dodgeStartX) * progress;
                    player.y = player.dodgeStartY + (player.dodgeTargetY - player.dodgeStartY) * progress;
                    
                    // 잔상 업데이트 (매 프레임마다)
                    if (!player.dodgeTrail) player.dodgeTrail = [];
                    player.dodgeTrail.push({ x: player.x, y: player.y, alpha: 0.3 });
                    // 잔상이 너무 많아지면 제거
                    if (player.dodgeTrail.length > 5) {
                        player.dodgeTrail.shift();
                    }
                }
                return; // 구르는 중에는 일반 이동 불가
            }

            // 부활 처리
            if (player.isReviving) {
                if (now >= player.reviveTime) {
                    player.isReviving = false;
                    player.health = 1;
                    // displayHealth는 애니메이션으로 자동 업데이트됨
                    player.isInvincible = true;
                    player.invincibleEndTime = now + 1000; // 1초 무적
                }
                return; // 부활 중에는 이동 불가
            }

            // 무적 상태 체크
            if (player.isInvincible && now >= player.invincibleEndTime) {
                player.isInvincible = false;
            }

            // 약화 상태 체크
            if (player.isWeakened && now >= player.weakenEndTime) {
                player.isWeakened = false;
                // 약화는 총알 생성 시에만 데미지를 감소시키므로, damage 자체는 변경하지 않음
            }

            // 기절 상태 체크
            if (player.isStunned && now >= player.stunEndTime) {
                player.isStunned = false;
            }

            // 방어막 쿨타임 체크
            if (player.hasShield && !player.shieldReady && now >= player.shieldCooldown) {
                player.shieldReady = true;
            }

            // 재생: 1초마다 체력 0.1 회복
            if (player.hasRegeneration) {
                if (now - player.lastRegenTime >= 1000) {
                    player.health = Math.min(player.health + 0.1, player.maxHealth);
                    player.lastRegenTime = now;
                }
            }

            // 기절 중에는 이동 불가
            if (player.isStunned) {
                return;
            }

            // 이동속도 감소 처리 (깊은 상처)
            let currentSpeed = player.speed;
            if (now < player.slowEndTime) {
                // 정화 증강이 있으면 상태이상 무시
                if (!player.hasPurify) {
                    currentSpeed *= 0.75; // -25%
                }
            }
            
            // 생존본능: 체력이 1일 때 이동속도 +50%
            if (player.hasSurvivalInstinct && player.health === 1) {
                currentSpeed *= 1.5;
            }
            
            // 회복계약: 체력이 1일 때 체력 2회복 (라운드당 한번)
            if (player.hasRecoveryContract && !player.hasRecoveryContractUsed && player.health === 1) {
                player.health = Math.min(player.health + 2, player.maxHealth);
                player.hasRecoveryContractUsed = true;
            }

            let dx = 0;
            let dy = 0;

            if (keys['w']) dy -= 1;
            if (keys['s']) dy += 1;
            if (keys['a']) dx -= 1;
            if (keys['d']) dx += 1;

            // 대각선 이동 정규화
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            // 거점확보: 위치 변화 체크
            if (player.hasFortify) {
                const moved = Math.abs(player.x - (player.lastPosition?.x || player.x)) > 0.1 || 
                             Math.abs(player.y - (player.lastPosition?.y || player.y)) > 0.1;
                
                if (moved) {
                    // 움직임: 거점 확보 해제
                    player.isFortified = false;
                    player.stationaryTime = 0;
                    if (!player.lastPosition) player.lastPosition = { x: player.x, y: player.y };
                    player.lastPosition.x = player.x;
                    player.lastPosition.y = player.y;
                } else {
                    // 정지: 시간 누적
                    if (!player.lastPosition) player.lastPosition = { x: player.x, y: player.y };
                    player.stationaryTime += 16; // 약 60fps 기준
                    
                    // 3초(3000ms) 동안 정지하면 거점 확보
                    if (player.stationaryTime >= 3000 && !player.isFortified) {
                        player.isFortified = true;
                        player.fortifyStartTime = now;
                    }
                }
            }

            // 이동
            const newX = player.x + dx * currentSpeed;
            const newY = player.y + dy * currentSpeed;

            // 경계 체크
            if (newX >= player.radius && newX <= canvas.width - player.radius) {
                player.x = newX;
            }
            if (newY >= player.radius && newY <= canvas.height - player.radius) {
                player.y = newY;
            }

            // 각도 계산 (마우스 방향)
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
        }


        // AI 적 업데이트
        function updateEnemy() {
            const now = Date.now();
            
            // 부활 처리
            if (enemy.isReviving) {
                if (now >= enemy.reviveTime) {
                    enemy.isReviving = false;
                    enemy.health = 1;
                    // displayHealth는 애니메이션으로 자동 업데이트됨
                    enemy.isInvincible = true;
                    enemy.invincibleEndTime = now + 1000; // 1초 무적
                }
                return; // 부활 중에는 이동 불가
            }

            // 무적 상태 체크
            if (enemy.isInvincible && now >= enemy.invincibleEndTime) {
                enemy.isInvincible = false;
            }

            // 약화 상태 체크
            if (enemy.isWeakened && now >= enemy.weakenEndTime) {
                enemy.isWeakened = false;
                // 약화는 총알 생성 시에만 데미지를 감소시키므로, damage 자체는 변경하지 않음
            }

            // 기절 상태 체크
            if (enemy.isStunned && now >= enemy.stunEndTime) {
                enemy.isStunned = false;
            }

            // 방어막 쿨타임 체크
            if (enemy.hasShield && !enemy.shieldReady && now >= enemy.shieldCooldown) {
                enemy.shieldReady = true;
            }

            // 재생: 1초마다 체력 0.1 회복
            if (enemy.hasRegeneration) {
                if (now - enemy.lastRegenTime >= 1000) {
                    enemy.health = Math.min(enemy.health + 0.1, enemy.maxHealth);
                    enemy.lastRegenTime = now;
                }
            }

            // 기절 중에는 이동 불가
            if (enemy.isStunned) {
                return;
            }

            // 이동속도 감소 처리 (깊은 상처)
            let currentSpeed = enemy.speed;
            if (now < enemy.slowEndTime) {
                // 정화 증강이 있으면 상태이상 무시
                if (!enemy.hasPurify) {
                    currentSpeed *= 0.75; // -25%
                }
            }
            
            // 생존본능: 체력이 1일 때 이동속도 +50%
            if (enemy.hasSurvivalInstinct && enemy.health === 1) {
                currentSpeed *= 1.5;
            }
            
            // 회복계약: 체력이 1일 때 체력 2회복 (라운드당 한번)
            if (enemy.hasRecoveryContract && !enemy.hasRecoveryContractUsed && enemy.health === 1) {
                enemy.health = Math.min(enemy.health + 2, enemy.maxHealth);
                enemy.hasRecoveryContractUsed = true;
            }

            enemy.aiTimer++;

            // 플레이어 방향으로 각도 설정
            const dxToPlayer = player.x - enemy.x;
            const dyToPlayer = player.y - enemy.y;
            enemy.angle = Math.atan2(dyToPlayer, dxToPlayer);

            // 플레이어와의 거리 계산
            const distance = Math.sqrt(dxToPlayer * dxToPlayer + dyToPlayer * dyToPlayer);
            const safeDistance = 500; // 안전 거리 (500px)

            // 적 이동 패턴 개선 - 항상 활발하게 움직임
            if (enemy.aiTimer > 30) { // 더 자주 방향 변경 (30프레임 = 약 0.5초)
                let targetAngle;
                
                // 랜덤하게 다양한 움직임 패턴 사용
                const movementPattern = Math.random();
                
                if (movementPattern < 0.3) {
                    // 30% 확률: 플레이어 방향으로 이동
                    targetAngle = Math.atan2(dyToPlayer, dxToPlayer);
                } else if (movementPattern < 0.5) {
                    // 20% 확률: 플레이어 반대 방향으로 이동
                    targetAngle = Math.atan2(-dyToPlayer, -dxToPlayer);
                } else if (movementPattern < 0.7) {
                    // 20% 확률: 측면 이동 (왼쪽/오른쪽)
                    targetAngle = Math.atan2(dyToPlayer, dxToPlayer) + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                } else {
                    // 30% 확률: 완전 랜덤 방향
                    targetAngle = Math.random() * Math.PI * 2;
                }
                
                // 거리 기반 조정 (선택적)
                if (distance < safeDistance * 0.7) {
                    // 너무 가까우면 멀어지는 경향
                    if (movementPattern < 0.5) {
                        targetAngle = Math.atan2(-dyToPlayer, -dxToPlayer);
                    }
                }
                
                // 랜덤 각도 추가로 더 자연스러운 움직임
                const randomAngle = (Math.random() - 0.5) * Math.PI * 0.5; // ±45도 랜덤
                enemy.aiDirection = targetAngle + randomAngle;
                enemy.aiTimer = 0;
            }

            // 경계에 닿으면 방향 변경
            if (enemy.x < enemy.radius || enemy.x > canvas.width - enemy.radius ||
                enemy.y < enemy.radius || enemy.y > canvas.height - enemy.radius) {
                enemy.aiDirection = Math.random() * Math.PI * 2;
                enemy.aiTimer = 0;
            }

            // 이동
            let dx = Math.cos(enemy.aiDirection) * currentSpeed;
            let dy = Math.sin(enemy.aiDirection) * currentSpeed;

            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x + dx));
            enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y + dy));

            // 플레이어가 범위 내에 있고 탄약이 있으면 발사 (더 공격적으로)
            // 거리 제한을 크게 늘리고 발사 확률도 높임
            const maxDistance = Math.max(canvas.width, canvas.height) * 0.8; // 화면 크기의 80%까지
            if (distance < maxDistance && enemy.ammo > 0 && !enemy.isReloading && Math.random() < 0.05) {
                shoot(enemy);
            }

            // 자동 재장전
            if (enemy.ammo === 0 && !enemy.isReloading) {
                reload(enemy);
            }
        }

        // 총알 업데이트
        function updateBullets(character) {
            for (let i = character.bullets.length - 1; i >= 0; i--) {
                const bullet = character.bullets[i];
                bullet.update();

                // 경계 체크
                if (bullet.isOutOfBounds()) {
                    character.bullets.splice(i, 1);
                    continue;
                }

                // 충돌 체크
                let target = character === player ? enemy : player;
                if (checkCollision(bullet, target)) {
                    // 구르는 중이거나 무적 상태면 데미지 무시
                    if (target.isDodging || target.isInvincible || target.isReviving) {
                        character.bullets.splice(i, 1);
                        continue;
                    }

                    // 방어막: 데미지 1회 무시 (쿨타임 5초)
                    if (target.hasShield && target.shieldReady) {
                        target.shieldReady = false;
                        target.shieldCooldown = Date.now() + 5000; // 5초 쿨타임
                        character.bullets.splice(i, 1);
                        // "무시" 텍스트 표시
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isShield: true, // 방어막 무시 여부
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: 0
                        });
                        continue; // 데미지 적용 안 함
                    }

                    // 유령 증강: 25% 확률로 공격 무시
                    if (target.hasGhost && Math.random() < 0.25) {
                        // 총알이 관통하고 지나감 (총알 제거하지 않음)
                        // "무시" 텍스트 표시
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isGhost: true, // 유령 무시 여부
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: 0
                        });
                        continue; // 총알은 계속 진행, 데미지 적용 안 함
                    }

                    // 크리티컬 계산 (25% 확률로 데미지 2배)
                    let finalDamage = bullet.damage;
                    let isCritical = false;
                    if (character.hasCritical && Math.random() < 0.25) {
                        finalDamage *= 2;
                        isCritical = true;
                    }
                    
                    // 취약 상태: 다음 데미지 1.5배
                    if (target.isVulnerable && !target.vulnerabilityUsed) {
                        finalDamage *= 1.5;
                        target.vulnerabilityUsed = true; // 취약 사용됨
                        target.isVulnerable = false; // 취약 상태 해제
                    }

                    // 거점확보: 데미지 *0.5
                    if (target.hasFortify && target.isFortified) {
                        finalDamage *= 0.5;
                    }

                    // 과열: 연속 히트 시 데미지 배율 적용
                    if (character.hasOverheat) {
                        const now = Date.now();
                        // 2초 이내에 히트하면 연속 히트로 간주
                        if (now - character.lastHitTime < 2000) {
                            character.overheatHitCount++;
                        } else {
                            // 2초 이상 지나면 초기화
                            character.overheatHitCount = 0;
                        }
                        // 데미지 배율: 1 + hitCount * 0.5 (첫번째는 1배, 두번째는 1.5배, 세번째는 2배...)
                        finalDamage *= (1 + character.overheatHitCount * 0.5);
                        character.lastHitTime = now;
                    }

                    // 약화: 상대에게 약화 상태 부여 (3초 동안 데미지 -0.25, 중첩 안됨)
                    if (character.hasWeaken && !target.isWeakened) {
                        target.isWeakened = true;
                        target.weakenEndTime = Date.now() + 3000;
                        // 데미지 감소 적용 (원래 데미지 저장 필요 없음, 발사 시 적용)
                    }

                    target.health -= finalDamage;
                    character.bullets.splice(i, 1);

                    // 데미지 숫자 표시 추가
                    target.damageNumbers.push({
                        x: target.x,
                        y: target.y,
                        damage: finalDamage,
                        isCritical: isCritical, // 크리티컬 여부
                        startTime: Date.now(),
                        duration: 1000, // 1초 동안 표시
                        offsetY: 0 // 위로 올라가는 오프셋
                    });

                    // 번개: 25% 확률로 적 0.75초 기절
                    if (character.hasLightning && Math.random() < 0.25) {
                        target.isStunned = true;
                        target.stunEndTime = Date.now() + 750; // 0.75초
                        // 기절 텍스트 표시 (데미지 숫자 위에 표시)
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isStunned: true, // 기절 여부
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: -40 // 데미지 숫자 위에 표시
                        });
                    }

                    // 깊은 상처 (피격 시 상대 이동속도 -25% (0.5초))
                    // 정화 증강이 있으면 상태이상 무시
                    if (character.hasDeepWound && !target.hasPurify) {
                        target.slowEndTime = Date.now() + 500;
                    }
                    
                    // 독 탄환 효과 (3초동안 1초마다 0.2데미지)
                    // 정화 증강이 있으면 상태이상 무시
                    if (bullet.hasPoison && !target.hasPurify) {
                        character.poisonEffects.push({
                            target: target,
                            startTime: Date.now(),
                            duration: 3000, // 3초
                            damagePerSecond: 0.2,
                            lastDamageTime: Date.now()
                        });
                    }
                    
                    // 집중 사격: 피격시 25% 확률로 상대에게 취약 부여
                    if (target.hasFocusedFire && Math.random() < 0.25) {
                        character.isVulnerable = true;
                        character.vulnerabilityUsed = false;
                    }

                    if (target.health <= 0) {
                        target.health = 0;
                        
                        // 부활 체크 (1번만 부활)
                        if (target.hasRevive && !target.hasRevived && !target.isReviving) {
                            target.hasRevived = true; // 부활 사용 표시
                            target.isReviving = true;
                            target.reviveTime = Date.now() + 2000;
                        } else {
                            endRound(character === player ? 'player' : 'enemy');
                        }
                    }
                    // 체력이 음수가 되지 않도록
                    if (target.health < 0) target.health = 0;
                }
            }
        }

        // 라운드 종료
        function endRound(winner) {
            gameState.isPaused = true;

            // 라운드 승리 기록에 추가 (순서대로)
            gameState.roundWins.push(winner);

            if (winner === 'player') {
                gameState.playerWins++;
            } else {
                gameState.enemyWins++;
            }

            // 승리 체크
            if (gameState.playerWins >= gameState.winsNeeded || gameState.enemyWins >= gameState.winsNeeded) {
                const finalWinner = winner === 'player' ? 'player' : 'enemy';
                endGame(finalWinner);
                return;
            }

            // 라운드 종료 체크
            if (gameState.round >= gameState.maxRounds) {
                const finalWinner = gameState.playerWins > gameState.enemyWins ? 'player' : 'enemy';
                endGame(finalWinner);
                return;
            }

            // 패배자가 증강 선택, 승리자는 확인만
            if (winner === 'player') {
                // 플레이어 승리: AI가 선택
                    gameState.showOpponentSelecting = true;
            selectAugmentForEnemy();
            } else {
                // enemy 승리: 플레이어는 선택
                showAugmentModal(player);
            }
        }

        // 적을 위한 증강 자동 선택
        function selectAugmentForEnemy() {
            const enemySelectionDiv = document.getElementById('enemySelection');
            const opponentSelectionDiv = document.getElementById('opponentSelection');
            
            if (enemySelectionDiv) {
            enemySelectionDiv.style.display = 'block';
            enemySelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">상대가 선택 중...</p>';
            }
            
            if (opponentSelectionDiv) {
                opponentSelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">상대가 선택 중...</p>';
            }
            
            // 3초 대기 후 선택
            setTimeout(() => {
                // AI는 구르기와 거점확보 증강을 뽑지 않음
                const availableAugments = augmentations.filter(aug => aug.id !== 'dodge' && aug.id !== 'fortify');
                const shuffled = [...availableAugments].sort(() => Math.random() - 0.5);
                const selectedAugment = shuffled[0]; // 랜덤으로 하나 선택
                selectedAugment.effect(enemy);
                enemy.augmentations.push(selectedAugment);
                
                // 선택한 증강 표시
                if (enemySelectionDiv) {
                enemySelectionDiv.innerHTML = `<p style="color: #e94560; margin: 0;">상대 선택: <strong style="color: #ffc107;">${selectedAugment.name}</strong></p>`;
                }
                if (opponentSelectionDiv) {
                    opponentSelectionDiv.innerHTML = `<p style="color: #e94560; margin: 0;">상대 선택: <strong style="color: #ffc107;">${selectedAugment.name}</strong></p>`;
                }
                
                // 플레이어가 승리한 경우: 상대 선택 완료 후 자동으로 다음 라운드로
                if (gameState.showOpponentSelecting) {
                    gameState.showOpponentSelecting = false;
                    // 약간의 딜레이 후 다음 라운드로
                    setTimeout(() => {
                        nextRound();
                    }, 500);
                }
            }, 3000);
        }

        // 증강 모달 표시 (플레이어용 - 선택 가능)
        function showAugmentModal(character) {
            const modal = document.getElementById('augmentModal');
            const optionsDiv = document.getElementById('augmentOptions');
            optionsDiv.innerHTML = '';

            // 랜덤 증강 3개 선택
            const shuffled = [...augmentations].sort(() => Math.random() - 0.5);
            const selectedAugments = shuffled.slice(0, 3);

            let timeLeft = 15;
            let isSelected = false;
            let timerInterval;

            // 증강 선택 함수
            const selectAugment = (aug) => {
                if (isSelected) return;
                isSelected = true;
                clearInterval(timerInterval);
                aug.effect(character);
                character.augmentations.push(aug);
                gameState.augmentCountdown = 0;
                
                // 플레이어가 패배한 경우: 플레이어만 선택하므로 바로 다음 라운드로
                        modal.style.display = 'none';
                // 확인 모달도 닫기
                const viewModal = document.getElementById('augmentViewModal');
                if (viewModal) {
                    viewModal.style.display = 'none';
                    }
                nextRound();
            };

            // 증강 옵션 생성
            selectedAugments.forEach(aug => {
                const option = document.createElement('div');
                option.className = 'augment-option';
                option.innerHTML = `
                    <h4>${aug.name}</h4>
                    <p>${aug.description}</p>
                `;
                option.onclick = () => selectAugment(aug);
                optionsDiv.appendChild(option);
            });

            // 모달 표시
            modal.style.display = 'block';
            const enemySelectionDiv = document.getElementById('enemySelection');
            // 플레이어가 패배한 경우: 적은 승리자이므로 증강을 선택하지 않음, 메시지 표시 안함
            enemySelectionDiv.style.display = 'none';
            
            // 화면 가운데 카운트다운 시작
            gameState.augmentCountdown = 15;
            timerInterval = setInterval(() => {
                timeLeft--;
                gameState.augmentCountdown = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    if (!isSelected) {
                        // 시간 초과 시 랜덤 선택
                        const randomAug = selectedAugments[Math.floor(Math.random() * selectedAugments.length)];
                        selectAugment(randomAug);
                    }
                }
            }, 1000);
        }

        // 증강 확인 모달 표시 (승리자용 - 확인만 가능)
        function showAugmentViewModal(winnerCharacter, loserType) {
            const modal = document.getElementById('augmentViewModal');
            const opponentSelectionDiv = document.getElementById('opponentSelection');
            
            // 모달 표시
            modal.style.display = 'block';
            opponentSelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">상대가 선택 중...</p>';
        }

        // 증강 확인 모달 닫기
        function closeAugmentViewModal() {
            const modal = document.getElementById('augmentViewModal');
            modal.style.display = 'none';
            
            // 상대 선택이 완료되었으면 다음 라운드로
            if (enemy.augmentations.length > 0) {
                nextRound();
            } else {
                // 아직 적이 선택 중이면 대기
                const checkEnemySelection = setInterval(() => {
                    if (enemy.augmentations.length > 0) {
                        clearInterval(checkEnemySelection);
                        nextRound();
                    }
                }, 100);
            }
        }

        // 다음 라운드
        function nextRound() {
            resizeCanvas();
            gameState.round++;
            gameState.gameTime = 180;
            gameState.showOpponentSelecting = false;

            // 플레이어 상태 초기화
            player.x = canvas.width * 0.2;
            player.y = canvas.height * 0.5;
            player.health = player.maxHealth;
            player.displayHealth = player.maxHealth;
            player.ammo = player.maxAmmo;
            player.bullets = [];
            player.isReloading = false;
            player.isDodging = false;
            player.dodgeStartTime = 0;
            player.dodgeEndTime = 0;
            player.dodgeStartX = 0;
            player.dodgeStartY = 0;
            player.dodgeTargetX = 0;
            player.dodgeTargetY = 0;
            player.dodgeTrail = [];
            player.lastDodgeTime = 0;
            player.isReviving = false;
            player.reviveTime = 0;
            player.hasRevived = false; // 부활 사용 여부 초기화
            player.isInvincible = false;
            player.invincibleEndTime = 0;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.poisonEffects = [];
            player.hasRecoveryContractUsed = false; // 회복계약 초기화
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.shieldReady = true; // 방어막 준비 상태로 초기화
            player.shieldCooldown = 0;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.lastRegenTime = Date.now(); // 재생 시작 시간

            // 적 상태 초기화
            enemy.x = canvas.width * 0.8;
            enemy.y = canvas.height * 0.5;
            enemy.health = enemy.maxHealth;
            enemy.displayHealth = enemy.maxHealth;
            enemy.ammo = enemy.maxAmmo;
            enemy.bullets = [];
            enemy.isReloading = false;
            enemy.isDodging = false;
            enemy.dodgeStartTime = 0;
            enemy.dodgeEndTime = 0;
            enemy.dodgeStartX = 0;
            enemy.dodgeStartY = 0;
            enemy.dodgeTargetX = 0;
            enemy.dodgeTargetY = 0;
            enemy.dodgeTrail = [];
            enemy.lastDodgeTime = 0;
            enemy.isReviving = false;
            enemy.reviveTime = 0;
            enemy.hasRevived = false; // 부활 사용 여부 초기화
            enemy.isInvincible = false;
            enemy.invincibleEndTime = 0;
            enemy.slowEndTime = 0;
            enemy.damageNumbers = [];
            enemy.poisonEffects = [];
            enemy.hasRecoveryContractUsed = false; // 회복계약 초기화
            enemy.isVulnerable = false;
            enemy.vulnerabilityUsed = false;
            enemy.isStunned = false;
            enemy.stunEndTime = 0;
            enemy.shieldReady = true; // 방어막 준비 상태로 초기화
            enemy.shieldCooldown = 0;
            enemy.isWeakened = false;
            enemy.weakenEndTime = 0;
            enemy.lastRegenTime = Date.now(); // 재생 시작 시간

            // 3초 카운트다운 시작 (게임 완전히 멈춤)
            gameState.countdown = 3;
            gameState.isPaused = true;
            
            // 카운트다운 처리
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.isPaused = false;
                }
            }, 1000);
        }

        // 게임 종료
        function endGame(winner) {
            gameState.isGameOver = true;
            const modal = document.getElementById('gameOverModal');
            const title = document.getElementById('gameOverTitle');
            const message = document.getElementById('gameOverMessage');

            if (winner === 'player') {
                title.textContent = '승리!';
                title.style.color = '#4a9eff';
                message.textContent = `축하합니다! ${gameState.playerWins}승으로 승리하셨습니다!`;
            } else {
                title.textContent = '패배';
                title.style.color = '#e94560';
                message.textContent = `아쉽네요... ${gameState.enemyWins}승으로 패배했습니다.`;
            }

            modal.style.display = 'block';
        }

        // 게임 재시작
        function restartGame() {
            // 메뉴로 돌아가기
            gameState.isMenu = true;
            gameState.isGameOver = false;
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            
            // 첫 라운드 카운트다운 시작
            gameState.isPaused = true;
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.isPaused = false;
                }
            }, 1000);

            player.x = canvas.width * 0.2;
            player.y = canvas.height * 0.5;
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.hasCritical = false;
            player.hasDoubleShot = false;
            player.hasDodge = false;
            player.hasRevive = false;
            player.hasDeepWound = false;
            player.hasOneShotOneKill = false;
            player.hasPoisonBullet = false;
            player.hasReloadHeal = false;
            player.hasSurvivalInstinct = false;
            player.hasLastBullet = false;
            player.hasRecoveryContract = false;
            player.hasRecoveryContractUsed = false;
            player.hasPurify = false;
            player.hasFocusedFire = false;
            player.hasShotgun = false;
            player.hasRagged = false;
            player.hasGhost = false;
            player.hasFortify = false;
            player.isFortified = false;
            player.fortifyStartTime = 0;
            player.lastPosition = { x: player.x, y: player.y };
            player.stationaryTime = 0;
            player.hasOverheat = false;
            player.overheatHitCount = 0;
            player.lastHitTime = 0;
            player.hasGamble = false;
            player.hasWeaken = false;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.hasDamageBoost = false;
            player.hasLightning = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.hasShield = false;
            player.shieldReady = false;
            player.shieldCooldown = 0;
            player.hasRegeneration = false;
            player.lastRegenTime = 0;
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.poisonEffects = [];
            player.isDodging = false;
            player.dodgeStartTime = 0;
            player.dodgeEndTime = 0;
            player.dodgeStartX = 0;
            player.dodgeStartY = 0;
            player.dodgeTargetX = 0;
            player.dodgeTargetY = 0;
            player.dodgeTrail = [];
            player.lastDodgeTime = 0;
            player.isReviving = false;
            player.reviveTime = 0;
            player.hasRevived = false; // 부활 사용 여부 초기화
            player.isInvincible = false;
            player.invincibleEndTime = 0;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.damage = 1;
            player.speed = 3;
            player.reloadTime = 3000;
            player.reloadStartTime = 0;
            player.shootCooldown = 1000;

            enemy.x = canvas.width * 0.8;
            enemy.y = canvas.height * 0.5;
            enemy.health = 5;
            enemy.displayHealth = 5;
            enemy.maxHealth = 5;
            enemy.ammo = 6;
            enemy.maxAmmo = 6;
            enemy.bullets = [];
            enemy.augmentations = [];
            enemy.bulletSpeedMultiplier = 1;
            enemy.bulletSizeMultiplier = 1;
            enemy.hasCritical = false;
            enemy.hasDoubleShot = false;
            enemy.hasDodge = false;
            enemy.hasRevive = false;
            enemy.hasRevived = false; // 부활 사용 여부 초기화
            enemy.hasDeepWound = false;
            enemy.hasOneShotOneKill = false;
            enemy.hasPoisonBullet = false;
            enemy.hasReloadHeal = false;
            enemy.hasSurvivalInstinct = false;
            enemy.hasLastBullet = false;
            enemy.hasRecoveryContract = false;
            enemy.hasRecoveryContractUsed = false;
            enemy.hasPurify = false;
            enemy.hasFocusedFire = false;
            enemy.isVulnerable = false;
            enemy.vulnerabilityUsed = false;
            enemy.poisonEffects = [];
            enemy.isDodging = false;
            enemy.dodgeStartTime = 0;
            enemy.dodgeEndTime = 0;
            enemy.dodgeStartX = 0;
            enemy.dodgeStartY = 0;
            enemy.dodgeTargetX = 0;
            enemy.dodgeTargetY = 0;
            enemy.dodgeTrail = [];
            enemy.lastDodgeTime = 0;
            enemy.isReviving = false;
            enemy.reviveTime = 0;
            enemy.hasRevived = false; // 부활 사용 여부 초기화
            enemy.isInvincible = false;
            enemy.invincibleEndTime = 0;
            enemy.slowEndTime = 0;
            enemy.damageNumbers = [];
            enemy.damage = 1;
            enemy.reloadTime = 3000;
            enemy.reloadStartTime = 0;
            enemy.shootCooldown = 1000;

            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('augmentModal').style.display = 'none';
        }

        // 둥근 사각형 그리기 헬퍼 함수
        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            // 상단 왼쪽
            ctx.moveTo(x + radius, y);
            // 상단 오른쪽
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            // 오른쪽 아래
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            // 아래 왼쪽
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            // 왼쪽 위
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
        }

        // 체력 표시 그리기 (직사각형 바)
        function drawHealthHearts(character, x, y, isPlayer) {
            const fixedBarWidth = 150; // 고정된 바 길이 (200 -> 150)
            const barHeight = 20;
            const borderRadius = 4;
            const color = isPlayer ? '#4a9eff' : '#e94560';
            
            // 배경 (빈 바)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
            ctx.fill();
            
            // 채워진 부분 (애니메이션)
            const fillRatio = Math.max(0, Math.min(1, character.displayHealth / character.maxHealth));
            const fillWidth = fixedBarWidth * fillRatio;
            
            if (fillWidth > 0) {
                ctx.fillStyle = color;
                // 부분 채우기를 위해 클리핑 사용
                if (fillWidth < fixedBarWidth) {
                    ctx.save();
                    ctx.beginPath();
                    drawRoundedRect(x, y, fillWidth, barHeight, borderRadius);
                    ctx.clip();
                    drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                ctx.fill();
                    ctx.restore();
                } else {
                    drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                    ctx.fill();
                }
            }
                
                // 테두리
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
            drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                ctx.stroke();
        }

        // 증강 아이콘 그리기
        function drawAugmentIcon(ctx, x, y, size, augId) {
            ctx.save();
            ctx.translate(x, y);
            
            switch(augId) {
                case 'health':
                    // 체력: 하트 모양 (중앙 정렬, 조금 더 위로)
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * -0.05);
                    ctx.bezierCurveTo(0, -size * 0.35, -size * 0.4, -size * 0.35, -size * 0.4, size * -0.05);
                    ctx.bezierCurveTo(-size * 0.4, size * 0.2, 0, size * 0.45, 0, size * 0.45);
                    ctx.bezierCurveTo(0, size * 0.45, size * 0.4, size * 0.2, size * 0.4, size * -0.05);
                    ctx.bezierCurveTo(size * 0.4, -size * 0.35, 0, -size * 0.35, 0, size * -0.05);
                    ctx.fill();
                    break;
                case 'speed':
                    // 속도: 화살표
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, 0);
                    ctx.lineTo(size * 0.3, 0);
                    ctx.lineTo(0, -size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, 0);
                    ctx.lineTo(0, size * 0.4);
                    ctx.lineTo(size * 0.3, 0);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bulletSpeed':
                    // 총알 속도: 번개
                    ctx.fillStyle = '#ffaa00'; // 파스텔 오렌지
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.4);
                    ctx.lineTo(size * 0.1, 0);
                    ctx.lineTo(-size * 0.1, 0);
                    ctx.lineTo(size * 0.2, size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'ammo':
                    // 탄약: 원
                    ctx.fillStyle = '#ffffff'; // 파스텔 화이트
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'fireRate':
                    // 발사 속도: 별
                    ctx.fillStyle = '#ff00ff'; // 파스텔 마젠타
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.4 : size * 0.2;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'reload':
                    // 재장전: 시계
                    ctx.strokeStyle = '#00ffff'; // 파스텔 시안
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -size * 0.3);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.2, 0);
                    ctx.stroke();
                    break;
                case 'critical':
                    // 크리티컬: X 표시
                    ctx.strokeStyle = '#ff0000'; // 파스텔 레드
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, -size * 0.3);
                    ctx.lineTo(size * 0.3, size * 0.3);
                    ctx.moveTo(size * 0.3, -size * 0.3);
                    ctx.lineTo(-size * 0.3, size * 0.3);
                    ctx.stroke();
                    break;
                case 'doubleShot':
                    // 더블샷: 두 개의 원
                    ctx.fillStyle = '#ffc107'; // 파스텔 옐로우
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.2, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'dodge':
                    // 구르기: 대시선
                    ctx.strokeStyle = '#8888ff'; // 파스텔 블루
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.4, 0);
                    ctx.lineTo(size * 0.4, 0);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    break;
                case 'revive':
                    // 부활: 십자가
                    ctx.fillStyle = '#00ff88'; // 파스텔 그린
                    ctx.fillRect(-size * 0.15, -size * 0.4, size * 0.3, size * 0.8);
                    ctx.fillRect(-size * 0.4, -size * 0.15, size * 0.8, size * 0.3);
                    break;
                case 'deepWound':
                    // 깊은 상처: 칼
                    ctx.fillStyle = '#880000';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.1, size * 0.2);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.1, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'giant':
                    // 거대화: 큰 사각형
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-size * 0.4, -size * 0.4, size * 0.8, size * 0.8);
                    // 내부 작은 사각형
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(-size * 0.25, -size * 0.25, size * 0.5, size * 0.5);
                    break;
                case 'sniper':
                    // 저격수: 스코프
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    // 외부 원
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    // 십자선
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.4, 0);
                    ctx.lineTo(size * 0.4, 0);
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(0, size * 0.4);
                    ctx.stroke();
                    // 중앙 점
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'oneShotOneKill':
                    // 원샷원킬: 큰 총알
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    // 중앙 X
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.2);
                    ctx.lineTo(size * 0.2, size * 0.2);
                    ctx.moveTo(size * 0.2, -size * 0.2);
                    ctx.lineTo(-size * 0.2, size * 0.2);
                    ctx.stroke();
                    break;
                case 'poisonBullet':
                    // 독 탄환: 독 방울
                    ctx.fillStyle = '#006600';
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.1, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // 작은 방울
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, size * 0.15, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, size * 0.15, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'reloadHeal':
                    // 재장전 회복: 하트 + 화살표
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.3, -size * 0.1, -size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.3, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.3, size * 0.3, size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(size * 0.3, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    // 화살표
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(size * 0.2, 0);
                    ctx.lineTo(0, -size * 0.2);
                    ctx.lineTo(0, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bigBullet':
                    // 큰 탄환: 큰 원
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // 내부 작은 원
                    ctx.fillStyle = '#888888';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'survivalInstinct':
                    // 생존본능: 번개 + 하트
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.3);
                    ctx.lineTo(size * 0.1, 0);
                    ctx.lineTo(-size * 0.1, 0);
                    ctx.lineTo(size * 0.2, size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.25, -size * 0.1, -size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.25, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.25, size * 0.3, size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(size * 0.25, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    break;
                case 'lastBullet':
                    // 비장의 한발: 큰 총알 + 별
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-size * 0.3, -size * 0.15, size * 0.6, size * 0.3);
                    ctx.fillStyle = '#ffc107';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.2 : size * 0.1;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'recoveryContract':
                    // 회복계약: 하트 + 화살표 위
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.3, -size * 0.1, -size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.3, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.3, size * 0.3, size * 0.3, size * 0.1);
                    ctx.bezierCurveTo(size * 0.3, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(-size * 0.15, -size * 0.1);
                    ctx.lineTo(size * 0.15, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'purify':
                    // 정화: 원 + 십자가
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(0, size * 0.4);
                    ctx.moveTo(-size * 0.4, 0);
                    ctx.lineTo(size * 0.4, 0);
                    ctx.stroke();
                    break;
                case 'focusedFire':
                    // 집중 사격: 눈 모양
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, 0, size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, 0, size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, 0, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, 0, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'ghost':
                    // 유령: 반투명 원 + 작은 원들
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#cccccc';
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.1, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // 작은 원들 (유령 느낌)
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, size * 0.1, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, size * 0.1, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    break;
                case 'fortify':
                    // 거점확보: 방패 모양
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    // 방패 본체
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.3, -size * 0.2);
                    ctx.lineTo(-size * 0.3, size * 0.2);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.3, size * 0.2);
                    ctx.lineTo(size * 0.3, -size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // 십자가
                    ctx.strokeStyle = '#000000';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.2);
                    ctx.lineTo(0, size * 0.1);
                    ctx.moveTo(-size * 0.15, -size * 0.05);
                    ctx.lineTo(size * 0.15, -size * 0.05);
                    ctx.stroke();
                    break;
                case 'overheat':
                    // 과열: 불꽃 모양
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.2, -size * 0.1);
                    ctx.lineTo(-size * 0.15, size * 0.1);
                    ctx.lineTo(0, size * 0.2);
                    ctx.lineTo(size * 0.15, size * 0.1);
                    ctx.lineTo(size * 0.2, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // 작은 불꽃들
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.2);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.lineTo(0, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(size * 0.1, -size * 0.2);
                    ctx.lineTo(size * 0.05, 0);
                    ctx.lineTo(0, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'gamble':
                    // 도박: 주사위 모양
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
                    // 주사위 눈
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, -size * 0.15, size * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, size * 0.15, size * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'weaken':
                    // 약화: 아래 화살표
                    ctx.fillStyle = '#888888';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(-size * 0.2, size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.2, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // 감소 표시
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, size * 0.2);
                    ctx.lineTo(size * 0.15, size * 0.2);
                    ctx.stroke();
                    break;
                case 'damageBoost':
                    // 데미지 1.2배: 위 화살표
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(-size * 0.2, -size * 0.1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.2, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // 증가 표시
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, -size * 0.2);
                    ctx.lineTo(size * 0.15, -size * 0.2);
                    ctx.stroke();
                    break;
                case 'lightning':
                    // 번개: 번개 모양
                    ctx.fillStyle = '#ffff00';
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.4);
                    ctx.lineTo(size * 0.1, -size * 0.2);
                    ctx.lineTo(-size * 0.05, -size * 0.1);
                    ctx.lineTo(size * 0.15, size * 0.2);
                    ctx.lineTo(-size * 0.1, size * 0.3);
                    ctx.lineTo(0, size * 0.1);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'shield':
                    // 방어막: 방패 모양
                    ctx.fillStyle = '#0066ff';
                    ctx.strokeStyle = '#0044cc';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.3, -size * 0.2);
                    ctx.lineTo(-size * 0.3, size * 0.1);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.3, size * 0.1);
                    ctx.lineTo(size * 0.3, -size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'regeneration':
                    // 재생: 하트 + 플러스
                    ctx.fillStyle = '#ff006e';
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(0, -size * 0.1, -size * 0.25, -size * 0.1, -size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.25, size * 0.3, 0, size * 0.5, 0, size * 0.5);
                    ctx.bezierCurveTo(0, size * 0.5, size * 0.25, size * 0.3, size * 0.25, size * 0.1);
                    ctx.bezierCurveTo(size * 0.25, -size * 0.1, 0, -size * 0.1, 0, size * 0.1);
                    ctx.fill();
                    // 플러스 표시
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-size * 0.1, -size * 0.05, size * 0.2, size * 0.03);
                    ctx.fillRect(-size * 0.05, -size * 0.1, size * 0.03, size * 0.2);
                    break;
                case 'shotgun':
                    // 샷건: 산탄총 모양
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-size * 0.4, -size * 0.1, size * 0.8, size * 0.2);
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(-size * 0.35, -size * 0.05, size * 0.7, size * 0.1);
                    break;
                case 'ragged':
                    // 오합지졸: 깨진 총알
                    ctx.fillStyle = '#888888';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.2, -size * 0.2);
                    ctx.lineTo(size * 0.2, size * 0.2);
                    ctx.stroke();
                    break;
                default:
                    // 기본: 사각형
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
            }
            
            ctx.restore();
        }

        // 증강 아이콘 목록 그리기
        function drawAugmentIcons(character, x, y, align = 'left') {
            const iconSize = 32; // 2배 증가 (16 -> 32)
            const spacing = 8; // 간격도 2배 증가
            const bgSize = iconSize + 4; // 배경 크기
            
            // 마우스 호버 감지
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseCanvasX = (mouse.x - rect.left) * scaleX;
            const mouseCanvasY = (mouse.y - rect.top) * scaleY;
            
            character.augmentations.forEach((aug, index) => {
                let iconX;
                if (align === 'right') {
                    iconX = x - (character.augmentations.length - index - 1) * (iconSize + spacing) - iconSize / 2;
                } else {
                    iconX = x + index * (iconSize + spacing) + iconSize / 2;
                }
                
                // 마우스 호버 체크
                const iconLeft = iconX - bgSize / 2;
                const iconRight = iconX + bgSize / 2;
                const iconTop = y - bgSize / 2;
                const iconBottom = y + bgSize / 2;
                
                if (mouseCanvasX >= iconLeft && mouseCanvasX <= iconRight &&
                    mouseCanvasY >= iconTop && mouseCanvasY <= iconBottom) {
                    hoveredAugment = {
                        aug: aug,
                        x: iconX,
                        y: y
                    };
                }
                
                // 배경 사각형 (호버 시 강조)
                if (hoveredAugment && hoveredAugment.aug === aug) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                }
                ctx.fillRect(iconX - bgSize / 2, y - bgSize / 2, bgSize, bgSize);
                
                // 아이콘 그리기
                drawAugmentIcon(ctx, iconX, y, iconSize, aug.id);
            });
        }

        // 탄환수 표시 (체력 아래 - 하얀색 원)
        function drawAmmoCount(character, x, y, align = 'left') {
            const circleSize = 12; // 체력바(30px)보다 더 작은 원
            const spacing = 4;
            const radius = circleSize / 2;
            const centerY = y + radius; // 원의 중심 Y 좌표
            
            // 총 탄환수만큼 원 그리기 (사용한 탄환은 반투명)
            for (let i = 0; i < character.maxAmmo; i++) {
                if (i < character.ammo) {
                    // 남은 탄환: 불투명 하얀색
                    ctx.fillStyle = '#ffffff'; // 파스텔 화이트
                } else {
                    // 사용한 탄환: 반투명
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                }
                
                let centerX;
                if (align === 'right') {
                    // 오른쪽 정렬: 오른쪽부터 왼쪽으로
                    centerX = x - (character.maxAmmo - i - 1) * (circleSize + spacing) - radius;
                } else {
                    // 왼쪽 정렬: 왼쪽부터 오른쪽으로
                    centerX = x + i * (circleSize + spacing) + radius;
                }
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 마름모 그리기 함수
        function drawDiamond(x, y, size, color) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2); // 위
            ctx.lineTo(x + size / 2, y); // 오른쪽
            ctx.lineTo(x, y + size / 2); // 아래
            ctx.lineTo(x - size / 2, y); // 왼쪽
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // 카운트다운 표시 (마름모 아래)
        function drawCountdown() {
            const countdownValue = gameState.countdown > 0 ? gameState.countdown : gameState.augmentCountdown;
            if (countdownValue <= 0) return;
            
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const y = 100; // 마름모 아래
            
            // 반투명 배경
            const textWidth = ctx.measureText(countdownValue).width;
            const padding = 30;
            ctx.fillRect(
                canvas.width / 2 - textWidth / 2 - padding,
                y - 50,
                textWidth + padding * 2,
                100
            );
            
            // 숫자 표시
            ctx.fillStyle = '#ffffff';
            ctx.fillText(countdownValue, canvas.width / 2, y);
            ctx.restore();
        }

        // 승리 표시 마름모 그리기 (화면 위쪽 가운데)
        function drawWinIndicators() {
            const totalRounds = 7;
            const diamondSize = 20;
            const spacing = 5;
            const totalWidth = (totalRounds * diamondSize) + ((totalRounds - 1) * spacing);
            const startX = (canvas.width - totalWidth) / 2;
            const y = 35; // 살짝 아래로 내림

            for (let i = 0; i < totalRounds; i++) {
                let color;
                // 라운드 순서대로 승자를 표시
                if (i < gameState.roundWins.length) {
                    if (gameState.roundWins[i] === 'player') {
                        // 플레이어 승리: 파란색
                        color = 'rgba(74, 158, 255, 0.8)';
                    } else {
                        // 적 승리: 빨간색
                        color = 'rgba(233, 69, 96, 0.8)';
                    }
                } else {
                    // 아직 진행되지 않은 라운드: 반투명 회색
                    color = 'rgba(255, 255, 255, 0.2)';
                }
                
                const x = startX + i * (diamondSize + spacing) + diamondSize / 2;
                drawDiamond(x, y, diamondSize, color);
            }
        }

        // 재장전 진행률 바 그리기 (동그란 바로)
        function drawReloadBar(character, x, y) {
            if (!character.isReloading) return;
            
            const now = Date.now();
            const elapsed = now - character.reloadStartTime;
            const progress = Math.min(elapsed / character.reloadTime, 1); // 0~1 사이 값
            
            const radius = 8; // 원의 반지름 (20% 줄임: 10 -> 8)
            const lineWidth = 4; // 선 두께 (30% 늘림: 3 -> 4)
            
            // 배경 원 (회색)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // 진행률 원 (하얀색)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(x, y, radius, -Math.PI / 2, -Math.PI / 2 + (progress * Math.PI * 2));
            ctx.stroke();
        }

        // 그리기 함수
        // 게임 시작 함수들
        function startSoloGame() {
            gameState.isMenu = false;
            document.getElementById('mainMenu').style.display = 'none';
            initGame();
        }

        function initGame() {
            // 게임 상태 초기화
            gameState.round = 1;
            gameState.playerWins = 0;
            gameState.enemyWins = 0;
            gameState.gameTime = 180;
            gameState.isGameOver = false;
            gameState.isPaused = true;
            gameState.roundWins = [];
            gameState.countdown = 3;
            gameState.augmentCountdown = 0;
            gameState.showOpponentSelecting = false;

            // 플레이어 초기화
            player.x = canvas.width * 0.2;
            player.y = canvas.height * 0.5;
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.angle = 0;
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.hasCritical = false;
            player.hasDoubleShot = false;
            player.hasDodge = false;
            player.hasRevive = false;
            player.hasRevived = false;
            player.hasDeepWound = false;
            player.hasOneShotOneKill = false;
            player.hasPoisonBullet = false;
            player.hasReloadHeal = false;
            player.hasSurvivalInstinct = false;
            player.hasLastBullet = false;
            player.hasRecoveryContract = false;
            player.hasRecoveryContractUsed = false;
            player.hasPurify = false;
            player.hasFocusedFire = false;
            player.hasShotgun = false;
            player.hasRagged = false;
            player.hasGhost = false;
            player.hasFortify = false;
            player.isFortified = false;
            player.fortifyStartTime = 0;
            player.lastPosition = { x: player.x, y: player.y };
            player.stationaryTime = 0;
            player.hasOverheat = false;
            player.overheatHitCount = 0;
            player.lastHitTime = 0;
            player.hasGamble = false;
            player.hasWeaken = false;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.hasDamageBoost = false;
            player.hasLightning = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.hasShield = false;
            player.shieldReady = false;
            player.shieldCooldown = 0;
            player.hasRegeneration = false;
            player.lastRegenTime = 0;
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.poisonEffects = [];
            player.isDodging = false;
            player.isReviving = false;
            player.isInvincible = false;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.damage = 1;
            player.speed = 3;

            // enemy 초기화
                enemy.x = canvas.width * 0.8;
                enemy.y = canvas.height * 0.5;
                enemy.health = 5;
                enemy.displayHealth = 5;
                enemy.maxHealth = 5;
                enemy.ammo = 6;
                enemy.maxAmmo = 6;
                enemy.bullets = [];
                enemy.augmentations = [];
                enemy.angle = Math.PI;
                enemy.bulletSpeedMultiplier = 1;
                enemy.bulletSizeMultiplier = 1;
                enemy.hasCritical = false;
                enemy.hasDoubleShot = false;
                enemy.hasDodge = false;
                enemy.hasRevive = false;
                enemy.hasRevived = false;
                enemy.hasDeepWound = false;
                enemy.hasOneShotOneKill = false;
                enemy.hasPoisonBullet = false;
                enemy.hasReloadHeal = false;
                enemy.hasSurvivalInstinct = false;
                enemy.hasLastBullet = false;
                enemy.hasRecoveryContract = false;
                enemy.hasRecoveryContractUsed = false;
                enemy.hasPurify = false;
                enemy.hasFocusedFire = false;
            enemy.hasShotgun = false;
            enemy.hasRagged = false;
            enemy.hasGhost = false;
            enemy.hasFortify = false;
            enemy.isFortified = false;
            enemy.fortifyStartTime = 0;
            enemy.lastPosition = { x: enemy.x, y: enemy.y };
            enemy.stationaryTime = 0;
            enemy.hasOverheat = false;
            enemy.overheatHitCount = 0;
            enemy.lastHitTime = 0;
            enemy.hasGamble = false;
            enemy.hasWeaken = false;
            enemy.isWeakened = false;
            enemy.weakenEndTime = 0;
            enemy.hasDamageBoost = false;
            enemy.hasLightning = false;
            enemy.isStunned = false;
            enemy.stunEndTime = 0;
            enemy.hasShield = false;
            enemy.shieldReady = false;
            enemy.shieldCooldown = 0;
            enemy.hasRegeneration = false;
            enemy.lastRegenTime = 0;
                enemy.isVulnerable = false;
                enemy.vulnerabilityUsed = false;
                enemy.poisonEffects = [];
                enemy.isDodging = false;
                enemy.isReviving = false;
                enemy.isInvincible = false;
                enemy.slowEndTime = 0;
                enemy.damageNumbers = [];
                enemy.damage = 1;
                enemy.speed = 2.5;
            enemy.reloadTime = 3000;

            // 첫 라운드 카운트다운 시작
            const initialCountdown = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(initialCountdown);
                    gameState.isPaused = false;
                }
            }, 1000);
        }

        function draw() {
            // 메뉴 화면 표시
            if (gameState.isMenu) {
                return; // 메뉴는 HTML로 표시되므로 여기서는 그리지 않음
            }

            // 호버된 증강 초기화
            hoveredAugment = null;
            
            // 화면 흔들림 적용
            let shakeX = 0;
            let shakeY = 0;
            if (gameState.shake.duration > 0) {
                shakeX = (Math.random() - 0.5) * gameState.shake.intensity;
                shakeY = (Math.random() - 0.5) * gameState.shake.intensity;
                gameState.shake.duration = Math.max(0, gameState.shake.duration - 16); // 약 60fps 기준
                gameState.shake.intensity *= 0.9; // 점진적으로 감소
            }

            // 배경 클리어 (흔들림 전에 그리기)
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 화면 흔들림 적용
            ctx.save();
            ctx.translate(shakeX, shakeY);

            // 격자 그리기
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // 총알 그리기
            player.bullets.forEach(bullet => bullet.draw());
            enemy.bullets.forEach(bullet => bullet.draw());

            // 구르기 잔상 그리기
            function drawDodgeTrail(character) {
                if (character.isDodging && character.dodgeTrail && character.dodgeTrail.length > 0) {
                    // 잔상 효과 (과거 위치 그리기)
                    character.dodgeTrail.forEach((trail, index) => {
                        const fadeAlpha = trail.alpha * (1 - index * 0.2); // 점진적으로 투명
                        ctx.globalAlpha = Math.max(0, fadeAlpha);
                        ctx.fillStyle = character.color;
                        ctx.beginPath();
                        ctx.arc(trail.x, trail.y, character.radius * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;
                }
            }

            // 플레이어 그리기
            drawDodgeTrail(player);
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            
            // 무적 상태일 때 반투명
            if (player.isInvincible || player.isReviving) {
                ctx.globalAlpha = 0.5;
            } else if (player.hasGhost) {
                // 유령 증강: 살짝 흐려지게
                ctx.globalAlpha = 0.7;
            }
            
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
            ctx.fill();
            // 거점확보: 하얀색 테두리
            if (player.hasFortify && player.isFortified) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // 방어막: 진한 파란색 테두리
            if (player.hasShield && player.shieldReady) {
                ctx.strokeStyle = '#0066ff'; // 진한 파란색
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            // 리볼버 그리기
            ctx.fillStyle = '#333'; // 파스텔 그레이
            ctx.fillRect(player.radius - 7.5, -4.5, 22.5, 9); // 1.5배 증가
            ctx.globalAlpha = 1.0;
            ctx.restore();

            // 적 그리기
            drawDodgeTrail(enemy);
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);
            
            // 무적 상태일 때 반투명
            if (enemy.isInvincible || enemy.isReviving) {
                ctx.globalAlpha = 0.5;
            } else if (enemy.hasGhost) {
                // 유령 증강: 살짝 흐려지게
                ctx.globalAlpha = 0.7;
            }
            
            ctx.fillStyle = enemy.color;
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
            ctx.fill();
            // 방어막: 진한 파란색 테두리
            if (enemy.hasShield && enemy.shieldReady) {
                ctx.strokeStyle = '#0066ff'; // 진한 파란색
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            // 리볼버 그리기
            ctx.fillStyle = '#333'; // 파스텔 그레이
            ctx.fillRect(enemy.radius - 7.5, -4.5, 22.5, 9); // 1.5배 증가
            ctx.globalAlpha = 1.0;
            ctx.restore();

            // 화면 흔들림 효과 종료
            ctx.restore();
            
            // 데미지 숫자 그리기 (흔들림 영향 받음)
            ctx.save();
            ctx.translate(shakeX, shakeY);
            drawDamageNumbers(player);
                drawDamageNumbers(enemy);
            ctx.restore();

            // UI 요소들 (흔들림의 영향을 받지 않음)
            // 승리 표시 마름모 (화면 위쪽 가운데)
            drawWinIndicators();
            
            // 카운트다운 표시 (마름모 아래)
            if (gameState.countdown > 0 || gameState.augmentCountdown > 0) {
                drawCountdown();
            }
            
            // 상대 선택 중 메시지 표시
            if (gameState.showOpponentSelecting) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const text = '상대가 선택중입니다';
                const textWidth = ctx.measureText(text).width;
                const padding = 40;
                const y = canvas.height / 2;
                
                // 배경 사각형
                ctx.fillRect(
                    canvas.width / 2 - textWidth / 2 - padding,
                    y - 40,
                    textWidth + padding * 2,
                    80
                );
                
                // 텍스트
                ctx.fillStyle = '#ffffff';
                ctx.fillText(text, canvas.width / 2, y);
                ctx.restore();
            }
            
            // 플레이어 체력 표시 (왼쪽 위)
            const playerHealthY = 20;
            drawHealthHearts(player, 20, playerHealthY, true);
            // 플레이어 탄환수 표시 (체력 아래 - 원으로)
            const playerAmmoY = playerHealthY + 40;
            drawAmmoCount(player, 20, playerAmmoY, 'left');
            // 플레이어 증강 아이콘 표시 (탄환 아래)
            drawAugmentIcons(player, 20, playerAmmoY + 50, 'left');
            // 플레이어 재장전 바 표시 (플레이어 바로 왼쪽 위) - 플레이어 위치에 흔들림 적용
            if (player.isReloading) {
                drawReloadBar(player, player.x - 40 + shakeX, player.y - 40 + shakeY); // 캐릭터 크기 증가에 맞춰 조정
            }
            
            // 적 체력 표시 (오른쪽 위)
            const fixedBarWidth = 150; // 고정된 바 길이
            const enemyHealthX = canvas.width - fixedBarWidth - 20;
            const enemyHealthY = 20;
            drawHealthHearts(enemy, enemyHealthX, enemyHealthY, false);
            // 적 탄환수 표시 (체력 아래, 오른쪽 정렬 - 원으로)
            const enemyAmmoY = enemyHealthY + 40;
            drawAmmoCount(enemy, enemyHealthX + fixedBarWidth, enemyAmmoY, 'right');
            // 적 증강 아이콘 표시 (탄환 아래)
            drawAugmentIcons(enemy, enemyHealthX + fixedBarWidth, enemyAmmoY + 50, 'right');
            // 적 재장전 바 표시 (적 바로 오른쪽 위) - 흔들림 적용
            if (enemy.isReloading) {
                drawReloadBar(enemy, enemy.x + 40 + shakeX, enemy.y - 40 + shakeY);
            }
            
            // 증강 툴팁 표시
            if (hoveredAugment) {
                drawAugmentTooltip(hoveredAugment.aug, hoveredAugment.x, hoveredAugment.y);
            }
        }
        
        // 증강 툴팁 그리기
        function drawAugmentTooltip(aug, x, y) {
            ctx.save();
            
            const padding = 12;
            const lineHeight = 24;
            const fontSize = 18;
            ctx.font = `bold ${fontSize}px Arial`;
            
            // 텍스트 크기 측정
            const titleWidth = ctx.measureText(aug.name).width;
            ctx.font = `${fontSize - 2}px Arial`;
            const descWidth = ctx.measureText(aug.description).width;
            const tooltipWidth = Math.max(titleWidth, descWidth) + padding * 2;
            const tooltipHeight = lineHeight * 2 + padding * 2;
            
            // 툴팁 위치 (아이콘 위쪽 또는 아래쪽)
            let tooltipX = x;
            let tooltipY = y - 50 - tooltipHeight; // 아이콘 위쪽
            
            // 화면 경계 체크
            if (tooltipY < 0) {
                tooltipY = y + 50; // 아이콘 아래쪽
            }
            if (tooltipX + tooltipWidth / 2 > canvas.width) {
                tooltipX = canvas.width - tooltipWidth / 2;
            }
            if (tooltipX - tooltipWidth / 2 < 0) {
                tooltipX = tooltipWidth / 2;
            }
            
            // 배경
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            drawRoundedRect(
                tooltipX - tooltipWidth / 2,
                tooltipY,
                tooltipWidth,
                tooltipHeight,
                8
            );
            ctx.fill();
            ctx.stroke();
            
            // 제목
            ctx.fillStyle = '#ffc107';
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(aug.name, tooltipX, tooltipY + padding);
            
            // 설명
            ctx.fillStyle = '#ffffff';
            ctx.font = `${fontSize - 2}px Arial`;
            ctx.fillText(aug.description, tooltipX, tooltipY + padding + lineHeight);
            
            ctx.restore();
        }

        // UI 업데이트 (체력 애니메이션 및 데미지 숫자)
        function updateUI() {
            // 플레이어 체력 애니메이션
            if (player.displayHealth !== player.health) {
                const diff = player.health - player.displayHealth;
                const speed = 0.15; // 애니메이션 속도
                player.displayHealth += diff * speed;
                // 거의 같아지면 바로 맞춤
                if (Math.abs(diff) < 0.01) {
                    player.displayHealth = player.health;
                }
            }
            
            // 적 체력 애니메이션
            if (enemy.displayHealth !== enemy.health) {
                const diff = enemy.health - enemy.displayHealth;
                const speed = 0.15; // 애니메이션 속도
                enemy.displayHealth += diff * speed;
                // 거의 같아지면 바로 맞춤
                if (Math.abs(diff) < 0.01) {
                    enemy.displayHealth = enemy.health;
                }
            }
            
            // 데미지 숫자 업데이트
            updateDamageNumbers(player);
            updateDamageNumbers(enemy);
            
            // 독 효과 처리
            updatePoisonEffects(player);
                updatePoisonEffects(enemy);
        }
        
        // 독 효과 업데이트
        function updatePoisonEffects(character) {
            const now = Date.now();
            for (let i = character.poisonEffects.length - 1; i >= 0; i--) {
                const poison = character.poisonEffects[i];
                const elapsed = now - poison.startTime;
                
                // 3초가 지나면 제거
                if (elapsed >= poison.duration) {
                    character.poisonEffects.splice(i, 1);
                    continue;
                }
                
                // 1초마다 0.2 데미지 (정화 증강이 있으면 무시)
                if (now - poison.lastDamageTime >= 1000 && !poison.target.hasPurify) {
                    // 유령 증강: 25% 확률로 독 데미지 무시
                    if (poison.target.hasGhost && Math.random() < 0.25) {
                        // "무시" 텍스트 표시
                        poison.target.damageNumbers.push({
                            x: poison.target.x,
                            y: poison.target.y,
                            damage: 0,
                            isCritical: false,
                            isGhost: true, // 유령 무시 여부
                            startTime: now,
                            duration: 1000,
                            offsetY: 0
                        });
                        poison.lastDamageTime = now; // 다음 데미지 타이머 리셋
                        continue; // 데미지 적용하지 않음
                    }
                    
                    let poisonDamage = poison.damagePerSecond;
                    // 거점확보: 데미지 *0.5
                    if (poison.target.hasFortify && poison.target.isFortified) {
                        poisonDamage *= 0.5;
                    }
                    
                    poison.target.health -= poisonDamage;
                    poison.lastDamageTime = now;
                    
                    // 독 데미지 숫자 표시 (어두운 초록색)
                    poison.target.damageNumbers.push({
                        x: poison.target.x,
                        y: poison.target.y,
                        damage: poison.damagePerSecond,
                        isCritical: false,
                        isPoison: true, // 독 데미지 여부
                        startTime: now,
                        duration: 1000,
                        offsetY: 0
                    });
                    
                    // 체력이 0 이하가 되면 처리
                    if (poison.target.health <= 0) {
                        poison.target.health = 0;
                        // 부활 체크
                        if (poison.target.hasRevive && !poison.target.hasRevived && !poison.target.isReviving) {
                            poison.target.hasRevived = true;
                            poison.target.isReviving = true;
                            poison.target.reviveTime = now + 2000;
                        } else {
                            endRound(poison.target === player ? 'enemy' : 'player');
                        }
                    }
                }
            }
        }
        
        // 데미지 숫자 업데이트
        function updateDamageNumbers(character) {
            const now = Date.now();
            for (let i = character.damageNumbers.length - 1; i >= 0; i--) {
                const damageNum = character.damageNumbers[i];
                const elapsed = now - damageNum.startTime;
                
                // 시간이 지나면 제거
                if (elapsed >= damageNum.duration) {
                    character.damageNumbers.splice(i, 1);
                    continue;
                }
                
                // 위로 올라가는 애니메이션
                const progress = elapsed / damageNum.duration;
                damageNum.offsetY = -30 * progress; // 위로 30px 이동
            }
        }
        
        // 데미지 숫자 그리기
        function drawDamageNumbers(character) {
            const now = Date.now();
            character.damageNumbers.forEach(damageNum => {
                const elapsed = now - damageNum.startTime;
                const progress = elapsed / damageNum.duration;
                
                // 페이드아웃 효과
                const alpha = 1 - progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // 색상 결정: 방어막 무시면 진한 파란색, 유령 무시면 회색, 기절이면 노란색, 독 데미지면 어두운 초록색, 크리티컬이면 어두운 노란색, 아니면 하얀색
                if (damageNum.isShield) {
                    ctx.fillStyle = '#0066ff'; // 진한 파란색
                } else if (damageNum.isGhost) {
                    ctx.fillStyle = '#888888'; // 회색
                } else if (damageNum.isStunned) {
                    ctx.fillStyle = '#ffffff'; // 하얀색
                } else if (damageNum.isPoison) {
                    ctx.fillStyle = '#006600'; // 어두운 초록색
                } else if (damageNum.isCritical) {
                    ctx.fillStyle = '#CCAA00'; // 어두운 노란색
                } else {
                    ctx.fillStyle = '#ffffff'; // 하얀색
                }
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 캐릭터 위치 기준으로 데미지 숫자 또는 특수 텍스트 표시
                let displayText;
                if (damageNum.isShield || damageNum.isGhost) {
                    displayText = '무시';
                } else if (damageNum.isStunned) {
                    displayText = '기절';
                } else {
                    displayText = damageNum.damage.toString();
                }
                ctx.fillText(
                    displayText,
                    damageNum.x,
                    damageNum.y + damageNum.offsetY
                );
                
                ctx.restore();
            });
        }

        // 게임 루프
        let lastTime = 0;
        function gameLoop(currentTime) {
            // 메뉴 화면이 아닐 때만 게임 로직 실행
            if (!gameState.isMenu && !gameState.isPaused && !gameState.isGameOver) {
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                // 타이머 감소 (초당 1씩)
                if (deltaTime >= 1000) {
                    gameState.gameTime--;
                    lastTime = currentTime;

                    // 시간 초과
                    if (gameState.gameTime <= 0) {
                        if (player.health > enemy.health) {
                            endRound('player');
                        } else if (enemy.health > player.health) {
                            endRound('enemy');
                        } else {
                            // 무승부 - 체력이 더 많은 쪽이 승리
                            endRound(player.health >= enemy.health ? 'player' : 'enemy');
                        }
                    }
                }

                updatePlayer();
                updateEnemy();
                updateBullets(enemy);
                updateBullets(player);
            }

            draw();
            
            // 메뉴 화면이 아닐 때만 UI 업데이트
            if (!gameState.isMenu) {
            updateUI();
            }

            requestAnimationFrame(gameLoop);
        }

        // 게임 시작 (메뉴에서 시작)
        gameLoop(0);
    </script>
</body>
</html>
