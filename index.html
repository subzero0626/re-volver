<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î¶¨Î≥ºÎ≤Ñ ÎìÄÏñº</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #0f0f1e;
            color: #fff;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #0f0f1e;
        }


        #augmentModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #e94560;
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        #augmentModal h2 {
            color: #e94560;
            margin-bottom: 20px;
        }

        #augmentViewModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 1000;
            max-width: 600px;
            width: 90%;
        }

        #augmentViewModal h2 {
            color: #4a9eff;
            margin-bottom: 20px;
        }

        .augment-option {
            background: rgba(233, 69, 96, 0.2);
            border: 2px solid #e94560;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .augment-option:hover {
            background: rgba(233, 69, 96, 0.4);
            transform: scale(1.05);
        }

        .augment-option h4 {
            color: #ffc107;
            margin-bottom: 5px;
        }

        #gameOverModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            border: 3px solid #ffc107;
            border-radius: 15px;
            padding: 40px;
            z-index: 1001;
            text-align: center;
        }

        #gameOverModal h2 {
            color: #ffc107;
            font-size: 32px;
            margin-bottom: 20px;
        }

        #collectionModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 3000;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
            pointer-events: auto;
        }

        #collectionModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        #roomModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 50px;
            padding-bottom: 100px;
            z-index: 3002;
            max-width: 625px;
            width: 90%;
            text-align: center;
            pointer-events: auto;
        }

        #roomModal h2 {
            color: #4a9eff;
            font-size: 40px;
            margin-bottom: 38px;
        }

        #controlsModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 3001;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        #controlsModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        #controlsModal .control-item {
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        #controlsModal .control-item h3 {
            color: #4a9eff;
            font-size: 20px;
            margin-bottom: 10px;
        }

        #controlsModal .control-item p {
            color: #ffffff;
            font-size: 16px;
            line-height: 1.6;
            margin: 5px 0;
        }

        #controlsModal .key {
            display: inline-block;
            padding: 5px 10px;
            background: rgba(74, 158, 255, 0.3);
            border: 1px solid #4a9eff;
            border-radius: 5px;
            font-weight: bold;
            margin: 0 5px;
        }

        .collection-item {
            background: rgba(74, 158, 255, 0.1);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            transition: all 0.3s;
            position: relative; /* ÏÑ†ÌÉù ÌöüÏàò ÏúÑÏπò ÏßÄÏ†ïÏùÑ ÏúÑÌï¥ */
        }
        
        .collection-item .select-count {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(74, 158, 255, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .collection-item.locked {
            background: rgba(100, 100, 100, 0.1);
            border-color: #666;
            filter: grayscale(100%);
            opacity: 0.5;
        }

        .collection-item h4 {
            color: #4a9eff;
            margin-bottom: 8px;
            font-size: 20px;
        }

        .collection-item.locked h4 {
            color: #666;
        }

        .collection-item p {
            color: #ccc;
            margin: 0;
            font-size: 16px;
        }

        .collection-item.locked p {
            color: #888;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s;
        }

        button:hover {
            background: #c7364d;
        }

        /* Ï†úÌôî ÌëúÏãú ÎÑ§Ïò® ÎßàÎ¶ÑÎ™® Ïä§ÌÉÄÏùº - ÎßàÎ¶ÑÎ™® (Ï†ïÏÇ¨Í∞ÅÌòï 45ÎèÑ ÌöåÏ†Ñ) */
        .neon-diamond {
            width: 16.875px;
            height: 16.875px;
            position: relative;
            /* Îæ∞Ï°±Ìïú Î∂ÄÎ∂ÑÏù¥ ÏúÑÎ°ú Í∞ÄÎèÑÎ°ù 45ÎèÑ ÌöåÏ†Ñ */
            transform: rotate(45deg);
            border: 3px solid #fff;
            background: transparent;
            box-shadow: 
                0 0 10px rgba(255, 255, 255, 0.5),
                0 0 20px rgba(255, 255, 255, 0.4),
                0 0 30px rgba(255, 255, 255, 0.3);
        }
        
        .kill-number {
            font-size: 24px;
            color: #fff;
            text-shadow: 
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 20px rgba(255, 255, 255, 0.6);
            font-weight: bold;
        }

        #killCountInfo {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
            line-height: 1.4;
            white-space: normal;
            max-width: 200px;
            transition: opacity 0.3s;
        }

        .achievement-icon:hover::after {
            opacity: 1;
        }

        /* ÌôîÎ©¥ Ï†ÑÌôò Ïä§ÌÉÄÏùº */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 30, 0.95);
            display: none;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 40px;
            padding-top: 60px;
            z-index: 2000;
        }

        .screen.active {
            display: flex;
        }


        .screen h1 {
            font-size: 100px;
            color: #e94560;
            margin-bottom: 25px;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }

        .screen h2 {
            font-size: 48px;
            color: #4a9eff;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(74, 158, 255, 0.5);
        }

        .back-button {
            font-size: 32px;
            color: #fff;
            cursor: pointer;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            transition: all 0.3s;
        }

        .back-button:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
            transform: scale(1.05);
        }

        #mainMenu h1 {
            font-size: 100px;
            color: #e94560;
            margin-bottom: 25px;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            animation: neonFlicker 1.67s ease-in-out;
            animation-fill-mode: forwards;
            opacity: 0;
        }

        @keyframes neonFlicker {
            0% {
                opacity: 0;
                text-shadow: 0 0 5px rgba(233, 69, 96, 0.2);
            }
            20% {
                opacity: 0.3;
                text-shadow: 0 0 10px rgba(233, 69, 96, 0.4);
            }
            40% {
                opacity: 0.1;
                text-shadow: 0 0 5px rgba(233, 69, 96, 0.2);
            }
            60% {
                opacity: 0.6;
                text-shadow: 0 0 18px rgba(233, 69, 96, 0.6);
            }
            80% {
                opacity: 0.3;
                text-shadow: 0 0 10px rgba(233, 69, 96, 0.4);
            }
            100% {
                opacity: 1;
                text-shadow: 0 0 20px rgba(233, 69, 96, 0.5),
                            0 0 40px rgba(233, 69, 96, 0.5),
                            0 0 60px rgba(233, 69, 96, 0.3);
            }
        }

        @keyframes neonFlickerLocked {
            0% {
                opacity: 0;
                text-shadow: 0 0 5px rgba(136, 136, 136, 0.1);
            }
            20% {
                opacity: 0.2;
                text-shadow: 0 0 8px rgba(136, 136, 136, 0.2);
            }
            40% {
                opacity: 0.1;
                text-shadow: 0 0 5px rgba(136, 136, 136, 0.1);
            }
            60% {
                opacity: 0.4;
                text-shadow: 0 0 12px rgba(136, 136, 136, 0.3);
            }
            80% {
                opacity: 0.2;
                text-shadow: 0 0 8px rgba(136, 136, 136, 0.2);
            }
            100% {
                opacity: 0.6;
                text-shadow: 0 0 10px rgba(136, 136, 136, 0.3),
                            0 0 20px rgba(136, 136, 136, 0.2),
                            0 0 30px rgba(136, 136, 136, 0.1);
            }
        }

        #soloPlayText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            margin-left: 12px;
            display: block;
            margin-top: 15px;
        }

        #soloPlayText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #multiPlayText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        #multiPlayText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #multiModeSelection {
            max-height: 0;
            opacity: 0;
            overflow: visible;
            margin-top: 0;
            margin-left: 12px;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
            pointer-events: none;
        }

        #multiModeSelection.expanded {
            max-height: 200px;
            opacity: 1;
            margin-top: 10px;
            pointer-events: auto;
        }

        #settingsText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        #settingsText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #storageText {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        #storageText:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        #achievementText {
            font-size: 42px;
            color: #666;
            cursor: not-allowed;
            margin-left: 12px;
            display: block;
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(136, 136, 136, 0.3),
                        0 0 20px rgba(136, 136, 136, 0.2),
                        0 0 30px rgba(136, 136, 136, 0.1),
                        0 0 40px rgba(136, 136, 136, 0.05);
            transition: all 0.3s;
            opacity: 0.5;
            filter: grayscale(100%);
        }

        #achievementText:hover {
            color: #666;
            text-shadow: 0 0 10px rgba(136, 136, 136, 0.3),
                        0 0 20px rgba(136, 136, 136, 0.2),
                        0 0 30px rgba(136, 136, 136, 0.1),
                        0 0 40px rgba(136, 136, 136, 0.05);
            transform: none;
        }

        #shopModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #ffc107;
            border-radius: 15px;
            padding: 30px;
            z-index: 3001;
            max-width: 1100px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        #shopModal h2 {
            color: #ffc107;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        .shop-item {
            background: rgba(255, 193, 7, 0.1);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 22px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            min-height: 225px; /* Í∞ÄÎ°ú,ÏÑ∏Î°ú 10% Í∞êÏÜå */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .shop-item:hover {
            transform: scale(1.02);
        }
        
        .shop-item.rarity-common {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #ffffff;
        }
        
        .shop-item.rarity-rare {
            background: rgba(74, 158, 255, 0.1);
            border: 2px solid #4a9eff;
        }
        
        .shop-item.rarity-epic {
            background: rgba(136, 0, 255, 0.1);
            border: 2px solid #8800ff;
        }
        
        .rarity-icon {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 20px;
            height: 20px;
            z-index: 10;
        }
        
        .rarity-icon.triangle {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 17px solid;
            background: transparent;
        }
        
        .rarity-icon.triangle.common {
            border-bottom-color: #ffffff;
        }
        
        .rarity-icon.square {
            width: 17px;
            height: 17px;
            background: #4a9eff;
        }
        
        .rarity-icon.pentagon {
            width: 17px;
            height: 17px;
            background: #8800ff;
            clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
        }


        .shop-item h4 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 22px;
        }
        
        .shop-item.rarity-common h4 {
            color: #ffffff;
        }
        
        .shop-item.rarity-rare h4 {
            color: #ffffff;
        }
        
        .shop-item.rarity-epic h4 {
            color: #ffffff;
        }

        .shop-item p {
            color: #ffffff;
            font-size: 15px;
            margin: 5px 0;
            font-size: 14px;
        }
        
        .shop-item.rarity-common p {
            color: #ffffff;
        }
        
        .shop-item.rarity-rare p {
            color: #ffffff;
        }
        
        .shop-item.rarity-epic p {
            color: #ffffff;
        }

        .shop-item-price {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            margin-top: 10px;
        }

        .shop-item.owned {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #storageModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 1);
            border: 3px solid #4a9eff;
            border-radius: 15px;
            padding: 30px;
            z-index: 3001;
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        #storageModal h2 {
            color: #4a9eff;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
        }

        .storage-item {
            background: rgba(74, 158, 255, 0.1);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        
        .storage-item.rarity-common {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #ffffff;
        }
        
        .storage-item.rarity-rare {
            background: rgba(74, 158, 255, 0.1);
            border: 2px solid #4a9eff;
        }
        
        .storage-item.rarity-epic {
            background: rgba(136, 0, 255, 0.1);
            border: 2px solid #8800ff;
        }
        
        
        .storage-item .selected-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ffc107;
            color: #000;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            display: none;
        }
        
        .storage-item.selected .selected-badge {
            display: block;
        }

        .storage-item h4 {
            color: #4a9eff;
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        .storage-item.rarity-common h4 {
            color: #ffffff;
        }
        
        .storage-item.rarity-rare h4 {
            color: #ffffff;
        }
        
        .storage-item.rarity-epic h4 {
            color: #ffffff;
        }

        .storage-item p {
            color: #ffffff;
            margin: 5px 0;
            font-size: 14px;
        }

        .menu-text {
            font-size: 42px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                        0 0 20px rgba(255, 255, 255, 0.4),
                        0 0 30px rgba(255, 255, 255, 0.3),
                        0 0 40px rgba(255, 255, 255, 0.2);
            margin-left: 12px;
            display: block;
            margin-top: 15px;
        }

        .menu-text:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        .menu-button {
            background: rgba(233, 69, 96, 0.3);
            border: 3px solid #e94560;
            color: #fff;
            padding: 20px 50px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            margin: 15px;
            transition: all 0.3s;
            min-width: 250px;
        }

        .menu-button:hover {
            background: rgba(233, 69, 96, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.7);
        }

        .menu-button:active {
            transform: scale(1.05);
        }

        #controlsInfo {
            margin-top: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            text-align: center;
            max-width: 600px;
        }

        #controlsInfo h3 {
            color: #4a9eff;
            margin-bottom: 15px;
        }

        #controlsInfo p {
            margin: 8px 0;
            color: #ccc;
        }

        #modeSelection {
            max-height: 0;
            opacity: 0;
            overflow: visible;
            margin-top: 0;
            margin-left: 12px;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
            pointer-events: none;
        }

        #modeSelection.expanded {
            max-height: 200px;
            opacity: 1;
            margin-top: 10px;
            pointer-events: auto;
        }

        .mode-option {
            font-size: 32px;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2),
                        0 0 20px rgba(255, 255, 255, 0.15),
                        0 0 30px rgba(255, 255, 255, 0.1),
                        0 0 40px rgba(255, 255, 255, 0.05);
            margin-top: 8px;
            margin-left: 0;
            display: block;
        }

        .mode-option:hover {
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5),
                        0 0 20px rgba(74, 158, 255, 0.5),
                        0 0 40px rgba(74, 158, 255, 0.5),
                        0 0 60px rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
        }

        .menu-text.moved-down {
            margin-top: 120px;
        }

        #multiPlayText.moved-down {
            margin-top: 20px;
            transition: margin-top 0.3s ease;
        }

        #collectionText.moved-down {
            margin-top: 20px;
            transition: margin-top 0.3s ease;
        }

        #settingsText.moved-down {
            margin-top: 120px;
        }

        #randomModeDisplay {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 28px;
            z-index: 100;
            cursor: pointer;
            transition: all 0.3s;
            max-width: 200px;
        }

        #randomModeDisplay::before,
        #randomModeDisplay::after {
            display: none;
        }

        #randomModeDisplay:hover {
            background: transparent;
        }

        #randomModeName {
            display: block;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        #randomModeTooltip {
            position: absolute;
            bottom: 100%;
            right: 0;
            margin-bottom: 10px;
            background: rgba(15, 15, 30, 0.95);
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 10px 15px;
            color: #fff;
            font-size: 14px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #randomModeDisplay:hover #randomModeTooltip {
            opacity: 1;
        }


    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="augmentModal">
            <h2>Ï¶ùÍ∞ï ÏÑ†ÌÉù</h2>
            <p style="margin-bottom: 20px;">Ìå®Î∞∞ÌïòÏÖ®ÏäµÎãàÎã§. Ï¶ùÍ∞ïÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:</p>
            <div id="enemySelection" style="margin-bottom: 20px; padding: 10px; background: rgba(233, 69, 96, 0.2); border-radius: 5px; display: none;">
                <p style="color: #e94560; margin: 0;">ÏÉÅÎåÄÍ∞Ä ÏÑ†ÌÉù Ï§ë...</p>
            </div>
            <div id="augmentOptions"></div>
        </div>

        <div id="augmentViewModal">
            <h2>Ï¶ùÍ∞ï ÌôïÏù∏</h2>
            <p style="margin-bottom: 20px;">ÏäπÎ¶¨ÌïòÏÖ®ÏäµÎãàÎã§! ÏÉÅÎåÄÏùò Ï¶ùÍ∞ï ÏÑ†ÌÉùÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî:</p>
            <div id="opponentSelection" style="margin-bottom: 20px; padding: 10px; background: rgba(233, 69, 96, 0.2); border-radius: 5px;">
                <p style="color: #e94560; margin: 0;">ÏÉÅÎåÄÍ∞Ä ÏÑ†ÌÉù Ï§ë...</p>
            </div>
            <button onclick="closeAugmentViewModal()" style="margin-top: 20px;">ÌôïÏù∏</button>
        </div>

        <div id="gameOverModal">
            <h2 id="gameOverTitle">Í≤åÏûÑ Ï¢ÖÎ£å</h2>
            <p id="gameOverMessage" style="font-size: 20px; margin-bottom: 20px;"></p>
            <button onclick="restartGame()">Î©îÏù∏Î©îÎâ¥Î°ú</button>
        </div>


        <div id="roomModal">
            <h2 id="roomModalTitle">Î∞© ÏÉùÏÑ±</h2>
            
            <!-- Î∞© ÏΩîÎìú ÌëúÏãú (Ìò∏Ïä§Ìä∏Ïö©, Ïó∞Í≤∞ Ï†Ñ) -->
            <div id="roomCodeSection" style="display: none;">
                <p style="margin-bottom: 13px;">Î∞© ÏΩîÎìú:</p>
                <div id="roomCode" style="font-size: 60px; color: #ffc107; text-shadow: 0 0 20px rgba(255, 193, 7, 0.5); letter-spacing: 13px; margin: 25px 0;"></div>
                <p style="color: #aaa; font-size: 18px;">ÏÉÅÎåÄÎ∞©ÏóêÍ≤å Ïù¥ ÏΩîÎìúÎ•º ÏïåÎ†§Ï£ºÏÑ∏Ïöî</p>
                <p id="waitingMessage" style="color: #4a9eff; margin-top: 25px;">ÏÉÅÎåÄÎ∞©ÏùÑ Í∏∞Îã§Î¶¨Îäî Ï§ë...</p>
            </div>
            
            <!-- Î∞© ÏΩîÎìú ÏûÖÎ†• (Í≤åÏä§Ìä∏Ïö©, Ïó∞Í≤∞ Ï†Ñ) -->
            <div id="roomJoinInput" style="display: none;">
                <p style="margin-bottom: 13px;">Î∞© ÏΩîÎìú ÏûÖÎ†•:</p>
                <input type="text" id="joinCodeInput" maxlength="5" placeholder="12345" style="
                    font-size: 45px;
                    text-align: center;
                    letter-spacing: 10px;
                    width: 250px;
                    padding: 19px;
                    border: 2px solid #4a9eff;
                    border-radius: 10px;
                    background: rgba(0, 0, 0, 0.3);
                    color: #fff;
                    outline: none;
                ">
                <p id="joinErrorMessage" style="color: #e94560; margin-top: 13px; display: none;">Î∞©ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§</p>
                <button id="joinRoomBtn" onclick="joinRoom()" style="margin-top: 25px; background: #4a9eff;">ÏûÖÏû•</button>
            </div>
            
            <!-- ÌåÄ ÏÑ†ÌÉù UI (Ïó∞Í≤∞ ÌõÑ) -->
            <div id="teamSelectUI" style="display: none;">
                <p style="margin-bottom: 25px; color: #aaa;">ÌåÄÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</p>
                <div style="display: flex; justify-content: center; gap: 38px; margin: 25px 0;">
                    <!-- ÌååÎûÄÌåÄ -->
                    <div id="blueTeamBox" onclick="selectTeam('blue')" style="
                        width: 225px;
                        height: 150px;
                        background: rgba(74, 158, 255, 0.1);
                        border: 2px solid rgba(74, 158, 255, 0.4);
                        border-radius: 15px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: flex-start;
                        padding-top: 19px;
                        cursor: pointer;
                        transition: all 0.3s;
                    ">
                        <p style="color: #4a9eff; font-size: 23px; margin-bottom: 10px;">ÌååÎûÄÌåÄ</p>
                        <p id="blueTeamPlayer" style="color: #fff; font-size: 20px; font-weight: bold;"></p>
                    </div>
                    <!-- Îπ®Í∞ÑÌåÄ -->
                    <div id="redTeamBox" onclick="selectTeam('red')" style="
                        width: 225px;
                        height: 150px;
                        background: rgba(233, 69, 96, 0.1);
                        border: 2px solid rgba(233, 69, 96, 0.4);
                        border-radius: 15px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: flex-start;
                        padding-top: 19px;
                        cursor: pointer;
                        transition: all 0.3s;
                    ">
                        <p style="color: #e94560; font-size: 23px; margin-bottom: 10px;">Îπ®Í∞ÑÌåÄ</p>
                        <p id="redTeamPlayer" style="color: #fff; font-size: 20px; font-weight: bold;"></p>
                    </div>
                </div>
                <p id="teamSelectStatus" style="color: #aaa; margin-top: 13px;"></p>
                <p id="guestWaitingMessage" style="display: none; color: #4a9eff; margin-top: 19px;">Ìò∏Ïä§Ìä∏Í∞Ä Í≤åÏûÑÏùÑ ÏãúÏûëÌïòÎ©¥ ÏãúÏûëÎê©ÎãàÎã§...</p>
            </div>
            
            <!-- ÌïòÎã® Î≤ÑÌäº ÏòÅÏó≠ -->
            <div style="position: absolute; bottom: 25px; left: 25px; right: 25px; display: flex; justify-content: space-between;">
                <button onclick="closeRoomModal()" style="background: #e94560; padding: 15px 38px; font-size: 20px;">ÎÇòÍ∞ÄÍ∏∞</button>
                <button id="startGameBtn" onclick="sendStartGame()" style="display: none; background: #00cc66; font-size: 23px; padding: 15px 38px;">Í≤åÏûÑ ÏãúÏûë</button>
            </div>
        </div>
        
        <div id="disconnectModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(15, 15, 30, 1); border: 3px solid #e94560; border-radius: 15px; padding: 40px; z-index: 4000; text-align: center;">
            <h2 style="color: #e94560; margin-bottom: 20px;">Ïó∞Í≤∞ ÎÅäÍπÄ</h2>
            <p style="color: #fff; margin-bottom: 30px;">ÏÉÅÎåÄÎ∞©Í≥ºÏùò Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ï°åÏäµÎãàÎã§.</p>
            <button onclick="confirmDisconnect()" style="background: #4a9eff; padding: 15px 40px;">ÌôïÏù∏</button>
        </div>
        
        <div id="nicknameModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(15, 15, 30, 1); border: 3px solid #ffc107; border-radius: 15px; padding: 50px; z-index: 5000; text-align: center; min-width: 400px;">
            <h2 style="color: #ffc107; margin-bottom: 15px; font-size: 28px;">Î¶¨Î≥ºÎ≤Ñ ÎìÄÏñºÏóê Ïò§Ïã†Í±∏ ÌôòÏòÅÌï©ÎãàÎã§</h2>
            <p style="color: #fff; margin-bottom: 30px; font-size: 18px;">ÌîåÎ†àÏù¥Ïñ¥ÎãòÏùò ÎãâÎÑ§ÏûÑÏùÑ ÏßÄÏñ¥Ï£ºÏÑ∏Ïöî</p>
            <input type="text" id="nicknameInput" maxlength="12" placeholder="ÎãâÎÑ§ÏûÑ ÏûÖÎ†•" style="
                font-size: 24px;
                text-align: center;
                width: 280px;
                padding: 15px;
                border: 2px solid #ffc107;
                border-radius: 10px;
                background: rgba(0, 0, 0, 0.3);
                color: #fff;
                outline: none;
                margin-bottom: 20px;
            ">
            <br>
            <button onclick="saveNickname()" style="background: #ffc107; color: #000; padding: 15px 50px; font-size: 18px; font-weight: bold;">ÌôïÏù∏</button>
        </div>
        


        <div id="mainMenu" class="screen active">
            <div id="nicknameDisplay" style="display: none; position: fixed; top: 25px; right: 30px; color: #fff; font-size: 24px; opacity: 0.7; z-index: 3000; flex-direction: column; align-items: flex-end;">
                <div id="killCountContainer" style="display: flex; align-items: center; gap: 15px;">
                    <div id="killCountDisplay" class="neon-diamond"></div>
                    <div class="kill-number" id="killCountNumber" style="min-width: fit-content;">0</div>
                    <span id="playerNickname" style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); white-space: nowrap;"></span>
                </div>
                <div id="killCountInfo" style="display: none; margin-top: 8px; font-size: 12px; color: rgba(255, 255, 255, 0.6); line-height: 1.4; white-space: normal; max-width: 250px; text-align: right;">
                    ÏÜîÎ°ú: Ïù¥Í∏¥ ÎùºÏö¥Îìú Ïàò (ÏäπÎ¶¨ Ïãú 2Î∞∞)<br>Î©ÄÌã∞: ÏäπÎ¶¨ 2Í∞ú, Ìå®Î∞∞ 1Í∞ú
                </div>
            </div>
            <h1>Î¶¨Î≥ºÎ≤Ñ ÎìÄÏñº</h1>
            <span id="soloPlayText" onclick="showModeSelection()">ÏÜîÎ°ú ÌîåÎ†àÏù¥</span>
            <div id="modeSelection">
                <span class="mode-option" onclick="startSoloGame('classic')">- ÌÅ¥ÎûòÏãù Î™®Îìú</span>
                <span class="mode-option" onclick="startSoloGame('random')">- ÎûúÎç§ Î™®Îìú</span>
            </div>
            <span id="multiPlayText" onclick="showMultiModeSelection()">Î©ÄÌã∞ ÌîåÎ†àÏù¥</span>
            <div id="multiModeSelection">
                <span class="mode-option" onclick="createRoom()">- Î∞© ÏÉùÏÑ±</span>
                <span class="mode-option" onclick="showJoinRoom()">- Î∞© ÏûÖÏû•</span>
            </div>
            <span class="menu-text" id="collectionText" onclick="showScreen('collection')">ÎèÑÍ∞ê</span>
            <span class="menu-text" id="settingsText" onclick="showScreen('shop')">ÏÉÅÏ†ê</span>
            <span class="menu-text" id="storageText" onclick="showScreen('storage')">Î≥¥Í¥ÄÏÜå</span>
            <span class="menu-text" id="achievementText">üîí ÏóÖÏ†Å</span>
        </div>

        <!-- ÎèÑÍ∞ê ÌôîÎ©¥ -->
        <div id="collectionScreen" class="screen">
            <div class="back-button" onclick="showScreen('main')">‚Üê Î©îÏù∏ Î©îÎâ¥</div>
            <h2>ÎèÑÍ∞ê</h2>
            <div id="collectionContent" style="max-height: 70vh; overflow-y: auto; padding: 10px; width: 100%;"></div>
        </div>

        <!-- ÏÉÅÏ†ê ÌôîÎ©¥ -->
        <div id="shopScreen" class="screen">
            <div class="back-button" onclick="showScreen('main')">‚Üê Î©îÏù∏ Î©îÎâ¥</div>
            <h2>ÏÉÅÏ†ê</h2>
            <div id="shopRefreshInfo" style="margin-bottom: 20px; color: #888; font-size: 14px;">
                <p>Ìï†Ïù∏ÏÉÅÌíàÏùÄ 6ÏãúÍ∞ÑÎßàÎã§ ÏÉàÎ°úÍ≥†Ïπ®Îê©ÎãàÎã§.</p>
                <p id="shopRefreshTime" style="margin-top: 5px; font-size: 18px; color: #ffc107; font-weight: bold; font-family: 'Courier New', monospace;">00:00:00</p>
            </div>
            <div id="shopItems" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; width: 100%; max-height: 70vh; overflow-y: auto; padding: 10px;">
                <!-- ÏÉÅÌíàÏù¥ Ïó¨Í∏∞Ïóê ÎèôÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎê©ÎãàÎã§ -->
            </div>
        </div>

        <!-- Î≥¥Í¥ÄÏÜå ÌôîÎ©¥ -->
        <div id="storageScreen" class="screen">
            <div class="back-button" onclick="showScreen('main')">‚Üê Î©îÏù∏ Î©îÎâ¥</div>
            <h2>Î≥¥Í¥ÄÏÜå</h2>
            <div id="storageItems" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-height: 70vh; overflow-y: auto; width: 100%;">
                <!-- Î≥¥Í¥ÄÎêú ÏïÑÏù¥ÌÖúÏù¥ Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§ -->
            </div>
        </div>

        <!-- ÏóÖÏ†Å ÌôîÎ©¥ -->
        <div id="achievementScreen" class="screen">
            <div class="back-button" onclick="showScreen('main')">‚Üê Î©îÏù∏ Î©îÎâ¥</div>
            <h2>ÏóÖÏ†Å</h2>
            <div id="achievementContent" style="max-height: 70vh; overflow-y: auto; padding: 10px; width: 100%;">
                <!-- ÏóÖÏ†ÅÏù¥ Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§ -->
            </div>
        </div>

        <!-- Í≤åÏûÑ ÌôîÎ©¥ (Í≤åÏûÑ Ï§ëÏóêÎäî Î™®Îì† ÌôîÎ©¥ Ïà®ÍπÄ) -->
        <div id="gameScreen" class="screen" style="display: none !important;">
        </div>

        <div id="randomModeDisplay" style="display: none;">
            <div id="randomModeTooltip"></div>
            <span id="randomModeName"></span>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞Î•º ÌôîÎ©¥ Ï†ÑÏ≤¥Î°ú ÏÑ§Ï†ï
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Î©îÏù∏ Î©îÎâ¥ Ïô∏Î∂Ä ÌÅ¥Î¶≠ Ïãú Î™®Îìú ÏÑ†ÌÉù Ï†ëÍ∏∞
        document.addEventListener('click', (e) => {
            const mainMenu = document.getElementById('mainMenu');
            const modeSelection = document.getElementById('modeSelection');
            const multiModeSelection = document.getElementById('multiModeSelection');
            const soloPlayText = document.getElementById('soloPlayText');
            const multiPlayText = document.getElementById('multiPlayText');
            
            // Î©îÏù∏ Î©îÎâ¥Í∞Ä ÌëúÏãúÎêòÏñ¥ ÏûàÏùÑ Îïå
            if (mainMenu && mainMenu.classList.contains('active')) {
                // ÏÜîÎ°úÌîåÎ†àÏù¥ Î™®Îìú ÏÑ†ÌÉùÏù¥ ÌéºÏ≥êÏ†∏ ÏûàÏùÑ Îïå
                if (modeSelection && modeSelection.classList.contains('expanded')) {
                    // ÌÅ¥Î¶≠Ìïú ÏöîÏÜåÍ∞Ä Î™®Îìú ÏÑ†ÌÉù ÏòÅÏó≠Ïù¥ÎÇò ÏÜîÎ°ú ÌîåÎ†àÏù¥ ÌÖçÏä§Ìä∏Í∞Ä ÏïÑÎãê Îïå
                    if (!modeSelection.contains(e.target) && !soloPlayText.contains(e.target)) {
                        collapseModeSelection();
                    }
                }
                // Î©ÄÌã∞ÌîåÎ†àÏù¥ Î™®Îìú ÏÑ†ÌÉùÏù¥ ÌéºÏ≥êÏ†∏ ÏûàÏùÑ Îïå
                if (multiModeSelection && multiModeSelection.classList.contains('expanded')) {
                    // ÌÅ¥Î¶≠Ìïú ÏöîÏÜåÍ∞Ä Î©ÄÌã∞ Î™®Îìú ÏÑ†ÌÉù ÏòÅÏó≠Ïù¥ÎÇò Î©ÄÌã∞ ÌîåÎ†àÏù¥ ÌÖçÏä§Ìä∏Í∞Ä ÏïÑÎãê Îïå
                    if (!multiModeSelection.contains(e.target) && !multiPlayText.contains(e.target)) {
                        collapseMultiModeSelection();
                    }
                }
            }
        });

        // ÌôîÎ©¥ Ï†ÑÌôò Ìï®Ïàò
        function showScreen(screenName) {
            // Î™®Îì† ÌôîÎ©¥ Ïà®Í∏∞Í∏∞
            const screens = document.querySelectorAll('.screen');
            screens.forEach(screen => {
                screen.classList.remove('active');
                screen.style.display = 'none';
            });
            
            // ÏÑ†ÌÉùÌïú ÌôîÎ©¥ ÌëúÏãú
            let targetScreen;
            if (screenName === 'main') {
                // Î©îÏù∏ Î©îÎâ¥Îäî idÍ∞Ä mainMenu
                targetScreen = document.getElementById('mainMenu');
            } else if (screenName === 'game') {
                // Í≤åÏûÑ ÌôîÎ©¥ÏùÄ Î™®Îì† ÌôîÎ©¥ Ïà®ÍπÄ
                gameState.isMenu = false;
                hideNicknameDisplay(); // Ïù∏Í≤åÏûÑÏóêÏÑúÎäî ÎãâÎÑ§ÏûÑ Ïà®ÍπÄ
                return;
            } else {
                // Îã§Î•∏ ÌôîÎ©¥Îì§ÏùÄ screenName + 'Screen' ÌòïÏãù
                targetScreen = document.getElementById(screenName + 'Screen') || document.getElementById(screenName);
            }
            
            if (targetScreen) {
                targetScreen.classList.add('active');
                targetScreen.style.display = 'flex';
                
                // Ïù∏Í≤åÏûÑÏù¥ ÏïÑÎãå Í≤ΩÏö∞ ÎãâÎÑ§ÏûÑÍ≥º Ï†úÌôî ÌëúÏãú
                if (screenName !== 'game') {
                    showNicknameDisplay();
                }
                
                // Í∞Å ÌôîÎ©¥Î≥Ñ Ï¥àÍ∏∞Ìôî
                if (screenName === 'collection') {
                    loadCollectionContent();
                    stopShopRefreshTimer(); // ÏÉÅÏ†ê ÌÉÄÏù¥Î®∏ Ï§ëÏßÄ
                } else if (screenName === 'shop') {
                    openShopModal();
                } else if (screenName === 'storage') {
                    openStorageModal();
                    stopShopRefreshTimer(); // ÏÉÅÏ†ê ÌÉÄÏù¥Î®∏ Ï§ëÏßÄ
                } else if (screenName === 'achievement') {
                    stopShopRefreshTimer(); // ÏÉÅÏ†ê ÌÉÄÏù¥Î®∏ Ï§ëÏßÄ
                } else if (screenName === 'main') {
                    // Î©îÏù∏ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞à Îïå
                    gameState.isMenu = true;
                    stopShopRefreshTimer(); // ÏÉÅÏ†ê ÌÉÄÏù¥Î®∏ Ï§ëÏßÄ
                    
                    // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïó∞Í≤∞Ïù¥ ÎÇ®ÏïÑÏûàÏúºÎ©¥ Ï†ïÎ¶¨ (ÏïàÏ†ÑÏû•Ïπò)
                    if (multiplayerPeer || multiplayerConnection) {
                        console.log('Î©îÏù∏ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ê: ÎÇ®ÏïÑÏûàÎäî Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïó∞Í≤∞ Ï†ïÎ¶¨');
                        cleanupMultiplayerConnection();
                    }
                } else if (screenName === 'game') {
                    stopShopRefreshTimer(); // ÏÉÅÏ†ê ÌÉÄÏù¥Î®∏ Ï§ëÏßÄ
                }
            }
        }

        // Í≤åÏûÑ ÏÉÅÌÉú
        let gameState = {
            round: 1,
            playerWins: 0,
            enemyWins: 0,
            winsNeeded: 5, // 5ÎùºÏö¥Îìú ÏÑ†ÏäπÏ†ú
            gameTime: 180, // 3Î∂Ñ = 180Ï¥à
            isGameOver: false,
            isPaused: false,
            isMenu: true, // Î©îÎâ¥ ÌôîÎ©¥ ÌëúÏãú Ïó¨Î∂Ä
            isNextRoundProcessing: false, // Îã§Ïùå ÎùºÏö¥Îìú Ï≤òÎ¶¨ Ï§ë ÌîåÎûòÍ∑∏ (Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ)
            roundWins: [], // Í∞Å ÎùºÏö¥ÎìúÏùò ÏäπÏûê Í∏∞Î°ù ('player' ÎòêÎäî 'enemy')
            countdown: 3, // ÎùºÏö¥Îìú ÏãúÏûë Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
            augmentCountdown: 0, // Ï¶ùÍ∞ï ÏÑ†ÌÉù Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ (0Ïù¥Î©¥ ÌëúÏãú ÏïàÌï®)
            showOpponentSelecting: false, // ÏÉÅÎåÄ ÏÑ†ÌÉù Ï§ë Î©îÏãúÏßÄ ÌëúÏãú Ïó¨Î∂Ä
            shake: {
                intensity: 0,
                duration: 0
            },
            // Ïä¨Î°ØÎ®∏Ïã† Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÉÅÌÉú
            isSlotMachine: false,
            slotMachineStartTime: 0,
            slotMachineCurrentIndex: 0,
            slotMachineSelectedMode: null,
            // Îßµ ÌÅ¨Í∏∞ (Í∏∞Î≥∏Í∞íÏùÄ Ï†ÑÏ≤¥ Ï∫îÎ≤ÑÏä§)
            mapBounds: {
                minX: 0,
                minY: 0,
                maxX: 0, // initGameÏóêÏÑú ÏÑ§Ï†ï
                maxY: 0  // initGameÏóêÏÑú ÏÑ§Ï†ï
            },
            // Î©ÄÌã∞ÌîåÎ†àÏù¥ ÏÉÅÌÉú
            isMultiplayer: false,
            multiplayerReady: false, // ÏñëÏ™Ω Î™®Îëê Ï§ÄÎπÑÎê®
            lastSyncTime: 0, // ÎßàÏßÄÎßâ ÎèôÍ∏∞Ìôî ÏãúÍ∞Ñ
            explosions: [], // Ìè≠Î∞ú Ïù¥ÌéôÌä∏ Î∞∞Ïó¥
            obstacles: [] // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïû•Ïï†Î¨º Î∞∞Ïó¥ {x, y, width, height, angle}
        };

        // ÌäúÌÜ†Î¶¨Ïñº ÏÉÅÌÉú

        // ÌîåÎ†àÏù¥Ïñ¥
        const player = {
            x: canvas.width * 0.2,
            y: canvas.height * 0.5,
            radius: 30, // 1.5Î∞∞ Ï¶ùÍ∞Ä (20 -> 30)
            speed: 3,
            health: 5,
            displayHealth: 5, // ÌëúÏãúÎêòÎäî Ï≤¥Î†• (Ïï†ÎãàÎ©îÏù¥ÏÖòÏö©)
            maxHealth: 5,
            ammo: 6,
            maxAmmo: 6,
            reloadTime: 3000, // 3Ï¥à
            isReloading: false,
            reloadStartTime: 0, // Ïû¨Ïû•Ï†Ñ ÏãúÏûë ÏãúÍ∞Ñ
            angle: 0,
            color: '#4a9eff',
            bullets: [],
            lastShot: 0,
            shootCooldown: 1000, // 1Ï¥àÎ°ú Í≥†Ï†ï
            damage: 1, // Í∏∞Î≥∏ Îç∞ÎØ∏ÏßÄ
            augmentations: [],
            // Ï¶ùÍ∞ï Í¥ÄÎ†® ÏÉÅÌÉú
            bulletSpeedMultiplier: 1,
            bulletSizeMultiplier: 1, // ÌÉÑÌôò ÌÅ¨Í∏∞ Î∞∞Ïú®
            hasCritical: false,
            hasDoubleShot: false,
            hasDodge: false,
            hasRevive: false,
            hasRevived: 0, // Î∂ÄÌôú ÏÇ¨Ïö© ÌöüÏàò
            hasDeepWound: false,
            hasOneShotOneKill: false,
            hasPoisonBullet: false,
            hasReloadHeal: false,
            hasSurvivalInstinct: false, // ÏÉùÏ°¥Î≥∏Îä•
            hasLastBullet: false, // ÎπÑÏû•Ïùò ÌïúÎ∞ú
            hasRecoveryContract: false, // ÌöåÎ≥µÍ≥ÑÏïΩ
            hasRecoveryContractUsed: false, // ÌöåÎ≥µÍ≥ÑÏïΩ ÏÇ¨Ïö© Ïó¨Î∂Ä (ÎùºÏö¥ÎìúÎãπ ÌïúÎ≤à)
            hasFocusedFire: false, // ÏßëÏ§ë ÏÇ¨Í≤©
            hasShotgun: false, // ÏÉ∑Í±¥
            hasRagged: false, // Îã§Îã§ÏùµÏÑ†
            hasGhost: false, // Ïú†Î†π
            hasFortify: false, // Í±∞Ï†êÌôïÎ≥¥
            isFortified: false, // Í±∞Ï†ê ÌôïÎ≥¥ ÏÉÅÌÉú
            fortifyStartTime: 0, // Í±∞Ï†ê ÌôïÎ≥¥ ÏãúÏûë ÏãúÍ∞Ñ
            lastPosition: { x: 0, y: 0 }, // ÎßàÏßÄÎßâ ÏúÑÏπò
            stationaryTime: 0, // Ï†ïÏßÄÌïú ÏãúÍ∞Ñ
            hasOverheat: false, // Í≥ºÏó¥
            overheatHitCount: 0, // Ïó∞ÏÜç ÌûàÌä∏ Ïπ¥Ïö¥Ìä∏
            lastHitTime: 0, // ÎßàÏßÄÎßâ ÌûàÌä∏ ÏãúÍ∞Ñ
            hasGamble: false, // ÎèÑÎ∞ï
            hasWeaken: false, // ÏïΩÌôî
            isWeakened: false, // ÏïΩÌôî ÏÉÅÌÉú
            weakenEndTime: 0, // ÏïΩÌôî Ï¢ÖÎ£å ÏãúÍ∞Ñ
            hasDamageBoost: false, // Îç∞ÎØ∏ÏßÄ 1.2Î∞∞
            hasLightning: false, // Î≤àÍ∞ú
            isStunned: false, // Í∏∞Ï†à ÏÉÅÌÉú
            stunEndTime: 0, // Í∏∞Ï†à Ï¢ÖÎ£å ÏãúÍ∞Ñ
            hasShield: false, // Î∞©Ïñ¥Îßâ
            shieldReady: false, // Î∞©Ïñ¥Îßâ Ï§ÄÎπÑÎê®
            shieldCooldown: 0, // Î∞©Ïñ¥Îßâ Ïø®ÌÉÄÏûÑ
            hasRegeneration: false, // Ïû¨ÏÉù
            lastRegenTime: 0, // ÎßàÏßÄÎßâ ÌöåÎ≥µ ÏãúÍ∞Ñ
            isVulnerable: false, // Ï∑®ÏïΩ ÏÉÅÌÉú
            vulnerabilityUsed: false, // Ï∑®ÏïΩ ÏÇ¨Ïö© Ïó¨Î∂Ä
            poisonEffects: [], // ÎèÖ Ìö®Í≥º Î∞∞Ïó¥ {target, startTime, duration, damagePerSecond}
            isDodging: false,
            dodgeStartTime: 0, // Íµ¨Î•¥Í∏∞ ÏãúÏûë ÏãúÍ∞Ñ
            dodgeEndTime: 0,
            dodgeStartX: 0,
            dodgeStartY: 0,
            dodgeTargetX: 0,
            dodgeTargetY: 0,
            dodgeTrail: [], // Íµ¨Î•¥Í∏∞ ÏûîÏÉÅ ÏúÑÏπò Î∞∞Ïó¥
            lastDodgeTime: 0, // ÎßàÏßÄÎßâ Íµ¨Î•¥Í∏∞ ÏãúÍ∞Ñ (Ïø®ÌÉÄÏûÑÏö©)
            isReviving: false,
            reviveTime: 0,
            isInvincible: false,
            invincibleEndTime: 0,
            slowEndTime: 0,
            damageNumbers: [], // Îç∞ÎØ∏ÏßÄ Ïà´Ïûê ÌëúÏãúÏö©
            hitEffectParticles: [] // ÌîºÍ≤© Ïù¥ÌéôÌä∏ ÌååÌã∞ÌÅ¥ Î∞∞Ïó¥
        };

        // Ï†Å (AI)
        const enemy = {
            x: canvas.width * 0.8,
            y: canvas.height * 0.5,
            radius: 30, // 1.5Î∞∞ Ï¶ùÍ∞Ä (20 -> 30)
            speed: 2.5,
            health: 5,
            displayHealth: 5, // ÌëúÏãúÎêòÎäî Ï≤¥Î†• (Ïï†ÎãàÎ©îÏù¥ÏÖòÏö©)
            maxHealth: 5,
            ammo: 6,
            maxAmmo: 6,
            reloadTime: 3000, // 3Ï¥à
            isReloading: false,
            reloadStartTime: 0, // Ïû¨Ïû•Ï†Ñ ÏãúÏûë ÏãúÍ∞Ñ
            angle: Math.PI,
            color: '#e94560',
            bullets: [],
            lastShot: 0,
            shootCooldown: 1000, // 1Ï¥àÎ°ú Í≥†Ï†ï
            damage: 1, // Í∏∞Î≥∏ Îç∞ÎØ∏ÏßÄ
            augmentations: [],
            // Ï¶ùÍ∞ï Í¥ÄÎ†® ÏÉÅÌÉú
            bulletSpeedMultiplier: 1,
            bulletSizeMultiplier: 1, // ÌÉÑÌôò ÌÅ¨Í∏∞ Î∞∞Ïú®
            hasCritical: false,
            hasDoubleShot: false,
            hasDodge: false,
            hasRevive: false,
            hasRevived: 0, // Î∂ÄÌôú ÏÇ¨Ïö© ÌöüÏàò
            hasDeepWound: false,
            hasOneShotOneKill: false,
            hasPoisonBullet: false,
            hasReloadHeal: false,
            hasSurvivalInstinct: false, // ÏÉùÏ°¥Î≥∏Îä•
            hasLastBullet: false, // ÎπÑÏû•Ïùò ÌïúÎ∞ú
            hasRecoveryContract: false, // ÌöåÎ≥µÍ≥ÑÏïΩ
            hasRecoveryContractUsed: false, // ÌöåÎ≥µÍ≥ÑÏïΩ ÏÇ¨Ïö© Ïó¨Î∂Ä (ÎùºÏö¥ÎìúÎãπ ÌïúÎ≤à)
            hasFocusedFire: false, // ÏßëÏ§ë ÏÇ¨Í≤©
            hasShotgun: false, // ÏÉ∑Í±¥
            hasRagged: false, // Îã§Îã§ÏùµÏÑ†
            hasGhost: false, // Ïú†Î†π
            hasFortify: false, // Í±∞Ï†êÌôïÎ≥¥
            isFortified: false, // Í±∞Ï†ê ÌôïÎ≥¥ ÏÉÅÌÉú
            fortifyStartTime: 0, // Í±∞Ï†ê ÌôïÎ≥¥ ÏãúÏûë ÏãúÍ∞Ñ
            lastPosition: { x: 0, y: 0 }, // ÎßàÏßÄÎßâ ÏúÑÏπò
            stationaryTime: 0, // Ï†ïÏßÄÌïú ÏãúÍ∞Ñ
            hasOverheat: false, // Í≥ºÏó¥
            overheatHitCount: 0, // Ïó∞ÏÜç ÌûàÌä∏ Ïπ¥Ïö¥Ìä∏
            lastHitTime: 0, // ÎßàÏßÄÎßâ ÌûàÌä∏ ÏãúÍ∞Ñ
            hasGamble: false, // ÎèÑÎ∞ï
            hasWeaken: false, // ÏïΩÌôî
            isWeakened: false, // ÏïΩÌôî ÏÉÅÌÉú
            weakenEndTime: 0, // ÏïΩÌôî Ï¢ÖÎ£å ÏãúÍ∞Ñ
            hasDamageBoost: false, // Îç∞ÎØ∏ÏßÄ 1.2Î∞∞
            hasLightning: false, // Î≤àÍ∞ú
            isStunned: false, // Í∏∞Ï†à ÏÉÅÌÉú
            stunEndTime: 0, // Í∏∞Ï†à Ï¢ÖÎ£å ÏãúÍ∞Ñ
            hasShield: false, // Î∞©Ïñ¥Îßâ
            shieldReady: false, // Î∞©Ïñ¥Îßâ Ï§ÄÎπÑÎê®
            shieldCooldown: 0, // Î∞©Ïñ¥Îßâ Ïø®ÌÉÄÏûÑ
            hasRegeneration: false, // Ïû¨ÏÉù
            lastRegenTime: 0, // ÎßàÏßÄÎßâ ÌöåÎ≥µ ÏãúÍ∞Ñ
            hasEvasiveManeuver: false, // ÌöåÌîºÍ∏∞Îèô
            hasCombatExperience: false, // Ï†ÑÌà¨ Í≤ΩÌóò
            combatExperienceRounds: 0, // Ï†ÑÌà¨ Í≤ΩÌóò ÎùºÏö¥Îìú Ïàò
            hasHallucination: false, // ÌôòÍ∞Å
            hasTasteOfBlood: false, // ÌîºÏùò Îßõ
            hasCannon: false, // ÎåÄÌè¨
            hasTimeBarrier: false, // ÏãúÍ∞ÑÏû•Îßâ
            timeBarrierRadius: 150, // ÏãúÍ∞ÑÏû•Îßâ Î∞òÏßÄÎ¶Ñ
            hasBouncyBullet: false, // ÌÜµÌÜµÌÉÑ
            hasGamble2: false, // Ïä§ÎÑ§Ïù¥ÌÅ¨
            hasReflect: false, // Î∞òÏÇ¨
            reflectActive: false, // Î∞òÏÇ¨ Î≥¥Ìò∏Îßâ ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
            reflectCooldown: 0, // Î∞òÏÇ¨ Ïø®ÌÉÄÏûÑ
            reflectEndTime: 0, // Î∞òÏÇ¨ Ï¢ÖÎ£å ÏãúÍ∞Ñ
            hasExplosiveBullet: false, // Ìè≠Î∞úÌÉÑ
            hasReaper: false, // ÏÇ¨Ïã†
            isInvisible: false, // ÏùÄÏã† ÏÉÅÌÉú
            invisibilityEndTime: 0, // ÏùÄÏã† Ï¢ÖÎ£å ÏãúÍ∞Ñ
            hasOvercharge: false, // Í≥ºÏ∂©Ï†Ñ
            overchargeActive: false, // Í≥ºÏ∂©Ï†Ñ ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
            overchargeCooldown: 0, // Í≥ºÏ∂©Ï†Ñ Ïø®ÌÉÄÏûÑ
            overchargeEndTime: 0, // Í≥ºÏ∂©Ï†Ñ Ï¢ÖÎ£å ÏãúÍ∞Ñ
            overchargeTrail: [], // Í≥ºÏ∂©Ï†Ñ ÏûîÏÉÅ ÏúÑÏπò Î∞∞Ïó¥
            hasVictor: false, // ÏäπÎ¶¨Ïûê
            hasTimeStop: false, // ÏãúÍ∞ÑÏ†ïÏßÄ
            timeStopCooldown: 0, // ÏãúÍ∞ÑÏ†ïÏßÄ Ïø®ÌÉÄÏûÑ
            timeStopActive: false, // ÏãúÍ∞ÑÏ†ïÏßÄ ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
            timeStopEndTime: 0, // ÏãúÍ∞ÑÏ†ïÏßÄ Ï¢ÖÎ£å ÏãúÍ∞Ñ
            hasScatter: false, // ÎπÑÏÇ∞ÌÉÑ
            hasRocket: false, // Î°úÏºìÌÉÑ
            hasTrinity: false, // ÏÇºÏúÑÏùºÏ≤¥
            hasJudgment: false, // ÏÑ†Í≥†
            isJudgmentPushing: false, // ÏÑ†Í≥† Î∞ÄÎ†§ÎÇòÎäî Ï§ë
            judgmentPushStartX: 0,
            judgmentPushStartY: 0,
            judgmentPushTargetX: 0,
            judgmentPushTargetY: 0,
            judgmentPushStartTime: 0,
            judgmentPushDuration: 0,
            hasBoomerang: false, // Î∂ÄÎß§Îûë
            isVulnerable: false, // Ï∑®ÏïΩ ÏÉÅÌÉú
            vulnerabilityUsed: false, // Ï∑®ÏïΩ ÏÇ¨Ïö© Ïó¨Î∂Ä
            poisonEffects: [], // ÎèÖ Ìö®Í≥º Î∞∞Ïó¥ {target, startTime, duration, damagePerSecond}
            isDodging: false,
            dodgeStartTime: 0, // Íµ¨Î•¥Í∏∞ ÏãúÏûë ÏãúÍ∞Ñ
            dodgeEndTime: 0,
            dodgeStartX: 0,
            dodgeStartY: 0,
            dodgeTargetX: 0,
            dodgeTargetY: 0,
            dodgeTrail: [], // Íµ¨Î•¥Í∏∞ ÏûîÏÉÅ ÏúÑÏπò Î∞∞Ïó¥
            lastDodgeTime: 0, // ÎßàÏßÄÎßâ Íµ¨Î•¥Í∏∞ ÏãúÍ∞Ñ (Ïø®ÌÉÄÏûÑÏö©)
            isReviving: false,
            reviveTime: 0,
            isInvincible: false,
            invincibleEndTime: 0,
            slowEndTime: 0,
            aiTimer: 0,
            aiDirection: Math.random() * Math.PI * 2,
            usePrediction: false, // Î∞úÏÇ¨ Ìå®ÌÑ¥: false=ÌòÑÏû¨ ÏúÑÏπò, true=ÏòàÏ∏° ÏúÑÏπò
            lastPlayerX: 0, // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Ï†Ñ ÏúÑÏπò (Ïù¥Îèô Î∞©Ìñ• Í≥ÑÏÇ∞Ïö©)
            lastPlayerY: 0,
            playerVelocity: { x: 0, y: 0 }, // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô ÏÜçÎèÑ
            lastPlayerBulletCount: 0, // ÌîåÎ†àÏù¥Ïñ¥ Ï¥ùÏïå Í∞úÏàò Ï∂îÏ†Å (Î∞úÏÇ¨ Í∞êÏßÄÏö©)
            bulletDodgeTargetY: 0, // Ï¥ùÏïå ÌöåÌîº Î™©Ìëú Y ÏúÑÏπò
            isDodgingBullet: false, // Ï¥ùÏïå ÌöåÌîº Ï§ëÏù∏ÏßÄ
            damageNumbers: [], // Îç∞ÎØ∏ÏßÄ Ïà´Ïûê ÌëúÏãúÏö©
            hitEffectParticles: [] // ÌîºÍ≤© Ïù¥ÌéôÌä∏ ÌååÌã∞ÌÅ¥ Î∞∞Ïó¥
        };

        // Ï¶ùÍ∞ï Î™©Î°ù
        // Ï¶ùÍ∞ï Ï§ëÏ≤© ÌöüÏàò Í≥ÑÏÇ∞ Ìó¨Ìçº Ìï®Ïàò
        function getAugmentCount(character, augmentId) {
            return character.augmentations.filter(aug => aug.id === augmentId).length;
        }

        const augmentations = [
            { 
                id: 'health', 
                name: 'ÏµúÎåÄÏ≤¥Î†• +1.5', 
                description: 'ÏµúÎåÄ Ï≤¥Î†• +1.5', 
                effect: (character) => { 
                    // Ï§ëÏ≤© Í∞ÄÎä•: ÌöüÏàòÎßåÌÅº Ï∂îÍ∞Ä
                    const count = character.augmentations.filter(aug => aug.id === 'health').length + 1;
                    character.maxHealth += 1.5;
                    character.health += 1.5;
                } 
            },
            { 
                id: 'speed', 
                name: 'Ïù¥ÎèôÏÜçÎèÑ +25%', 
                description: 'Ïù¥Îèô ÏÜçÎèÑ +25%', 
                effect: (character) => { 
                    character.speed *= 1.25; 
                } 
            },
            { 
                id: 'bulletSpeed', 
                name: 'Ï¥ùÏïå ÏÜçÎèÑ +25%', 
                description: 'Ï¥ùÏïå ÏÜçÎèÑ +25%', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 1.25; 
                } 
            },
            { 
                id: 'ammo', 
                name: 'ÌÉÑÏïΩ +1', 
                description: 'ÏµúÎåÄ ÌÉÑÏïΩ +1', 
                effect: (character) => { 
                    character.maxAmmo += 1; 
                    character.ammo += 1; 
                } 
            },
            { 
                id: 'fireRate', 
                name: 'Î∞úÏÇ¨ÏÜçÎèÑ -25%', 
                description: 'Î∞úÏÇ¨ÏÜçÎèÑ -25%', 
                effect: (character) => { 
                    character.shootCooldown *= 0.75; 
                } 
            },
            { 
                id: 'reload', 
                name: 'Ïû¨Ïû•Ï†Ñ ÏÜçÎèÑ -1.5Ï¥à', 
                description: 'Ïû¨Ïû•Ï†Ñ ÏãúÍ∞Ñ -1.5Ï¥à', 
                effect: (character) => { 
                    character.reloadSpeedCount = (character.reloadSpeedCount || 0) + 1;
                    // Ï§ëÏ≤© Ï†ÅÏö©: Í∏∞Î≥∏ Ïû¨Ïû•Ï†Ñ ÏãúÍ∞ÑÏóêÏÑú Ï§ëÏ≤© ÌöüÏàò * 1.5Ï¥àÎ•º Î∫å
                    const baseReloadTime = character.baseReloadTime || 3000;
                    character.reloadTime = Math.max(1000, baseReloadTime - (1500 * character.reloadSpeedCount));
                } 
            },
            { 
                id: 'critical', 
                name: 'ÌÅ¨Î¶¨Ìã∞Ïª¨', 
                description: 'ÌîºÍ≤© Ïãú 25% ÌôïÎ•†Î°ú Îç∞ÎØ∏ÏßÄ 2Î∞∞', 
                effect: (character) => { 
                    character.hasCritical = true; 
                    character.criticalCount = (character.criticalCount || 0) + 1; 
                } 
            },
            { 
                id: 'doubleShot', 
                name: 'ÎçîÎ∏îÏÉ∑', 
                description: 'Î∞úÏÇ¨ Ïãú 25% ÌôïÎ•†Î°ú Ï∂îÍ∞Ä Î∞úÏÇ¨', 
                effect: (character) => { 
                    character.hasDoubleShot = true; 
                    character.doubleShotCount = (character.doubleShotCount || 0) + 1; 
                } 
            },
            { 
                id: 'dodge', 
                name: 'Íµ¨Î•¥Í∏∞', 
                description: 'Ïö∞ÌÅ¥Î¶≠ÏúºÎ°ú Íµ¨Î•¥Í∏∞ (Íµ¨Î•¥Îäî ÎèôÏïà Î¨¥Ï†Å)', 
                effect: (character) => { 
                    character.hasDodge = true; 
                } 
            },
            { 
                id: 'revive', 
                name: 'Î∂ÄÌôú', 
                description: 'Ï£ΩÏóàÏùÑ Îïå 2Ï¥à ÌõÑ Ï≤¥Î†• 1Î°ú Î∂ÄÌôú', 
                effect: (character) => { 
                    character.hasRevive = true; 
                    character.reviveCount = (character.reviveCount || 0) + 1; 
                } 
            },
            { 
                id: 'deepWound', 
                name: 'ÍπäÏùÄ ÏÉÅÏ≤ò', 
                description: 'ÌîºÍ≤© Ïãú ÏÉÅÎåÄ Ïù¥ÎèôÏÜçÎèÑ -25%', 
                effect: (character) => { 
                    character.hasDeepWound = true; 
                    character.deepWoundCount = (character.deepWoundCount || 0) + 1; 
                } 
            },
            { 
                id: 'giant', 
                name: 'Í±∞ÎåÄÌôî', 
                description: 'Ï≤¥Î†• +3, Ïù¥ÎèôÏÜçÎèÑ -25%', 
                effect: (character) => { 
                    character.maxHealth += 3; 
                    character.health += 3; 
                    character.speed *= 0.75; 
                } 
            },
            { 
                id: 'sniper', 
                name: 'Ï†ÄÍ≤©Ïàò', 
                description: 'Ï¥ùÏïå ÏÜçÎèÑ +75%, ÏµúÎåÄ ÌÉÑÏïΩ -3', 
                effect: (character) => { 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 1.75; 
                    character.maxAmmo = Math.max(1, character.maxAmmo - 3); 
                    character.ammo = Math.min(character.ammo, character.maxAmmo); 
                } 
            },
            { 
                id: 'oneShotOneKill', 
                name: 'ÏõêÏÉ∑ÏõêÌÇ¨', 
                description: 'ÏµúÎåÄ ÌÉÑÏïΩ 1Í∞úÎ°ú Í≥†Ï†ï, Ï¥ùÏïå Îç∞ÎØ∏ÏßÄ *3', 
                effect: (character) => { 
                    character.maxAmmo = 1; 
                    character.ammo = Math.min(character.ammo, 1); 
                    character.damage = (character.damage || 1) * 3; // Ï¥ùÏïå Îç∞ÎØ∏ÏßÄ *3
                    character.hasOneShotOneKill = true; 
                } 
            },
            { 
                id: 'poisonBullet', 
                name: 'ÎèÖ ÌÉÑÌôò', 
                description: 'Ï†Å ÌîºÍ≤©Ïãú 0.2Îç∞ÎØ∏ÏßÄÎ•º 1Ï¥àÍ∞ÑÍ≤©ÏúºÎ°ú 2Î≤à Ï∂îÍ∞ÄÌîºÌï¥', 
                effect: (character) => { 
                    character.hasPoisonBullet = true; 
                    character.poisonBulletCount = (character.poisonBulletCount || 0) + 1; 
                } 
            },
            { 
                id: 'reloadHeal', 
                name: 'Ïû¨Ïû•Ï†Ñ ÌöåÎ≥µ', 
                description: 'Ïû¨Ïû•Ï†Ñ Ïãú Ï≤¥Î†• 1ÌöåÎ≥µ', 
                effect: (character) => { 
                    character.hasReloadHeal = true; 
                    character.reloadHealCount = (character.reloadHealCount || 0) + 1; 
                } 
            },
            { 
                id: 'bigBullet', 
                name: 'ÌÅ∞ ÌÉÑÌôò', 
                description: 'ÌÉÑÌôò ÌÅ¨Í∏∞ +50%', 
                effect: (character) => { 
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 1.5; 
                } 
            },
            { 
                id: 'survivalInstinct', 
                name: 'ÏÉùÏ°¥Î≥∏Îä•', 
                description: 'Ï≤¥Î†•Ïù¥ 1Ïùº Îïå Ïù¥ÎèôÏÜçÎèÑ +50%', 
                effect: (character) => { 
                    character.hasSurvivalInstinct = true; 
                    character.survivalInstinctCount = (character.survivalInstinctCount || 0) + 1; 
                } 
            },
            { 
                id: 'lastBullet', 
                name: 'ÎπÑÏû•Ïùò ÌïúÎ∞ú', 
                description: 'ÎßàÏßÄÎßâ ÌÉÑÌôòÏùò Îç∞ÎØ∏ÏßÄ +1.5', 
                effect: (character) => { 
                    character.hasLastBullet = true; 
                    character.lastBulletCount = (character.lastBulletCount || 0) + 1; 
                } 
            },
            { 
                id: 'recoveryContract', 
                name: 'ÌöåÎ≥µÍ≥ÑÏïΩ', 
                description: 'Ï≤¥Î†•Ïù¥ 1Ïùº Îïå Ï≤¥Î†• 2ÌöåÎ≥µ', 
                effect: (character) => { 
                    character.hasRecoveryContract = true; 
                    character.recoveryContractCount = (character.recoveryContractCount || 0) + 1; 
                } 
            },
            { 
                id: 'focusedFire', 
                name: 'ÏßëÏ§ë ÏÇ¨Í≤©', 
                description: 'ÌîºÍ≤©Ïãú 50% ÌôïÎ•†Î°ú ÏÉÅÎåÄÏóêÍ≤å Ï∑®ÏïΩ Î∂ÄÏó¨ (Îã§Ïùå Îç∞ÎØ∏ÏßÄ *1.5Î∞∞)', 
                effect: (character) => { 
                    character.hasFocusedFire = true; 
                } 
            },
            { 
                id: 'shotgun', 
                name: 'ÏÉ∑Í±¥', 
                description: 'Î™®Îì† ÌÉÑÏïΩÏùÑ ¬±25ÎèÑ Î≤îÏúÑÏóêÏÑú ÌïúÎ≤àÏóê Î∞úÏÇ¨', 
                effect: (character) => { 
                    character.hasShotgun = true; 
                } 
            },
            { 
                id: 'ragged', 
                name: 'Îã§Îã§ÏùµÏÑ†', 
                description: 'ÏµúÎåÄ ÌÉÑÏïΩ +3, Î∞úÏÇ¨ÏÜçÎèÑ -50%, Ï¥ùÏïå Îç∞ÎØ∏ÏßÄ *0.5', 
                effect: (character) => { 
                    character.maxAmmo += 3; 
                    character.ammo += 3; 
                    character.shootCooldown *= 0.5; // Î∞úÏÇ¨ÏÜçÎèÑ -50% (Ïø®ÌÉÄÏûÑ Ï†àÎ∞ò)
                    character.damage = (character.damage || 1) * 0.5; // Ï¥ùÏïå Îç∞ÎØ∏ÏßÄ *0.5
                    character.hasRagged = true; 
                } 
            },
            { 
                id: 'ghost', 
                name: 'Ïú†Î†π', 
                description: 'ÏÉÅÎåÄÏùò Í≥µÍ≤©ÏùÑ 25% ÌôïÎ•†Î°ú Î¨¥Ïãú', 
                effect: (character) => { 
                    character.hasGhost = true; 
                    character.ghostCount = (character.ghostCount || 0) + 1; 
                } 
            },
            { 
                id: 'fortify', 
                name: 'Í±∞Ï†êÌôïÎ≥¥', 
                description: '3Ï¥àÎèôÏïà Í∞ÄÎßåÌûà ÏÑúÏûàÏùÑ Í≤ΩÏö∞ Îã§Ïãú ÏõÄÏßÅÏùºÎïåÍπåÏßÄ Î∞õÎäî Îç∞ÎØ∏ÏßÄ *0.5', 
                effect: (character) => { 
                    character.hasFortify = true; 
                    character.fortifyStartTime = 0; // Í±∞Ï†ê ÌôïÎ≥¥ ÏãúÏûë ÏãúÍ∞Ñ
                    character.isFortified = false; // Í±∞Ï†ê ÌôïÎ≥¥ ÏÉÅÌÉú
                    character.lastPosition = { x: character.x, y: character.y }; // ÎßàÏßÄÎßâ ÏúÑÏπò
                    character.stationaryTime = 0; // Ï†ïÏßÄÌïú ÏãúÍ∞Ñ
                } 
            },
            { 
                id: 'overheat', 
                name: 'Í≥ºÏó¥', 
                description: 'ÏÉÅÎåÄÏóêÍ≤å Ï¥ùÏïåÏùÑ Ïó∞ÏÜçÏúºÎ°ú ÎßûÏ∂ú Ïãú ÎßûÏ∂úÎïåÎßàÎã§ Îç∞ÎØ∏ÏßÄ 0.5Î∞∞Ïî© ÏÉÅÏäπ', 
                effect: (character) => { 
                    character.hasOverheat = true; 
                    character.overheatHitCount = 0; // Ïó∞ÏÜç ÌûàÌä∏ Ïπ¥Ïö¥Ìä∏
                    character.lastHitTime = 0; // ÎßàÏßÄÎßâ ÌûàÌä∏ ÏãúÍ∞Ñ
                } 
            },
            { 
                id: 'gamble', 
                name: 'ÎèÑÎ∞ï', 
                description: 'Ï¥ùÏïåÏù¥ ¬±10ÎèÑ Î≤îÏúÑÏóêÏÑú ÎûúÎç§ÌïòÍ≤å ÎÇòÍ∞ÄÏßÄÎßå Îç∞ÎØ∏ÏßÄÎäî 1~2Î∞∞ ÏÇ¨Ïù¥Î°ú ÎûúÎç§', 
                effect: (character) => { 
                    character.hasGamble = true; 
                } 
            },
            { 
                id: 'weaken', 
                name: 'ÏïΩÌôî', 
                description: 'ÏÉÅÎåÄÏóêÍ≤å Ï¥ùÏïåÏùÑ ÎßûÏ∂ú Ïãú 3Ï¥àÎèôÏïà ÏÉÅÎåÄ Îç∞ÎØ∏ÏßÄ -0.25', 
                effect: (character) => { 
                    character.hasWeaken = true; 
                    character.weakenCount = (character.weakenCount || 0) + 1; 
                } 
            },
            { 
                id: 'damageBoost', 
                name: 'Îç∞ÎØ∏ÏßÄ 1.2Î∞∞', 
                description: 'Ï¥ùÏïå Îç∞ÎØ∏ÏßÄ *1.2', 
                effect: (character) => { 
                    character.damage = (character.damage || 1) * 1.2; 
                    character.hasDamageBoost = true; 
                } 
            },
            { 
                id: 'lightning', 
                name: 'Î≤àÍ∞ú', 
                description: 'Ï†ÅÏóêÍ≤å Ï¥ùÏïåÏùÑ ÎßûÏ∂ú Ïãú 25% ÌôïÎ•†Î°ú Ï†Å 0.75Ï¥à Í∏∞Ï†à', 
                effect: (character) => { 
                    character.hasLightning = true; 
                    character.lightningCount = (character.lightningCount || 0) + 1; 
                } 
            },
            { 
                id: 'shield', 
                name: 'Î∞©Ïñ¥Îßâ', 
                description: 'Î∞õÎäî Îç∞ÎØ∏ÏßÄ 1Ìöå Î¨¥Ïãú (Ïø®ÌÉÄÏûÑ 7.5Ï¥à)', 
                effect: (character) => { 
                    character.hasShield = true; 
                    character.shieldReady = true; // Î∞©Ïñ¥Îßâ Ï§ÄÎπÑÎê®
                    character.shieldCooldown = 0; // Ïø®ÌÉÄÏûÑ
                } 
            },
            { 
                id: 'regeneration', 
                name: 'Ïû¨ÏÉù', 
                description: '1Ï¥àÎßàÎã§ Ï≤¥Î†• 0.1 ÌöåÎ≥µ', 
                effect: (character) => { 
                    character.hasRegeneration = true; 
                    character.lastRegenTime = 0; // ÎßàÏßÄÎßâ ÌöåÎ≥µ ÏãúÍ∞Ñ
                    character.regenerationCount = (character.regenerationCount || 0) + 1; 
                } 
            },
            { 
                id: 'evasiveManeuver', 
                name: 'ÌöåÌîºÍ∏∞Îèô', 
                description: 'Ïû¨Ïû•Ï†Ñ Ï§ë Ïù¥ÎèôÏÜçÎèÑ +75%', 
                effect: (character) => { 
                    character.hasEvasiveManeuver = true; 
                    character.evasiveManeuverCount = (character.evasiveManeuverCount || 0) + 1; 
                } 
            },
            { 
                id: 'combatExperience', 
                name: 'Ï†ÑÌà¨ Í≤ΩÌóò', 
                description: 'ÏßÑ ÎùºÏö¥Îìú ÏàòÎßàÎã§ ÏµúÎåÄÏ≤¥Î†• 0.5, Îç∞ÎØ∏ÏßÄ 0.1 Ï¶ùÍ∞Ä', 
                effect: (character) => { 
                    character.hasCombatExperience = true; 
                    character.combatExperienceRounds = 0; // ÌòÑÏû¨ ÎùºÏö¥Îìú Ïàò
                    character.combatExperienceCount = (character.combatExperienceCount || 0) + 1; 
                } 
            },
            { 
                id: 'hallucination', 
                name: 'ÌôòÍ∞Å', 
                description: 'Ï¥ùÏïåÏù¥ ÎÇ†ÏïÑÍ∞ÄÎäî ÎèÑÏ§ëÏóê 0.1Ï¥àÎßàÎã§ ÏÜçÎèÑÍ∞Ä 0.75Î∞∞~2Î∞∞ ÏÇ¨Ïù¥Î°ú ÎûúÎç§ÏúºÎ°ú Ï°∞Ï†ïÎê®', 
                effect: (character) => { 
                    character.hasHallucination = true; 
                } 
            },
            { 
                id: 'tasteOfBlood', 
                name: 'ÌîºÏùò Îßõ', 
                description: 'Ï†ÅÏóêÍ≤å ÏûÖÌûå ÌîºÌï¥Ïùò 20%ÎßåÌÅº ÌöåÎ≥µ', 
                effect: (character) => { 
                    character.hasTasteOfBlood = true; 
                    character.tasteOfBloodCount = (character.tasteOfBloodCount || 0) + 1; 
                } 
            },
            { 
                id: 'cannon', 
                name: 'ÎåÄÌè¨', 
                description: 'Ï¥ùÏïåÏùò ÏÜçÎèÑ -50% ÎåÄÏã† Ï¥ùÏïåÏùò ÌÅ¨Í∏∞ +200%', 
                effect: (character) => { 
                    // ÏÜçÎèÑÎäî 0.5Î∞∞Ïî© Í≥±ÌïòÍ∏∞ (Ï§ëÏ≤©)
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 0.5; 
                    // ÌÅ¨Í∏∞Îäî 200%Ïî© Ï§ëÏ≤© (3Î∞∞Ïî© Í≥±ÌïòÍ∏∞)
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 3; // +200% = 3Î∞∞
                    character.hasCannon = true; 
                } 
            },
            { 
                id: 'timeBarrier', 
                name: 'ÏãúÍ∞ÑÏû•Îßâ', 
                description: 'ÏûêÏã† Ï£ºÏúÑÏùò Î∞òÏßÄÎ¶Ñ 150pxÏßúÎ¶¨ Ïõê ÏÉùÏÑ±, Ïù¥ Ïõê ÏïàÏóê Îì§Ïñ¥Ïò§Îäî Ï†ÅÏùò Ï¥ùÏïå 35% ÎëîÌôî', 
                effect: (character) => { 
                    character.hasTimeBarrier = true; 
                    character.timeBarrierRadius = 150; 
                } 
            },
            { 
                id: 'bouncyBullet', 
                name: 'ÌÜµÌÜµÌÉÑ', 
                description: 'Ï¥ùÏïåÏù¥ Î≤ΩÏóê ÎßûÏúºÎ©¥ 1Ìöå ÌäïÍπÄ', 
                effect: (character) => { 
                    character.hasBouncyBullet = true; 
                    character.bouncyBulletCount = (character.bouncyBulletCount || 0) + 1; 
                } 
            },
            { 
                id: 'gamble2', 
                name: 'Ïä§ÎÑ§Ïù¥ÌÅ¨', 
                description: 'Ï¥ùÏïåÏù¥ ÎÇ†ÏïÑÍ∞ÄÎäî ÎèÑÏ§ëÏóê 0.2Ï¥àÎßàÎã§ ¬±20ÎèÑÎßåÌÅº ÎûúÎç§ÏúºÎ°ú Î∞©Ìñ• Ï†ÑÌôò + Ï¥ùÏïåÏÜçÎèÑ -50% + Î∞úÏÇ¨ÏÜçÎèÑ -50%', 
                effect: (character) => { 
                    character.hasGamble2 = true; 
                    character.bulletSpeedMultiplier = (character.bulletSpeedMultiplier || 1) * 0.5;
                    character.shootCooldown *= 0.5; // Î∞úÏÇ¨ÏÜçÎèÑ -50% (Ïø®ÌÉÄÏûÑ Ï†àÎ∞ò)
                } 
            },
            { 
                id: 'reflect', 
                name: 'Î∞òÏÇ¨', 
                description: '5Ï¥àÎßàÎã§ Ïö∞ÌÅ¥Î¶≠ÏúºÎ°ú 0.1Ï¥àÎèôÏïà Î∞òÏÇ¨Î•º Ìï† Ïàò ÏûàÎäî Î≥¥Ìò∏ÎßâÏùÑ ÏñªÏùÑ Ïàò ÏûàÏùå. Î≥¥Ìò∏ÎßâÏù¥ ÏûàÎäîÎèôÏïà Ï†ÅÏùò Ï¥ùÏïåÏóê ÎßûÏúºÎ©¥ ÏÉÅÎåÄÍ∞Ä ÏûàÎäî Ï™ΩÏúºÎ°ú ÎÇ†ÏïÑÍ∞ê', 
                effect: (character) => { 
                    character.hasReflect = true;
                    character.reflectCooldown = 0;
                } 
            },
            { 
                id: 'timeStop', 
                name: 'ÏãúÍ∞ÑÏ†ïÏßÄ', 
                description: '10Ï¥àÎßàÎã§ Ïö∞ÌÅ¥Î¶≠ÏúºÎ°ú 1Ï¥àÎèôÏïà ÏãúÍ∞ÑÏùÑ Ï†ïÏßÄÏãúÏºú ÏÉÅÎåÄÏùò Ï¥ùÏïåÏùÄ Í∑∏ ÏÉÅÌÉúÏóêÏÑú Î©àÏ∂îÍ≥†, ÏÉÅÎåÄÎäî ÏõÄÏßÅÏù¥ÏßÄ Î™ªÌïòÍ≤å Ìï† Ïàò ÏûàÏùå', 
                effect: (character) => { 
                    character.hasTimeStop = true;
                    character.timeStopCooldown = 0;
                } 
            },
            { 
                id: 'scatter', 
                name: 'ÎπÑÏÇ∞ÌÉÑ', 
                description: 'Ï¥ùÏïå ÌÅ¨Í∏∞ -25%, Ï¥ùÏïåÏù¥ ¬±4ÎèÑ ÏÇ¨Ïù¥ÏóêÏÑú 2ÎèÑ Í∞ÑÍ≤©ÏúºÎ°ú 4Í∞úÎ°ú ÎÇòÎàî + ÌïúÎ∞úÎãπ Îç∞ÎØ∏ÏßÄ 0.25Î∞∞', 
                effect: (character) => { 
                    character.hasScatter = true;
                    character.bulletSizeMultiplier = (character.bulletSizeMultiplier || 1) * 0.75; // Ï¥ùÏïå ÌÅ¨Í∏∞ -25%
                } 
            },
            { 
                id: 'rocket', 
                name: 'Î°úÏºìÌÉÑ', 
                description: 'Ï¥ùÏïå ÏÜçÎèÑÍ∞Ä Ï¥àÍ∏∞ ÏÜçÎèÑÏùò 0.1Î∞∞Î∂ÄÌÑ∞ ÏãúÏûëÌï¥ 0.2Ï¥àÎßàÎã§ 2Î∞∞Ïî© Ï¶ùÍ∞Ä (ÏµúÎåÄ 6.4Î∞∞)', 
                effect: (character) => { 
                    character.hasRocket = true; 
                } 
            },
            { 
                id: 'trinity', 
                name: 'ÏÇºÏúÑÏùºÏ≤¥', 
                description: 'Ïù¥ÎèôÏÜçÎèÑ +10%, Î∞úÏÇ¨ÏÜçÎèÑ +10%, ÏµúÎåÄÏ≤¥Î†• +0.5', 
                effect: (character) => { 
                    character.speed *= 1.1;
                    character.shootCooldown *= 0.9; // Î∞úÏÇ¨ÏÜçÎèÑ +10% (Ïø®ÌÉÄÏûÑ 10% Í∞êÏÜå)
                    character.maxHealth += 0.5;
                    character.health += 0.5;
                    character.hasTrinity = true;
                } 
            },
            { 
                id: 'judgment', 
                name: 'ÏÑ†Í≥†', 
                description: 'Ï†ÅÏùÑ ÎßûÏ∂ú Ïãú Ï†ÅÏù¥ ÎßûÏùÄ Î∞©Ìñ•ÏúºÎ°ú 75px Î∞ÄÎ†§ÎÇ©ÎãàÎã§', 
                effect: (character) => { 
                    character.hasJudgment = true;
                } 
            },
            { 
                id: 'boomerang', 
                name: 'Î∂ÄÎß§Îûë', 
                description: 'Ï¥ùÏïå Îç∞ÎØ∏ÏßÄ -0.25, Ï¥ùÏïåÏùò ÏµúÎåÄ ÏÇ¨Í±∞Î¶¨ 850pxÎ°ú Ï†úÌïú ÎåÄÏã† Ï¥ùÏïåÏù¥ ÏµúÎåÄ ÏÇ¨Í±∞Î¶¨ÍπåÏßÄ Í∞îÎã§Í∞Ä Îã§Ïãú ÎêòÎèåÏïÑÏòµÎãàÎã§', 
                effect: (character) => { 
                    character.hasBoomerang = true;
                } 
            },
            { 
                id: 'explosiveBullet', 
                name: 'Ìè≠Î∞úÌÉÑ', 
                description: 'Ï¥ùÏïåÏù¥ Î≤ΩÏóê ÎãøÏïòÏùÑ Îïå 100px Î∞òÍ≤ΩÏóê 0.5 Îç∞ÎØ∏ÏßÄ', 
                effect: (character) => { 
                    character.hasExplosiveBullet = true;
                } 
            },
            { 
                id: 'reaper', 
                name: 'ÏÇ¨Ïã†', 
                description: 'Ï†ÅÏóêÍ≤å Ï¥ùÏïåÏùÑ ÎßûÏ∂ú Ïãú 0.4Ï¥àÍ∞Ñ ÏùÄÏã† + Ïù¥ÎèôÏÜçÎèÑ 15%', 
                effect: (character) => { 
                    character.hasReaper = true;
                } 
            },
            { 
                id: 'overcharge', 
                name: 'Í≥ºÏ∂©Ï†Ñ', 
                description: '10Ï¥àÎßàÎã§ Ïö∞ÌÅ¥Î¶≠ÏúºÎ°ú 1.5Ï¥àÎèôÏïà Ïù¥ÎèôÏÜçÎèÑ 33% + Ï¥ùÏïåÏÜçÎèÑ +33%', 
                effect: (character) => { 
                    character.hasOvercharge = true;
                    character.overchargeCooldown = 0;
                } 
            },
            { 
                id: 'victor', 
                name: 'ÏäπÎ¶¨Ïûê', 
                description: 'ÎùºÏö¥ÎìúÍ∞Ä ÏãúÏûëÌï† Îïå 10% ÌôïÎ•†Î°ú Í∑∏ ÎùºÏö¥Îìú Ï¶âÏãú ÏäπÎ¶¨', 
                effect: (character) => { 
                    character.hasVictor = true;
                } 
            },
        ];

        // ÌÇ§ ÏûÖÎ†• ÏÉÅÌÉú
        const keys = {};
        let mouse = { x: 0, y: 0 };
        let hoveredAugment = null; // ÎßàÏö∞Ïä§ Ìò∏Î≤ÑÎêú Ï¶ùÍ∞ï Ï†ïÎ≥¥

        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        canvas.addEventListener('click', (e) => {
            if (!gameState.isPaused && !gameState.isGameOver && !player.isDodging) {
                shoot(player);
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Ïö∞ÌÅ¥Î¶≠ Î©îÎâ¥ Î∞©ÏßÄ
            
            if (gameState.isPaused || gameState.isGameOver) return;
            
            // ÌîåÎ†àÏù¥Ïñ¥ Íµ¨Î•¥Í∏∞ (Ïö∞ÌÅ¥Î¶≠)
            if (player.hasDodge && !player.isDodging) {
                    dodge(player);
            }
            
            // Î∞òÏÇ¨ Î≥¥Ìò∏Îßâ ÌôúÏÑ±Ìôî (Ïö∞ÌÅ¥Î¶≠)
            if (player.hasReflect && !player.reflectActive && player.reflectCooldown === 0) {
                player.reflectActive = true;
                player.reflectEndTime = Date.now() + 100; // 0.1Ï¥à
            }
            
            // ÏãúÍ∞ÑÏ†ïÏßÄ ÌôúÏÑ±Ìôî (Ïö∞ÌÅ¥Î¶≠)
            if (player.hasTimeStop && !player.timeStopActive && player.timeStopCooldown === 0) {
                player.timeStopActive = true;
                player.timeStopEndTime = Date.now() + 1000; // 1Ï¥à
            }
            
            // Í≥ºÏ∂©Ï†Ñ ÌôúÏÑ±Ìôî (Ïö∞ÌÅ¥Î¶≠)
            if (player.hasOvercharge && !player.overchargeActive && player.overchargeCooldown === 0) {
                const now = Date.now();
                player.overchargeActive = true;
                player.overchargeEndTime = now + 1500; // 1.5Ï¥à
                player.overchargeCooldown = now + 10000; // 10Ï¥à Ïø®ÌÉÄÏûÑ
            }
        });

        // Ï¥ùÏïå ÌÅ¥ÎûòÏä§
        class Bullet {
            constructor(x, y, angle, owner, isFreeShot = false) {
                this.x = x;
                this.y = y;
                this.startX = x; // ÏãúÏûë ÏúÑÏπò Ï†ÄÏû• (Í∑ºÏ†ëÏ†ÑÎ™®ÎìúÏö©)
                this.startY = y;
                this.angle = angle;
                this.createTime = Date.now(); // ÏÉùÏÑ± ÏãúÍ∞Ñ Ï†ÄÏû• (10Ï¥à ÌõÑ ÏÇ≠Ï†úÏö©)
                const baseSpeed = 20;
                let speedMultiplier = owner.bulletSpeedMultiplier || 1;
                // Í≥ºÏ∂©Ï†Ñ: ÌôúÏÑ±Ìôî Ï§ë Ï¥ùÏïå ÏÜçÎèÑ +33%
                if (owner.overchargeActive && Date.now() < owner.overchargeEndTime) {
                    speedMultiplier *= 1.33;
                }
                this.speed = baseSpeed * speedMultiplier;
                this.baseSpeed = this.speed; // ÏõêÎûò ÏÜçÎèÑ Ï†ÄÏû• (ÏãúÍ∞ÑÏû•ÎßâÏö©)
                // ÌôòÍ∞Å: ÎÇ†ÏïÑÍ∞ÄÎäî ÎèÑÏ§ëÏóê 0.1Ï¥àÎßàÎã§ ÏÜçÎèÑ Î≥ÄÍ≤ΩÏùÑ ÏúÑÌïú Î≥ÄÏàò
                if (owner.hasHallucination) {
                    this.hallucinationLastChange = Date.now(); // ÎßàÏßÄÎßâ ÏÜçÎèÑ Î≥ÄÍ≤Ω ÏãúÍ∞Ñ
                    // Ï¥àÍ∏∞ ÏÜçÎèÑÎèÑ ÎûúÎç§ÏúºÎ°ú ÏÑ§Ï†ï (0.75Î∞∞~2Î∞∞)
                    const randomMultiplier = 0.75 + Math.random() * 1.25; // 0.75 ~ 2.0
                    this.hallucinationSpeed = this.baseSpeed * randomMultiplier;
                    this.speed = this.hallucinationSpeed; // Ï¥àÍ∏∞ ÏÜçÎèÑÎäî ÌôòÍ∞Å ÏÜçÎèÑÎ°ú
                }
                this.isInTimeBarrier = false; // ÏãúÍ∞ÑÏû•Îßâ ÏïàÏóê ÏûàÎäîÏßÄ Ïó¨Î∂Ä
                const sizeMultiplier = owner.bulletSizeMultiplier || 1;
                this.radius = 9 * sizeMultiplier;
                this.owner = owner;
                this.damage = owner.damage || 1;
                // Î∂ÄÎß§Îûë: Ï¥ùÏïå Îç∞ÎØ∏ÏßÄ -0.25
                if (owner.hasBoomerang) {
                    this.damage = Math.max(0.25, this.damage - 0.25);
                }
                // ÎπÑÏû•Ïùò ÌïúÎ∞ú: ÎßàÏßÄÎßâ ÌÉÑÌôòÏùò Îç∞ÎØ∏ÏßÄ +1.5 (Ï§ëÏ≤©)
                if (owner.hasLastBullet && owner.ammo === 1) {
                    const lastBulletCount = owner.lastBulletCount || 1;
                    this.damage += 1.5 * lastBulletCount;
                }
                // ÏïΩÌôî ÏÉÅÌÉú: Î™®Îì† Í≥µÍ≤© Îç∞ÎØ∏ÏßÄ -0.25 (Ï§ëÏ≤©)
                if (owner.isWeakened) {
                    const weakenCount = owner.weakenCount || 1;
                    this.damage = Math.max(0.25, this.damage - (0.25 * weakenCount));
                }
                this.isFreeShot = isFreeShot; // ÌÉÑÏïΩ ÏÜåÎ™® ÏóÜÎäî Ï¥ùÏïå (ÎçîÎ∏îÏÉ∑Ïö©)
                this.hasPoison = owner.hasPoisonBullet || false; // ÎèÖ ÌÉÑÌôò Ïó¨Î∂Ä
                this.hasBouncy = owner.hasBouncyBullet || false; // ÌÜµÌÜµÌÉÑ Ïó¨Î∂Ä
                this.bounceCount = 0; // ÌäïÍπÄ ÌöüÏàò
                this.maxBounces = owner.hasBouncyBullet ? (owner.bouncyBulletCount || 1) : 0; // ÏµúÎåÄ ÌäïÍπÄ ÌöüÏàò
                this.lastX = x; // Ïù¥Ï†Ñ ÏúÑÏπò (Î≤Ω Ï∂©Îèå Í∞êÏßÄÏö©)
                this.lastY = y;
                // ÎèÑÎ∞ïÌÉÑ_2: 0.2Ï¥àÎßàÎã§ ¬±10ÎèÑ ÎûúÎç§ Î∞©Ìñ• Ï†ÑÌôò
                if (owner.hasGamble2) {
                    this.gamble2LastChange = Date.now();
                }
                // Î°úÏºìÌÉÑ: 0.1Î∞∞Î∂ÄÌÑ∞ ÏãúÏûë, 0.2Ï¥àÎßàÎã§ 2Î∞∞Ïî© Ï¶ùÍ∞Ä
                if (owner.hasRocket) {
                    this.rocketSpeed = this.baseSpeed * 0.1; // 0.1Î∞∞
                    this.rocketLastChange = Date.now();
                    this.speed = this.rocketSpeed;
                }
                // Í∑ºÏ†ëÏ†ÑÎ™®Îìú: Î©àÏ∂§ ÏÉÅÌÉú
                this.isStopped = false; // Î©àÏ∂§ Ïó¨Î∂Ä
                this.stopTime = 0; // Î©àÏ∂ò ÏãúÍ∞Ñ
                this.fadeStartTime = 0; // ÌéòÏù¥Îìú ÏïÑÏõÉ ÏãúÏûë ÏãúÍ∞Ñ
                
                // Î∂ÄÎß§Îûë: Ï¥ùÏïåÏù¥ ÎêòÎèåÏïÑÏò¥
                this.hasBoomerang = owner.hasBoomerang || false;
                this.isReturning = false; // ÎêòÎèåÏïÑÍ∞ÄÎäî Ï§ëÏù∏ÏßÄ
                this.maxDistance = owner.hasBoomerang ? 850 : Infinity; // ÏµúÎåÄ ÏÇ¨Í±∞Î¶¨
            }

            update(deltaTime = 16.67) {
                // deltaTimeÏùÑ 60fps Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÍ∑úÌôî (Í∏∞Î≥∏Í∞í 16.67ms = 60fps)
                const normalizedDelta = deltaTime / 16.67;
                
                // Î°úÏºìÌÉÑ: 0.2Ï¥àÎßàÎã§ ÏÜçÎèÑ 2Î∞∞Ïî© Ï¶ùÍ∞Ä (ÏµúÎåÄ 6.4Î∞∞)
                if (this.owner && this.owner.hasRocket && this.rocketSpeed !== undefined) {
                    const now = Date.now();
                    if (now - this.rocketLastChange >= 200) { // 0.2Ï¥à = 200ms
                        if (this.rocketSpeed < this.baseSpeed * 6.4) {
                            this.rocketSpeed *= 2;
                            if (this.rocketSpeed > this.baseSpeed * 6.4) {
                                this.rocketSpeed = this.baseSpeed * 6.4;
                            }
                        }
                        this.rocketLastChange = now;
                    }
                    // ÏãúÍ∞ÑÏû•ÎßâÏù¥ ÏóÜÍ±∞ÎÇò Î∞ñÏóê ÏûàÏùÑ ÎïåÎßå Î°úÏºì ÏÜçÎèÑ Ï†ÅÏö©
                    if (!this.isInTimeBarrier) {
                        this.speed = this.rocketSpeed;
                    }
                }
                
                // Ïä§ÎÑ§Ïù¥ÌÅ¨: 0.2Ï¥àÎßàÎã§ ¬±20ÎèÑ ÎûúÎç§ Î∞©Ìñ• Ï†ÑÌôò
                if (this.owner && this.owner.hasGamble2 && this.gamble2LastChange !== undefined) {
                    const now = Date.now();
                    if (now - this.gamble2LastChange >= 200) { // 0.2Ï¥à = 200ms
                        const randomOffset = (Math.random() - 0.5) * 40 * Math.PI / 180; // ¬±20ÎèÑ
                        this.angle += randomOffset;
                        this.gamble2LastChange = now;
                    }
                }
                
                // ÌôòÍ∞Å: ÎÇ†ÏïÑÍ∞ÄÎäî ÎèÑÏ§ëÏóê 0.1Ï¥àÎßàÎã§ Ï¥ùÏïå ÏÜçÎèÑÎ•º Ïã§ÏãúÍ∞ÑÏúºÎ°ú Î≥ÄÍ≤Ω
                if (this.owner && this.owner.hasHallucination && this.hallucinationLastChange !== undefined) {
                    const now = Date.now();
                    if (now - this.hallucinationLastChange >= 100) { // 0.1Ï¥à = 100ms
                        // 0.75Î∞∞~2Î∞∞ ÏÇ¨Ïù¥Î°ú ÎûúÎç§ Ï°∞Ï†ï
                        const randomMultiplier = 0.75 + Math.random() * 1.25; // 0.75 ~ 2.0
                        this.hallucinationSpeed = this.baseSpeed * randomMultiplier;
                        this.hallucinationLastChange = now;
                    }
                    // ÌôòÍ∞Å ÏÜçÎèÑ ÏÇ¨Ïö© (ÏãúÍ∞ÑÏû•ÎßâÏù¥ Ï†ÅÏö©ÎêòÎ©¥ Í∑∏Í≤å Ïö∞ÏÑ†Ïù¥ÎØÄÎ°ú ÏãúÍ∞ÑÏû•Îßâ Î°úÏßÅÏóêÏÑú Ï≤òÎ¶¨)
                    // ÏãúÍ∞ÑÏû•ÎßâÏù¥ ÏóÜÍ±∞ÎÇò Î∞ñÏóê ÏûàÏùÑ ÎïåÎßå ÌôòÍ∞Å ÏÜçÎèÑ Ï†ÅÏö©
                    if (!this.isInTimeBarrier && !this.owner.hasRocket) { // Î°úÏºìÌÉÑÏù¥ ÏûàÏúºÎ©¥ Î°úÏºì ÏÜçÎèÑ Ïö∞ÏÑ†
                        this.speed = this.hallucinationSpeed;
                    }
                }
                
                // Î∂ÄÎß§Îûë: Ï¥ùÏïåÏù¥ ÏµúÎåÄ ÏÇ¨Í±∞Î¶¨ÍπåÏßÄ Í∞ÄÍ±∞ÎÇò Îßµ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ ÎêòÎèåÏïÑÏò¥
                if (this.hasBoomerang && !this.isReturning) {
                    const distance = Math.sqrt(
                        Math.pow(this.x - this.startX, 2) + 
                        Math.pow(this.y - this.startY, 2)
                    );
                    
                    // Îßµ Î∞ñÏúºÎ°ú ÎÇòÍ∞îÍ±∞ÎÇò ÏµúÎåÄ ÏÇ¨Í±∞Î¶¨Ïóê ÎèÑÎã¨ÌïòÎ©¥ ÎêòÎèåÏïÑÍ∞ÄÍ∏∞ ÏãúÏûë
                    if (this.isOutOfBounds() || distance >= this.maxDistance) {
                        // ÎêòÎèåÏïÑÍ∞ÄÍ∏∞ ÏãúÏûë
                        this.isReturning = true;
                        // ÏÜçÎèÑÍ∞Ä Îß§Ïö∞ Ï§ÑÏñ¥Îì¶
                        this.speed = this.baseSpeed * 0.1;
                    }
                }
                
                // Î∂ÄÎß§Îûë: ÎêòÎèåÏïÑÍ∞ÄÎäî Ï§ë
                if (this.hasBoomerang && this.isReturning) {
                    // ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ•ÏúºÎ°ú Ïù¥Îèô
                    const dxToOwner = this.owner.x - this.x;
                    const dyToOwner = this.owner.y - this.y;
                    const distanceToOwner = Math.sqrt(dxToOwner * dxToOwner + dyToOwner * dyToOwner);
                    
                    if (distanceToOwner > 0) {
                        this.angle = Math.atan2(dyToOwner, dxToOwner);
                        // ÏÜçÎèÑ Ï†êÏßÑÏ†ÅÏúºÎ°ú Ï¶ùÍ∞Ä
                        this.speed = Math.min(this.baseSpeed * 1.5, this.speed * 1.05);
                    }
                }
                
                // Ïù¥Îèô Ï†Ñ ÏúÑÏπò Ï†ÄÏû•
                const prevX = this.x;
                const prevY = this.y;
                
                // ÌÜµÌÜµÌÉÑ: Î≤ΩÏóê ÎßûÏúºÎ©¥ ÌäïÍπÄ (Ï§ëÏ≤© ÌöüÏàòÎßåÌÅº)
                if (this.hasBouncy && this.bounceCount < this.maxBounces) {
                    const nextX = this.x + Math.cos(this.angle) * this.speed * normalizedDelta;
                    const nextY = this.y + Math.sin(this.angle) * this.speed * normalizedDelta;
                    
                    // Î≤Ω Ï∂©Îèå Í∞êÏßÄ
                    let hitWall = false;
                    let newAngle = this.angle;
                    
                    // ÏôºÏ™Ω Î≤Ω ÎòêÎäî Ïò§Î•∏Ï™Ω Î≤ΩÏóê Ï∂©Îèå
                    if (nextX - this.radius < 0 || nextX + this.radius > canvas.width) {
                        hitWall = true;
                        // Î∞òÎåÄÎ∞©Ìñ•ÏóêÏÑú ¬±25ÎèÑ (ÏàòÌèâ Î∞òÏÇ¨)
                        const reflectAngle = Math.PI - this.angle; // Î∞òÏÇ¨Í∞Å
                        const randomOffset = (Math.random() - 0.5) * 50 * Math.PI / 180; // ¬±25ÎèÑ
                        newAngle = reflectAngle + randomOffset;
                    }
                    // ÏúÑÏ™Ω Î≤Ω ÎòêÎäî ÏïÑÎûòÏ™Ω Î≤ΩÏóê Ï∂©Îèå
                    if (nextY - this.radius < 0 || nextY + this.radius > canvas.height) {
                        hitWall = true;
                        // Î∞òÎåÄÎ∞©Ìñ•ÏóêÏÑú ¬±25ÎèÑ (ÏàòÏßÅ Î∞òÏÇ¨)
                        const reflectAngle = -this.angle; // Î∞òÏÇ¨Í∞Å
                        const randomOffset = (Math.random() - 0.5) * 50 * Math.PI / 180; // ¬±25ÎèÑ
                        newAngle = reflectAngle + randomOffset;
                    }
                    
                    if (hitWall) {
                        this.bounceCount++;
                        this.angle = newAngle;
                        // Î≤Ω Í≤ΩÍ≥ÑÎ°ú ÏúÑÏπò Ï°∞Ï†ï (Îßµ Í≤ΩÍ≥Ñ ÏÇ¨Ïö©)
                        this.x = Math.max(gameState.mapBounds.minX + this.radius, Math.min(gameState.mapBounds.maxX - this.radius, this.x));
                        this.y = Math.max(gameState.mapBounds.minY + this.radius, Math.min(gameState.mapBounds.maxY - this.radius, this.y));
                    } else {
                        this.x = nextX;
                        this.y = nextY;
                    }
                } else {
                    this.x += Math.cos(this.angle) * this.speed * normalizedDelta;
                    this.y += Math.sin(this.angle) * this.speed * normalizedDelta;
                }
                
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // ÌéòÏù¥Îìú ÏïÑÏõÉ Ìö®Í≥º (Í∑ºÏ†ëÏ†ÑÎ™®ÎìúÏóêÏÑú Î©àÏ∂ò Ï¥ùÏïå)
                let alpha = 1.0;
                if (this.isStopped && this.fadeStartTime > 0) {
                    const fadeElapsed = Date.now() - this.fadeStartTime;
                    const fadeDuration = 300; // 0.3Ï¥à
                    alpha = Math.max(0, 1 - (fadeElapsed / fadeDuration));
                }
                ctx.globalAlpha = alpha;
                
                // ÏßÅÏÇ¨Í∞ÅÌòï Ï¥ùÏïå Í∑∏Î¶¨Í∏∞ (ÎÑ§Ïò® Ìö®Í≥º Ï∂îÍ∞Ä)
                // ÎèÖ ÌÉÑÌôòÏù¥Î©¥ Ïñ¥ÎëêÏö¥ Ï¥àÎ°ùÏÉâ, ÏïÑÎãàÎ©¥ ÌïòÏñÄÏÉâ
                const bulletColor = this.hasPoison ? '#006600' : '#ffffff';
                ctx.fillStyle = bulletColor;
                ctx.shadowBlur = 10;
                ctx.shadowColor = bulletColor;
                const sizeMultiplier = this.owner.bulletSizeMultiplier || 1;
                const bulletWidth = 24 * sizeMultiplier; // Ï¥ùÏïå ÎÑàÎπÑ
                const bulletHeight = 9 * sizeMultiplier; // Ï¥ùÏïå ÎÜíÏù¥
                ctx.fillRect(-bulletWidth / 2, -bulletHeight / 2, bulletWidth, bulletHeight);
                
                ctx.globalAlpha = 1.0; // Î≥µÏõê
                ctx.restore();
            }

            isOutOfBounds() {
                // Îßµ Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
                return this.x < gameState.mapBounds.minX || this.x > gameState.mapBounds.maxX || 
                       this.y < gameState.mapBounds.minY || this.y > gameState.mapBounds.maxY;
            }
        }

        // ÏÜåÏàòÏ†ê Î∞òÏò¨Î¶º Ìó¨Ìçº Ìï®Ïàò: 1~2ÏûêÎ¶¨Îäî Ïú†ÏßÄ, 3ÏûêÎ¶¨ Ïù¥ÏÉÅÏùÄ 2ÏûêÎ¶¨Î°ú Î∞òÏò¨Î¶º
        function roundToMaxTwoDecimals(value) {
            const strValue = value.toString();
            const decimalIndex = strValue.indexOf('.');
            if (decimalIndex === -1) {
                return value; // Ï†ïÏàòÎ©¥ Í∑∏ÎåÄÎ°ú
            }
            const decimalPart = strValue.substring(decimalIndex + 1);
            if (decimalPart.length <= 2) {
                return value; // 2ÏûêÎ¶¨ Ïù¥ÌïòÎ©¥ Í∑∏ÎåÄÎ°ú
            }
            // 3ÏûêÎ¶¨ Ïù¥ÏÉÅÏù¥Î©¥ 2ÏûêÎ¶¨Î°ú Î∞òÏò¨Î¶º
            return Math.round(value * 100) / 100;
        }

        // ÌôîÎ©¥ ÌùîÎì§Î¶º Ìï®Ïàò
        function addScreenShake(intensity, duration) {
            gameState.shake.intensity = intensity;
            gameState.shake.duration = duration;
        }

        // Î∞úÏÇ¨ Ìï®Ïàò
        function shoot(character) {
            const now = Date.now();
            // Í∏∞Ï†à ÏÉÅÌÉúÎ©¥ Î∞úÏÇ¨ Î∂àÍ∞Ä
            if (character.isStunned) return;
            if (character.ammo > 0 && !character.isReloading && 
                now - character.lastShot > character.shootCooldown) {
                
                // ÎπÑÏÇ∞ÌÉÑ Ï¶ùÍ∞ïÏù¥ ÏûàÏùÑ ÎïåÏùò Î∞úÏÇ¨ Ï≤òÎ¶¨
                if (character.hasScatter) {
                    // ÎπÑÏÇ∞ÌÉÑ: ¬±4ÎèÑ Î≤îÏúÑÏóêÏÑú 2ÎèÑ Í∞ÑÍ≤©ÏúºÎ°ú 4Í∞úÎ°ú ÎÇòÎàî + Îç∞ÎØ∏ÏßÄ 0.25Î∞∞
                    const scatterAngles = [-4, -2, 0, 2];
                    
                    // ÎèÑÎ∞ï Ï¶ùÍ∞ï: Í∞Å Î∞úÏÇ¨ÎßàÎã§ ÎûúÎç§ Î∞∞Ïú® Ï†ÅÏö©
                    let scatterGambleMultiplier = 1;
                    let scatterBaseAngle = character.angle;
                    if (character.hasGamble) {
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // ¬±10ÎèÑ
                        scatterBaseAngle = character.angle + randomAngle;
                        scatterGambleMultiplier = 1 + Math.random(); // 1~2Î∞∞
                    }
                    
                    if (character.hasShotgun) {
                        // ÏÉ∑Í±¥ + ÎπÑÏÇ∞ÌÉÑ: Î™®Îì† ÌÉÑÏïΩÏùÑ ÏÉ∑Í±¥ÏúºÎ°ú Î∞úÏÇ¨ÌïòÎêò, Í∞Å Ï¥ùÏïåÏùÑ ÎπÑÏÇ∞ÌÉÑÏúºÎ°ú Î∂ÑÏÇ∞
                        const currentAmmo = character.ammo;
                        for (let i = 0; i < currentAmmo; i++) {
                            // ¬±25ÎèÑ Î≤îÏúÑ ÎÇ¥ ÎûúÎç§ Í∞ÅÎèÑ
                            const randomAngle = (Math.random() - 0.5) * (Math.PI * 50 / 180); // -25ÎèÑ ~ +25ÎèÑ
                            const baseAngle = scatterBaseAngle + randomAngle;
                            
                            // Í∞Å Ï¥ùÏïåÏùÑ ÎπÑÏÇ∞ÌÉÑÏúºÎ°ú Î∂ÑÏÇ∞
                            scatterAngles.forEach(angleDeg => {
                                const angle = baseAngle + (angleDeg * Math.PI / 180);
                                const bullet = new Bullet(
                                    character.x + Math.cos(character.angle) * character.radius,
                                    character.y + Math.sin(character.angle) * character.radius,
                                    angle,
                                    character,
                                    false
                                );
                                // ÎèÑÎ∞ï Ï¶ùÍ∞ï: Îç∞ÎØ∏ÏßÄ ÎûúÎç§ Ï†ÅÏö© (Îã§Î•∏ Îç∞ÎØ∏ÏßÄ Í∞êÏÜå Ìö®Í≥ºÎ•º Í≥†Î†§ÌïòÏó¨ Í≥±ÏÖà Ï†ÅÏö©)
                                if (character.hasGamble) {
                                    bullet.damage = Math.round(bullet.damage * scatterGambleMultiplier * 10) / 10; // ÏÜåÏàòÏ†ê 1ÏûêÎ¶¨ÍπåÏßÄÎßå Î∞òÏò¨Î¶º
                                }
                                bullet.damage = bullet.damage * 0.25; // Îç∞ÎØ∏ÏßÄ 0.25Î∞∞
                                character.bullets.push(bullet);
                            });
                        }
                        character.ammo = 0; // Î™®Îì† ÌÉÑÏïΩ ÏÜåÎ™®
                        character.lastShot = now;
                    } else {
                        // ÎπÑÏÇ∞ÌÉÑÎßå: Ìïú Î∞úÏî© Î∞úÏÇ¨Ìï† Îïå ¬±4ÎèÑ Î≤îÏúÑÏóêÏÑú 2ÎèÑ Í∞ÑÍ≤©ÏúºÎ°ú 4Í∞úÎ°ú ÎÇòÎàî
                        scatterAngles.forEach(angleDeg => {
                            const angle = scatterBaseAngle + (angleDeg * Math.PI / 180);
                            const bullet = new Bullet(
                                character.x + Math.cos(character.angle) * character.radius,
                                character.y + Math.sin(character.angle) * character.radius,
                                angle,
                                character,
                                false
                            );
                            // ÎèÑÎ∞ï Ï¶ùÍ∞ï: Îç∞ÎØ∏ÏßÄ ÎûúÎç§ Ï†ÅÏö© (Îã§Î•∏ Îç∞ÎØ∏ÏßÄ Í∞êÏÜå Ìö®Í≥ºÎ•º Í≥†Î†§ÌïòÏó¨ Í≥±ÏÖà Ï†ÅÏö©)
                            if (character.hasGamble) {
                                bullet.damage = Math.round(bullet.damage * scatterGambleMultiplier * 10) / 10; // ÏÜåÏàòÏ†ê 1ÏûêÎ¶¨ÍπåÏßÄÎßå Î∞òÏò¨Î¶º
                            }
                            bullet.damage = bullet.damage * 0.25; // Îç∞ÎØ∏ÏßÄ 0.25Î∞∞
                            character.bullets.push(bullet);
                        });
                        character.ammo--; // Ìïú Î∞úÎßå ÏÜåÎ™®
                        character.lastShot = now;
                    }
                } else if (character.hasShotgun) {
                // ÏÉ∑Í±¥ Ï¶ùÍ∞ï: Î™®Îì† ÌÉÑÏïΩÏùÑ ¬±25ÎèÑ Î≤îÏúÑÏóêÏÑú ÌïúÎ≤àÏóê Î∞úÏÇ¨
                    // ÎèÑÎ∞ï Ï¶ùÍ∞ï: Í∞Å Î∞úÏÇ¨ÎßàÎã§ ÎûúÎç§ Î∞∞Ïú® Ï†ÅÏö©
                    let shotgunGambleMultiplier = 1;
                    if (character.hasGamble) {
                        shotgunGambleMultiplier = 1 + Math.random(); // 1~2Î∞∞
                    }
                    
                    const currentAmmo = character.ammo;
                    for (let i = 0; i < currentAmmo; i++) {
                        // ¬±25ÎèÑ Î≤îÏúÑ ÎÇ¥ ÎûúÎç§ Í∞ÅÎèÑ
                        let randomAngle = (Math.random() - 0.5) * (Math.PI * 50 / 180); // -25ÎèÑ ~ +25ÎèÑ
                        // ÎèÑÎ∞ï Ï¶ùÍ∞ï: Í∞ÅÎèÑÏóêÎèÑ ¬±10ÎèÑ Ï∂îÍ∞Ä
                        if (character.hasGamble) {
                            randomAngle += (Math.random() - 0.5) * (Math.PI * 20 / 180); // ¬±10ÎèÑ Ï∂îÍ∞Ä
                        }
                const bullet = new Bullet(
                    character.x + Math.cos(character.angle) * character.radius,
                    character.y + Math.sin(character.angle) * character.radius,
                            character.angle + randomAngle,
                    character,
                    false
                );
                        // ÎèÑÎ∞ï Ï¶ùÍ∞ï: Îç∞ÎØ∏ÏßÄ ÎûúÎç§ Ï†ÅÏö© (Îã§Î•∏ Îç∞ÎØ∏ÏßÄ Í∞êÏÜå Ìö®Í≥ºÎ•º Í≥†Î†§ÌïòÏó¨ Í≥±ÏÖà Ï†ÅÏö©)
                        if (character.hasGamble) {
                            bullet.damage = Math.round(bullet.damage * shotgunGambleMultiplier * 10) / 10; // ÏÜåÏàòÏ†ê 1ÏûêÎ¶¨ÍπåÏßÄÎßå Î∞òÏò¨Î¶º
                        }
                        character.bullets.push(bullet);
                    }
                    character.ammo = 0; // Î™®Îì† ÌÉÑÏïΩ ÏÜåÎ™®
                    character.lastShot = now;
                } else {
                    // ÏùºÎ∞ò Î∞úÏÇ¨
                    let bulletAngle = character.angle;
                    let bulletDamage = character.damage || 1;
                    
                    // ÎèÑÎ∞ï Ï¶ùÍ∞ï: ¬±10ÎèÑ ÎûúÎç§ Í∞ÅÎèÑ, Îç∞ÎØ∏ÏßÄ 1~2Î∞∞ ÎûúÎç§
                    let gambleMultiplier = 1;
                    if (character.hasGamble) {
                        const randomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // ¬±10ÎèÑ
                        bulletAngle = character.angle + randomAngle;
                        gambleMultiplier = 1 + Math.random(); // 1~2Î∞∞
                    }
                    
                    // ÎπÑÏÇ∞ÌÉÑÏù¥ ÏûàÏúºÎ©¥ ÏùºÎ∞ò Î∞úÏÇ¨ÎèÑ ÎπÑÏÇ∞ÌÉÑÏúºÎ°ú Î∂ÑÏÇ∞
                    if (character.hasScatter) {
                        const scatterAngles = [-4, -2, 0, 2];
                        scatterAngles.forEach(angleDeg => {
                            const scatterAngle = bulletAngle + (angleDeg * Math.PI / 180);
                            const bullet = new Bullet(
                                character.x + Math.cos(character.angle) * character.radius,
                                character.y + Math.sin(character.angle) * character.radius,
                                scatterAngle,
                                character,
                                false
                            );
                            // ÎèÑÎ∞ï Ï¶ùÍ∞ï: Îç∞ÎØ∏ÏßÄ ÎûúÎç§ Ï†ÅÏö© (Îã§Î•∏ Îç∞ÎØ∏ÏßÄ Í∞êÏÜå Ìö®Í≥ºÎ•º Í≥†Î†§ÌïòÏó¨ Í≥±ÏÖà Ï†ÅÏö©)
                            if (character.hasGamble) {
                                bullet.damage = Math.round(bullet.damage * gambleMultiplier * 10) / 10; // ÏÜåÏàòÏ†ê 1ÏûêÎ¶¨ÍπåÏßÄÎßå Î∞òÏò¨Î¶º
                            }
                            bullet.damage = bullet.damage * 0.25; // Îç∞ÎØ∏ÏßÄ 0.25Î∞∞
                            character.bullets.push(bullet);
                        });
                    } else {
                        const bullet = new Bullet(
                            character.x + Math.cos(character.angle) * character.radius,
                            character.y + Math.sin(character.angle) * character.radius,
                            bulletAngle,
                            character,
                            false
                        );
                        // ÎèÑÎ∞ï Ï¶ùÍ∞ï: Îç∞ÎØ∏ÏßÄ ÎûúÎç§ Ï†ÅÏö© (Îã§Î•∏ Îç∞ÎØ∏ÏßÄ Í∞êÏÜå Ìö®Í≥ºÎ•º Í≥†Î†§ÌïòÏó¨ Í≥±ÏÖà Ï†ÅÏö©)
                        if (character.hasGamble) {
                            bullet.damage = Math.round(bullet.damage * gambleMultiplier * 10) / 10; // ÏÜåÏàòÏ†ê 1ÏûêÎ¶¨ÍπåÏßÄÎßå Î∞òÏò¨Î¶º
                        }
                        character.bullets.push(bullet);
                    }
                    character.ammo--;
                    character.lastShot = now;

                // ÎçîÎ∏îÏÉ∑ (ÌôïÎ•† Ï§ëÏ≤©: 25% * count)
                const doubleShotCount = character.doubleShotCount || 1;
                if (character.hasDoubleShot && Math.random() < (0.25 * doubleShotCount)) {
                    // ¬±15ÎèÑ ÏÇ¨Ïù¥Ïùò ÎûúÎç§ Í∞ÅÎèÑ
                    const randomAngle = (Math.random() - 0.5) * (Math.PI * 30 / 180); // -15ÎèÑ ~ +15ÎèÑ
                    let doubleBulletAngle = character.angle + randomAngle;
                    
                    // ÎçîÎ∏îÏÉ∑ÏóêÎèÑ ÎèÑÎ∞ï Ï¶ùÍ∞ï Ï†ÅÏö© (Í∞ÅÎèÑÎßå, Îç∞ÎØ∏ÏßÄÎäî Ï¥ùÏïå ÏÉùÏÑ± ÌõÑ Ï†ÅÏö©)
                    let doubleGambleMultiplier = 1;
                    if (character.hasGamble) {
                        const doubleRandomAngle = (Math.random() - 0.5) * (Math.PI * 20 / 180); // ¬±10ÎèÑ
                        doubleBulletAngle = character.angle + doubleRandomAngle;
                        doubleGambleMultiplier = 1 + Math.random(); // 1~2Î∞∞
                    }
                    
                    // ÎçîÎ∏îÏÉ∑ÏóêÎèÑ ÎπÑÏÇ∞ÌÉÑ Ï†ÅÏö©
                    if (character.hasScatter) {
                        const scatterAngles = [-4, -2, 0, 2];
                        scatterAngles.forEach(angleDeg => {
                            const angle = doubleBulletAngle + (angleDeg * Math.PI / 180);
                            const doubleBullet = new Bullet(
                                character.x + Math.cos(character.angle) * character.radius,
                                character.y + Math.sin(character.angle) * character.radius,
                                angle,
                                character,
                                true // ÌÉÑÏïΩ ÏÜåÎ™® ÏóÜÏùå
                            );
                            // ÎèÑÎ∞ï Ï¶ùÍ∞ï: Îç∞ÎØ∏ÏßÄ ÎûúÎç§ Ï†ÅÏö© (Îã§Î•∏ Îç∞ÎØ∏ÏßÄ Í∞êÏÜå Ìö®Í≥ºÎ•º Í≥†Î†§ÌïòÏó¨ Í≥±ÏÖà Ï†ÅÏö©)
                            if (character.hasGamble) {
                                doubleBullet.damage = Math.round(doubleBullet.damage * doubleGambleMultiplier * 10) / 10; // ÏÜåÏàòÏ†ê 1ÏûêÎ¶¨ÍπåÏßÄÎßå Î∞òÏò¨Î¶º
                            }
                            doubleBullet.damage = doubleBullet.damage * 0.25; // Îç∞ÎØ∏ÏßÄ 0.25Î∞∞
                            character.bullets.push(doubleBullet);
                        });
                    } else {
                        const doubleBullet = new Bullet(
                            character.x + Math.cos(character.angle) * character.radius,
                            character.y + Math.sin(character.angle) * character.radius,
                            doubleBulletAngle,
                            character,
                            true // ÌÉÑÏïΩ ÏÜåÎ™® ÏóÜÏùå
                        );
                        // ÎèÑÎ∞ï Ï¶ùÍ∞ï: Îç∞ÎØ∏ÏßÄ ÎûúÎç§ Ï†ÅÏö© (Îã§Î•∏ Îç∞ÎØ∏ÏßÄ Í∞êÏÜå Ìö®Í≥ºÎ•º Í≥†Î†§ÌïòÏó¨ Í≥±ÏÖà Ï†ÅÏö©)
                        if (character.hasGamble) {
                            doubleBullet.damage = Math.round(doubleBullet.damage * doubleGambleMultiplier * 10) / 10; // ÏÜåÏàòÏ†ê 1ÏûêÎ¶¨ÍπåÏßÄÎßå Î∞òÏò¨Î¶º
                        }
                        character.bullets.push(doubleBullet);
                    }
                    }
                }

                // ÌôîÎ©¥ ÌùîÎì§Î¶º Ìö®Í≥º (ÌîåÎ†àÏù¥Ïñ¥ Î∞úÏÇ¨ ÏãúÏóêÎßå)
                if (character === player) {
                    addScreenShake(18, 200);
                }

                // ÏûêÎèô Ïû¨Ïû•Ï†Ñ
                if (character.ammo === 0 && !character.isReloading) {
                    reload(character);
                }
                
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ïèú Ï¥ùÏïå Ï†ïÎ≥¥ Ï†ÑÏÜ°
                if (gameState.isMultiplayer && character === player && character.bullets.length > 0) {
                    // Î∞©Í∏à Ï∂îÍ∞ÄÎêú Ï¥ùÏïåÎì§Îßå Ï†ÑÏÜ° (ÎßàÏßÄÎßâÏóê Ï∂îÍ∞ÄÎêú Ï¥ùÏïå)
                    const newBullets = character.bullets.slice(-10); // ÏµúÎåÄ 10Í∞ú (ÏÉ∑Í±¥/ÎπÑÏÇ∞ÌÉÑ ÎåÄÎπÑ)
                    sendShootData(newBullets);
                }
            }
        }

        // Ïû¨Ïû•Ï†Ñ Ìï®Ïàò
        function reload(character) {
            if (character.ammo < character.maxAmmo && !character.isReloading) {
                character.isReloading = true;
                character.reloadStartTime = Date.now();
                
                setTimeout(() => {
                    character.ammo = character.maxAmmo;
                    character.isReloading = false;
                    character.reloadStartTime = 0;
                    
                    // Ïû¨Ïû•Ï†Ñ ÌöåÎ≥µ Ï¶ùÍ∞ï (ÌöåÎ≥µÎüâ Ï§ëÏ≤©)
                    if (character.hasReloadHeal) {
                        const reloadHealCount = character.reloadHealCount || 1;
                        character.health = Math.min(character.health + (1 * reloadHealCount), character.maxHealth);
                    }
                }, character.reloadTime);
            }
        }

        // Ï∂©Îèå Í∞êÏßÄ
        function checkCollision(bullet, target) {
            const dx = bullet.x - target.x;
            const dy = bullet.y - target.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < bullet.radius + target.radius;
        }
        
        // Ï¥ùÏïåÍ≥º ÏßÅÏÇ¨Í∞ÅÌòï Ïû•Ïï†Î¨º Ï∂©Îèå Í∞êÏßÄ
        function checkBulletObstacleCollision(bullet, obstacle) {
            if (!gameState.isMultiplayer || !gameState.obstacles) return false;
            
            // ÌöåÏ†ÑÎêú ÏßÅÏÇ¨Í∞ÅÌòïÏùò Î™®ÏÑúÎ¶¨ Ï¢åÌëú Í≥ÑÏÇ∞
            const cos = Math.cos(obstacle.angle);
            const sin = Math.sin(obstacle.angle);
            const hw = obstacle.width / 2;
            const hh = obstacle.height / 2;
            
            // ÏßÅÏÇ¨Í∞ÅÌòïÏùò 4Í∞ú Î™®ÏÑúÎ¶¨ (Î°úÏª¨ Ï¢åÌëú)
            const corners = [
                { x: -hw, y: -hh },
                { x: hw, y: -hh },
                { x: hw, y: hh },
                { x: -hw, y: hh }
            ];
            
            // ÏõîÎìú Ï¢åÌëúÎ°ú Î≥ÄÌôò
            const worldCorners = corners.map(c => ({
                x: obstacle.x + c.x * cos - c.y * sin,
                y: obstacle.y + c.x * sin + c.y * cos
            }));
            
            // Ï¥ùÏïå ÏúÑÏπòÎ•º ÏßÅÏÇ¨Í∞ÅÌòïÏùò Î°úÏª¨ Ï¢åÌëúÎ°ú Î≥ÄÌôò
            const dx = bullet.x - obstacle.x;
            const dy = bullet.y - obstacle.y;
            const localX = dx * cos + dy * sin;
            const localY = -dx * sin + dy * cos;
            
            // AABB Ï∂©Îèå Í∞êÏßÄ (Î°úÏª¨ Ï¢åÌëúÏóêÏÑú)
            if (Math.abs(localX) < hw + bullet.radius && Math.abs(localY) < hh + bullet.radius) {
                // Îçî Ï†ïÌôïÌïú Ï∂©Îèå Í∞êÏßÄÎ•º ÏúÑÌï¥ Í∞ÄÏû• Í∞ÄÍπåÏö¥ Î™®ÏÑúÎ¶¨ÍπåÏßÄÏùò Í±∞Î¶¨ ÌôïÏù∏
                let minDist = Infinity;
                for (let i = 0; i < worldCorners.length; i++) {
                    const next = worldCorners[(i + 1) % worldCorners.length];
                    const dist = pointToLineSegmentDistance(bullet.x, bullet.y, 
                                                           worldCorners[i].x, worldCorners[i].y,
                                                           next.x, next.y);
                    minDist = Math.min(minDist, dist);
                }
                return minDist < bullet.radius;
            }
            
            return false;
        }
        
        // ÌîåÎ†àÏù¥Ïñ¥/Ï†ÅÍ≥º ÏßÅÏÇ¨Í∞ÅÌòï Ïû•Ïï†Î¨º Ï∂©Îèå Í∞êÏßÄ
        function checkCharacterObstacleCollision(character, obstacle) {
            if (!gameState.isMultiplayer || !gameState.obstacles) return false;
            
            // ÌöåÏ†ÑÎêú ÏßÅÏÇ¨Í∞ÅÌòïÏùò Î°úÏª¨ Ï¢åÌëúÎ°ú Î≥ÄÌôò
            const cos = Math.cos(obstacle.angle);
            const sin = Math.sin(obstacle.angle);
            const dx = character.x - obstacle.x;
            const dy = character.y - obstacle.y;
            const localX = dx * cos + dy * sin;
            const localY = -dx * sin + dy * cos;
            
            // AABB Ï∂©Îèå Í∞êÏßÄ (Î°úÏª¨ Ï¢åÌëúÏóêÏÑú)
            const hw = obstacle.width / 2;
            const hh = obstacle.height / 2;
            
            // Ï∫êÎ¶≠ÌÑ∞ Î∞òÏßÄÎ¶ÑÏùÑ Í≥†Î†§Ìïú Ï∂©Îèå Ï≤¥ÌÅ¨
            if (Math.abs(localX) < hw + character.radius && Math.abs(localY) < hh + character.radius) {
                return true;
            }
            
            return false;
        }
        
        // Ï†êÏóêÏÑú ÏÑ†Î∂ÑÍπåÏßÄÏùò Í±∞Î¶¨ Í≥ÑÏÇ∞
        function pointToLineSegmentDistance(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSq = dx * dx + dy * dy;
            
            if (lengthSq === 0) {
                // ÏÑ†Î∂ÑÏù¥ Ï†êÏù∏ Í≤ΩÏö∞
                const dx2 = px - x1;
                const dy2 = py - y1;
                return Math.sqrt(dx2 * dx2 + dy2 * dy2);
            }
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            const dx2 = px - projX;
            const dy2 = py - projY;
            return Math.sqrt(dx2 * dx2 + dy2 * dy2);
        }

        // Íµ¨Î•¥Í∏∞ Ìï®Ïàò
        function dodge(character) {
            const now = Date.now();
            // Í∏∞Ï†à ÏÉÅÌÉúÎ©¥ Íµ¨Î•¥Í∏∞ Î∂àÍ∞Ä
            if (character.isStunned) return;
            // Ïø®ÌÉÄÏûÑ Ï≤¥ÌÅ¨ (3Ï¥à)
            if (character.isDodging || now - character.lastDodgeTime < 3000) return;
            
            character.isDodging = true;
            const dodgeDistance = character.radius * 6.4; // ÌîåÎ†àÏù¥Ïñ¥ ÌÅ¨Í∏∞Ïùò 3.2Î∞∞ (20% Í∞êÏÜå: 8 -> 6.4)
            const dodgeDuration = 300; // 0.3Ï¥à
            character.dodgeStartTime = now; // Íµ¨Î•¥Í∏∞ ÏãúÏûë ÏãúÍ∞Ñ
            character.dodgeEndTime = now + dodgeDuration;
            character.lastDodgeTime = now; // Ïø®ÌÉÄÏûÑ ÏãúÏûë
            character.dodgeTrail = []; // ÏûîÏÉÅ Ï¥àÍ∏∞Ìôî
            
            // Íµ¨Î•¥Í∏∞ ÏãúÏûë ÏúÑÏπò Ï†ÄÏû•
            character.dodgeStartX = character.x;
            character.dodgeStartY = character.y;
            character.dodgeTrail.push({ x: character.x, y: character.y, alpha: 0.5 });
            
            // Íµ¨Î•¥Í∏∞ Î™©Ìëú ÏúÑÏπò Í≥ÑÏÇ∞
            const targetX = character.x + Math.cos(character.angle) * dodgeDistance;
            const targetY = character.y + Math.sin(character.angle) * dodgeDistance;
            
            // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
            character.dodgeTargetX = Math.max(character.radius, Math.min(canvas.width - character.radius, targetX));
            character.dodgeTargetY = Math.max(character.radius, Math.min(canvas.height - character.radius, targetY));
        }

        // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô
        function updatePlayer(deltaTime = 16.67) {
            const now = Date.now();
            // deltaTimeÏùÑ 60fps Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÍ∑úÌôî (Í∏∞Î≥∏Í∞í 16.67ms = 60fps)
            const normalizedDelta = deltaTime / 16.67;
            
            // ÏãúÍ∞ÑÏ†ïÏßÄ ÏÉÅÌÉú Ï≤¥ÌÅ¨ (ÏÉÅÎåÄÍ∞Ä ÏãúÍ∞ÑÏ†ïÏßÄ Ï§ëÏù¥Î©¥ ÏòÅÌñ• ÏóÜÏùå)
            // ÏãúÍ∞ÑÏ†ïÏßÄÍ∞Ä ÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏúºÎ©¥ ÏïÑÎ¨¥Í≤ÉÎèÑ Ìï† Ïàò ÏóÜÏùå
            
            // Íµ¨Î•¥Í∏∞ ÏÉÅÌÉú Ï≤¥ÌÅ¨
            if (player.isDodging) {
                if (now >= player.dodgeEndTime) {
                    // Íµ¨Î•¥Í∏∞ ÏôÑÎ£å
                    player.x = player.dodgeTargetX;
                    player.y = player.dodgeTargetY;
                    player.isDodging = false;
                    player.dodgeTrail = [];
                } else {
                    // Íµ¨Î•¥Îäî ÎèôÏïà Îπ†Î•∏ ÏÜçÎèÑÎ°ú Ïù¥Îèô
                    const elapsed = now - player.dodgeStartTime; // ÏãúÏûë ÏãúÍ∞ÑÏúºÎ°úÎ∂ÄÌÑ∞Ïùò Í≤ΩÍ≥º ÏãúÍ∞Ñ
                    const progress = Math.min(elapsed / 300, 1); // 0~1 (300ms = 0.3Ï¥à)
                    
                    // ÏãúÏûë ÏúÑÏπòÏóêÏÑú Î™©Ìëú ÏúÑÏπòÎ°ú ÏÑ†Ìòï Î≥¥Í∞Ñ
                    player.x = player.dodgeStartX + (player.dodgeTargetX - player.dodgeStartX) * progress;
                    player.y = player.dodgeStartY + (player.dodgeTargetY - player.dodgeStartY) * progress;
                    
                    // ÏûîÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏ (Îß§ ÌîÑÎ†àÏûÑÎßàÎã§)
                    if (!player.dodgeTrail) player.dodgeTrail = [];
                    player.dodgeTrail.push({ x: player.x, y: player.y, alpha: 0.3 });
                    // ÏûîÏÉÅÏù¥ ÎÑàÎ¨¥ ÎßéÏïÑÏßÄÎ©¥ Ï†úÍ±∞
                    if (player.dodgeTrail.length > 5) {
                        player.dodgeTrail.shift();
                    }
                }
                return; // Íµ¨Î•¥Îäî Ï§ëÏóêÎäî ÏùºÎ∞ò Ïù¥Îèô Î∂àÍ∞Ä
            }

            // Î∂ÄÌôú Ï≤òÎ¶¨
            if (player.isReviving) {
                if (now >= player.reviveTime) {
                    player.isReviving = false;
                    player.health = 1;
                    // displayHealthÎäî Ïï†ÎãàÎ©îÏù¥ÏÖòÏúºÎ°ú ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏Îê®
                    player.isInvincible = true;
                    player.invincibleEndTime = now + 1000; // 1Ï¥à Î¨¥Ï†Å
                    // Î∂ÄÌôú ÌöüÏàò ÌôïÏù∏ - ÏïÑÏßÅ Îçî Î∂ÄÌôúÌï† Ïàò ÏûàÏúºÎ©¥ Í≥ÑÏÜç ÏßÑÌñâ
                    const reviveCount = player.reviveCount || 1;
                    const hasRevivedCount = (typeof player.hasRevived === 'number' ? player.hasRevived : (player.hasRevived ? 1 : 0));
                    if (hasRevivedCount >= reviveCount) {
                        // Îçî Ïù¥ÏÉÅ Î∂ÄÌôú Î∂àÍ∞Ä
                    }
                }
                return; // Î∂ÄÌôú Ï§ëÏóêÎäî Ïù¥Îèô Î∂àÍ∞Ä
            }

            // Î¨¥Ï†Å ÏÉÅÌÉú Ï≤¥ÌÅ¨
            if (player.isInvincible && now >= player.invincibleEndTime) {
                player.isInvincible = false;
            }

            // ÏïΩÌôî ÏÉÅÌÉú Ï≤¥ÌÅ¨
            if (player.isWeakened && now >= player.weakenEndTime) {
                player.isWeakened = false;
                // ÏïΩÌôîÎäî Ï¥ùÏïå ÏÉùÏÑ± ÏãúÏóêÎßå Îç∞ÎØ∏ÏßÄÎ•º Í∞êÏÜåÏãúÌÇ§ÎØÄÎ°ú, damage ÏûêÏ≤¥Îäî Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå
            }
            
            // ÏÇ¨Ïã† Ï¶ùÍ∞ï: ÏùÄÏã† Ï¢ÖÎ£å Ï≤¥ÌÅ¨
            if (player.isInvisible && now >= player.invisibilityEndTime) {
                player.isInvisible = false;
            }
            
            // Í≥ºÏ∂©Ï†Ñ: Ï¢ÖÎ£å Î∞è Ïø®ÌÉÄÏûÑ Ï≤¥ÌÅ¨
            if (player.overchargeActive && now >= player.overchargeEndTime) {
                player.overchargeActive = false;
            }
            if (player.overchargeCooldown > 0 && now >= player.overchargeCooldown) {
                player.overchargeCooldown = 0;
            }

            // Í∏∞Ï†à ÏÉÅÌÉú Ï≤¥ÌÅ¨
            if (player.isStunned && now >= player.stunEndTime) {
                player.isStunned = false;
            }

            // Î∞©Ïñ¥Îßâ Ïø®ÌÉÄÏûÑ Ï≤¥ÌÅ¨
            if (player.hasShield && !player.shieldReady && now >= player.shieldCooldown) {
                player.shieldReady = true;
            }
            
            // Î∞òÏÇ¨ Ïø®ÌÉÄÏûÑ Ï≤¥ÌÅ¨
            if (player.hasReflect && !player.reflectActive && now >= player.reflectCooldown) {
                player.reflectCooldown = 0; // Ïø®ÌÉÄÏûÑ ÏôÑÎ£å
            }
            
            // Î∞òÏÇ¨ Î≥¥Ìò∏Îßâ Ï¢ÖÎ£å Ï≤¥ÌÅ¨
            if (player.reflectActive && now >= player.reflectEndTime) {
                player.reflectActive = false;
                player.reflectCooldown = now + 5000; // 5Ï¥à Ïø®ÌÉÄÏûÑ
            }
            
            // ÏãúÍ∞ÑÏ†ïÏßÄ Ïø®ÌÉÄÏûÑ Ï≤¥ÌÅ¨
            if (player.hasTimeStop && now >= player.timeStopCooldown) {
                player.timeStopCooldown = 0; // Ïø®ÌÉÄÏûÑ ÏôÑÎ£å
            }
            
            // ÏãúÍ∞ÑÏ†ïÏßÄ Ï¢ÖÎ£å Ï≤¥ÌÅ¨
            if (player.timeStopActive && now >= player.timeStopEndTime) {
                player.timeStopActive = false;
                player.timeStopCooldown = now + 10000; // 10Ï¥à Ïø®ÌÉÄÏûÑ
            }

            // ÌîºÍ≤© Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
            if (player.hitEffectParticles) {
                for (let i = player.hitEffectParticles.length - 1; i >= 0; i--) {
                    const particle = player.hitEffectParticles[i];
                    particle.life -= deltaTime / 1000;
                    
                    // dot, triangle, square, burst ÌÉÄÏûÖÏùÄ Ïù¥Îèô (ÌçºÏßÄÎäî Ìö®Í≥º)
                    if ((particle.type === 'dot' || particle.type === 'triangle' || particle.type === 'square' || particle.type === 'burst') && particle.vx !== undefined) {
                        particle.x += particle.vx * (deltaTime / 1000);
                        particle.y += particle.vy * (deltaTime / 1000);
                        // Í∞êÏÜç
                        particle.vx *= 0.95;
                        particle.vy *= 0.95;
                    }
                    
                    // firework ÌÉÄÏûÖÏùÄ ÏßÅÏÇ¨Í∞ÅÌòïÏù¥ ÌçºÏßÄÎ©¥ÏÑú Í∏∏Ïñ¥ÏßÄÎäî Ìö®Í≥º (Í∞êÏÜç Ìö®Í≥º Ìè¨Ìï®)
                    if (particle.type === 'firework') {
                        // ÏÜçÎèÑÍ∞Ä Ï†êÏ†ê Ï§ÑÏñ¥Îì§Î©¥ÏÑú ÌçºÏßê
                        if (!particle.speed) {
                            particle.speed = 1.0;
                        }
                        // Í∞êÏÜç Ìö®Í≥º (ÏãúÍ∞ÑÏù¥ ÏßÄÎÇ†ÏàòÎ°ù ÏÜçÎèÑ Í∞êÏÜå)
                        const lifeProgress = 1 - (particle.life / particle.maxLife);
                        particle.speed = Math.max(0.1, 1.0 - lifeProgress * 0.9); // ÏµúÏÜå 0.1ÍπåÏßÄ Í∞êÏÜå
                    }
                    
                    // ring ÌÉÄÏûÖÏùÄ ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä
                    if (particle.type === 'ring' && particle.maxSize !== undefined) {
                        const progress = 1 - (particle.life / particle.maxLife);
                        particle.size = particle.size + (particle.maxSize - particle.size) * progress * 0.1;
                    }
                    
                    if (particle.life <= 0) {
                        player.hitEffectParticles.splice(i, 1);
                    }
                }
            }
            
            // Ïû¨ÏÉù: 1Ï¥àÎßàÎã§ Ï≤¥Î†• 0.1 ÌöåÎ≥µ (ÌöåÎ≥µÎüâ Ï§ëÏ≤©)
            if (player.hasRegeneration) {
                if (now - player.lastRegenTime >= 1000) {
                    const regenerationCount = player.regenerationCount || 1;
                    player.health = Math.min(player.health + (0.1 * regenerationCount), player.maxHealth);
                    player.lastRegenTime = now;
                }
            }

            // Í∏∞Ï†à Ï§ëÏóêÎäî Ïù¥Îèô Î∂àÍ∞Ä
            if (player.isStunned) {
                return;
            }
            
            // ÏÑ†Í≥†: Î∞ÄÎ†§ÎÇòÎäî Ìö®Í≥º Ï≤òÎ¶¨
            if (player.isJudgmentPushing) {
                const elapsed = now - player.judgmentPushStartTime;
                const progress = Math.min(1, elapsed / player.judgmentPushDuration);
                
                // Î∂ÄÎìúÎü¨Ïö¥ Ïù¥Îèô (ease-out)
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                player.x = player.judgmentPushStartX + (player.judgmentPushTargetX - player.judgmentPushStartX) * easeProgress;
                player.y = player.judgmentPushStartY + (player.judgmentPushTargetY - player.judgmentPushStartY) * easeProgress;
                
                // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
                player.x = Math.max(gameState.mapBounds.minX + player.radius, Math.min(gameState.mapBounds.maxX - player.radius, player.x));
                player.y = Math.max(gameState.mapBounds.minY + player.radius, Math.min(gameState.mapBounds.maxY - player.radius, player.y));
                
                if (progress >= 1) {
                    player.isJudgmentPushing = false;
                } else {
                    return; // Î∞ÄÎ†§ÎÇòÎäî Ï§ëÏóêÎäî Îã§Î•∏ Ïù¥Îèô Î∂àÍ∞Ä
                }
            }

            // Ïù¥ÎèôÏÜçÎèÑ Í∞êÏÜå Ï≤òÎ¶¨ (ÍπäÏùÄ ÏÉÅÏ≤ò)
            let currentSpeed = player.speed;
            if (now < player.slowEndTime) {
                    currentSpeed *= 0.75; // -25%
                }
            
            // ÏÇ¨Ïã† Ï¶ùÍ∞ï: ÏùÄÏã† Ï§ë Ïù¥ÎèôÏÜçÎèÑ +15%
            if (player.isInvisible && now < player.invisibilityEndTime) {
                currentSpeed *= 1.15;
            }
            
            // Í≥ºÏ∂©Ï†Ñ: ÌôúÏÑ±Ìôî Ï§ë Ïù¥ÎèôÏÜçÎèÑ +33%
            if (player.overchargeActive && now < player.overchargeEndTime) {
                currentSpeed *= 1.33;
                // Í≥ºÏ∂©Ï†Ñ ÏûîÏÉÅ Ï∂îÍ∞Ä (ÌååÎûÄÏÉâ)
                if (!player.overchargeTrail) player.overchargeTrail = [];
                player.overchargeTrail.push({ x: player.x, y: player.y, alpha: 0.6 });
                // ÏûîÏÉÅÏù¥ ÎÑàÎ¨¥ ÎßéÏïÑÏßÄÎ©¥ Ï†úÍ±∞
                if (player.overchargeTrail.length > 8) {
                    player.overchargeTrail.shift();
                }
            } else {
                // Í≥ºÏ∂©Ï†Ñ ÎπÑÌôúÏÑ±Ìôî Ïãú ÏûîÏÉÅ Ï¥àÍ∏∞Ìôî
                if (player.overchargeTrail) player.overchargeTrail = [];
            }
            
            // ÌöåÌîºÍ∏∞Îèô: Ïû¨Ïû•Ï†Ñ Ï§ë Ïù¥ÎèôÏÜçÎèÑ +75% (Ï§ëÏ≤©)
            if (player.hasEvasiveManeuver && player.isReloading) {
                const evasiveManeuverCount = player.evasiveManeuverCount || 1;
                currentSpeed *= (1 + 0.75 * evasiveManeuverCount);
            }
            
            // ÏÉùÏ°¥Î≥∏Îä•: Ï≤¥Î†•Ïù¥ 1Ïùº Îïå Ïù¥ÎèôÏÜçÎèÑ +50% (Ï§ëÏ≤©)
            if (player.hasSurvivalInstinct && player.health === 1) {
                const survivalInstinctCount = player.survivalInstinctCount || 1;
                currentSpeed *= (1 + 0.5 * survivalInstinctCount);
            }
            
            // ÌöåÎ≥µÍ≥ÑÏïΩ: Ï≤¥Î†•Ïù¥ 1Ïùº Îïå Ï≤¥Î†• 2ÌöåÎ≥µ (ÌöåÎ≥µÎüâ Ï§ëÏ≤©)
            if (player.hasRecoveryContract && !player.hasRecoveryContractUsed && player.health === 1) {
                const recoveryContractCount = player.recoveryContractCount || 1;
                player.health = Math.min(player.health + (2 * recoveryContractCount), player.maxHealth);
                player.hasRecoveryContractUsed = true;
            }

            let dx = 0;
            let dy = 0;

            // Î¨¥ÎπôÏõåÌÅ¨Î™®Îìú: 5Ï¥àÎßàÎã§ Î∞îÎÄåÎäî Î∞©Ìñ•ÏúºÎ°ú Ï¥àÎãπ 25px Ïù¥Îèô + WASD ÏûÖÎ†•ÎèÑ Í∞ÄÎä•
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'movingWork') {
                // ÏúÑ, ÏïÑÎûò, Ï¢å, Ïö∞ 4Î∞©Ìñ• Ï§ë 1Í∞ú ÏÑ†ÌÉù
                if (!gameState.movingWorkDirection) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // Ïö∞, ÏïÑÎûò, Ï¢å, ÏúÑ
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // 5Ï¥àÎßàÎã§ Î∞©Ìñ• Î≥ÄÍ≤Ω
                if (now - gameState.movingWorkLastChange >= 5000) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // Ïö∞, ÏïÑÎûò, Ï¢å, ÏúÑ
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // Ï¥àÎãπ 25px Ïù¥Îèô (Î∂ÄÎìúÎüΩÍ≤å)
                const moveSpeed = 25 / 60; // 60fps Í∏∞Ï§Ä
                let autoDx = Math.cos(gameState.movingWorkDirection) * moveSpeed * normalizedDelta;
                let autoDy = Math.sin(gameState.movingWorkDirection) * moveSpeed * normalizedDelta;
                
                // WASD ÏûÖÎ†•ÎèÑ Î∞õÍ∏∞
                if (keys['w']) dy -= 1;
                if (keys['s']) dy += 1;
                if (keys['a']) dx -= 1;
                if (keys['d']) dx += 1;
                
                // ÎåÄÍ∞ÅÏÑ† Ïù¥Îèô Ï†ïÍ∑úÌôî
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                // ÏûêÎèô Ïù¥ÎèôÍ≥º WASD ÏûÖÎ†• Ìï©ÏÇ∞
                dx += autoDx;
                dy += autoDy;
            } else {
                // ÏùºÎ∞ò Ïù¥Îèô
                if (keys['w']) dy -= 1;
                if (keys['s']) dy += 1;
                if (keys['a']) dx -= 1;
                if (keys['d']) dx += 1;
                
                // ÎåÄÍ∞ÅÏÑ† Ïù¥Îèô Ï†ïÍ∑úÌôî
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
            }

            // Í±∞Ï†êÌôïÎ≥¥: ÏúÑÏπò Î≥ÄÌôî Ï≤¥ÌÅ¨
            if (player.hasFortify) {
                const moved = Math.abs(player.x - (player.lastPosition?.x || player.x)) > 0.1 || 
                             Math.abs(player.y - (player.lastPosition?.y || player.y)) > 0.1;
                
                if (moved) {
                    // ÏõÄÏßÅÏûÑ: Í±∞Ï†ê ÌôïÎ≥¥ Ìï¥Ï†ú
                    player.isFortified = false;
                    player.stationaryTime = 0;
                    if (!player.lastPosition) player.lastPosition = { x: player.x, y: player.y };
                    player.lastPosition.x = player.x;
                    player.lastPosition.y = player.y;
                } else {
                    // Ï†ïÏßÄ: ÏãúÍ∞Ñ ÎàÑÏ†Å
                    if (!player.lastPosition) player.lastPosition = { x: player.x, y: player.y };
                    player.stationaryTime += 16; // ÏïΩ 60fps Í∏∞Ï§Ä
                    
                    // 3Ï¥à(3000ms) ÎèôÏïà Ï†ïÏßÄÌïòÎ©¥ Í±∞Ï†ê ÌôïÎ≥¥
                    if (player.stationaryTime >= 3000 && !player.isFortified) {
                        player.isFortified = true;
                        player.fortifyStartTime = now;
                    }
                }
            }

            // ÎπôÌåêÎ™®Îìú: ÎØ∏ÎÅÑÎü¨Ïßê Ìö®Í≥º
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'ice') {
                // ÏÜçÎèÑ Î≤°ÌÑ∞ Ï¥àÍ∏∞Ìôî
                if (!player.velocityX) player.velocityX = 0;
                if (!player.velocityY) player.velocityY = 0;
                
                // ÏûÖÎ†•Ïù¥ ÏûàÏúºÎ©¥ ÏÜçÎèÑ Î≤°ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                if (dx !== 0 || dy !== 0) {
                    player.velocityX = dx * currentSpeed;
                    player.velocityY = dy * currentSpeed;
                }
                
                // ÎßàÏ∞∞ Ï†ÅÏö© (ÏÜçÎèÑ Í∞êÏÜå) - ÎπôÌåêÎ™®ÎìúÏóêÏÑúÎäî Ìõ®Ïî¨ Îçî Ïûò ÎØ∏ÎÅÑÎü¨Ïßê
                player.velocityX *= 0.995;
                player.velocityY *= 0.995;
                
                // ÏÜçÎèÑÍ∞Ä Îß§Ïö∞ ÏûëÏúºÎ©¥ Ï†ïÏßÄ
                if (Math.abs(player.velocityX) < 0.01) player.velocityX = 0;
                if (Math.abs(player.velocityY) < 0.01) player.velocityY = 0;
                
                // ÏÜçÎèÑ Î≤°ÌÑ∞Î°ú Ïù¥Îèô (deltaTime Ï†ïÍ∑úÌôî Ï†ÅÏö©)
                let newX = player.x + player.velocityX * normalizedDelta;
                let newY = player.y + player.velocityY * normalizedDelta;
                
                // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ (Îßµ Í≤ΩÍ≥Ñ ÏÇ¨Ïö©) - Í≤ΩÍ≥ÑÎ•º ÎÑòÏñ¥Í∞ÄÎ©¥ Í∞ïÏ†úÎ°ú Í≤ΩÍ≥Ñ ÏïàÏúºÎ°ú Ï†úÌïú
                newX = Math.max(gameState.mapBounds.minX + player.radius, Math.min(gameState.mapBounds.maxX - player.radius, newX));
                newY = Math.max(gameState.mapBounds.minY + player.radius, Math.min(gameState.mapBounds.maxY - player.radius, newY));
                
                // Í≤ΩÍ≥ÑÏóê ÎãøÏúºÎ©¥ ÏÜçÎèÑ Î∞òÏÇ¨
                if (newX !== player.x + player.velocityX) player.velocityX *= -0.5;
                if (newY !== player.y + player.velocityY) player.velocityY *= -0.5;
                
                player.x = newX;
                player.y = newY;
            } else {
                // ÏùºÎ∞ò Ïù¥Îèô (deltaTime Ï†ïÍ∑úÌôî Ï†ÅÏö©)
                let newX = player.x + dx * currentSpeed * normalizedDelta;
                let newY = player.y + dy * currentSpeed * normalizedDelta;

                // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ (Îßµ Í≤ΩÍ≥Ñ ÏÇ¨Ïö©) - Í≤ΩÍ≥ÑÎ•º ÎÑòÏñ¥Í∞ÄÎ©¥ Í∞ïÏ†úÎ°ú Í≤ΩÍ≥Ñ ÏïàÏúºÎ°ú Ï†úÌïú
                newX = Math.max(gameState.mapBounds.minX + player.radius, Math.min(gameState.mapBounds.maxX - player.radius, newX));
                newY = Math.max(gameState.mapBounds.minY + player.radius, Math.min(gameState.mapBounds.maxY - player.radius, newY));
                
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïû•Ïï†Î¨º Ï∂©Îèå Ï≤¥ÌÅ¨
                if (gameState.isMultiplayer && gameState.obstacles) {
                    const testPlayer = { x: newX, y: newY, radius: player.radius };
                    for (let i = 0; i < gameState.obstacles.length; i++) {
                        if (checkCharacterObstacleCollision(testPlayer, gameState.obstacles[i])) {
                            // Ï∂©Îèå Î∞úÏÉù: Ïù¥Ï†Ñ ÏúÑÏπò Ïú†ÏßÄ
                            newX = player.x;
                            newY = player.y;
                            break;
                        }
                    }
                }
                
                player.x = newX;
                player.y = newY;
            }

            // Í∞ÅÎèÑ Í≥ÑÏÇ∞ (ÎßàÏö∞Ïä§ Î∞©Ìñ•)
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
        }


        // AI Ï†Å ÏóÖÎç∞Ïù¥Ìä∏
        function updateEnemy(deltaTime = 16.67) {
            const now = Date.now();
            // deltaTimeÏùÑ 60fps Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÍ∑úÌôî (Í∏∞Î≥∏Í∞í 16.67ms = 60fps)
            const normalizedDelta = deltaTime / 16.67;
            
            // Î∂ÄÌôú Ï≤òÎ¶¨
            if (enemy.isReviving) {
                if (now >= enemy.reviveTime) {
                    enemy.isReviving = false;
                    enemy.health = 1;
                    // displayHealthÎäî Ïï†ÎãàÎ©îÏù¥ÏÖòÏúºÎ°ú ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏Îê®
                    enemy.isInvincible = true;
                    enemy.invincibleEndTime = now + 1000; // 1Ï¥à Î¨¥Ï†Å
                    // Î∂ÄÌôú ÌöüÏàò ÌôïÏù∏ - ÏïÑÏßÅ Îçî Î∂ÄÌôúÌï† Ïàò ÏûàÏúºÎ©¥ Í≥ÑÏÜç ÏßÑÌñâ
                    const reviveCount = enemy.reviveCount || 1;
                    const hasRevivedCount = (typeof enemy.hasRevived === 'number' ? enemy.hasRevived : (enemy.hasRevived ? 1 : 0));
                    if (hasRevivedCount >= reviveCount) {
                        // Îçî Ïù¥ÏÉÅ Î∂ÄÌôú Î∂àÍ∞Ä
                    }
                }
                return; // Î∂ÄÌôú Ï§ëÏóêÎäî Ïù¥Îèô Î∂àÍ∞Ä
            }

            // Î¨¥Ï†Å ÏÉÅÌÉú Ï≤¥ÌÅ¨
            if (enemy.isInvincible && now >= enemy.invincibleEndTime) {
                enemy.isInvincible = false;
            }

            // ÏïΩÌôî ÏÉÅÌÉú Ï≤¥ÌÅ¨
            if (enemy.isWeakened && now >= enemy.weakenEndTime) {
                enemy.isWeakened = false;
                // ÏïΩÌôîÎäî Ï¥ùÏïå ÏÉùÏÑ± ÏãúÏóêÎßå Îç∞ÎØ∏ÏßÄÎ•º Í∞êÏÜåÏãúÌÇ§ÎØÄÎ°ú, damage ÏûêÏ≤¥Îäî Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå
            }
            
            // ÏÇ¨Ïã† Ï¶ùÍ∞ï: ÏùÄÏã† Ï¢ÖÎ£å Ï≤¥ÌÅ¨
            if (enemy.isInvisible && now >= enemy.invisibilityEndTime) {
                enemy.isInvisible = false;
            }
            
            // Í≥ºÏ∂©Ï†Ñ: Ï¢ÖÎ£å Î∞è Ïø®ÌÉÄÏûÑ Ï≤¥ÌÅ¨
            if (enemy.overchargeActive && now >= enemy.overchargeEndTime) {
                enemy.overchargeActive = false;
            }
            if (enemy.overchargeCooldown > 0 && now >= enemy.overchargeCooldown) {
                enemy.overchargeCooldown = 0;
            }

            // Í∏∞Ï†à ÏÉÅÌÉú Ï≤¥ÌÅ¨
            if (enemy.isStunned && now >= enemy.stunEndTime) {
                enemy.isStunned = false;
            }

            // Î∞©Ïñ¥Îßâ Ïø®ÌÉÄÏûÑ Ï≤¥ÌÅ¨
            if (enemy.hasShield && !enemy.shieldReady && now >= enemy.shieldCooldown) {
                enemy.shieldReady = true;
            }

            // Ïû¨ÏÉù: 1Ï¥àÎßàÎã§ Ï≤¥Î†• 0.1 ÌöåÎ≥µ (ÌöåÎ≥µÎüâ Ï§ëÏ≤©)
            if (enemy.hasRegeneration) {
                if (now - enemy.lastRegenTime >= 1000) {
                    const regenerationCount = enemy.regenerationCount || 1;
                    enemy.health = Math.min(enemy.health + (0.1 * regenerationCount), enemy.maxHealth);
                    enemy.health = roundToMaxTwoDecimals(enemy.health);
                    enemy.lastRegenTime = now;
                }
            }

            // Í∏∞Ï†à Ï§ëÏóêÎäî Ïù¥Îèô Î∂àÍ∞Ä
            if (enemy.isStunned) {
                return;
            }
            
            // ÏãúÍ∞ÑÏ†ïÏßÄ: ÏÉÅÎåÄÍ∞Ä ÏãúÍ∞ÑÏ†ïÏßÄÎ•º ÏÇ¨Ïö© Ï§ëÏù¥Î©¥ ÏõÄÏßÅÏù¥ÏßÄ Î™ªÌï®
            if (player.timeStopActive) {
                return;
            }
            
            // ÏÑ†Í≥†: Î∞ÄÎ†§ÎÇòÎäî Ìö®Í≥º Ï≤òÎ¶¨
            if (enemy.isJudgmentPushing) {
                const elapsed = now - enemy.judgmentPushStartTime;
                const progress = Math.min(1, elapsed / enemy.judgmentPushDuration);
                
                // Î∂ÄÎìúÎü¨Ïö¥ Ïù¥Îèô (ease-out)
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                enemy.x = enemy.judgmentPushStartX + (enemy.judgmentPushTargetX - enemy.judgmentPushStartX) * easeProgress;
                enemy.y = enemy.judgmentPushStartY + (enemy.judgmentPushTargetY - enemy.judgmentPushStartY) * easeProgress;
                
                // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
                enemy.x = Math.max(gameState.mapBounds.minX + enemy.radius, Math.min(gameState.mapBounds.maxX - enemy.radius, enemy.x));
                enemy.y = Math.max(gameState.mapBounds.minY + enemy.radius, Math.min(gameState.mapBounds.maxY - enemy.radius, enemy.y));
                
                if (progress >= 1) {
                    enemy.isJudgmentPushing = false;
                } else {
                    return; // Î∞ÄÎ†§ÎÇòÎäî Ï§ëÏóêÎäî Îã§Î•∏ Ïù¥Îèô Î∂àÍ∞Ä
                }
            }

            // Ïù¥ÎèôÏÜçÎèÑ Í∞êÏÜå Ï≤òÎ¶¨ (ÍπäÏùÄ ÏÉÅÏ≤ò)
            let currentSpeed = enemy.speed;
            if (now < enemy.slowEndTime) {
                    currentSpeed *= 0.75; // -25%
                }
            
            // ÏÇ¨Ïã† Ï¶ùÍ∞ï: ÏùÄÏã† Ï§ë Ïù¥ÎèôÏÜçÎèÑ +15%
            if (enemy.isInvisible && now < enemy.invisibilityEndTime) {
                currentSpeed *= 1.15;
            }
            
            // Í≥ºÏ∂©Ï†Ñ: ÌôúÏÑ±Ìôî Ï§ë Ïù¥ÎèôÏÜçÎèÑ +33%
            if (enemy.overchargeActive && now < enemy.overchargeEndTime) {
                currentSpeed *= 1.33;
                // Í≥ºÏ∂©Ï†Ñ ÏûîÏÉÅ Ï∂îÍ∞Ä (ÌååÎûÄÏÉâ)
                if (!enemy.overchargeTrail) enemy.overchargeTrail = [];
                enemy.overchargeTrail.push({ x: enemy.x, y: enemy.y, alpha: 0.6 });
                // ÏûîÏÉÅÏù¥ ÎÑàÎ¨¥ ÎßéÏïÑÏßÄÎ©¥ Ï†úÍ±∞
                if (enemy.overchargeTrail.length > 8) {
                    enemy.overchargeTrail.shift();
                }
            } else {
                // Í≥ºÏ∂©Ï†Ñ ÎπÑÌôúÏÑ±Ìôî Ïãú ÏûîÏÉÅ Ï¥àÍ∏∞Ìôî
                if (enemy.overchargeTrail) enemy.overchargeTrail = [];
            }
            
            // ÌöåÌîºÍ∏∞Îèô: Ïû¨Ïû•Ï†Ñ Ï§ë Ïù¥ÎèôÏÜçÎèÑ +75% (Ï§ëÏ≤©)
            if (enemy.hasEvasiveManeuver && enemy.isReloading) {
                const evasiveManeuverCount = enemy.evasiveManeuverCount || 1;
                currentSpeed *= (1 + 0.75 * evasiveManeuverCount);
            }
            
            // ÏÉùÏ°¥Î≥∏Îä•: Ï≤¥Î†•Ïù¥ 1Ïùº Îïå Ïù¥ÎèôÏÜçÎèÑ +50% (Ï§ëÏ≤©)
            if (enemy.hasSurvivalInstinct && enemy.health === 1) {
                const survivalInstinctCount = enemy.survivalInstinctCount || 1;
                currentSpeed *= (1 + 0.5 * survivalInstinctCount);
            }
            
            // ÌöåÎ≥µÍ≥ÑÏïΩ: Ï≤¥Î†•Ïù¥ 1Ïùº Îïå Ï≤¥Î†• 2ÌöåÎ≥µ (ÌöåÎ≥µÎüâ Ï§ëÏ≤©)
            if (enemy.hasRecoveryContract && !enemy.hasRecoveryContractUsed && enemy.health === 1) {
                const recoveryContractCount = enemy.recoveryContractCount || 1;
                enemy.health = Math.min(enemy.health + (2 * recoveryContractCount), enemy.maxHealth);
                enemy.hasRecoveryContractUsed = true;
            }

            enemy.aiTimer++;

            // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ï¥ùÏùÑ ÏèòÎäîÏßÄ Í∞êÏßÄ
            const currentPlayerBulletCount = player.bullets.length;
            if (currentPlayerBulletCount > enemy.lastPlayerBulletCount) {
                // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ï¥ùÏùÑ ÏêàÏùå
                const dodgeProbability = 0.85; // 85% ÌôïÎ•†
                if (Math.random() < dodgeProbability) {
                    // 85% ÌôïÎ•†Î°ú ÌöåÌîº
                    enemy.isDodgingBullet = true;
                    // Ï¥ùÏïå Î∞©Ìñ•ÏóêÏÑú +90ÎèÑ ÎòêÎäî -90ÎèÑÎ°ú Ïù¥Îèô
                    const bulletAngle = player.angle; // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ïèú Ï¥ùÏïåÏùò Î∞©Ìñ•
                    const dodgeDirection = Math.random() < 0.5 ? 1 : -1; // 1 = +90ÎèÑ, -1 = -90ÎèÑ
                    const dodgeAngle = bulletAngle + (dodgeDirection * Math.PI / 2); // ¬±90ÎèÑ
                    const dodgeDistance = 30 + Math.random() * 30; // 30px~60px ÎûúÎç§
                    
                    // ¬±90ÎèÑ Î∞©Ìñ•ÏúºÎ°ú ÎûúÎç§ Í±∞Î¶¨ÎßåÌÅº Ïù¥ÎèôÌïú Î™©Ìëú ÏúÑÏπò Í≥ÑÏÇ∞
                    const targetX = enemy.x + Math.cos(dodgeAngle) * dodgeDistance;
                    const targetY = enemy.y + Math.sin(dodgeAngle) * dodgeDistance;
                    
                    // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
                    enemy.bulletDodgeTargetX = Math.max(
                        enemy.radius,
                        Math.min(canvas.width - enemy.radius, targetX)
                    );
                    enemy.bulletDodgeTargetY = Math.max(
                        enemy.radius,
                        Math.min(canvas.height - enemy.radius, targetY)
                    );
                    // ÌòÑÏû¨ ÏõÄÏßÅÏûÑ Î©àÏ∂îÍ∏∞
                    enemy.aiTimer = 0;
                }
            }
            enemy.lastPlayerBulletCount = currentPlayerBulletCount;

            // Ï¥ùÏïå ÌöåÌîº Ï§ëÏù¥Î©¥ Î™©Ìëú ÏúÑÏπòÎ°ú Ïù¥Îèô
            if (enemy.isDodgingBullet) {
                const dxToTarget = enemy.bulletDodgeTargetX - enemy.x;
                const dyToTarget = enemy.bulletDodgeTargetY - enemy.y;
                const distanceToTarget = Math.sqrt(dxToTarget * dxToTarget + dyToTarget * dyToTarget);
                
                if (distanceToTarget > 2) {
                    // Î™©Ìëú ÏúÑÏπòÎ°ú Ïù¥Îèô
                    enemy.aiDirection = Math.atan2(dyToTarget, dxToTarget);
                } else {
                    // Î™©Ìëú ÏúÑÏπòÏóê ÎèÑÎã¨ÌñàÏúºÎ©¥ ÌöåÌîº Ï¢ÖÎ£å
                    enemy.isDodgingBullet = false;
                    enemy.aiTimer = 0; // ÏÉàÎ°úÏö¥ Î∞©Ìñ• ÏÑ†ÌÉù
                }
            }

            // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô Î∞©Ìñ• Ï∂îÏ†Å (ÏòàÏ∏° Î∞úÏÇ¨Ïö©)
            if (enemy.lastPlayerX === 0 && enemy.lastPlayerY === 0) {
                enemy.lastPlayerX = player.x;
                enemy.lastPlayerY = player.y;
            }
            // ÌîåÎ†àÏù¥Ïñ¥ ÏÜçÎèÑ Í≥ÑÏÇ∞ (ÌîÑÎ†àÏûÑÎãπ Ïù¥ÎèôÎüâ)
            enemy.playerVelocity.x = player.x - enemy.lastPlayerX;
            enemy.playerVelocity.y = player.y - enemy.lastPlayerY;
            enemy.lastPlayerX = player.x;
            enemy.lastPlayerY = player.y;

            // ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ•ÏúºÎ°ú Í∞ÅÎèÑ ÏÑ§Ï†ï
            const dxToPlayer = player.x - enemy.x;
            const dyToPlayer = player.y - enemy.y;
            enemy.angle = Math.atan2(dyToPlayer, dxToPlayer);

            // ÌîåÎ†àÏù¥Ïñ¥ÏôÄÏùò Í±∞Î¶¨ Í≥ÑÏÇ∞
            const distance = Math.sqrt(dxToPlayer * dxToPlayer + dyToPlayer * dyToPlayer);
            const safeDistance = 500; // ÏïàÏ†Ñ Í±∞Î¶¨ (500px)

            const aiTimerThreshold = 30; // ÏõêÎûòÎåÄÎ°ú Î≥µÍµ¨ (30ÌîÑÎ†àÏûÑ = ÏïΩ 0.5Ï¥à)
            
            // Ï†Å Ïù¥Îèô Ìå®ÌÑ¥ Í∞úÏÑ† - ÏúÑÏïÑÎûòÎ°ú Îçî ÏûêÏ£º ÏõÄÏßÅÏûÑ (ÌöåÌîº Ï§ëÏù¥ ÏïÑÎãê ÎïåÎßå)
            if (!enemy.isDodgingBullet && enemy.aiTimer > aiTimerThreshold) {
                let targetAngle;
                
                // ÎûúÎç§ÌïòÍ≤å Îã§ÏñëÌïú ÏõÄÏßÅÏûÑ Ìå®ÌÑ¥ ÏÇ¨Ïö©
                const movementPattern = Math.random();
                
                if (movementPattern < 0.2) {
                    // 20% ÌôïÎ•†: ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ•ÏúºÎ°ú Ïù¥Îèô
                    targetAngle = Math.atan2(dyToPlayer, dxToPlayer);
                } else if (movementPattern < 0.35) {
                    // 15% ÌôïÎ•†: ÌîåÎ†àÏù¥Ïñ¥ Î∞òÎåÄ Î∞©Ìñ•ÏúºÎ°ú Ïù¥Îèô
                    targetAngle = Math.atan2(-dyToPlayer, -dxToPlayer);
                } else if (movementPattern < 0.45) {
                    // 10% ÌôïÎ•†: Ï∏°Î©¥ Ïù¥Îèô (ÏôºÏ™Ω/Ïò§Î•∏Ï™Ω)
                    targetAngle = Math.atan2(dyToPlayer, dxToPlayer) + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                } else if (movementPattern < 0.75) {
                    // 30% ÌôïÎ•†: ÏúÑÏïÑÎûò Ïù¥Îèô (ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ• Í∏∞Ï§Ä ÏúÑ/ÏïÑÎûò)
                    const playerAngle = Math.atan2(dyToPlayer, dxToPlayer);
                    targetAngle = playerAngle + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                } else {
                    // 25% ÌôïÎ•†: ÏôÑÏ†Ñ ÎûúÎç§ Î∞©Ìñ•
                    targetAngle = Math.random() * Math.PI * 2;
                }
                
                // Í±∞Î¶¨ Í∏∞Î∞ò Ï°∞Ï†ï (ÏÑ†ÌÉùÏ†Å)
                if (distance < safeDistance * 0.7) {
                    // ÎÑàÎ¨¥ Í∞ÄÍπåÏö∞Î©¥ Î©ÄÏñ¥ÏßÄÎäî Í≤ΩÌñ•
                    if (movementPattern < 0.5) {
                        targetAngle = Math.atan2(-dyToPlayer, -dxToPlayer);
                    }
                }
                
                // ÎûúÎç§ Í∞ÅÎèÑ Ï∂îÍ∞ÄÎ°ú Îçî ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏõÄÏßÅÏûÑ
                const randomAngle = (Math.random() - 0.5) * Math.PI * 0.5; // ¬±45ÎèÑ ÎûúÎç§
                enemy.aiDirection = targetAngle + randomAngle;
                enemy.aiTimer = 0;
            }

            // Î≤ΩÏóê ÎÑàÎ¨¥ Î∂ôÏúºÎ©¥ Îßµ Ï§ëÏïôÏúºÎ°ú Ïù¥Îèô (ÌöåÌîº Ï§ëÏù¥ ÏïÑÎãê ÎïåÎßå)
            if (!enemy.isDodgingBullet) {
                const mapWidth = gameState.mapBounds.maxX - gameState.mapBounds.minX;
                const mapHeight = gameState.mapBounds.maxY - gameState.mapBounds.minY;
                const wallThreshold = Math.min(mapWidth, mapHeight) * 0.05; // Îßµ ÌÅ¨Í∏∞Ïùò 5% Ïù¥ÎÇ¥
                
                const distToLeftWall = enemy.x - (gameState.mapBounds.minX + enemy.radius);
                const distToRightWall = (gameState.mapBounds.maxX - enemy.radius) - enemy.x;
                const distToTopWall = enemy.y - (gameState.mapBounds.minY + enemy.radius);
                const distToBottomWall = (gameState.mapBounds.maxY - enemy.radius) - enemy.y;
                
                // Î≤ΩÏóê ÎÑàÎ¨¥ Î∂ôÏóàÎäîÏßÄ ÌôïÏù∏
                if (distToLeftWall < wallThreshold || distToRightWall < wallThreshold ||
                    distToTopWall < wallThreshold || distToBottomWall < wallThreshold) {
                    // Îßµ Ï§ëÏïôÏúºÎ°ú Ïù¥Îèô
                    const centerX = (gameState.mapBounds.minX + gameState.mapBounds.maxX) / 2;
                    const centerY = (gameState.mapBounds.minY + gameState.mapBounds.maxY) / 2;
                    const dxToCenter = centerX - enemy.x;
                    const dyToCenter = centerY - enemy.y;
                    enemy.aiDirection = Math.atan2(dyToCenter, dxToCenter);
                    enemy.aiTimer = 0;
                }
            }
            
            // Í≤ΩÍ≥ÑÏóê ÎãøÏúºÎ©¥ Î∞©Ìñ• Î≥ÄÍ≤Ω (Îßµ Í≤ΩÍ≥Ñ ÏÇ¨Ïö©)
            if (enemy.x < gameState.mapBounds.minX + enemy.radius || enemy.x > gameState.mapBounds.maxX - enemy.radius ||
                enemy.y < gameState.mapBounds.minY + enemy.radius || enemy.y > gameState.mapBounds.maxY - enemy.radius) {
                enemy.aiDirection = Math.random() * Math.PI * 2;
                enemy.aiTimer = 0;
            }

            // Ïù¥Îèô Í≥ÑÏÇ∞
            let dx = Math.cos(enemy.aiDirection) * currentSpeed;
            let dy = Math.sin(enemy.aiDirection) * currentSpeed;
            
            // Î¨¥ÎπôÏõåÌÅ¨Î™®Îìú: 5Ï¥àÎßàÎã§ Î∞îÎÄåÎäî Î∞©Ìñ•ÏúºÎ°ú Ï¥àÎãπ 25px Ïù¥Îèô Ï∂îÍ∞Ä (ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Í∞ôÏùÄ Î∞©Ìñ•)
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'movingWork') {
                // ÏúÑ, ÏïÑÎûò, Ï¢å, Ïö∞ 4Î∞©Ìñ• Ï§ë 1Í∞ú ÏÑ†ÌÉù (ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Í∞ôÏùÄ Î∞©Ìñ• ÏÇ¨Ïö©)
                if (!gameState.movingWorkDirection) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // Ïö∞, ÏïÑÎûò, Ï¢å, ÏúÑ
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // 5Ï¥àÎßàÎã§ Î∞©Ìñ• Î≥ÄÍ≤Ω
                if (now - gameState.movingWorkLastChange >= 5000) {
                    const directions = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; // Ïö∞, ÏïÑÎûò, Ï¢å, ÏúÑ
                    gameState.movingWorkDirection = directions[Math.floor(Math.random() * 4)];
                    gameState.movingWorkLastChange = now;
                }
                
                // Ï¥àÎãπ 25px Ïù¥Îèô (Î∂ÄÎìúÎüΩÍ≤å) - currentSpeedÎ•º Í≥±ÌïòÏßÄ ÏïäÍ≥† ÏßÅÏ†ë Ï∂îÍ∞Ä
                const moveSpeed = 25 / 60; // 60fps Í∏∞Ï§Ä
                const moveDx = Math.cos(gameState.movingWorkDirection) * moveSpeed * normalizedDelta;
                const moveDy = Math.sin(gameState.movingWorkDirection) * moveSpeed * normalizedDelta;
                
                // AI Ïù¥ÎèôÍ≥º Î¨¥ÎπôÏõåÌÅ¨ Ïù¥Îèô Ìï©ÏÇ∞
                dx += moveDx;
                dy += moveDy;
            }

            // ÎπôÌåêÎ™®Îìú: ÎØ∏ÎÅÑÎü¨Ïßê Ìö®Í≥º
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'ice') {
                // ÏÜçÎèÑ Î≤°ÌÑ∞ Ï¥àÍ∏∞Ìôî
                if (enemy.velocityX === undefined) enemy.velocityX = 0;
                if (enemy.velocityY === undefined) enemy.velocityY = 0;
                
                // ÏûÖÎ†•Ïù¥ ÏûàÏúºÎ©¥ ÏÜçÎèÑ Î≤°ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (Ìï≠ÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏)
                enemy.velocityX = dx;
                enemy.velocityY = dy;
                
                // ÎßàÏ∞∞ Ï†ÅÏö© (ÏÜçÎèÑ Í∞êÏÜå) - ÎπôÌåêÎ™®ÎìúÏóêÏÑúÎäî Ìõ®Ïî¨ Îçî Ïûò ÎØ∏ÎÅÑÎü¨Ïßê
                enemy.velocityX *= 0.995;
                enemy.velocityY *= 0.995;
                
                // ÏÜçÎèÑÍ∞Ä Îß§Ïö∞ ÏûëÏúºÎ©¥ Ï†ïÏßÄ
                if (Math.abs(enemy.velocityX) < 0.01) enemy.velocityX = 0;
                if (Math.abs(enemy.velocityY) < 0.01) enemy.velocityY = 0;
                
                // ÏÜçÎèÑ Î≤°ÌÑ∞Î°ú Ïù¥Îèô (deltaTime Ï†ïÍ∑úÌôî Ï†ÅÏö©)
                let newX = enemy.x + enemy.velocityX * normalizedDelta;
                let newY = enemy.y + enemy.velocityY * normalizedDelta;
                
                // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ (Îßµ Í≤ΩÍ≥Ñ ÏÇ¨Ïö©) - Í≤ΩÍ≥ÑÎ•º ÎÑòÏñ¥Í∞ÄÎ©¥ Í∞ïÏ†úÎ°ú Í≤ΩÍ≥Ñ ÏïàÏúºÎ°ú Ï†úÌïú
                newX = Math.max(gameState.mapBounds.minX + enemy.radius, Math.min(gameState.mapBounds.maxX - enemy.radius, newX));
                newY = Math.max(gameState.mapBounds.minY + enemy.radius, Math.min(gameState.mapBounds.maxY - enemy.radius, newY));
                
                // Í≤ΩÍ≥ÑÏóê ÎãøÏúºÎ©¥ ÏÜçÎèÑ Î∞òÏÇ¨
                if (newX !== enemy.x + enemy.velocityX * normalizedDelta) enemy.velocityX *= -0.5;
                if (newY !== enemy.y + enemy.velocityY * normalizedDelta) enemy.velocityY *= -0.5;
                
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïû•Ïï†Î¨º Ï∂©Îèå Ï≤¥ÌÅ¨
                if (gameState.isMultiplayer && gameState.obstacles) {
                    const testEnemy = { x: newX, y: newY, radius: enemy.radius };
                    for (let i = 0; i < gameState.obstacles.length; i++) {
                        if (checkCharacterObstacleCollision(testEnemy, gameState.obstacles[i])) {
                            // Ï∂©Îèå Î∞úÏÉù: Ïù¥Ï†Ñ ÏúÑÏπò Ïú†ÏßÄ
                            newX = enemy.x;
                            newY = enemy.y;
                            break;
                        }
                    }
                }
                
                enemy.x = newX;
                enemy.y = newY;
            } else {
                // ÏùºÎ∞ò Ïù¥Îèô (deltaTime Ï†ïÍ∑úÌôî Ï†ÅÏö©)
                let newX = Math.max(gameState.mapBounds.minX + enemy.radius, Math.min(gameState.mapBounds.maxX - enemy.radius, enemy.x + dx * normalizedDelta));
                let newY = Math.max(gameState.mapBounds.minY + enemy.radius, Math.min(gameState.mapBounds.maxY - enemy.radius, enemy.y + dy * normalizedDelta));
                
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïû•Ïï†Î¨º Ï∂©Îèå Ï≤¥ÌÅ¨
                if (gameState.isMultiplayer && gameState.obstacles) {
                    const testEnemy = { x: newX, y: newY, radius: enemy.radius };
                    for (let i = 0; i < gameState.obstacles.length; i++) {
                        if (checkCharacterObstacleCollision(testEnemy, gameState.obstacles[i])) {
                            // Ï∂©Îèå Î∞úÏÉù: Ïù¥Ï†Ñ ÏúÑÏπò Ïú†ÏßÄ
                            newX = enemy.x;
                            newY = enemy.y;
                            break;
                        }
                    }
                }
                
                enemy.x = newX;
                enemy.y = newY;
                // ÎπôÌåêÎ™®ÎìúÍ∞Ä ÏïÑÎãê ÎïåÎäî ÏÜçÎèÑ Î≤°ÌÑ∞ Ï¥àÍ∏∞Ìôî
                enemy.velocityX = 0;
                enemy.velocityY = 0;
            }
            
            // Í∞ÅÎèÑ Í≥ÑÏÇ∞ (ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ•)
            enemy.angle = Math.atan2(dyToPlayer, dxToPlayer);


            // Í∑ºÏ†ëÏ†ÑÎ™®Îìú: ÌîåÎ†àÏù¥Ïñ¥Í∞Ä 500px ÏïàÏóê Îì§Ïñ¥ÏôîÏùÑ ÎïåÎßå Î∞úÏÇ¨
            const isMeleeMode = gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'melee';
            const maxDistance = isMeleeMode ? 500 : Math.max(canvas.width, canvas.height) * 0.8; // Í∑ºÏ†ëÏ†ÑÎ™®ÎìúÎ©¥ 500px, ÏïÑÎãàÎ©¥ ÌôîÎ©¥ ÌÅ¨Í∏∞Ïùò 80%
            const shootProbability = isMeleeMode ? 0.6 : 0.3; // Í∑ºÏ†ëÏ†ÑÎ™®ÎìúÎ©¥ Îçî Ï†ÅÍ∑πÏ†ÅÏúºÎ°ú Î∞úÏÇ¨ (60%)
            const nowForShoot = Date.now();
            // Ïø®ÌÉÄÏûÑ Ï≤¥ÌÅ¨ Ï∂îÍ∞Ä (Í∑ºÏ†ëÏ†ÑÎ™®ÎìúÎ©¥ Ïø®ÌÉÄÏûÑ Í∞êÏÜå)
            const shootCooldown = isMeleeMode ? enemy.shootCooldown * 0.7 : enemy.shootCooldown; // Í∑ºÏ†ëÏ†ÑÎ™®ÎìúÎ©¥ Ïø®ÌÉÄÏûÑ 30% Í∞êÏÜå
            const canShoot = !enemy.lastShot || (nowForShoot - enemy.lastShot >= shootCooldown);
            if (distance < maxDistance && enemy.ammo > 0 && !enemy.isReloading && canShoot && Math.random() < shootProbability) {
                // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÏõÄÏßÅÏù¥Í≥† ÏûàÎäîÏßÄ ÌôïÏù∏
                const playerSpeed = Math.sqrt(enemy.playerVelocity.x * enemy.playerVelocity.x + enemy.playerVelocity.y * enemy.playerVelocity.y);
                const isPlayerMoving = playerSpeed > 0.1; // 0.1px Ïù¥ÏÉÅ ÏõÄÏßÅÏù¥Î©¥ ÏõÄÏßÅÏù¥Îäî Í≤ÉÏúºÎ°ú Í∞ÑÏ£º
                
                const originalAngle = enemy.angle;
                const currentAngle = Math.atan2(dyToPlayer, dxToPlayer);
                
                // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Î©àÏ∂∞ÏûàÏúºÎ©¥ 100% ÌòÑÏû¨ ÏúÑÏπòÎ°ú Î∞úÏÇ¨
                if (!isPlayerMoving) {
                    // Î©àÏ∂∞ÏûàÏùÑ Îïå: Ìï≠ÏÉÅ Ï†ïÌôïÌûà ÌòÑÏû¨ ÏúÑÏπò
                    enemy.angle = currentAngle;
                } else {
                    // ÏõÄÏßÅÏùº Îïå: 80% ÌôïÎ•†Î°ú Ïù¥Îèô Î∞©Ìñ•ÏúºÎ°ú Í±∞Î¶¨Ïóê Îî∞Îùº ÏòàÏ∏°, 20% ÌòÑÏû¨ ÏúÑÏπò
                    if (Math.random() < 0.8) {
                        // 80% ÌôïÎ•†: ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô Î∞©Ìñ•ÏúºÎ°ú Í±∞Î¶¨Ïóê Îî∞Îùº ÏòàÏ∏° Í±∞Î¶¨ Ï°∞Ï†ï
                        let predictedDistance;
                        if (distance <= 300) {
                            // 300px Ïù¥ÎÇ¥: 15px~25px ÏÇ¨Ïù¥ ÎûúÎç§
                            predictedDistance = 15 + Math.random() * (25 - 15);
                        } else if (distance <= 750) {
                            // 750px Ïù¥ÎÇ¥: 50px~75px ÏÇ¨Ïù¥ ÎûúÎç§
                            predictedDistance = 50 + Math.random() * (75 - 50);
                    } else {
                            // 750px Ïù¥ÏÉÅ: 150px (Í∏∞Î≥∏Í∞í)
                            predictedDistance = 150;
                        }
                        
                        // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô Î∞©Ìñ• Í≥ÑÏÇ∞
                        const playerMoveAngle = Math.atan2(enemy.playerVelocity.y, enemy.playerVelocity.x);
                        // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπòÏóêÏÑú Ïù¥Îèô Î∞©Ìñ•ÏúºÎ°ú Í≥ÑÏÇ∞Îêú Í±∞Î¶¨ÎßåÌÅº Ïïû ÏßÄÏ†ê Í≥ÑÏÇ∞
                        const predictedX = player.x + Math.cos(playerMoveAngle) * predictedDistance;
                        const predictedY = player.y + Math.sin(playerMoveAngle) * predictedDistance;
                        // ÏòàÏ∏° ÏßÄÏ†êÏúºÎ°ú Í∞ÅÎèÑ ÏÑ§Ï†ï
                        const dxToPredicted = predictedX - enemy.x;
                        const dyToPredicted = predictedY - enemy.y;
                        enemy.angle = Math.atan2(dyToPredicted, dxToPredicted);
                    } else {
                        // 20% ÌôïÎ•†: ÌòÑÏû¨ ÏúÑÏπòÎ°ú Î∞úÏÇ¨
                        enemy.angle = currentAngle;
                    }
                }
                
                shoot(enemy);
                enemy.lastShot = nowForShoot; // Î∞úÏÇ¨ ÏãúÍ∞Ñ Í∏∞Î°ù
                // Î∞úÏÇ¨ ÌõÑ Í∞ÅÎèÑ Î≥µÏõê (Ïù¥Îèô Î∞©Ìñ• Ïú†ÏßÄ)
                enemy.angle = originalAngle;
            }

            // ÏûêÎèô Ïû¨Ïû•Ï†Ñ
            if (enemy.ammo === 0 && !enemy.isReloading) {
                reload(enemy);
            }
        }

        // Ï¥ùÏïå ÏóÖÎç∞Ïù¥Ìä∏
        function updateBullets(character, deltaTime = 16.67) {
            for (let i = character.bullets.length - 1; i >= 0; i--) {
                const bullet = character.bullets[i];
                
                // ÏãúÍ∞ÑÏ†ïÏßÄ: ÏÉÅÎåÄÏùò Ï¥ùÏïåÏùÄ Î©àÏ∂§ (ÏÇ¨Ïö©ÏûêÎäî ÏòÅÌñ• ÏóÜÏùå)
                const target = character === player ? enemy : player;
                if (target.timeStopActive && character !== target) {
                    continue; // Ï¥ùÏïå ÏóÖÎç∞Ïù¥Ìä∏ Ïïà Ìï® (Î©àÏ∂§)
                }
                
                // ÏãúÍ∞ÑÏû•Îßâ: Ï†ÅÏùò Ï¥ùÏïåÏù¥ ÌîåÎ†àÏù¥Ïñ¥Ïùò ÏãúÍ∞ÑÏû•Îßâ ÏïàÏóê ÏûàÏúºÎ©¥ ÏÜçÎèÑ 35% ÎëîÌôî
                if (character === enemy && player.hasTimeBarrier) {
                    const dx = bullet.x - player.x;
                    const dy = bullet.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= player.timeBarrierRadius) {
                        // ÏÜçÎèÑ 65%Î°ú ÏÑ§Ï†ï (35% Í∞êÏÜå) - ÌôòÍ∞ÅÏù¥ ÏûàÏúºÎ©¥ ÌôòÍ∞Å ÏÜçÎèÑ Í∏∞Ï§ÄÏúºÎ°ú
                        const baseSpeedForBarrier = bullet.hallucinationSpeed !== undefined ? bullet.hallucinationSpeed : (bullet.baseSpeed || bullet.speed);
                        bullet.speed = baseSpeedForBarrier * 0.65;
                        bullet.isInTimeBarrier = true;
                    } else {
                        // ÏãúÍ∞ÑÏû•Îßâ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ ÏõêÎûò ÏÜçÎèÑÎ°ú Î≥µÏõê (ÌôòÍ∞ÅÏù¥ ÏûàÏúºÎ©¥ ÌôòÍ∞Å ÏÜçÎèÑ)
                        bullet.isInTimeBarrier = false;
                        if (bullet.hallucinationSpeed !== undefined) {
                            bullet.speed = bullet.hallucinationSpeed;
                        } else {
                            bullet.speed = bullet.baseSpeed || bullet.speed;
                        }
                    }
                }
                // ÏãúÍ∞ÑÏû•Îßâ: ÌîåÎ†àÏù¥Ïñ¥Ïùò Ï¥ùÏïåÏù¥ Ï†ÅÏùò ÏãúÍ∞ÑÏû•Îßâ ÏïàÏóê ÏûàÏúºÎ©¥ ÏÜçÎèÑ 35% ÎëîÌôî
                if (character === player && enemy.hasTimeBarrier) {
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= enemy.timeBarrierRadius) {
                        // ÏÜçÎèÑ 65%Î°ú ÏÑ§Ï†ï (35% Í∞êÏÜå) - ÌôòÍ∞ÅÏù¥ ÏûàÏúºÎ©¥ ÌôòÍ∞Å ÏÜçÎèÑ Í∏∞Ï§ÄÏúºÎ°ú
                        const baseSpeedForBarrier = bullet.hallucinationSpeed !== undefined ? bullet.hallucinationSpeed : (bullet.baseSpeed || bullet.speed);
                        bullet.speed = baseSpeedForBarrier * 0.65;
                        bullet.isInTimeBarrier = true;
                    } else {
                        // ÏãúÍ∞ÑÏû•Îßâ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ ÏõêÎûò ÏÜçÎèÑÎ°ú Î≥µÏõê (ÌôòÍ∞ÅÏù¥ ÏûàÏúºÎ©¥ ÌôòÍ∞Å ÏÜçÎèÑ)
                        bullet.isInTimeBarrier = false;
                        if (bullet.hallucinationSpeed !== undefined) {
                            bullet.speed = bullet.hallucinationSpeed;
                        } else {
                            bullet.speed = bullet.baseSpeed || bullet.speed;
                        }
                    }
                }
                
                // Í∑ºÏ†ëÏ†ÑÎ™®Îìú: Ï¥ùÏïåÏù¥ 500px Ïù¥ÎèôÌñàÎäîÏßÄ Ï≤¥ÌÅ¨
                if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'melee') {
                    if (!bullet.isStopped) {
                        // ÌòÑÏû¨ ÏúÑÏπòÏóêÏÑú Í±∞Î¶¨ Í≥ÑÏÇ∞
                        const currentDistance = Math.sqrt(
                            Math.pow(bullet.x - bullet.startX, 2) + 
                            Math.pow(bullet.y - bullet.startY, 2)
                        );
                        
                        if (currentDistance >= 500) {
                            // Ï¥ùÏïåÏù¥ 500pxÎ•º ÎÑòÏóàÏúºÎ©¥ Ï†ïÌôïÌûà 500px ÏúÑÏπòÎ°ú Ï°∞Ï†ï
                            const angle = Math.atan2(bullet.y - bullet.startY, bullet.x - bullet.startX);
                            bullet.x = bullet.startX + Math.cos(angle) * 500;
                            bullet.y = bullet.startY + Math.sin(angle) * 500;
                            
                            // Ï¥ùÏïå Î©àÏ∂îÍ∏∞
                            bullet.isStopped = true;
                            bullet.stopTime = Date.now();
                            bullet.speed = 0; // ÏÜçÎèÑ 0ÏúºÎ°ú ÏÑ§Ï†ï
                        } else {
                            // ÏïÑÏßÅ 500px ÎØ∏ÎßåÏù¥Î©¥ ÏóÖÎç∞Ïù¥Ìä∏
                            bullet.update(deltaTime);
                            
                            // update ÌõÑ Îã§Ïãú Ï≤¥ÌÅ¨ (500pxÎ•º ÎÑòÏóàÎäîÏßÄ)
                            const newDistance = Math.sqrt(
                                Math.pow(bullet.x - bullet.startX, 2) + 
                                Math.pow(bullet.y - bullet.startY, 2)
                            );
                            if (newDistance >= 500) {
                                // Ï†ïÌôïÌûà 500px ÏúÑÏπòÎ°ú Ï°∞Ï†ï
                                const angle = Math.atan2(bullet.y - bullet.startY, bullet.x - bullet.startX);
                                bullet.x = bullet.startX + Math.cos(angle) * 500;
                                bullet.y = bullet.startY + Math.sin(angle) * 500;
                                
                                bullet.isStopped = true;
                                bullet.stopTime = Date.now();
                                bullet.speed = 0;
                            }
                        }
                    } else {
                        // Î©àÏ∂ò Ï¥ùÏïå: 0.7Ï¥à ÌõÑ ÌéòÏù¥Îìú ÏïÑÏõÉ ÏãúÏûë, 1Ï¥à ÌõÑ Ï†úÍ±∞
                        const now = Date.now();
                        const elapsed = now - bullet.stopTime;
                        
                        if (elapsed >= 700 && bullet.fadeStartTime === 0) {
                            // ÌéòÏù¥Îìú ÏïÑÏõÉ ÏãúÏûë
                            bullet.fadeStartTime = now;
                        }
                        
                        if (elapsed >= 1000) {
                            character.bullets.splice(i, 1);
                            continue;
                        }
                    }
                } else {
                    // Í∑ºÏ†ëÏ†ÑÎ™®ÎìúÍ∞Ä ÏïÑÎãàÎ©¥ ÏùºÎ∞ò ÏóÖÎç∞Ïù¥Ìä∏
                    bullet.update(deltaTime);
                }

                // Î∂ÄÎß§Îûë: ÎêòÎèåÏïÑÏò§Îäî Ï¥ùÏïåÏù¥ ÌîåÎ†àÏù¥Ïñ¥ÏóêÍ≤å ÎãøÏúºÎ©¥ ÏÇ≠Ï†ú
                if (bullet.hasBoomerang && bullet.isReturning && bullet.owner) {
                    if (checkCollision(bullet, bullet.owner)) {
                        character.bullets.splice(i, 1);
                        continue;
                    }
                }
                
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïû•Ïï†Î¨º Ï∂©Îèå Ï≤¥ÌÅ¨
                if (gameState.isMultiplayer && gameState.obstacles && !bullet.isStopped) {
                    for (let j = 0; j < gameState.obstacles.length; j++) {
                        const obstacle = gameState.obstacles[j];
                        if (checkBulletObstacleCollision(bullet, obstacle)) {
                            // Ìè≠Î∞úÌÉÑ: Ïû•Ïï†Î¨ºÏóê ÎãøÏïòÏùÑ ÎïåÎèÑ Ìè≠Î∞ú
                            if (bullet.owner && bullet.owner.hasExplosiveBullet) {
                                const explosionRadius = 125;
                                const explosionDamage = 0.5;
                                const explosionX = bullet.x;
                                const explosionY = bullet.y;
                                
                                // Ìè≠Î∞ú Ïù¥ÌéôÌä∏ Ï∂îÍ∞Ä
                                if (!gameState.explosions) gameState.explosions = [];
                                gameState.explosions.push({
                                    x: explosionX,
                                    y: explosionY,
                                    radius: explosionRadius,
                                    startTime: Date.now(),
                                    duration: 300
                                });
                                
                                // Ìè≠Î∞ú Î≤îÏúÑ ÎÇ¥Ïùò ÌÉÄÍ≤üÏóêÍ≤å Îç∞ÎØ∏ÏßÄ
                                const target = character === player ? enemy : player;
                                const distToTarget = Math.sqrt(
                                    Math.pow(explosionX - target.x, 2) + 
                                    Math.pow(explosionY - target.y, 2)
                                );
                                if (distToTarget <= explosionRadius) {
                                    target.health -= explosionDamage;
                                    target.health = roundToMaxTwoDecimals(target.health);
                                }
                            }
                            
                            // Ï¥ùÏïå ÏÇ≠Ï†ú
                            character.bullets.splice(i, 1);
                            i--;
                            continue;
                        }
                    }
                }
                
                // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ (Î©àÏ∂ò Ï¥ùÏïåÏùÄ Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Ïïà Ìï®, Î∂ÄÎß§Îûë Ï¥ùÏïåÏùÄ Îßµ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎèÑ ÎêòÎèåÏïÑÏò§ÎØÄÎ°ú Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Ïïà Ìï®)
                if (!bullet.isStopped && !bullet.hasBoomerang && bullet.isOutOfBounds()) {
                    // Ìè≠Î∞úÌÉÑ: Î≤ΩÏóê ÎãøÏïòÏùÑ Îïå Ìè≠Î∞ú
                    if (bullet.owner && bullet.owner.hasExplosiveBullet) {
                        const explosionRadius = 125;
                        const explosionDamage = 0.5;
                        const explosionX = bullet.x;
                        const explosionY = bullet.y;
                        
                        // Ìè≠Î∞ú Ïù¥ÌéôÌä∏ Ï∂îÍ∞Ä
                        if (!gameState.explosions) gameState.explosions = [];
                        gameState.explosions.push({
                            x: explosionX,
                            y: explosionY,
                            radius: explosionRadius,
                            startTime: Date.now(),
                            duration: 300
                        });
                        
                        // Ìè≠Î∞ú Î≤îÏúÑ ÎÇ¥Ïùò Ï†ÅÏóêÍ≤å Îç∞ÎØ∏ÏßÄ
                        const target = bullet.owner === player ? enemy : player;
                        const dx = target.x - explosionX;
                        const dy = target.y - explosionY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance <= explosionRadius) {
                            // Îç∞ÎØ∏ÏßÄ Ï†ÅÏö©
                            target.health = Math.max(0, target.health - explosionDamage);
                            target.displayHealth = Math.max(0, target.displayHealth - explosionDamage);
                            
                            // Îç∞ÎØ∏ÏßÄ Ïà´Ïûê ÌëúÏãú (Ï£ºÌô©ÏÉâ)
                            target.damageNumbers.push({
                                value: explosionDamage,
                                x: target.x,
                                y: target.y - target.radius - 20,
                                startTime: Date.now(),
                                color: '#ff8800'
                            });
                            
                            // ÌîºÍ≤© Ïù¥ÌéôÌä∏
                            addHitEffect(target, explosionX, explosionY);
                        }
                    }
                    
                    character.bullets.splice(i, 1);
                    continue;
                }

                // Ï∂©Îèå Ï≤¥ÌÅ¨ (targetÏùÄ ÏúÑÏóêÏÑú Ïù¥ÎØ∏ ÏÑ†Ïñ∏Îê®)
                if (checkCollision(bullet, target)) {
                    // Í≤åÏûÑÏù¥ ÏùºÏãúÏ†ïÏßÄÎêú ÏÉÅÌÉúÎ©¥ Îç∞ÎØ∏ÏßÄ Î¨¥Ïãú (Ï¶ùÍ∞ï ÏÑ†ÌÉù ÏãúÍ∞Ñ ÎèôÏïà)
                    if (gameState.isPaused) {
                        character.bullets.splice(i, 1);
                        continue;
                    }
                    // Î∞òÏÇ¨ Î≥¥Ìò∏Îßâ: Ï†ÅÏùò Ï¥ùÏïåÏùÑ Î∞òÏÇ¨
                    if (target.reflectActive && character !== target) {
                        // Ï¥ùÏïå Î∞©Ìñ•ÏùÑ Î∞òÎåÄÎ°ú (ÏÉÅÎåÄ Ï™ΩÏúºÎ°ú)
                        const dxToTarget = character.x - target.x;
                        const dyToTarget = character.y - target.y;
                        bullet.angle = Math.atan2(dyToTarget, dxToTarget);
                        bullet.owner = target; // Ï¥ùÏïå ÏÜåÏú†ÏûêÎ•º Î≥ÄÍ≤Ω
                        // Ï¥ùÏïåÏùÑ targetÏùò bullets Î∞∞Ïó¥Î°ú Ïù¥Îèô
                        character.bullets.splice(i, 1);
                        target.bullets.push(bullet);
                        continue; // Îç∞ÎØ∏ÏßÄ Ï†ÅÏö© Ïïà Ìï®
                    }
                    // Î∞òÏÇ¨ Î≥¥Ìò∏Îßâ: Ï†ÅÏùò Ï¥ùÏïåÏùÑ Î∞òÏÇ¨
                    if (target.reflectActive && character !== target) {
                        // Ï¥ùÏïå Î∞©Ìñ•ÏùÑ Î∞òÎåÄÎ°ú (ÏÉÅÎåÄ Ï™ΩÏúºÎ°ú)
                        const dxToTarget = character.x - target.x;
                        const dyToTarget = character.y - target.y;
                        bullet.angle = Math.atan2(dyToTarget, dxToTarget);
                        bullet.owner = target; // Ï¥ùÏïå ÏÜåÏú†ÏûêÎ•º Î≥ÄÍ≤Ω
                        // Ï¥ùÏïåÏùÑ targetÏùò bullets Î∞∞Ïó¥Î°ú Ïù¥Îèô
                        character.bullets.splice(i, 1);
                        target.bullets.push(bullet);
                        continue; // Îç∞ÎØ∏ÏßÄ Ï†ÅÏö© Ïïà Ìï®
                    }
                    
                    // Íµ¨Î•¥Îäî Ï§ëÏù¥Í±∞ÎÇò Î¨¥Ï†Å ÏÉÅÌÉúÎ©¥ Îç∞ÎØ∏ÏßÄ Î¨¥Ïãú
                    if (target.isDodging || target.isInvincible || target.isReviving) {
                        character.bullets.splice(i, 1);
                        continue;
                    }

                    // Î∞©Ïñ¥Îßâ: Îç∞ÎØ∏ÏßÄ 1Ìöå Î¨¥Ïãú (Ïø®ÌÉÄÏûÑ 7.5Ï¥à)
                    if (target.hasShield && target.shieldReady) {
                        target.shieldReady = false;
                        target.shieldCooldown = Date.now() + 7500; // 7.5Ï¥à Ïø®ÌÉÄÏûÑ
                        character.bullets.splice(i, 1);
                        // "Î¨¥Ïãú" ÌÖçÏä§Ìä∏ ÌëúÏãú
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isShield: true, // Î∞©Ïñ¥Îßâ Î¨¥Ïãú Ïó¨Î∂Ä
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: 0
                        });
                        continue; // Îç∞ÎØ∏ÏßÄ Ï†ÅÏö© Ïïà Ìï®
                    }

                    // Ïú†Î†π Ï¶ùÍ∞ï: ÌôïÎ•† Ï§ëÏ≤© (25% * count)
                    const ghostCount = target.ghostCount || 1;
                    if (target.hasGhost && Math.random() < (0.25 * ghostCount)) {
                        // "Î¨¥Ïãú" ÌÖçÏä§Ìä∏ ÌëúÏãú
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isGhost: true, // Ïú†Î†π Î¨¥Ïãú Ïó¨Î∂Ä
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: 0
                        });
                        // Ï¥ùÏïå Ï†úÍ±∞ÌïòÍ≥† Îç∞ÎØ∏ÏßÄ Ï†ÅÏö© Ïïà Ìï®
                        character.bullets.splice(i, 1);
                        i--; // Ïù∏Îç±Ïä§ Ï°∞Ï†ï
                        continue; // Îç∞ÎØ∏ÏßÄ Ï†ÅÏö© Ïïà Ìï®
                    }

                    // ÌÅ¨Î¶¨Ìã∞Ïª¨ Í≥ÑÏÇ∞ (ÌôïÎ•† Ï§ëÏ≤©: 25% * count)
                    let finalDamage = bullet.damage;
                    let isCritical = false;
                    const criticalCount = character.criticalCount || 1;
                    if (character.hasCritical && Math.random() < (0.25 * criticalCount)) {
                        finalDamage *= 2;
                        isCritical = true;
                    }
                    
                    // Ï∑®ÏïΩ ÏÉÅÌÉú: Îã§Ïùå Îç∞ÎØ∏ÏßÄ 1.5Î∞∞
                    if (target.isVulnerable && !target.vulnerabilityUsed) {
                        finalDamage *= 1.5;
                        target.vulnerabilityUsed = true; // Ï∑®ÏïΩ ÏÇ¨Ïö©Îê®
                        target.isVulnerable = false; // Ï∑®ÏïΩ ÏÉÅÌÉú Ìï¥Ï†ú
                    }

                    // Í±∞Ï†êÌôïÎ≥¥: Îç∞ÎØ∏ÏßÄ *0.5
                    if (target.hasFortify && target.isFortified) {
                        finalDamage *= 0.5;
                    }

                    // Í≥ºÏó¥: Ïó∞ÏÜç ÌûàÌä∏ Ïãú Îç∞ÎØ∏ÏßÄ Î∞∞Ïú® Ï†ÅÏö©
                    if (character.hasOverheat) {
                        const now = Date.now();
                        // 2Ï¥à Ïù¥ÎÇ¥Ïóê ÌûàÌä∏ÌïòÎ©¥ Ïó∞ÏÜç ÌûàÌä∏Î°ú Í∞ÑÏ£º
                        if (now - character.lastHitTime < 2000) {
                            character.overheatHitCount++;
                        } else {
                            // 2Ï¥à Ïù¥ÏÉÅ ÏßÄÎÇòÎ©¥ Ï¥àÍ∏∞Ìôî
                            character.overheatHitCount = 0;
                        }
                        // Îç∞ÎØ∏ÏßÄ Î∞∞Ïú®: 1 + hitCount * 0.5 (Ï≤´Î≤àÏß∏Îäî 1Î∞∞, ÎëêÎ≤àÏß∏Îäî 1.5Î∞∞, ÏÑ∏Î≤àÏß∏Îäî 2Î∞∞...)
                        finalDamage *= (1 + character.overheatHitCount * 0.5);
                        character.lastHitTime = now;
                    }

                    // ÏïΩÌôî: ÏÉÅÎåÄÏóêÍ≤å ÏïΩÌôî ÏÉÅÌÉú Î∂ÄÏó¨ (3Ï¥à ÎèôÏïà Î™®Îì† Í≥µÍ≤© Îç∞ÎØ∏ÏßÄ -0.25, Ï§ëÏ≤© ÏïàÎê®)
                    // ÏïΩÌôî: ÏÉÅÎåÄÏóêÍ≤å Ï¥ùÏïåÏùÑ ÎßûÏ∂ú Ïãú 3Ï¥àÎèôÏïà ÏÉÅÎåÄ Îç∞ÎØ∏ÏßÄ -0.25 (Ï§ëÏ≤©)
                    if (character.hasWeaken && !target.isWeakened) {
                        target.isWeakened = true;
                        target.weakenEndTime = Date.now() + 3000;
                    }

                    // ÏÜåÏàòÏ†ê 3ÏûêÎ¶¨ Ïù¥ÏÉÅÏù¥Î©¥ 2ÏûêÎ¶¨Î°ú Î∞òÏò¨Î¶º, 1~2ÏûêÎ¶¨Îäî Ïú†ÏßÄ
                    finalDamage = roundToMaxTwoDecimals(finalDamage);
                    target.health -= finalDamage;
                    target.health = roundToMaxTwoDecimals(target.health);
                    
                    // ÏÇ¨Ïã† Ï¶ùÍ∞ï: Ï†ÅÏóêÍ≤å Ï¥ùÏïåÏùÑ ÎßûÏ∂ú Ïãú 0.4Ï¥àÍ∞Ñ ÏùÄÏã† + Ïù¥ÎèôÏÜçÎèÑ 15%
                    if (character.hasReaper && character === player) {
                        const now = Date.now();
                        player.isInvisible = true;
                        player.invisibilityEndTime = now + 400; // 0.4Ï¥à
                    } else if (character.hasReaper && character === enemy) {
                        const now = Date.now();
                        enemy.isInvisible = true;
                        enemy.invisibilityEndTime = now + 400; // 0.4Ï¥à
                    }
                    
                    // ÌîºÍ≤© Ïù¥ÌéôÌä∏ ÏÉùÏÑ± (ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ï†ÅÏùÑ ÎßûÏ∑ÑÏùÑ Îïå)
                    if (character === player) {
                        const selectedHitEffect = localStorage.getItem('selectedHitEffectItem');
                        if (selectedHitEffect) {
                            const parts = selectedHitEffect.split('_');
                            if (parts.length >= 3) {
                                const effectType = parts[1]; // dot, triangle, square, etc.
                                
                                // Í∞ïÌôî Ïó¨Î∂Ä ÌôïÏù∏ (ÏÑ†ÌÉùÎêú Í∞ïÌôî Îã®Í≥Ñ ÏÇ¨Ïö©)
                                const levelKey = `hitEffect_level_${selectedHitEffect}`;
                                let currentLevel = parseInt(localStorage.getItem(levelKey) || '0');
                                // Í∞ïÌôîÎäî ÏµúÎåÄ 2Îã®Í≥ÑÍπåÏßÄÎßå Í∞ÄÎä•ÌïòÎØÄÎ°ú Ï†úÌïú
                                if (currentLevel > 2) {
                                    currentLevel = 2;
                                    localStorage.setItem(levelKey, '2');
                                }
                                const selectedLevelKey = `selectedHitEffectLevel_${selectedHitEffect}`;
                                let selectedLevel = parseInt(localStorage.getItem(selectedLevelKey) || '0');
                                // ÏÑ†ÌÉùÎêú Îã®Í≥ÑÍ∞Ä Í∞ïÌôîÌïú Îã®Í≥ÑÎ•º Ï¥àÍ≥ºÌïòÏßÄ ÏïäÎèÑÎ°ù Ï†úÌïú
                                if (selectedLevel > currentLevel) {
                                    selectedLevel = 0;
                                    localStorage.setItem(selectedLevelKey, '0');
                                }
                                
                                // ÏÑ†ÌÉùÎêú Í∞ïÌôî Îã®Í≥ÑÏóê Îî∞Îùº ÏÉâÏÉÅ Í≤∞Ï†ï
                                let color = 'gray';
                                let hasNeon = false;
                                if (selectedLevel > 0) {
                                    // Í∞ïÌôîÎêú Í≤ΩÏö∞: Îπ®Í∞ï, Ï£ºÌô©, ÎÖ∏Îûë, Ï¥àÎ°ù, ÌååÎûë, Î≥¥Îùº Ï§ë ÎûúÎç§ ÏÑ†ÌÉù
                                    const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
                                    color = colors[Math.floor(Math.random() * colors.length)];
                                }
                                if (selectedLevel >= 2) {
                                    // 2Îã®Í≥Ñ Í∞ïÌôî: ÎÑ§Ïò® Ìö®Í≥º Ï†ÅÏö©
                                    hasNeon = true;
                                }
                                
                                const colorMap = {
                                    'red': '#ff6666',
                                    'orange': '#ffaa66',
                                    'yellow': '#ffff88',
                                    'blue': '#66aaff',
                                    'purple': '#aa66ff',
                                    'white': '#ffffff',
                                    'green': '#66ff66',
                                    'pink': '#ff66ff',
                                    'gray': '#888888'
                                };
                                const effectColor = colorMap[color] || '#888888';
                                
                                // ÎÑ§Ïò® Ìö®Í≥º Ïó¨Î∂ÄÎ•º ÌååÌã∞ÌÅ¥Ïóê Ï†ÄÏû•
                                const neonEffect = hasNeon;
                                
                                // Ï¥ùÏïåÏù¥ ÎßûÏùÄ ÏúÑÏπòÏóêÏÑú Ïù¥ÌéôÌä∏ ÏÉùÏÑ±
                                const hitX = bullet.x;
                                const hitY = bullet.y;
                                
                                if (effectType === 'dot') {
                                    // Ï†ê Ïù¥ÌéôÌä∏: ÌöåÏÉâ Ï†ê 3~5Í∞ú Ìù©ÎøåÎ¶¨Í∏∞
                                    const dotCount = 3 + Math.floor(Math.random() * 3); // 3~5Í∞ú
                                    for (let i = 0; i < dotCount; i++) {
                                        // Ï¥ùÏïåÏù¥ ÎßûÏùÄ ÏúÑÏπòÏóêÏÑú ¬±10px Î≤îÏúÑ ÎÇ¥ÏóêÏÑú ÎûúÎç§ ÏÉùÏÑ±
                                        const offsetX = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const offsetY = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const startX = hitX + offsetX;
                                        const startY = hitY + offsetY;
                                        
                                        // ÌçºÏßÄÎäî Î∞©Ìñ•Í≥º ÏÜçÎèÑ
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 50 + Math.random() * 50; // ÌçºÏßÄÎäî ÏÜçÎèÑ (Îçî ÎÑìÍ≤å)
                                        
                                        player.hitEffectParticles.push({
                                            x: startX,
                                            y: startY,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            type: 'dot',
                                            color: effectColor,
                                            life: neonEffect ? 1.1 : 0.75, // ÎÑ§Ïò® Ìö®Í≥º Ïãú Îçî Í∏∏Í≤å ÏßÄÏÜç
                                            maxLife: neonEffect ? 1.1 : 0.75,
                                            size: 4 + Math.random() * 2, // ÌÅ¨Í∏∞ 4~6
                                            hasNeon: neonEffect // ÎÑ§Ïò® Ìö®Í≥º Ïó¨Î∂Ä
                                        });
                                    }
                                } else if (effectType === 'triangle') {
                                    // ÏÇºÍ∞ÅÌòï Ïù¥ÌéôÌä∏: ÌöåÏÉâ ÏÇºÍ∞ÅÌòï 3~5Í∞ú Ìù©ÎøåÎ¶¨Í∏∞
                                    const triangleCount = 3 + Math.floor(Math.random() * 3); // 3~5Í∞ú
                                    for (let i = 0; i < triangleCount; i++) {
                                        // Ï¥ùÏïåÏù¥ ÎßûÏùÄ ÏúÑÏπòÏóêÏÑú ¬±10px Î≤îÏúÑ ÎÇ¥ÏóêÏÑú ÎûúÎç§ ÏÉùÏÑ±
                                        const offsetX = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const offsetY = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const startX = hitX + offsetX;
                                        const startY = hitY + offsetY;
                                        
                                        // ÌçºÏßÄÎäî Î∞©Ìñ•Í≥º ÏÜçÎèÑ
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 50 + Math.random() * 50; // ÌçºÏßÄÎäî ÏÜçÎèÑ (Îçî ÎÑìÍ≤å)
                                        
                                        player.hitEffectParticles.push({
                                            x: startX,
                                            y: startY,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            type: 'triangle',
                                            color: effectColor,
                                            life: neonEffect ? 1.1 : 0.75, // ÎÑ§Ïò® Ìö®Í≥º Ïãú Îçî Í∏∏Í≤å ÏßÄÏÜç
                                            maxLife: neonEffect ? 1.1 : 0.75,
                                            size: 6 + Math.random() * 2, // ÌÅ¨Í∏∞ 6~8
                                            rotation: Math.random() * Math.PI * 2, // ÎûúÎç§ ÌöåÏ†Ñ Í∞ÅÎèÑ
                                            hasNeon: neonEffect // ÎÑ§Ïò® Ìö®Í≥º Ïó¨Î∂Ä
                                        });
                                    }
                                } else if (effectType === 'square') {
                                    // ÏÇ¨Í∞ÅÌòï Ïù¥ÌéôÌä∏: ÌöåÏÉâ ÏÇ¨Í∞ÅÌòï 3~5Í∞ú Ìù©ÎøåÎ¶¨Í∏∞
                                    const squareCount = 3 + Math.floor(Math.random() * 3); // 3~5Í∞ú
                                    for (let i = 0; i < squareCount; i++) {
                                        // Ï¥ùÏïåÏù¥ ÎßûÏùÄ ÏúÑÏπòÏóêÏÑú ¬±10px Î≤îÏúÑ ÎÇ¥ÏóêÏÑú ÎûúÎç§ ÏÉùÏÑ±
                                        const offsetX = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const offsetY = (Math.random() - 0.5) * 20; // -10 ~ +10
                                        const startX = hitX + offsetX;
                                        const startY = hitY + offsetY;
                                        
                                        // ÌçºÏßÄÎäî Î∞©Ìñ•Í≥º ÏÜçÎèÑ
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 50 + Math.random() * 50; // ÌçºÏßÄÎäî ÏÜçÎèÑ (Îçî ÎÑìÍ≤å)
                                        
                                        player.hitEffectParticles.push({
                                            x: startX,
                                            y: startY,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            type: 'square',
                                            color: effectColor,
                                            life: neonEffect ? 1.1 : 0.75, // ÎÑ§Ïò® Ìö®Í≥º Ïãú Îçî Í∏∏Í≤å ÏßÄÏÜç
                                            maxLife: neonEffect ? 1.1 : 0.75,
                                            size: 4 + Math.random() * 2, // ÌÅ¨Í∏∞ 4~6
                                            rotation: Math.random() * Math.PI * 2, // ÎûúÎç§ ÌöåÏ†Ñ Í∞ÅÎèÑ
                                            hasNeon: neonEffect // ÎÑ§Ïò® Ìö®Í≥º Ïó¨Î∂Ä
                                        });
                                    }
                                } else if (effectType === 'diamond') {
                                    // ÎßàÎ¶ÑÎ™® Ïù¥ÌéôÌä∏
                                    for (let i = 0; i < 6; i++) {
                                        const angle = (Math.PI * 2 / 6) * i;
                                        const distance = 12 + Math.random() * 8;
                                        player.hitEffectParticles.push({
                                            x: hitX + Math.cos(angle) * distance,
                                            y: hitY + Math.sin(angle) * distance,
                                            type: 'diamond',
                                            color: effectColor,
                                            life: 0.5,
                                            maxLife: 0.5,
                                            size: 4 + Math.random() * 3
                                        });
                                    }
                                } else if (effectType === 'spark') {
                                    // Ïä§ÌååÌÅ¨ Ïù¥ÌéôÌä∏: Ïó¨Îü¨ Í∞úÏùò ÏßßÏùÄ ÏÑ†
                                    for (let i = 0; i < 12; i++) {
                                        const angle = Math.random() * Math.PI * 2;
                                        player.hitEffectParticles.push({
                                            x: hitX,
                                            y: hitY,
                                            angle: angle,
                                            type: 'spark',
                                            color: effectColor,
                                            life: neonEffect ? 0.6 : 0.3, // ÎÑ§Ïò® Ìö®Í≥º Ïãú 2Î∞∞ ÏßÄÏÜç
                                            maxLife: neonEffect ? 0.6 : 0.3,
                                            length: 8 + Math.random() * 6,
                                            size: 1.5 + Math.random() * 1,
                                            hasNeon: neonEffect // ÎÑ§Ïò® Ìö®Í≥º Ïó¨Î∂Ä
                                        });
                                    }
                                } else if (effectType === 'firework') {
                                    // Ìè≠Ï£Ω Ïù¥ÌéôÌä∏: Ï¥ùÏïå ÌÅ¨Í∏∞Ïùò 75% ÏßÅÏÇ¨Í∞ÅÌòï 6Í∞úÍ∞Ä 60ÎèÑÏî© ÌçºÏßÄÎäî Î∂àÍΩÉÎÜÄÏù¥ ÎäêÎÇå
                                    const rectangleCount = 6;
                                    const angleStep = (Math.PI * 2) / rectangleCount; // 60ÎèÑÏî©
                                    const randomRotation = Math.random() * Math.PI * 2; // Ï†ÑÏ≤¥ ÎûúÎç§ ÌöåÏ†Ñ
                                    
                                    // Ï¥ùÏïå Í∏∞Î≥∏ ÌÅ¨Í∏∞ (radius 9, ÏßÄÎ¶Ñ 18)
                                    const bulletSize = 9 * 2; // Ï¥ùÏïå ÏßÄÎ¶Ñ
                                    const rectangleSize = bulletSize * 0.75 * 1.25; // Ï¥ùÏïå ÌÅ¨Í∏∞Ïùò 75% * 1.25Î∞∞ (25% Ï¶ùÍ∞Ä)
                                    
                                    for (let i = 0; i < rectangleCount; i++) {
                                        const angle = angleStep * i + randomRotation; // 60ÎèÑ Í∞ÑÍ≤© + ÎûúÎç§ ÌöåÏ†Ñ
                                        
                                        player.hitEffectParticles.push({
                                            x: hitX,
                                            y: hitY,
                                            angle: angle,
                                            type: 'firework',
                                            color: effectColor,
                                            life: neonEffect ? 1.1 : 0.75, // ÎÑ§Ïò® Ìö®Í≥º Ïãú Îçî Í∏∏Í≤å ÏßÄÏÜç
                                            maxLife: neonEffect ? 1.1 : 0.75,
                                            size: rectangleSize, // ÏßÅÏÇ¨Í∞ÅÌòï ÌÅ¨Í∏∞ (Ï¥ùÏïå ÌÅ¨Í∏∞Ïùò 75% * 1.25Î∞∞)
                                            speed: 1.0, // Ï¥àÍ∏∞ ÏÜçÎèÑ
                                            hasNeon: neonEffect // ÎÑ§Ïò® Ìö®Í≥º Ïó¨Î∂Ä
                                        });
                                    }
                                } else if (effectType === 'ring') {
                                    // ÎßÅ Ïù¥ÌéôÌä∏: ÌôïÏû•ÎêòÎäî Ïõê
                                    for (let i = 0; i < 3; i++) {
                                        player.hitEffectParticles.push({
                                            x: hitX,
                                            y: hitY,
                                            type: 'ring',
                                            color: effectColor,
                                            life: 0.6,
                                            maxLife: 0.6,
                                            size: 5 + i * 5,
                                            maxSize: 30 + i * 10
                                        });
                                    }
                                } else if (effectType === 'burst') {
                                    // Ìè≠Î∞ú Ïù¥ÌéôÌä∏: Ïó¨Îü¨ Î∞©Ìñ•ÏúºÎ°ú ÌçºÏßÄÎäî ÌååÌã∞ÌÅ¥
                                    for (let i = 0; i < 16; i++) {
                                        const angle = (Math.PI * 2 / 16) * i + Math.random() * 0.3;
                                        const speed = 20 + Math.random() * 30;
                                        player.hitEffectParticles.push({
                                            x: hitX,
                                            y: hitY,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            type: 'burst',
                                            color: effectColor,
                                            life: 0.5,
                                            maxLife: 0.5,
                                            size: 4 + Math.random() * 3
                                        });
                                    }
                                }
                            }
                        }
                    }
                    
                    // ÌîºÏùò Îßõ: Ï†ÅÏóêÍ≤å ÏûÖÌûå ÌîºÌï¥Ïùò 20%ÎßåÌÅº ÌöåÎ≥µ (20%Ïî© Ï§ëÏ≤©)
                    if (character.hasTasteOfBlood) {
                        const tasteOfBloodCount = character.tasteOfBloodCount || 1;
                        let healAmount = finalDamage * (0.2 * tasteOfBloodCount);
                        healAmount = roundToMaxTwoDecimals(healAmount);
                        const oldHealth = character.health;
                        character.health = Math.min(character.health + healAmount, character.maxHealth);
                        character.health = roundToMaxTwoDecimals(character.health);
                        const actualHeal = character.health - oldHealth;
                        if (actualHeal > 0) {
                            // ÌöåÎ≥µ Ïà´Ïûê ÌëúÏãú (Îπ®Í∞ÑÏÉâ)
                            character.damageNumbers.push({
                                x: character.x,
                                y: character.y,
                                damage: roundToMaxTwoDecimals(actualHeal),
                                isCritical: false,
                                isHeal: true, // ÌöåÎ≥µ Ïó¨Î∂Ä
                                startTime: Date.now(),
                                duration: 1000,
                                offsetY: 0
                            });
                        }
                    }
                    
                    // ÏÑ†Í≥†: Ï†ÅÏùÑ ÎßûÏùÄ Î∞©Ìñ•ÏúºÎ°ú 75px Î∞ÄÎ†§ÎÇ® (0.1Ï¥à ÏÜåÏöî)
                    if (character.hasJudgment) {
                        const bulletAngle = bullet.angle;
                        const pushDistance = 75;
                        const pushDuration = 100; // 0.1Ï¥à
                        const pushDx = Math.cos(bulletAngle) * pushDistance;
                        const pushDy = Math.sin(bulletAngle) * pushDistance;
                        
                        // Î∞ÄÎ†§ÎÇòÎäî Î™©Ìëú ÏúÑÏπò
                        const targetPushX = Math.max(
                            gameState.mapBounds.minX + target.radius,
                            Math.min(gameState.mapBounds.maxX - target.radius, target.x + pushDx)
                        );
                        const targetPushY = Math.max(
                            gameState.mapBounds.minY + target.radius,
                            Math.min(gameState.mapBounds.maxY - target.radius, target.y + pushDy)
                        );
                        
                        // Î∞ÄÎ†§ÎÇòÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
                        target.judgmentPushStartX = target.x;
                        target.judgmentPushStartY = target.y;
                        target.judgmentPushTargetX = targetPushX;
                        target.judgmentPushTargetY = targetPushY;
                        target.judgmentPushStartTime = Date.now();
                        target.judgmentPushDuration = pushDuration;
                        target.isJudgmentPushing = true;
                    }
                    
                    character.bullets.splice(i, 1);

                    // Îç∞ÎØ∏ÏßÄ Ïà´Ïûê ÌëúÏãú Ï∂îÍ∞Ä
                    target.damageNumbers.push({
                        x: target.x,
                        y: target.y,
                        damage: finalDamage,
                        isCritical: isCritical, // ÌÅ¨Î¶¨Ìã∞Ïª¨ Ïó¨Î∂Ä
                        startTime: Date.now(),
                        duration: 1000, // 1Ï¥à ÎèôÏïà ÌëúÏãú
                        offsetY: 0 // ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÎäî Ïò§ÌîÑÏÖã
                    });

                    // Î≤àÍ∞ú: ÌôïÎ•† Ï§ëÏ≤© (25% * count)
                    const lightningCount = character.lightningCount || 1;
                    if (character.hasLightning && Math.random() < (0.25 * lightningCount)) {
                        target.isStunned = true;
                        target.stunEndTime = Date.now() + 750; // 0.75Ï¥à
                        // Í∏∞Ï†à ÌÖçÏä§Ìä∏ ÌëúÏãú (Îç∞ÎØ∏ÏßÄ Ïà´Ïûê ÏúÑÏóê ÌëúÏãú)
                        target.damageNumbers.push({
                            x: target.x,
                            y: target.y,
                            damage: 0,
                            isCritical: false,
                            isStunned: true, // Í∏∞Ï†à Ïó¨Î∂Ä
                            startTime: Date.now(),
                            duration: 1000,
                            offsetY: -40 // Îç∞ÎØ∏ÏßÄ Ïà´Ïûê ÏúÑÏóê ÌëúÏãú
                        });
                    }

                    // ÍπäÏùÄ ÏÉÅÏ≤ò (ÌîºÍ≤© Ïãú ÏÉÅÎåÄ Ïù¥ÎèôÏÜçÎèÑ -25% (ÏãúÍ∞Ñ Ï§ëÏ≤©))
                    if (character.hasDeepWound) {
                        const deepWoundCount = character.deepWoundCount || 1;
                        target.slowEndTime = Date.now() + (500 * deepWoundCount);
                    }
                    
                    // ÎèÖ ÌÉÑÌôò Ìö®Í≥º (1Ï¥àÍ∞ÑÍ≤©ÏúºÎ°ú 3Î≤à, Îç∞ÎØ∏ÏßÄ Ï§ëÏ≤©)
                    if (bullet.hasPoison) {
                        const poisonCount = character.poisonBulletCount || 1;
                        character.poisonEffects.push({
                            target: target,
                            startTime: Date.now(),
                            duration: 3000, // 3Ï¥à (1Ï¥àÍ∞ÑÍ≤©ÏúºÎ°ú 3Î≤à)
                            damagePerSecond: 0.2 * poisonCount, // Ï§ëÏ≤©Îêú Îç∞ÎØ∏ÏßÄ
                            lastDamageTime: Date.now(),
                            hitCount: 0, // ÌûàÌä∏ ÌöüÏàò
                            maxHits: 3 // ÏµúÎåÄ ÌûàÌä∏ ÌöüÏàò
                        });
                    }
                    
                    // ÏßëÏ§ë ÏÇ¨Í≤©: ÌîºÍ≤©Ïãú 50% ÌôïÎ•†Î°ú ÏÉÅÎåÄÏóêÍ≤å Ï∑®ÏïΩ Î∂ÄÏó¨
                    if (target.hasFocusedFire && Math.random() < 0.5) {
                        character.isVulnerable = true;
                        character.vulnerabilityUsed = false;
                    }

                    if (target.health <= 0) {
                        target.health = 0;
                        
                        // Î∂ÄÌôú Ï≤¥ÌÅ¨ (ÌöüÏàò Ï§ëÏ≤©)
                        const reviveCount = target.reviveCount || 1;
                        const hasRevivedCount = (typeof target.hasRevived === 'number' ? target.hasRevived : (target.hasRevived ? 1 : 0));
                        if (target.hasRevive && hasRevivedCount < reviveCount && !target.isReviving) {
                            target.hasRevived = hasRevivedCount + 1; // Î∂ÄÌôú ÏÇ¨Ïö© ÌöüÏàò Ï¶ùÍ∞Ä
                            target.isReviving = true;
                            target.reviveTime = Date.now() + 2000; // 2Ï¥à
                        } else {
                            endRound(character === player ? 'player' : 'enemy');
                        }
                    }
                    // Ï≤¥Î†•Ïù¥ ÏùåÏàòÍ∞Ä ÎêòÏßÄ ÏïäÎèÑÎ°ù
                    if (target.health < 0) target.health = 0;
                }
            }
        }

        // ÎùºÏö¥Îìú Ï¢ÖÎ£å
        function endRound(winner) {
            // Î™®Îì† Ïù¥ÌéôÌä∏ ÏßÄÏö∞Í∏∞
            if (player.hitEffectParticles) {
                player.hitEffectParticles = [];
            }
            if (enemy.hitEffectParticles) {
                enemy.hitEffectParticles = [];
            }
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: Í≤åÏä§Ìä∏Îäî Ìò∏Ïä§Ìä∏Î°úÎ∂ÄÌÑ∞ Í≤∞Í≥ºÎ•º Î∞õÏúºÎØÄÎ°ú Ïó¨Í∏∞ÏÑú Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùå
            if (gameState.isMultiplayer && !isHost) {
                return; // Í≤åÏä§Ìä∏Îäî handleRoundEndFromHostÏóêÏÑú Ï≤òÎ¶¨
            }
            
            gameState.isPaused = true;

            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: Ìò∏Ïä§Ìä∏Í∞Ä Í≤∞Í≥º Ï†ÑÏÜ°
            if (gameState.isMultiplayer && isHost) {
                sendMultiplayerData({
                    type: 'roundEnd',
                    winner: winner === 'player' ? 'host' : 'guest'
                });
            }

            // ÎùºÏö¥Îìú ÏäπÎ¶¨ Í∏∞Î°ùÏóê Ï∂îÍ∞Ä (ÏàúÏÑúÎåÄÎ°ú)
            gameState.roundWins.push(winner);

            if (winner === 'player') {
                gameState.playerWins++;
            } else {
                gameState.enemyWins++;
            }

            // ÏäπÎ¶¨ Ï≤¥ÌÅ¨ (5ÎùºÏö¥Îìú ÏÑ†ÏäπÏ†ú)
            if (gameState.playerWins >= gameState.winsNeeded || gameState.enemyWins >= gameState.winsNeeded) {
                const finalWinner = winner === 'player' ? 'player' : 'enemy';
                endGame(finalWinner);
                return;
            }

            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®Îìú (Ìò∏Ïä§Ìä∏)
            if (gameState.isMultiplayer) {
                if (winner === 'player') {
                    // ÎÇ¥Í∞Ä ÏäπÎ¶¨: ÏÉÅÎåÄÍ∞Ä Ï¶ùÍ∞ï ÏÑ†ÌÉù Ï§ë - 15Ï¥à Ïπ¥Ïö¥Ìä∏Îã§Ïö¥Îßå ÌëúÏãú
                    gameState.showOpponentSelecting = true;
                    gameState.augmentCountdown = 15;
                    startOpponentWaitCountdown();
                } else {
                    // ÎÇ¥Í∞Ä Ìå®Î∞∞: Ï¶ùÍ∞ï ÏÑ†ÌÉù
                    showAugmentModal(player);
                }
                return;
            }

            // ÏÜîÎ°ú Î™®Îìú: Ìå®Î∞∞ÏûêÍ∞Ä Ï¶ùÍ∞ï ÏÑ†ÌÉù, ÏäπÎ¶¨ÏûêÎäî ÌôïÏù∏Îßå
            if (winner === 'player') {
                // ÌîåÎ†àÏù¥Ïñ¥ ÏäπÎ¶¨: AIÍ∞Ä ÏÑ†ÌÉù
                gameState.showOpponentSelecting = true;
                selectAugmentForEnemy();
            } else {
                // enemy ÏäπÎ¶¨: ÌîåÎ†àÏù¥Ïñ¥Îäî ÏÑ†ÌÉù
                showAugmentModal(player);
            }
        }

        // Ï†ÅÏùÑ ÏúÑÌïú Ï¶ùÍ∞ï ÏûêÎèô ÏÑ†ÌÉù
        function selectAugmentForEnemy() {
            const enemySelectionDiv = document.getElementById('enemySelection');
            const opponentSelectionDiv = document.getElementById('opponentSelection');
            
            if (enemySelectionDiv) {
            enemySelectionDiv.style.display = 'block';
            enemySelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ÏÉÅÎåÄÍ∞Ä ÏÑ†ÌÉù Ï§ë...</p>';
            }
            
            if (opponentSelectionDiv) {
                opponentSelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ÏÉÅÎåÄÍ∞Ä ÏÑ†ÌÉù Ï§ë...</p>';
            }
            
            // 2XÎ™®Îìú Ï≤¥ÌÅ¨ - AIÎèÑ 2Í∞ú ÏÑ†ÌÉù
            const isDoubleAugmentMode = gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'doubleAugment';
            const selectCount = isDoubleAugmentMode ? 2 : 1;
            
            // 3Ï¥à ÎåÄÍ∏∞ ÌõÑ ÏÑ†ÌÉù
            setTimeout(() => {
                // AIÎäî Íµ¨Î•¥Í∏∞, Í±∞Ï†êÌôïÎ≥¥, ÏãúÍ∞ÑÏ†ïÏßÄ Ï¶ùÍ∞ïÏùÑ ÎΩëÏßÄ ÏïäÏùå
                const availableAugments = augmentations.filter(aug => aug.id !== 'dodge' && aug.id !== 'fortify' && aug.id !== 'timeStop');
                const shuffled = [...availableAugments].sort(() => Math.random() - 0.5);
                
                // selectCountÎßåÌÅº Ï¶ùÍ∞ï ÏÑ†ÌÉù
                const selectedAugments = [];
                for (let i = 0; i < selectCount && i < shuffled.length; i++) {
                    const selectedAugment = shuffled[i];
                    selectedAugment.effect(enemy);
                    enemy.augmentations.push(selectedAugment);
                    incrementAugmentSelectCount(selectedAugment.id); // ÏÑ†ÌÉù ÌöüÏàò Ï¶ùÍ∞Ä
                    markAugmentAsSeen(selectedAugment.id); // Î≥∏ Ï¶ùÍ∞ï Î™©Î°ùÏóê Ï∂îÍ∞Ä
                    selectedAugments.push(selectedAugment);
                }
                
                // ÏÑ†ÌÉùÌïú Ï¶ùÍ∞ï ÌëúÏãú
                const selectedNames = selectedAugments.map(aug => aug.name).join(', ');
                if (enemySelectionDiv) {
                    enemySelectionDiv.innerHTML = `<p style="color: #e94560; margin: 0;">ÏÉÅÎåÄ ÏÑ†ÌÉù: <strong style="color: #ffc107;">${selectedNames}</strong></p>`;
                }
                if (opponentSelectionDiv) {
                    opponentSelectionDiv.innerHTML = `<p style="color: #e94560; margin: 0;">ÏÉÅÎåÄ ÏÑ†ÌÉù: <strong style="color: #ffc107;">${selectedNames}</strong></p>`;
                }
                
                // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÏäπÎ¶¨Ìïú Í≤ΩÏö∞: ÏÉÅÎåÄ ÏÑ†ÌÉù ÏôÑÎ£å ÌõÑ ÏûêÎèôÏúºÎ°ú Îã§Ïùå ÎùºÏö¥ÎìúÎ°ú
                if (gameState.showOpponentSelecting) {
                    gameState.showOpponentSelecting = false;
                    // ÏïΩÍ∞ÑÏùò ÎîúÎ†àÏù¥ ÌõÑ Îã§Ïùå ÎùºÏö¥ÎìúÎ°ú
                    setTimeout(() => {
                        nextRound();
                    }, 500);
                }
            }, 3000);
        }

        // Ï¶ùÍ∞ï Î™®Îã¨ ÌëúÏãú (ÌîåÎ†àÏù¥Ïñ¥Ïö© - ÏÑ†ÌÉù Í∞ÄÎä•)
        function showAugmentModal(character) {
            const modal = document.getElementById('augmentModal');
            const optionsDiv = document.getElementById('augmentOptions');
            optionsDiv.innerHTML = '';

            // ÎûúÎç§ Ï¶ùÍ∞ï 3Í∞ú ÏÑ†ÌÉù (Ï§ëÎ≥µ ÏÑ†ÌÉù Í∞ÄÎä•)
            const shuffled = [...augmentations].sort(() => Math.random() - 0.5);
            const selectedAugments = shuffled.slice(0, 3);

            // ÏÑ†ÌÉù Í∞ÄÎä•Ìïú 3Í∞ú Ï¶ùÍ∞ï Î™®Îëê ÎèÑÍ∞êÏóê Ï†ÄÏû•
            selectedAugments.forEach(aug => {
                markAugmentAsSeen(aug.id);
            });

            let timeLeft = 15;
            let isSelected = false;
            let timerInterval;

            // 2XÎ™®Îìú Ï≤¥ÌÅ¨
            const isDoubleAugmentMode = gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'doubleAugment';
            
            // 2XÎ™®ÎìúÏóêÏÑú ÌòÑÏû¨ ÎùºÏö¥ÎìúÏóê ÏÑ†ÌÉùÌïú Ï¶ùÍ∞ï Í∞úÏàò Ï¥àÍ∏∞Ìôî (Ï≤òÏùå Ìò∏Ï∂ú ÏãúÏóêÎßå)
            if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount === undefined) {
                gameState.doubleAugmentSelectedCount = 0;
            }
            
            const maxSelections = isDoubleAugmentMode ? 2 : 1;
            const currentSelectedCount = isDoubleAugmentMode ? (gameState.doubleAugmentSelectedCount || 0) : 0;

            // Ï¶ùÍ∞ï ÏÑ†ÌÉù Ìï®Ïàò
            const selectAugment = (aug) => {
                if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount >= maxSelections) return;
                if (!isDoubleAugmentMode && isSelected) return;
                
                aug.effect(character);
                character.augmentations.push(aug);
                incrementAugmentSelectCount(aug.id); // ÏÑ†ÌÉù ÌöüÏàò Ï¶ùÍ∞Ä
                
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: Ï¶ùÍ∞ï ÏÑ†ÌÉù Ï†ïÎ≥¥ Ï†ÑÏÜ°
                if (gameState.isMultiplayer) {
                    sendMultiplayerData({
                        type: 'augmentSelected',
                        augment: { id: aug.id, name: aug.name }
                    });
                }
                
                if (isDoubleAugmentMode) {
                    gameState.doubleAugmentSelectedCount = (gameState.doubleAugmentSelectedCount || 0) + 1;
                }
                
                // 2XÎ™®ÎìúÏù¥Í≥† Ï≤´ Î≤àÏß∏ ÏÑ†ÌÉùÏù¥Î©¥ Ï∞ΩÏùÑ Îã´Í≥† ÏÉàÎ°úÏö¥ Ï∞Ω ÎùÑÏö∞Í∏∞
                if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount === 1) {
                    isSelected = true;
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    modal.style.display = 'none';
                    
                    // ÏïΩÍ∞ÑÏùò ÎîúÎ†àÏù¥ ÌõÑ ÏÉàÎ°úÏö¥ Ï∞Ω ÎùÑÏö∞Í∏∞
                    setTimeout(() => {
                        showAugmentModal(character);
                    }, 300);
                    
                    return; // ÏïÑÏßÅ ÏÑ†ÌÉù Ï§ë
                }
                
                // ÏÑ†ÌÉù ÏôÑÎ£å
                if (isDoubleAugmentMode && gameState.doubleAugmentSelectedCount >= maxSelections) {
                    isSelected = true;
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    gameState.doubleAugmentSelectedCount = 0; // Îã§Ïùå ÎùºÏö¥ÎìúÎ•º ÏúÑÌï¥ Ï¥àÍ∏∞Ìôî
                    modal.style.display = 'none';
                    const viewModal = document.getElementById('augmentViewModal');
                    if (viewModal) {
                        viewModal.style.display = 'none';
                    }
                    nextRound();
                } else if (!isDoubleAugmentMode) {
                    isSelected = true;
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    modal.style.display = 'none';
                    const viewModal = document.getElementById('augmentViewModal');
                    if (viewModal) {
                        viewModal.style.display = 'none';
                    }
                    nextRound();
                }
            };

            // Ï¶ùÍ∞ï ÏòµÏÖò ÏÉùÏÑ±
            selectedAugments.forEach(aug => {
                const option = document.createElement('div');
                option.className = 'augment-option';
                option.innerHTML = `
                    <h4>${aug.name}</h4>
                    <p>${aug.description}</p>
                `;
                option.onclick = () => selectAugment(aug);
                optionsDiv.appendChild(option);
            });

            // Î™®Îã¨ ÌëúÏãú
            modal.style.display = 'block';
            const enemySelectionDiv = document.getElementById('enemySelection');
            // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ìå®Î∞∞Ìïú Í≤ΩÏö∞: Ï†ÅÏùÄ ÏäπÎ¶¨ÏûêÏù¥ÎØÄÎ°ú Ï¶ùÍ∞ïÏùÑ ÏÑ†ÌÉùÌïòÏßÄ ÏïäÏùå, Î©îÏãúÏßÄ ÌëúÏãú ÏïàÌï®
            enemySelectionDiv.style.display = 'none';
            
            // ÌôîÎ©¥ Í∞ÄÏö¥Îç∞ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏãúÏûë
            gameState.augmentCountdown = 15;
            timerInterval = setInterval(() => {
                timeLeft--;
                gameState.augmentCountdown = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    gameState.augmentCountdown = 0;
                    if (!isSelected) {
                        // ÏãúÍ∞Ñ Ï¥àÍ≥º Ïãú ÎûúÎç§ ÏÑ†ÌÉù
                        const randomAug = selectedAugments[Math.floor(Math.random() * selectedAugments.length)];
                        selectAugment(randomAug);
                    }
                }
            }, 1000);
        }

        // Ï¶ùÍ∞ï ÌôïÏù∏ Î™®Îã¨ ÌëúÏãú (ÏäπÎ¶¨ÏûêÏö© - ÌôïÏù∏Îßå Í∞ÄÎä•)
        function showAugmentViewModal(winnerCharacter, loserType) {
            const modal = document.getElementById('augmentViewModal');
            const opponentSelectionDiv = document.getElementById('opponentSelection');
            
            // Î™®Îã¨ ÌëúÏãú
            modal.style.display = 'block';
            opponentSelectionDiv.innerHTML = '<p style="color: #e94560; margin: 0;">ÏÉÅÎåÄÍ∞Ä ÏÑ†ÌÉù Ï§ë...</p>';
        }

        // Ï¶ùÍ∞ï ÌôïÏù∏ Î™®Îã¨ Îã´Í∏∞
        function closeAugmentViewModal() {
            const modal = document.getElementById('augmentViewModal');
            modal.style.display = 'none';
            
            // ÏÉÅÎåÄ ÏÑ†ÌÉùÏù¥ ÏôÑÎ£åÎêòÏóàÏúºÎ©¥ Îã§Ïùå ÎùºÏö¥ÎìúÎ°ú
            if (enemy.augmentations.length > 0) {
                nextRound();
            } else {
                // ÏïÑÏßÅ Ï†ÅÏù¥ ÏÑ†ÌÉù Ï§ëÏù¥Î©¥ ÎåÄÍ∏∞
                const checkEnemySelection = setInterval(() => {
                    if (enemy.augmentations.length > 0) {
                        clearInterval(checkEnemySelection);
                        nextRound();
                    }
                }, 100);
            }
        }

        // Îã§Ïùå ÎùºÏö¥Îìú
        function nextRound() {
            // Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ (Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑú)
            if (gameState.isMultiplayer && gameState.isNextRoundProcessing) {
                return;
            }
            gameState.isNextRoundProcessing = true;
            
            // ÏäπÎ¶¨Ïûê Ï¶ùÍ∞ï: ÎùºÏö¥Îìú ÏãúÏûë Ïãú 10% ÌôïÎ•†Î°ú Ï¶âÏãú ÏäπÎ¶¨
            if (player.hasVictor && Math.random() < 0.1) {
                gameState.isNextRoundProcessing = false;
                handleRoundEnd('player');
                return;
            }
            if (enemy.hasVictor && Math.random() < 0.1) {
                gameState.isNextRoundProcessing = false;
                handleRoundEnd('enemy');
                return;
            }
            
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: Ìò∏Ïä§Ìä∏Í∞Ä Îã§Ïùå ÎùºÏö¥Îìú ÏãúÏûë ÏïåÎ¶º
            if (gameState.isMultiplayer && isHost) {
                sendMultiplayerData({ type: 'nextRound' });
            }
            
            resizeCanvas();
            gameState.round++;
            gameState.gameTime = 180;
            gameState.showOpponentSelecting = false;
            // 2XÎ™®Îìú ÏÑ†ÌÉù Ïπ¥Ïö¥Ìä∏ Ï¥àÍ∏∞Ìôî
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'doubleAugment') {
                gameState.doubleAugmentSelectedCount = 0;
            }
            
            // Ï†ÑÌà¨ Í≤ΩÌóò: ÏßÑ ÎùºÏö¥Îìú ÏàòÎßàÎã§ ÏµúÎåÄÏ≤¥Î†• 0.5, Îç∞ÎØ∏ÏßÄ 0.1 Ï¶ùÍ∞Ä (Ï§ëÏ≤©)
            if (player.hasCombatExperience) {
                player.combatExperienceRounds = gameState.enemyWins; // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÏßÑ ÎùºÏö¥Îìú Ïàò (Ï†ÅÏù¥ Ïù¥Í∏¥ ÎùºÏö¥Îìú)
                const combatExperienceCount = player.combatExperienceCount || 1;
                player.maxHealth = 5 + player.combatExperienceRounds * (0.5 * combatExperienceCount);
                player.damage = 1 + player.combatExperienceRounds * (0.1 * combatExperienceCount);
            }
            if (enemy.hasCombatExperience) {
                enemy.combatExperienceRounds = gameState.playerWins; // Ï†ÅÏù¥ ÏßÑ ÎùºÏö¥Îìú Ïàò (ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ïù¥Í∏¥ ÎùºÏö¥Îìú)
                const combatExperienceCount = enemy.combatExperienceCount || 1;
                enemy.maxHealth = 5 + enemy.combatExperienceRounds * (0.5 * combatExperienceCount);
                enemy.damage = 1 + enemy.combatExperienceRounds * (0.1 * combatExperienceCount);
            }

            // ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî - Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥Ïùº Îïå ÌåÄÏóê Îî∞Î•∏ ÏúÑÏπò ÏÑ§Ï†ï
            const leftX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            const rightX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            const centerY = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            
            if (gameState.isMultiplayer && myTeam) {
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: ÌååÎûÄÌåÄÏùÄ ÏôºÏ™Ω, Îπ®Í∞ÑÌåÄÏùÄ Ïò§Î•∏Ï™Ω
                player.x = myTeam === 'blue' ? leftX : rightX;
                enemy.x = myTeam === 'blue' ? rightX : leftX;
            } else {
                // ÏÜîÎ°ú: ÌîåÎ†àÏù¥Ïñ¥ ÏôºÏ™Ω, Ï†Å Ïò§Î•∏Ï™Ω
                player.x = leftX;
            }
            player.y = centerY;
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑúÎäî Ï≤¥Î†•ÏùÑ Ï¥àÍ∏∞ÌôîÌïòÏßÄ ÏïäÏùå (Í≤åÏûÑ Ï§ëÏóêÎäî Ï≤¥Î†• Ïú†ÏßÄ)
            // ÎùºÏö¥Îìú ÏãúÏûë ÏãúÏóêÎßå Ï≤¥Î†• Ï¥àÍ∏∞Ìôî
            if (!gameState.isMultiplayer || gameState.round === 1) {
                player.health = player.maxHealth;
                player.displayHealth = player.maxHealth;
            }
            player.ammo = player.maxAmmo;
            player.bullets = [];
            player.isReloading = false;
            player.isDodging = false;
            player.dodgeStartTime = 0;
            player.dodgeEndTime = 0;
            player.dodgeStartX = 0;
            player.dodgeStartY = 0;
            player.dodgeTargetX = 0;
            player.dodgeTargetY = 0;
            player.dodgeTrail = [];
            player.lastDodgeTime = 0;
            player.isReviving = false;
            player.reviveTime = 0;
            player.hasRevived = 0; // Î∂ÄÌôú ÏÇ¨Ïö© ÌöüÏàò Ï¥àÍ∏∞Ìôî
            player.isInvincible = false;
            player.invincibleEndTime = 0;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.poisonEffects = [];
            player.hasRecoveryContractUsed = false; // ÌöåÎ≥µÍ≥ÑÏïΩ Ï¥àÍ∏∞Ìôî
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.shieldReady = true; // Î∞©Ïñ¥Îßâ Ï§ÄÎπÑ ÏÉÅÌÉúÎ°ú Ï¥àÍ∏∞Ìôî
            player.shieldCooldown = 0;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.lastRegenTime = Date.now(); // Ïû¨ÏÉù ÏãúÏûë ÏãúÍ∞Ñ
            // ÏÉàÎ°úÏö¥ Ï¶ùÍ∞ï ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî (ÎùºÏö¥Îìú Ï¥àÍ∏∞Ìôî)
            player.reflectActive = false;
            player.reflectCooldown = 0;
            player.reflectEndTime = 0;
            player.timeStopActive = false;
            player.timeStopCooldown = 0;
            player.timeStopEndTime = 0;

            // Ï†Å ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî - Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÏïÑÎãê ÎïåÎßå ÏúÑÏπò ÏÑ§Ï†ï (ÏúÑÏóêÏÑú Ïù¥ÎØ∏ ÏÑ§Ï†ïÌï®)
            if (!gameState.isMultiplayer) {
                enemy.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            }
            enemy.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑúÎäî Ï≤¥Î†•ÏùÑ Ï¥àÍ∏∞ÌôîÌïòÏßÄ ÏïäÏùå (Í≤åÏûÑ Ï§ëÏóêÎäî Ï≤¥Î†• Ïú†ÏßÄ)
            // ÎùºÏö¥Îìú ÏãúÏûë ÏãúÏóêÎßå Ï≤¥Î†• Ï¥àÍ∏∞Ìôî
            if (!gameState.isMultiplayer || gameState.round === 1) {
                enemy.health = enemy.maxHealth;
                enemy.displayHealth = enemy.maxHealth;
            }
            
            // ÌîåÎûòÍ∑∏ Ìï¥Ï†ú (Îã§Ïùå ÎùºÏö¥Îìú Ï§ÄÎπÑ)
            gameState.isNextRoundProcessing = false;
            enemy.ammo = enemy.maxAmmo;
            enemy.bullets = [];
            enemy.isReloading = false;
            enemy.isDodging = false;
            enemy.dodgeStartTime = 0;
            enemy.dodgeEndTime = 0;
            enemy.dodgeStartX = 0;
            enemy.dodgeStartY = 0;
            enemy.dodgeTargetX = 0;
            enemy.dodgeTargetY = 0;
            enemy.bulletDodgeTargetY = 0;
            enemy.isDodgingBullet = false;
            enemy.lastPlayerBulletCount = 0;
            enemy.dodgeTrail = [];
            enemy.lastDodgeTime = 0;
            enemy.isReviving = false;
            enemy.reviveTime = 0;
            enemy.hasRevived = 0; // Î∂ÄÌôú ÏÇ¨Ïö© ÌöüÏàò Ï¥àÍ∏∞Ìôî
            enemy.isInvincible = false;
            enemy.invincibleEndTime = 0;
            enemy.slowEndTime = 0;
            enemy.damageNumbers = [];
            enemy.usePrediction = false;
            enemy.lastPlayerX = 0;
            enemy.lastPlayerY = 0;
            enemy.playerVelocity = { x: 0, y: 0 };
            enemy.poisonEffects = [];
            enemy.hasRecoveryContractUsed = false; // ÌöåÎ≥µÍ≥ÑÏïΩ Ï¥àÍ∏∞Ìôî
            enemy.isVulnerable = false;
            enemy.vulnerabilityUsed = false;
            enemy.isStunned = false;
            enemy.stunEndTime = 0;
            enemy.shieldReady = true; // Î∞©Ïñ¥Îßâ Ï§ÄÎπÑ ÏÉÅÌÉúÎ°ú Ï¥àÍ∏∞Ìôî
            enemy.shieldCooldown = 0;
            enemy.isWeakened = false;
            enemy.weakenEndTime = 0;
            enemy.lastRegenTime = Date.now(); // Ïû¨ÏÉù ÏãúÏûë ÏãúÍ∞Ñ
            // ÏÉàÎ°úÏö¥ Ï¶ùÍ∞ï ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî (ÎùºÏö¥Îìú Ï¥àÍ∏∞Ìôî)
            enemy.reflectActive = false;
            enemy.reflectCooldown = 0;
            enemy.reflectEndTime = 0;
            enemy.timeStopActive = false;
            enemy.timeStopCooldown = 0;
            enemy.timeStopEndTime = 0;

            // 3Ï¥à Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏãúÏûë (Í≤åÏûÑ ÏôÑÏ†ÑÌûà Î©àÏ∂§)
            gameState.countdown = 3;
            gameState.isPaused = true;
            
            // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Ï≤òÎ¶¨ - Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏä§Ìä∏Îäî Ìò∏Ïä§Ìä∏Ïùò Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ÏùÑ Îî∞Î¶Ñ
            if (!gameState.isMultiplayer || isHost) {
                const countdownInterval = setInterval(() => {
                    gameState.countdown--;
                    if (gameState.countdown <= 0) {
                        clearInterval(countdownInterval);
                        gameState.isPaused = false;
                    }
                }, 1000);
            }
        }

        // Í≤åÏûÑ Ï¢ÖÎ£å
        function endGame(winner) {
            gameState.isGameOver = true;
            const modal = document.getElementById('gameOverModal');
            const title = document.getElementById('gameOverTitle');
            const message = document.getElementById('gameOverMessage');

            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏûÑ Ï¢ÖÎ£å Ïãú Ïó∞Í≤∞ Ï†ïÎ¶¨ (ÏÉÅÎåÄÎ∞©ÏóêÍ≤å ÏïåÎ¶º)
            if (gameState.isMultiplayer) {
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏûÑ Î£®ÌîÑ Ï†ïÏßÄ
                stopMultiplayerGameLoop();
                
                // ÏÉÅÎåÄÎ∞©ÏóêÍ≤å Í≤åÏûÑ Ï¢ÖÎ£å ÏïåÎ¶º (Ïó∞Í≤∞Ïù¥ Ïó¥Î†§ÏûàÏùÑ ÎïåÎßå)
                if (multiplayerConnection && multiplayerConnection.open) {
                    try {
                        sendMultiplayerData({ type: 'gameEnd', winner: winner });
                    } catch (e) {
                        console.log('Í≤åÏûÑ Ï¢ÖÎ£å ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®:', e);
                    }
                }
            }

            // Ï†úÌôî ÏßÄÍ∏â (Í≤åÏûÑ ÏôÑÏ†Ñ Ï¢ÖÎ£å Ïãú)
            let killReward = 0;
            if (gameState.isMultiplayer) {
                // Î©ÄÌã∞ÌîåÎ†àÏù¥: ÏäπÎ¶¨ Ïãú 2Í∞ú, Ìå®Î∞∞ Ïãú 1Í∞ú
                if (winner === 'player') {
                    killReward = 2;
                } else {
                    killReward = 1;
                }
            } else {
                // ÏÜîÎ°úÌîåÎ†àÏù¥: Ïù¥Í∏¥ ÎùºÏö¥Îìú ÏàòÎßåÌÅº Ï†úÌôî ÏßÄÍ∏â (ÏµúÏ¢Ö ÏäπÎ¶¨ Ïãú 2Î∞∞ ÏßÄÍ∏â)
                killReward = gameState.playerWins || 0;
                if (winner === 'player') {
                    // ÏµúÏ¢Ö ÏäπÎ¶¨ Ïãú 2Î∞∞ ÏßÄÍ∏â
                    killReward *= 2;
                }
            }
            
            // Ï†úÌôî ÏßÄÍ∏â
            updateKillCount(gameKillCount + killReward);

            if (winner === 'player') {
                title.textContent = 'ÏäπÎ¶¨';
                title.style.color = '#4a9eff'; // ÌååÎûÄÏÉâ
                message.textContent = 'ÏäπÎ¶¨';
                message.style.color = '#4a9eff'; // ÌååÎûÄÏÉâ
            } else {
                title.textContent = 'Ìå®Î∞∞';
                title.style.color = '#e94560'; // Îπ®Í∞ÑÏÉâ
                message.textContent = 'Ìå®Î∞∞';
                message.style.color = '#e94560'; // Îπ®Í∞ÑÏÉâ
            }

            modal.style.display = 'block';
            
            // 10Ï¥à ÌõÑ Î©îÏù∏ÌôîÎ©¥ÏúºÎ°ú Ïù¥Îèô
            setTimeout(() => {
                // Ïä§ÌÅ¨Î°§ÏùÑ Îß® ÏúÑÎ°ú Ïù¥Îèô
                window.scrollTo(0, 0);
                restartGame();
            }, 10000);
        }

        // Í≤åÏûÑ Ïû¨ÏãúÏûë
        function restartGame() {
            // Ïä§ÌÅ¨Î°§ÏùÑ Îß® ÏúÑÎ°ú Ïù¥Îèô
            window.scrollTo(0, 0);
            
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïó∞Í≤∞ Ï†ïÎ¶¨ (Í≤åÏûÑ Ï¢ÖÎ£å Ïãú Ìï≠ÏÉÅ Ï†ïÎ¶¨)
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏûÑÏù¥ÏóàÍ±∞ÎÇò Peer Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÎÇ®ÏïÑÏûàÏúºÎ©¥ ÏôÑÏ†ÑÌûà Ï†ïÎ¶¨
            if (gameState.isMultiplayer || multiplayerPeer || multiplayerConnection) {
                console.log('Í≤åÏûÑ Ïû¨ÏãúÏûë: Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïó∞Í≤∞ Ï†ïÎ¶¨ Ï§ë...');
                cleanupMultiplayerConnection();
                // Ï∂îÍ∞Ä Ï†ïÎ¶¨: ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ ÌõÑ Ìïú Î≤à Îçî ÌôïÏù∏
                setTimeout(() => {
                    if (multiplayerPeer || multiplayerConnection) {
                        console.log('Ï∂îÍ∞Ä Ï†ïÎ¶¨: ÎÇ®ÏïÑÏûàÎäî Ïó∞Í≤∞ Ï†ïÎ¶¨ Ï§ë...');
                        cleanupMultiplayerConnection();
                    }
                }, 100);
            }
            
            // ÌîåÎ†àÏù¥Ïñ¥ ÏÉâÏÉÅ Ï¥àÍ∏∞Ìôî
            player.color = '#4a9eff';
            enemy.color = '#e94560';
            
            // Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ÄÍ∏∞
            gameState.isMenu = true;
            gameState.isGameOver = false;
            document.getElementById('gameOverModal').style.display = 'none';
            showScreen('main');
            
            // ÎãâÎÑ§ÏûÑ ÌëúÏãú
            showNicknameDisplay();
            
            // Î™®Îìú ÏÑ†ÌÉù Ï†ëÍ∏∞
            collapseModeSelection();
            collapseMultiModeSelection();
            
            // Ï≤´ ÎùºÏö¥Îìú Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏãúÏûë
            gameState.isPaused = true;
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.isPaused = false;
                }
            }, 1000);

            player.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            player.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.hasCritical = false;
            player.hasDoubleShot = false;
            player.hasDodge = false;
            player.hasRevive = false;
            player.hasDeepWound = false;
            player.hasOneShotOneKill = false;
            player.hasPoisonBullet = false;
            player.hasReloadHeal = false;
            player.hasSurvivalInstinct = false;
            player.hasLastBullet = false;
            player.hasRecoveryContract = false;
            player.hasRecoveryContractUsed = false;
            player.hasFocusedFire = false;
            player.hasShotgun = false;
            player.hasRagged = false;
            player.hasGhost = false;
            player.hasFortify = false;
            player.isFortified = false;
            player.fortifyStartTime = 0;
            player.lastPosition = { x: player.x, y: player.y };
            player.stationaryTime = 0;
            player.hasOverheat = false;
            player.overheatHitCount = 0;
            player.lastHitTime = 0;
            player.hasGamble = false;
            player.hasWeaken = false;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.hasDamageBoost = false;
            player.hasLightning = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.hasShield = false;
            player.shieldReady = false;
            player.shieldCooldown = 0;
            player.hasRegeneration = false;
            player.lastRegenTime = 0;
            player.hasEvasiveManeuver = false;
            player.hasCombatExperience = false;
            player.combatExperienceRounds = 0;
            player.hasHallucination = false;
            player.hasTasteOfBlood = false;
            player.hasCannon = false;
            player.hasTimeBarrier = false;
            player.timeBarrierRadius = 150;
            player.hasBouncyBullet = false;
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.poisonEffects = [];
            player.isDodging = false;
            player.dodgeStartTime = 0;
            player.dodgeEndTime = 0;
            player.dodgeStartX = 0;
            player.dodgeStartY = 0;
            player.dodgeTargetX = 0;
            player.dodgeTargetY = 0;
            player.dodgeTrail = [];
            player.lastDodgeTime = 0;
            player.isReviving = false;
            player.reviveTime = 0;
            player.hasRevived = 0; // Î∂ÄÌôú ÏÇ¨Ïö© ÌöüÏàò Ï¥àÍ∏∞Ìôî
            player.isInvincible = false;
            player.invincibleEndTime = 0;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.damage = 1;
            player.speed = 3;
            player.reloadTime = 3000;
            player.baseReloadTime = 3000; // Í∏∞Î≥∏ Ïû¨Ïû•Ï†Ñ ÏãúÍ∞Ñ Ï†ÄÏû•
            player.reloadStartTime = 0;
            player.shootCooldown = 1000;

            enemy.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            enemy.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            enemy.health = 5;
            enemy.displayHealth = 5;
            enemy.maxHealth = 5;
            enemy.ammo = 6;
            enemy.maxAmmo = 6;
            enemy.bullets = [];
            enemy.augmentations = [];
            enemy.bulletSpeedMultiplier = 1;
            enemy.bulletSizeMultiplier = 1;
            enemy.hasCritical = false;
            enemy.hasDoubleShot = false;
            enemy.hasDodge = false;
            enemy.hasRevive = false;
            enemy.hasRevived = 0; // Î∂ÄÌôú ÏÇ¨Ïö© ÌöüÏàò Ï¥àÍ∏∞Ìôî
            enemy.hasDeepWound = false;
            enemy.hasOneShotOneKill = false;
            enemy.hasPoisonBullet = false;
            enemy.hasReloadHeal = false;
            enemy.hasSurvivalInstinct = false;
            enemy.hasLastBullet = false;
            enemy.hasRecoveryContract = false;
            enemy.hasRecoveryContractUsed = false;
            enemy.hasFocusedFire = false;
            enemy.hasEvasiveManeuver = false;
            enemy.hasCombatExperience = false;
            enemy.combatExperienceRounds = 0;
            enemy.hasHallucination = false;
            enemy.hasTasteOfBlood = false;
            enemy.hasCannon = false;
            enemy.hasTimeBarrier = false;
            enemy.timeBarrierRadius = 150;
            enemy.hasBouncyBullet = false;
            enemy.hasExplosiveBullet = false;
            enemy.hasReaper = false;
            enemy.isInvisible = false;
            enemy.invisibilityEndTime = 0;
            enemy.hasOvercharge = false;
            enemy.overchargeActive = false;
            enemy.overchargeCooldown = 0;
            enemy.overchargeEndTime = 0;
            enemy.overchargeTrail = [];
            enemy.hasVictor = false;
            enemy.hasReflect = false;
            enemy.reflectActive = false;
            enemy.reflectCooldown = 0;
            enemy.reflectEndTime = 0;
            enemy.hasTimeStop = false;
            enemy.timeStopCooldown = 0;
            enemy.timeStopActive = false;
            enemy.timeStopEndTime = 0;
            enemy.hasScatter = false;
            enemy.hasGamble2 = false;
            enemy.hasRocket = false;
            enemy.hasTrinity = false;
            enemy.hasJudgment = false;
            enemy.isJudgmentPushing = false;
            enemy.judgmentPushStartX = 0;
            enemy.judgmentPushStartY = 0;
            enemy.judgmentPushTargetX = 0;
            enemy.judgmentPushTargetY = 0;
            enemy.judgmentPushStartTime = 0;
            enemy.judgmentPushDuration = 0;
            enemy.hasBoomerang = false;
            enemy.isVulnerable = false;
            enemy.vulnerabilityUsed = false;
            enemy.poisonEffects = [];
            enemy.isDodging = false;
            enemy.dodgeStartTime = 0;
            enemy.dodgeEndTime = 0;
            enemy.dodgeStartX = 0;
            enemy.dodgeStartY = 0;
            enemy.dodgeTargetX = 0;
            enemy.dodgeTargetY = 0;
            enemy.bulletDodgeTargetY = 0;
            enemy.isDodgingBullet = false;
            enemy.lastPlayerBulletCount = 0;
            enemy.dodgeTrail = [];
            enemy.lastDodgeTime = 0;
            enemy.isReviving = false;
            enemy.reviveTime = 0;
            enemy.hasRevived = 0; // Î∂ÄÌôú ÏÇ¨Ïö© ÌöüÏàò Ï¥àÍ∏∞Ìôî
            enemy.isInvincible = false;
            enemy.invincibleEndTime = 0;
            enemy.slowEndTime = 0;
            enemy.damageNumbers = [];
            enemy.usePrediction = false;
            enemy.lastPlayerX = 0;
            enemy.lastPlayerY = 0;
            enemy.playerVelocity = { x: 0, y: 0 };
            enemy.damage = 1;
            enemy.reloadTime = 3000;
            enemy.baseReloadTime = 3000; // Í∏∞Î≥∏ Ïû¨Ïû•Ï†Ñ ÏãúÍ∞Ñ Ï†ÄÏû•
            enemy.reloadStartTime = 0;
            enemy.shootCooldown = 1000;

            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('augmentModal').style.display = 'none';
        }

        // Îë•Í∑º ÏÇ¨Í∞ÅÌòï Í∑∏Î¶¨Í∏∞ Ìó¨Ìçº Ìï®Ïàò
        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            // ÏÉÅÎã® ÏôºÏ™Ω
            ctx.moveTo(x + radius, y);
            // ÏÉÅÎã® Ïò§Î•∏Ï™Ω
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            // Ïò§Î•∏Ï™Ω ÏïÑÎûò
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            // ÏïÑÎûò ÏôºÏ™Ω
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            // ÏôºÏ™Ω ÏúÑ
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
        }

        // Ï≤¥Î†• ÌëúÏãú Í∑∏Î¶¨Í∏∞ (ÏßÅÏÇ¨Í∞ÅÌòï Î∞î)
        function drawHealthHearts(character, x, y, isPlayer) {
            const fixedBarWidth = 150; // Í≥†Ï†ïÎêú Î∞î Í∏∏Ïù¥ (200 -> 150)
            const barHeight = 20;
            const borderRadius = 4;
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: Ï∫êÎ¶≠ÌÑ∞Ïùò Ïã§Ï†ú ÏÉâÏÉÅ ÏÇ¨Ïö©, ÏÜîÎ°ú: Í∏∞Î≥∏ ÏÉâÏÉÅ
            const color = character.color || (isPlayer ? '#4a9eff' : '#e94560');
            
            // Î∞∞Í≤Ω (Îπà Î∞î)
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
            ctx.fill();
            ctx.restore();
            
            // Ï±ÑÏõåÏßÑ Î∂ÄÎ∂Ñ (Ïï†ÎãàÎ©îÏù¥ÏÖò) - Ìï≠ÏÉÅ ÎÑ§Ïò® Ìö®Í≥º Ï†ÅÏö©
            const fillRatio = Math.max(0, Math.min(1, character.displayHealth / character.maxHealth));
            const fillWidth = fixedBarWidth * fillRatio;
            
            if (fillWidth > 0) {
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.fillStyle = color;
                // Î∂ÄÎ∂Ñ Ï±ÑÏö∞Í∏∞Î•º ÏúÑÌï¥ ÌÅ¥Î¶¨Ìïë ÏÇ¨Ïö©
                if (fillWidth < fixedBarWidth) {
                    ctx.save();
                    ctx.beginPath();
                    drawRoundedRect(x, y, fillWidth, barHeight, borderRadius);
                    ctx.clip();
                    drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                    ctx.fill();
                    ctx.restore();
                } else {
                    drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
                    ctx.fill();
                }
                ctx.restore();
            }
            
            // ÌÖåÎëêÎ¶¨ - Ìï≠ÏÉÅ ÎÑ§Ïò® Ìö®Í≥º Ï†ÅÏö©
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            drawRoundedRect(x, y, fixedBarWidth, barHeight, borderRadius);
            ctx.stroke();
            ctx.restore();
        }

        // Ï¶ùÍ∞ï ÏïÑÏù¥ÏΩò Í∑∏Î¶¨Í∏∞
        function drawAugmentIcon(ctx, x, y, size, augId) {
            ctx.save();
            ctx.translate(x, y);
            ctx.shadowBlur = 8; // Í∏∞Î≥∏ ÎÑ§Ïò® Ìö®Í≥º
            
            switch(augId) {
                case 'health':
                    // Ï≤¥Î†•: ÌòÑÎåÄÏ†ÅÏù∏ ÌïòÌä∏ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìö®Í≥º)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff006e';
                    const healthGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                    healthGradient.addColorStop(0, '#ff3399');
                    healthGradient.addColorStop(1, '#ff006e');
                    ctx.fillStyle = healthGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.1);
                    ctx.bezierCurveTo(-size * 0.35, -size * 0.2, -size * 0.35, -size * 0.35, 0, -size * 0.2);
                    ctx.bezierCurveTo(size * 0.35, -size * 0.35, size * 0.35, -size * 0.2, 0, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'speed':
                    // ÏÜçÎèÑ: ÌòÑÎåÄÏ†ÅÏù∏ Ïù¥Ï§ë ÌôîÏÇ¥Ìëú (ÏúÑÏïÑÎûò)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ff88';
                    ctx.fillStyle = '#00ff88';
                    // ÏúÑÏ™Ω ÌôîÏÇ¥Ìëú
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.35);
                    ctx.lineTo(-size * 0.2, -size * 0.1);
                    ctx.lineTo(-size * 0.1, -size * 0.1);
                    ctx.lineTo(-size * 0.1, size * 0.05);
                    ctx.lineTo(size * 0.1, size * 0.05);
                    ctx.lineTo(size * 0.1, -size * 0.1);
                    ctx.lineTo(size * 0.2, -size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    // ÏïÑÎûòÏ™Ω ÌôîÏÇ¥Ìëú
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.35);
                    ctx.lineTo(-size * 0.2, size * 0.1);
                    ctx.lineTo(-size * 0.1, size * 0.1);
                    ctx.lineTo(-size * 0.1, -size * 0.05);
                    ctx.lineTo(size * 0.1, -size * 0.05);
                    ctx.lineTo(size * 0.1, size * 0.1);
                    ctx.lineTo(size * 0.2, size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bulletSpeed':
                    // Ï¥ùÏïå ÏÜçÎèÑ: ÌòÑÎåÄÏ†ÅÏù∏ Î≤àÍ∞ú (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffaa00';
                    const bulletSpeedGradient = ctx.createLinearGradient(-size * 0.2, -size * 0.4, size * 0.2, size * 0.4);
                    bulletSpeedGradient.addColorStop(0, '#ffcc44');
                    bulletSpeedGradient.addColorStop(0.5, '#ffaa00');
                    bulletSpeedGradient.addColorStop(1, '#ff8800');
                    ctx.fillStyle = bulletSpeedGradient;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, -size * 0.4);
                    ctx.lineTo(size * 0.08, -size * 0.15);
                    ctx.lineTo(-size * 0.08, -size * 0.1);
                    ctx.lineTo(size * 0.12, size * 0.15);
                    ctx.lineTo(-size * 0.1, size * 0.35);
                    ctx.lineTo(0, size * 0.15);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'ammo':
                    // ÌÉÑÏïΩ: ÌòÑÎåÄÏ†ÅÏù∏ Ï¥ùÏïå ÏïÑÏù¥ÏΩò (Ïõê + ÏÇºÍ∞ÅÌòï)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff';
                    // Ï¥ùÏïå Î≥∏Ï≤¥ (Ïõê)
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Ï¥ùÏïå ÎÅù (ÏÇºÍ∞ÅÌòï)
                    ctx.beginPath();
                    ctx.moveTo(size * 0.3, 0);
                    ctx.lineTo(size * 0.45, -size * 0.15);
                    ctx.lineTo(size * 0.45, size * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'fireRate':
                    // Î∞úÏÇ¨ ÏÜçÎèÑ: ÌòÑÎåÄÏ†ÅÏù∏ Î≥Ñ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff00ff';
                    const fireRateGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                    fireRateGradient.addColorStop(0, '#ff66ff');
                    fireRateGradient.addColorStop(1, '#ff00ff');
                    ctx.fillStyle = fireRateGradient;
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.4 : size * 0.18;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'reload':
                    // Ïû¨Ïû•Ï†Ñ: ÌòÑÎåÄÏ†ÅÏù∏ ÏãúÍ≥Ñ (ÏõêÌòï + Î∞îÎäò)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ffff';
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2.5;
                    ctx.lineCap = 'round';
                    // ÏãúÍ≥Ñ Ïô∏Í≥Ω
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.stroke();
                    // ÏãúÍ≥Ñ Î∞îÎäò (Î∂ÑÏπ®)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -size * 0.28);
                    ctx.stroke();
                    // ÏãúÍ≥Ñ Î∞îÎäò (ÏãúÏπ®)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.18, size * 0.05);
                    ctx.stroke();
                    // Ï§ëÏïô Ï†ê
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'critical':
                    // ÌÅ¨Î¶¨Ìã∞Ïª¨: ÌòÑÎåÄÏ†ÅÏù∏ X ÌëúÏãú (ÎëêÍ∫ºÏö¥ ÏÑ†)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff0000';
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.32, -size * 0.32);
                    ctx.lineTo(size * 0.32, size * 0.32);
                    ctx.moveTo(size * 0.32, -size * 0.32);
                    ctx.lineTo(-size * 0.32, size * 0.32);
                    ctx.stroke();
                    break;
                case 'doubleShot':
                    // ÎçîÎ∏îÏÉ∑: ÌòÑÎåÄÏ†ÅÏù∏ Îëê Í∞úÏùò Ï¥ùÏïå (Ïõê + ÏÇºÍ∞ÅÌòï)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffc107';
                    ctx.fillStyle = '#ffc107';
                    // ÏôºÏ™Ω Ï¥ùÏïå
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, 0, size * 0.22, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.02, 0);
                    ctx.lineTo(-size * 0.12, -size * 0.12);
                    ctx.lineTo(-size * 0.12, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // Ïò§Î•∏Ï™Ω Ï¥ùÏïå
                    ctx.beginPath();
                    ctx.arc(size * 0.2, 0, size * 0.22, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(size * 0.02, 0);
                    ctx.lineTo(size * 0.12, -size * 0.12);
                    ctx.lineTo(size * 0.12, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'dodge':
                    // Íµ¨Î•¥Í∏∞: ÌòÑÎåÄÏ†ÅÏù∏ ÎåÄÏãúÏÑ† (ÌôîÏÇ¥Ìëú Ìè¨Ìï®)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#8888ff';
                    ctx.strokeStyle = '#8888ff';
                    ctx.fillStyle = '#8888ff';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.35, 0);
                    ctx.lineTo(size * 0.2, 0);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    // ÌôîÏÇ¥Ìëú Î®∏Î¶¨
                    ctx.beginPath();
                    ctx.moveTo(size * 0.2, 0);
                    ctx.lineTo(size * 0.35, -size * 0.12);
                    ctx.lineTo(size * 0.35, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'revive':
                    // Î∂ÄÌôú: ÌòÑÎåÄÏ†ÅÏù∏ Ïã≠ÏûêÍ∞Ä (Îë•Í∑º Î™®ÏÑúÎ¶¨)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#00ff88';
                    ctx.fillStyle = '#00ff88';
                    // ÏÑ∏Î°ú ÎßâÎåÄ
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.12, -size * 0.4, size * 0.24, size * 0.8, size * 0.05);
                    ctx.fill();
                    // Í∞ÄÎ°ú ÎßâÎåÄ
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.4, -size * 0.12, size * 0.8, size * 0.24, size * 0.05);
                    ctx.fill();
                    break;
                case 'deepWound':
                    // ÍπäÏùÄ ÏÉÅÏ≤ò: ÌòÑÎåÄÏ†ÅÏù∏ Ïπº (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#880000';
                    const deepWoundGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.3);
                    deepWoundGradient.addColorStop(0, '#aa0000');
                    deepWoundGradient.addColorStop(1, '#660000');
                    ctx.fillStyle = deepWoundGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(-size * 0.12, size * 0.15);
                    ctx.lineTo(0, size * 0.3);
                    ctx.lineTo(size * 0.12, size * 0.15);
                    ctx.closePath();
                    ctx.fill();
                    // ÏπºÎÇ† Í∞ïÏ°∞ÏÑ†
                    ctx.strokeStyle = '#cc0000';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.4);
                    ctx.lineTo(0, size * 0.25);
                    ctx.stroke();
                    break;
                case 'giant':
                    // Í±∞ÎåÄÌôî: ÌòÑÎåÄÏ†ÅÏù∏ ÌÅ∞ ÏÇ¨Í∞ÅÌòï (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#8B4513';
                    const giantGradient = ctx.createLinearGradient(-size * 0.4, -size * 0.4, size * 0.4, size * 0.4);
                    giantGradient.addColorStop(0, '#A0522D');
                    giantGradient.addColorStop(1, '#8B4513');
                    ctx.fillStyle = giantGradient;
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.38, -size * 0.38, size * 0.76, size * 0.76, size * 0.08);
                    ctx.fill();
                    // ÎÇ¥Î∂Ä ÏûëÏùÄ ÏÇ¨Í∞ÅÌòï
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.24, -size * 0.24, size * 0.48, size * 0.48, size * 0.05);
                    ctx.fill();
                    break;
                case 'sniper':
                    // Ï†ÄÍ≤©Ïàò: ÌòÑÎåÄÏ†ÅÏù∏ Ïä§ÏΩîÌîÑ (ÏõêÌòï + Ïã≠ÏûêÏÑ†)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#333333';
                    ctx.strokeStyle = '#555555';
                    ctx.lineWidth = 2.5;
                    // Ïô∏Î∂Ä Ïõê
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.stroke();
                    // ÎÇ¥Î∂Ä Ïõê
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    // Ïã≠ÏûêÏÑ†
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.38, 0);
                    ctx.lineTo(size * 0.38, 0);
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(0, size * 0.38);
                    ctx.stroke();
                    // Ï§ëÏïô Ï†ê
                    ctx.fillStyle = '#ff0000';
                    ctx.shadowColor = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'oneShotOneKill':
                    // ÏõêÏÉ∑ÏõêÌÇ¨: ÌòÑÎåÄÏ†ÅÏù∏ ÌÅ∞ Ï¥ùÏïå (Í∑∏ÎùºÎç∞Ïù¥ÏÖò + X)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0000';
                    const oskGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.35);
                    oskGradient.addColorStop(0, '#ff4444');
                    oskGradient.addColorStop(1, '#cc0000');
                    ctx.fillStyle = oskGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.33, 0, Math.PI * 2);
                    ctx.fill();
                    // Ï§ëÏïô X (ÎëêÍ∫ºÏö¥ ÏÑ†)
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.22, -size * 0.22);
                    ctx.lineTo(size * 0.22, size * 0.22);
                    ctx.moveTo(size * 0.22, -size * 0.22);
                    ctx.lineTo(-size * 0.22, size * 0.22);
                    ctx.stroke();
                    break;
                case 'poisonBullet':
                    // ÎèÖ ÌÉÑÌôò: ÌòÑÎåÄÏ†ÅÏù∏ ÎèÖ Î∞©Ïö∏ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#00aa00';
                    const poisonGradient = ctx.createRadialGradient(0, -size * 0.1, 0, 0, -size * 0.1, size * 0.3);
                    poisonGradient.addColorStop(0, '#00cc00');
                    poisonGradient.addColorStop(1, '#006600');
                    ctx.fillStyle = poisonGradient;
                    // ÌÅ∞ Î∞©Ïö∏
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.1, size * 0.28, 0, Math.PI * 2);
                    ctx.fill();
                    // ÏûëÏùÄ Î∞©Ïö∏Îì§
                    ctx.fillStyle = '#00aa00';
                    ctx.beginPath();
                    ctx.arc(-size * 0.18, size * 0.12, size * 0.14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.18, size * 0.12, size * 0.14, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'reloadHeal':
                    // Ïû¨Ïû•Ï†Ñ ÌöåÎ≥µ: ÌòÑÎåÄÏ†ÅÏù∏ ÌïòÌä∏ + ÌôîÏÇ¥Ìëú
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff006e';
                    const reloadHealGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
                    reloadHealGradient.addColorStop(0, '#ff3399');
                    reloadHealGradient.addColorStop(1, '#ff006e');
                    ctx.fillStyle = reloadHealGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.12);
                    ctx.bezierCurveTo(-size * 0.28, -size * 0.08, -size * 0.28, -size * 0.25, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.28, -size * 0.25, size * 0.28, -size * 0.08, 0, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // ÌôîÏÇ¥Ìëú (Ïò§Î•∏Ï™Ω)
                    ctx.shadowColor = '#00ff00';
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(size * 0.25, 0);
                    ctx.lineTo(size * 0.1, -size * 0.18);
                    ctx.lineTo(size * 0.1, size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bigBullet':
                    // ÌÅ∞ ÌÉÑÌôò: ÌòÑÎåÄÏ†ÅÏù∏ ÌÅ∞ Ï¥ùÏïå (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffffff';
                    const bigBulletGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                    bigBulletGradient.addColorStop(0, '#ffffff');
                    bigBulletGradient.addColorStop(0.7, '#cccccc');
                    bigBulletGradient.addColorStop(1, '#999999');
                    ctx.fillStyle = bigBulletGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.fill();
                    // ÎÇ¥Î∂Ä ÏûëÏùÄ Ïõê (ÌïòÏù¥ÎùºÏù¥Ìä∏)
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, -size * 0.15, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'survivalInstinct':
                    // ÏÉùÏ°¥Î≥∏Îä•: ÌòÑÎåÄÏ†ÅÏù∏ Î≤àÍ∞ú + ÌïòÌä∏
                    ctx.shadowBlur = 12;
                    // Î≤àÍ∞ú
                    ctx.shadowColor = '#ffaa00';
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.15, -size * 0.32);
                    ctx.lineTo(size * 0.08, -size * 0.12);
                    ctx.lineTo(-size * 0.08, -size * 0.08);
                    ctx.lineTo(size * 0.15, size * 0.25);
                    ctx.lineTo(-size * 0.1, size * 0.32);
                    ctx.lineTo(0, size * 0.12);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    // ÌïòÌä∏
                    ctx.shadowColor = '#ff006e';
                    const survivalHeartGradient = ctx.createRadialGradient(0, size * 0.15, 0, 0, size * 0.15, size * 0.25);
                    survivalHeartGradient.addColorStop(0, '#ff3399');
                    survivalHeartGradient.addColorStop(1, '#ff006e');
                    ctx.fillStyle = survivalHeartGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.2);
                    ctx.bezierCurveTo(-size * 0.22, -size * 0.08, -size * 0.22, -size * 0.2, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.22, -size * 0.2, size * 0.22, -size * 0.08, 0, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'lastBullet':
                    // ÎπÑÏû•Ïùò ÌïúÎ∞ú: ÌòÑÎåÄÏ†ÅÏù∏ ÌÅ∞ Ï¥ùÏïå + Î≥Ñ
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff0000';
                    const lastBulletGradient = ctx.createLinearGradient(-size * 0.3, 0, size * 0.3, 0);
                    lastBulletGradient.addColorStop(0, '#ff4444');
                    lastBulletGradient.addColorStop(1, '#cc0000');
                    ctx.fillStyle = lastBulletGradient;
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.28, -size * 0.14, size * 0.56, size * 0.28, size * 0.05);
                    ctx.fill();
                    // Î≥Ñ
                    ctx.shadowColor = '#ffc107';
                    ctx.fillStyle = '#ffc107';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.18 : size * 0.09;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'recoveryContract':
                    // ÌöåÎ≥µÍ≥ÑÏïΩ: ÌòÑÎåÄÏ†ÅÏù∏ ÌïòÌä∏ + ÌôîÏÇ¥Ìëú ÏúÑ
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#00ff00';
                    const recoveryGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
                    recoveryGradient.addColorStop(0, '#44ff44');
                    recoveryGradient.addColorStop(1, '#00aa00');
                    ctx.fillStyle = recoveryGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.12);
                    ctx.bezierCurveTo(-size * 0.28, -size * 0.08, -size * 0.28, -size * 0.25, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.28, -size * 0.25, size * 0.28, -size * 0.08, 0, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // ÌôîÏÇ¥Ìëú ÏúÑ
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.32);
                    ctx.lineTo(-size * 0.18, -size * 0.12);
                    ctx.lineTo(size * 0.18, -size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'focusedFire':
                    // ÏßëÏ§ë ÏÇ¨Í≤©: ÌòÑÎåÄÏ†ÅÏù∏ Îàà Î™®Ïñë (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffff00';
                    // ÏôºÏ™Ω Îàà
                    const leftEyeGradient = ctx.createRadialGradient(-size * 0.15, 0, 0, -size * 0.15, 0, size * 0.2);
                    leftEyeGradient.addColorStop(0, '#ffff88');
                    leftEyeGradient.addColorStop(1, '#ffff00');
                    ctx.fillStyle = leftEyeGradient;
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, 0, size * 0.18, 0, Math.PI * 2);
                    ctx.fill();
                    // Ïò§Î•∏Ï™Ω Îàà
                    const rightEyeGradient = ctx.createRadialGradient(size * 0.15, 0, 0, size * 0.15, 0, size * 0.2);
                    rightEyeGradient.addColorStop(0, '#ffff88');
                    rightEyeGradient.addColorStop(1, '#ffff00');
                    ctx.fillStyle = rightEyeGradient;
                    ctx.beginPath();
                    ctx.arc(size * 0.15, 0, size * 0.18, 0, Math.PI * 2);
                    ctx.fill();
                    // ÎèôÍ≥µ
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-size * 0.15, 0, size * 0.09, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.15, 0, size * 0.09, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'ghost':
                    // Ïú†Î†π: ÌòÑÎåÄÏ†ÅÏù∏ Î∞òÌà¨Î™Ö Ïõê + ÏûëÏùÄ ÏõêÎì§ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#cccccc';
                    ctx.globalAlpha = 0.75;
                    const ghostGradient = ctx.createRadialGradient(0, -size * 0.1, 0, 0, -size * 0.1, size * 0.3);
                    ghostGradient.addColorStop(0, '#eeeeee');
                    ghostGradient.addColorStop(1, '#aaaaaa');
                    ctx.fillStyle = ghostGradient;
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.1, size * 0.28, 0, Math.PI * 2);
                    ctx.fill();
                    // ÏûëÏùÄ ÏõêÎì§ (Ïú†Î†π ÎäêÎÇå)
                    ctx.fillStyle = '#cccccc';
                    ctx.beginPath();
                    ctx.arc(-size * 0.16, size * 0.12, size * 0.14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.16, size * 0.12, size * 0.14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    break;
                case 'fortify':
                    // Í±∞Ï†êÌôïÎ≥¥: ÌòÑÎåÄÏ†ÅÏù∏ Î∞©Ìå® Î™®Ïñë (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffffff';
                    const fortifyGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.3);
                    fortifyGradient.addColorStop(0, '#ffffff');
                    fortifyGradient.addColorStop(1, '#cccccc');
                    ctx.fillStyle = fortifyGradient;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2.5;
                    // Î∞©Ìå® Î≥∏Ï≤¥
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.28, -size * 0.18);
                    ctx.lineTo(-size * 0.28, size * 0.18);
                    ctx.lineTo(0, size * 0.28);
                    ctx.lineTo(size * 0.28, size * 0.18);
                    ctx.lineTo(size * 0.28, -size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // Ïã≠ÏûêÍ∞Ä
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.2);
                    ctx.lineTo(0, size * 0.1);
                    ctx.moveTo(-size * 0.16, -size * 0.05);
                    ctx.lineTo(size * 0.16, -size * 0.05);
                    ctx.stroke();
                    break;
                case 'overheat':
                    // Í≥ºÏó¥: ÌòÑÎåÄÏ†ÅÏù∏ Î∂àÍΩÉ Î™®Ïñë (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff6600';
                    const overheatGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.2);
                    overheatGradient.addColorStop(0, '#ffaa00');
                    overheatGradient.addColorStop(0.5, '#ff6600');
                    overheatGradient.addColorStop(1, '#ff4400');
                    ctx.fillStyle = overheatGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.18, -size * 0.08);
                    ctx.lineTo(-size * 0.14, size * 0.12);
                    ctx.lineTo(0, size * 0.18);
                    ctx.lineTo(size * 0.14, size * 0.12);
                    ctx.lineTo(size * 0.18, -size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    // ÏûëÏùÄ Î∂àÍΩÉÎì§
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffaa00';
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.18);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.lineTo(0, -size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(size * 0.1, -size * 0.18);
                    ctx.lineTo(size * 0.05, 0);
                    ctx.lineTo(0, -size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'gamble':
                    // ÎèÑÎ∞ï: ÌòÑÎåÄÏ†ÅÏù∏ Ï£ºÏÇ¨ÏúÑ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò + Í∑∏Î¶ºÏûê)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    const gambleGradient = ctx.createLinearGradient(-size * 0.3, -size * 0.3, size * 0.3, size * 0.3);
                    gambleGradient.addColorStop(0, '#ffffff');
                    gambleGradient.addColorStop(1, '#dddddd');
                    ctx.fillStyle = gambleGradient;
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.28, -size * 0.28, size * 0.56, size * 0.56, size * 0.08);
                    ctx.fill();
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.28, -size * 0.28, size * 0.56, size * 0.56, size * 0.08);
                    ctx.stroke();
                    // Ï£ºÏÇ¨ÏúÑ Îàà (Îçî ÌòÑÎåÄÏ†ÅÏúºÎ°ú)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-size * 0.16, -size * 0.16, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size * 0.16, size * 0.16, size * 0.06, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'weaken':
                    // ÏïΩÌôî: ÌòÑÎåÄÏ†ÅÏù∏ ÏïÑÎûò ÌôîÏÇ¥Ìëú (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#888888';
                    const weakenGradient = ctx.createLinearGradient(0, -size * 0.3, 0, size * 0.1);
                    weakenGradient.addColorStop(0, '#aaaaaa');
                    weakenGradient.addColorStop(1, '#666666');
                    ctx.fillStyle = weakenGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.28);
                    ctx.lineTo(-size * 0.18, size * 0.08);
                    ctx.lineTo(-size * 0.08, size * 0.08);
                    ctx.lineTo(-size * 0.08, size * 0.15);
                    ctx.lineTo(size * 0.08, size * 0.15);
                    ctx.lineTo(size * 0.08, size * 0.08);
                    ctx.lineTo(size * 0.18, size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    // Í∞êÏÜå ÌëúÏãú (Îπ®Í∞Ñ ÏÑ†)
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.16, size * 0.18);
                    ctx.lineTo(size * 0.16, size * 0.18);
                    ctx.stroke();
                    break;
                case 'damageBoost':
                    // Îç∞ÎØ∏ÏßÄ 1.2Î∞∞: ÌòÑÎåÄÏ†ÅÏù∏ ÏúÑ ÌôîÏÇ¥Ìëú (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff6600';
                    const damageBoostGradient = ctx.createLinearGradient(0, size * 0.3, 0, -size * 0.1);
                    damageBoostGradient.addColorStop(0, '#ff8800');
                    damageBoostGradient.addColorStop(1, '#ff4400');
                    ctx.fillStyle = damageBoostGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.28);
                    ctx.lineTo(-size * 0.18, -size * 0.08);
                    ctx.lineTo(-size * 0.08, -size * 0.08);
                    ctx.lineTo(-size * 0.08, -size * 0.15);
                    ctx.lineTo(size * 0.08, -size * 0.15);
                    ctx.lineTo(size * 0.08, -size * 0.08);
                    ctx.lineTo(size * 0.18, -size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    // Ï¶ùÍ∞Ä ÌëúÏãú (Ï¥àÎ°ù ÏÑ†)
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.16, -size * 0.18);
                    ctx.lineTo(size * 0.16, -size * 0.18);
                    ctx.stroke();
                    break;
                case 'lightning':
                    // Î≤àÍ∞ú: ÌòÑÎåÄÏ†ÅÏù∏ Î≤àÍ∞ú (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffff00';
                    const lightningGradient = ctx.createLinearGradient(-size * 0.1, -size * 0.4, size * 0.15, size * 0.3);
                    lightningGradient.addColorStop(0, '#ffff88');
                    lightningGradient.addColorStop(0.5, '#ffff00');
                    lightningGradient.addColorStop(1, '#ffaa00');
                    ctx.fillStyle = lightningGradient;
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.08, -size * 0.38);
                    ctx.lineTo(size * 0.08, -size * 0.18);
                    ctx.lineTo(-size * 0.05, -size * 0.08);
                    ctx.lineTo(size * 0.14, size * 0.18);
                    ctx.lineTo(-size * 0.1, size * 0.28);
                    ctx.lineTo(0, size * 0.12);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'shield':
                    // Î∞©Ïñ¥Îßâ: ÌòÑÎåÄÏ†ÅÏù∏ Î∞©Ìå® Î™®Ïñë (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0066ff';
                    const shieldGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.3);
                    shieldGradient.addColorStop(0, '#3399ff');
                    shieldGradient.addColorStop(1, '#0044cc');
                    ctx.fillStyle = shieldGradient;
                    ctx.strokeStyle = '#0044cc';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.28, -size * 0.18);
                    ctx.lineTo(-size * 0.28, size * 0.12);
                    ctx.lineTo(0, size * 0.28);
                    ctx.lineTo(size * 0.28, size * 0.12);
                    ctx.lineTo(size * 0.28, -size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // ÌïòÏù¥ÎùºÏù¥Ìä∏
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.14, -size * 0.18);
                    ctx.lineTo(0, size * 0.05);
                    ctx.lineTo(size * 0.14, -size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'regeneration':
                    // Ïû¨ÏÉù: ÌòÑÎåÄÏ†ÅÏù∏ ÌïòÌä∏ + ÌîåÎü¨Ïä§ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff006e';
                    const regenGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.25);
                    regenGradient.addColorStop(0, '#ff3399');
                    regenGradient.addColorStop(1, '#ff006e');
                    ctx.fillStyle = regenGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.12);
                    ctx.bezierCurveTo(-size * 0.24, -size * 0.08, -size * 0.24, -size * 0.25, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.24, -size * 0.25, size * 0.24, -size * 0.08, 0, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // ÌîåÎü¨Ïä§ ÌëúÏãú (Îë•Í∑º Î™®ÏÑúÎ¶¨)
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.1, -size * 0.05, size * 0.2, size * 0.03, size * 0.01);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.05, -size * 0.1, size * 0.03, size * 0.2, size * 0.01);
                    ctx.fill();
                    break;
                case 'shotgun':
                    // ÏÉ∑Í±¥: ÌòÑÎåÄÏ†ÅÏù∏ ÏÇ∞ÌÉÑÏ¥ù Î™®Ïñë (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#8B4513';
                    const shotgunGradient = ctx.createLinearGradient(-size * 0.4, 0, size * 0.4, 0);
                    shotgunGradient.addColorStop(0, '#A0522D');
                    shotgunGradient.addColorStop(1, '#654321');
                    ctx.fillStyle = shotgunGradient;
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.38, -size * 0.1, size * 0.76, size * 0.2, size * 0.03);
                    ctx.fill();
                    ctx.fillStyle = '#4a2c1a';
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.34, -size * 0.05, size * 0.68, size * 0.1, size * 0.02);
                    ctx.fill();
                    // Ï¥ùÍµ¨
                    ctx.fillStyle = '#333333';
                    ctx.beginPath();
                    ctx.arc(size * 0.38, 0, size * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'ragged':
                    // Îã§Îã§ÏùµÏÑ†: ÌòÑÎåÄÏ†ÅÏù∏ Íπ®ÏßÑ Ï¥ùÏïå (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#888888';
                    const raggedGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
                    raggedGradient.addColorStop(0, '#aaaaaa');
                    raggedGradient.addColorStop(1, '#666666');
                    ctx.fillStyle = raggedGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.28, 0, Math.PI * 2);
                    ctx.fill();
                    // Íπ®ÏßÑ ÏÑ† (X)
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.22, -size * 0.22);
                    ctx.lineTo(size * 0.22, size * 0.22);
                    ctx.moveTo(size * 0.22, -size * 0.22);
                    ctx.lineTo(-size * 0.22, size * 0.22);
                    ctx.stroke();
                    break;
                case 'evasiveManeuver':
                    // ÌöåÌîºÍ∏∞Îèô: ÌòÑÎåÄÏ†ÅÏù∏ ÌôîÏÇ¥Ìëú + Î≤àÍ∞ú
                    ctx.shadowBlur = 12;
                    // ÌôîÏÇ¥Ìëú
                    ctx.shadowColor = '#4a9eff';
                    const evasiveGradient = ctx.createLinearGradient(0, -size * 0.3, 0, size * 0.1);
                    evasiveGradient.addColorStop(0, '#66b3ff');
                    evasiveGradient.addColorStop(1, '#3399ff');
                    ctx.fillStyle = evasiveGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.28);
                    ctx.lineTo(-size * 0.18, size * 0.08);
                    ctx.lineTo(-size * 0.08, size * 0.08);
                    ctx.lineTo(-size * 0.08, size * 0.15);
                    ctx.lineTo(size * 0.08, size * 0.15);
                    ctx.lineTo(size * 0.08, size * 0.08);
                    ctx.lineTo(size * 0.18, size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    // Î≤àÍ∞ú (X)
                    ctx.shadowColor = '#ffff00';
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.12, -size * 0.12);
                    ctx.lineTo(size * 0.12, size * 0.12);
                    ctx.moveTo(size * 0.12, -size * 0.12);
                    ctx.lineTo(-size * 0.12, size * 0.12);
                    ctx.stroke();
                    break;
                case 'combatExperience':
                    // Ï†ÑÌà¨ Í≤ΩÌóò: ÌòÑÎåÄÏ†ÅÏù∏ Î≥Ñ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffaa00';
                    const combatGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
                    combatGradient.addColorStop(0, '#ffcc44');
                    combatGradient.addColorStop(1, '#ff8800');
                    ctx.fillStyle = combatGradient;
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? size * 0.32 : size * 0.16;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'hallucination':
                    // ÌôòÍ∞Å: ÌòÑÎåÄÏ†ÅÏù∏ Î¨ºÍ≤∞ Î™®Ïñë (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff00ff';
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    for (let i = -size * 0.38; i <= size * 0.38; i += 4) {
                        const y = Math.sin(i * 0.25) * size * 0.22;
                        if (i === -size * 0.38) ctx.moveTo(i, y);
                        else ctx.lineTo(i, y);
                    }
                    ctx.stroke();
                    // Îëê Î≤àÏß∏ Î¨ºÍ≤∞
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    for (let i = -size * 0.38; i <= size * 0.38; i += 4) {
                        const y = Math.sin(i * 0.25 + Math.PI) * size * 0.15;
                        if (i === -size * 0.38) ctx.moveTo(i, y);
                        else ctx.lineTo(i, y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    break;
                case 'tasteOfBlood':
                    // ÌîºÏùò Îßõ: ÌòÑÎåÄÏ†ÅÏù∏ Îπ®Í∞Ñ ÌïòÌä∏ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0000';
                    const bloodGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.25);
                    bloodGradient.addColorStop(0, '#ff4444');
                    bloodGradient.addColorStop(1, '#cc0000');
                    ctx.fillStyle = bloodGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.12);
                    ctx.bezierCurveTo(-size * 0.24, -size * 0.08, -size * 0.24, -size * 0.25, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.24, -size * 0.25, size * 0.24, -size * 0.08, 0, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // ÌïòÏù¥ÎùºÏù¥Ìä∏
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.08);
                    ctx.bezierCurveTo(-size * 0.12, -size * 0.15, -size * 0.12, -size * 0.2, 0, -size * 0.08);
                    ctx.bezierCurveTo(size * 0.12, -size * 0.2, size * 0.12, -size * 0.15, 0, -size * 0.08);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'cannon':
                    // ÎåÄÌè¨: ÌòÑÎåÄÏ†ÅÏù∏ ÌÅ∞ Ïõê (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#8B4513';
                    const cannonGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.4);
                    cannonGradient.addColorStop(0, '#A0522D');
                    cannonGradient.addColorStop(0.7, '#8B4513');
                    cannonGradient.addColorStop(1, '#654321');
                    ctx.fillStyle = cannonGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#4a2c1a';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.stroke();
                    // ÎÇ¥Î∂Ä Ïõê (Íµ¨Î©ç)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'timeBarrier':
                    // ÏãúÍ∞ÑÏû•Îßâ: ÌòÑÎåÄÏ†ÅÏù∏ Ïõê + ÏãúÍ≥Ñ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ff00';
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2.5;
                    ctx.globalAlpha = 0.6;
                    // Ïô∏Î∂Ä Ïõê
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.38, 0, Math.PI * 2);
                    ctx.stroke();
                    // ÎÇ¥Î∂Ä Ïõê
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    // ÏãúÍ≥Ñ Î∞îÎäò
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -size * 0.22);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.16, size * 0.08);
                    ctx.stroke();
                    // Ï§ëÏïô Ï†ê
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'bouncyBullet':
                    // ÌÜµÌÜµÌÉÑ: ÌòÑÎåÄÏ†ÅÏù∏ ÌäïÍ∏∞Îäî ÌôîÏÇ¥Ìëú (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffaa00';
                    const bouncyGradient = ctx.createLinearGradient(0, -size * 0.3, 0, size * 0.3);
                    bouncyGradient.addColorStop(0, '#ffcc44');
                    bouncyGradient.addColorStop(0.5, '#ffaa00');
                    bouncyGradient.addColorStop(1, '#ff8800');
                    ctx.fillStyle = bouncyGradient;
                    // ÏúÑÏ™Ω ÌôîÏÇ¥Ìëú
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.28);
                    ctx.lineTo(-size * 0.16, -size * 0.12);
                    ctx.lineTo(-size * 0.08, -size * 0.12);
                    ctx.lineTo(-size * 0.08, 0);
                    ctx.lineTo(size * 0.08, 0);
                    ctx.lineTo(size * 0.08, -size * 0.12);
                    ctx.lineTo(size * 0.16, -size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // ÏïÑÎûòÏ™Ω ÌôîÏÇ¥Ìëú (Î∞òÎåÄ Î∞©Ìñ•)
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.28);
                    ctx.lineTo(-size * 0.16, size * 0.12);
                    ctx.lineTo(-size * 0.08, size * 0.12);
                    ctx.lineTo(-size * 0.08, 0);
                    ctx.lineTo(size * 0.08, 0);
                    ctx.lineTo(size * 0.08, size * 0.12);
                    ctx.lineTo(size * 0.16, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'gamble2':
                    // Ïä§ÎÑ§Ïù¥ÌÅ¨: ÌòÑÎåÄÏ†ÅÏù∏ Íµ¨Î∂àÍµ¨Î∂àÌïú ÌôîÏÇ¥Ìëú (Î∞©Ìñ• Ï†ÑÌôò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffffff';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3.5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    // Íµ¨Î∂àÍµ¨Î∂àÌïú ÏÑ†
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, -size * 0.1);
                    ctx.quadraticCurveTo(-size * 0.1, 0, 0, size * 0.1);
                    ctx.quadraticCurveTo(size * 0.1, 0, size * 0.3, -size * 0.1);
                    ctx.stroke();
                    // ÌôîÏÇ¥Ìëú Î®∏Î¶¨
                    ctx.beginPath();
                    ctx.moveTo(size * 0.3, -size * 0.1);
                    ctx.lineTo(size * 0.35, -size * 0.18);
                    ctx.lineTo(size * 0.32, -size * 0.12);
                    ctx.lineTo(size * 0.38, -size * 0.12);
                    ctx.lineTo(size * 0.38, -size * 0.05);
                    ctx.lineTo(size * 0.32, -size * 0.05);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'reflect':
                    // Î∞òÏÇ¨: ÌòÑÎåÄÏ†ÅÏù∏ Î∞©Ìå® + ÌôîÏÇ¥Ìëú Î∞òÏÇ¨ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffffff';
                    const reflectGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.3);
                    reflectGradient.addColorStop(0, '#ffffff');
                    reflectGradient.addColorStop(1, '#cccccc');
                    ctx.fillStyle = reflectGradient;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2.5;
                    // Î∞©Ìå® Î≥∏Ï≤¥
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.28, -size * 0.18);
                    ctx.lineTo(-size * 0.28, size * 0.18);
                    ctx.lineTo(0, size * 0.28);
                    ctx.lineTo(size * 0.28, size * 0.18);
                    ctx.lineTo(size * 0.28, -size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // Î∞òÏÇ¨ ÌôîÏÇ¥Ìëú (ÎÖ∏ÎûÄÏÉâ)
                    ctx.shadowColor = '#ffff00';
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.22, 0);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size * 0.22, 0);
                    ctx.stroke();
                    // ÌôîÏÇ¥Ìëú Î®∏Î¶¨
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.moveTo(size * 0.22, 0);
                    ctx.lineTo(size * 0.32, -size * 0.12);
                    ctx.lineTo(size * 0.32, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'explosiveBullet':
                    // Ìè≠Î∞úÌÉÑ: Ìè≠Î∞ú ÏïÑÏù¥ÏΩò
                    ctx.fillStyle = '#ff8800';
                    ctx.shadowColor = '#ff8800';
                    // Ï§ëÏã¨ Ïõê
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    // Ìè≠Î∞úÏÑ†Îì§
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI * 2 / 8);
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * size * 0.15, Math.sin(angle) * size * 0.15);
                        ctx.lineTo(Math.cos(angle) * size * 0.35, Math.sin(angle) * size * 0.35);
                        ctx.strokeStyle = '#ff8800';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    break;
                case 'reaper':
                    // ÏÇ¨Ïã†: ÎÇ´ Î™®Ïñë
                    ctx.strokeStyle = '#333333';
                    ctx.shadowColor = '#333333';
                    ctx.lineWidth = 3;
                    // ÎÇ´ ÏÜêÏû°Ïù¥
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.3);
                    ctx.lineTo(0, size * 0.3);
                    ctx.stroke();
                    // ÎÇ´ ÎÇ†
                    ctx.beginPath();
                    ctx.arc(size * 0.1, -size * 0.2, size * 0.25, -Math.PI * 0.3, Math.PI * 0.7);
                    ctx.stroke();
                    break;
                case 'overcharge':
                    // Í≥ºÏ∂©Ï†Ñ: Î≤àÍ∞ú + Ïõê
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    // Î≤àÍ∞ú
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.1, -size * 0.3);
                    ctx.lineTo(size * 0.1, -size * 0.1);
                    ctx.lineTo(-size * 0.05, -size * 0.05);
                    ctx.lineTo(size * 0.15, size * 0.2);
                    ctx.lineTo(-size * 0.1, size * 0.3);
                    ctx.lineTo(0, size * 0.1);
                    ctx.lineTo(-size * 0.05, 0);
                    ctx.closePath();
                    ctx.fill();
                    // ÏõêÌòï ÌÖåÎëêÎ¶¨
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'victor':
                    // ÏäπÎ¶¨Ïûê: ÏôïÍ¥Ä
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowColor = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.3, size * 0.2);
                    ctx.lineTo(-size * 0.2, -size * 0.1);
                    ctx.lineTo(0, size * 0.1);
                    ctx.lineTo(size * 0.2, -size * 0.1);
                    ctx.lineTo(size * 0.3, size * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    // Î≥¥ÏÑù
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'timeStop':
                    // ÏãúÍ∞ÑÏ†ïÏßÄ: ÌòÑÎåÄÏ†ÅÏù∏ Î©àÏ∂§ ÏïÑÏù¥ÏΩò (pause icon, Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#888888';
                    const timeStopGradient = ctx.createLinearGradient(-size * 0.15, -size * 0.2, -size * 0.15, size * 0.2);
                    timeStopGradient.addColorStop(0, '#aaaaaa');
                    timeStopGradient.addColorStop(1, '#666666');
                    ctx.fillStyle = timeStopGradient;
                    // Îëê Í∞úÏùò ÏÑ∏Î°ú ÎßâÎåÄ (pause icon, Îë•Í∑º Î™®ÏÑúÎ¶¨)
                    ctx.beginPath();
                    ctx.roundRect(-size * 0.15, -size * 0.2, size * 0.1, size * 0.4, size * 0.02);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.roundRect(size * 0.05, -size * 0.2, size * 0.1, size * 0.4, size * 0.02);
                    ctx.fill();
                    break;
                case 'scatter':
                    // ÎπÑÏÇ∞ÌÉÑ: ÌòÑÎåÄÏ†ÅÏù∏ 4Î∞©Ìñ• ÌôîÏÇ¥Ìëú (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffaa00';
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI * 2 / 4) - Math.PI / 2;
                        const x = Math.cos(angle) * size * 0.25;
                        const y = Math.sin(angle) * size * 0.25;
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle);
                        const scatterGradient = ctx.createLinearGradient(0, -size * 0.15, 0, 0);
                        scatterGradient.addColorStop(0, '#ffcc44');
                        scatterGradient.addColorStop(1, '#ff8800');
                        ctx.fillStyle = scatterGradient;
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.16);
                        ctx.lineTo(-size * 0.08, -size * 0.06);
                        ctx.lineTo(-size * 0.04, -size * 0.06);
                        ctx.lineTo(-size * 0.04, 0);
                        ctx.lineTo(size * 0.04, 0);
                        ctx.lineTo(size * 0.04, -size * 0.06);
                        ctx.lineTo(size * 0.08, -size * 0.06);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    break;
                case 'rocket':
                    // Î°úÏºìÌÉÑ: ÌòÑÎåÄÏ†ÅÏù∏ Î°úÏºì Î™®Ïñë (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff6600';
                    const rocketGradient = ctx.createLinearGradient(0, -size * 0.4, 0, size * 0.3);
                    rocketGradient.addColorStop(0, '#ffaa00');
                    rocketGradient.addColorStop(0.5, '#ff6600');
                    rocketGradient.addColorStop(1, '#ff4400');
                    ctx.fillStyle = rocketGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.38);
                    ctx.lineTo(-size * 0.18, size * 0.18);
                    ctx.lineTo(0, size * 0.28);
                    ctx.lineTo(size * 0.18, size * 0.18);
                    ctx.closePath();
                    ctx.fill();
                    // Î∂àÍΩÉ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowColor = '#ffff00';
                    const flameGradient = ctx.createLinearGradient(0, size * 0.3, 0, size * 0.4);
                    flameGradient.addColorStop(0, '#ffff00');
                    flameGradient.addColorStop(1, '#ff6600');
                    ctx.fillStyle = flameGradient;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.14, size * 0.28);
                    ctx.lineTo(-size * 0.05, size * 0.38);
                    ctx.lineTo(0, size * 0.33);
                    ctx.lineTo(size * 0.05, size * 0.38);
                    ctx.lineTo(size * 0.14, size * 0.28);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'trinity':
                    // ÏÇºÏúÑÏùºÏ≤¥: ÌòÑÎåÄÏ†ÅÏù∏ ÏÑ∏ Í∞úÏùò ÏõêÏù¥ Ïó∞Í≤∞Îêú Î™®Ïñë (ÏÇºÍ∞ÅÌòï Î∞∞Ïπò, Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#9b59b6';
                    const trinityGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.2);
                    trinityGradient.addColorStop(0, '#bb77dd');
                    trinityGradient.addColorStop(1, '#7b39a6');
                    ctx.fillStyle = trinityGradient;
                    // ÏúÑÏ™Ω Ïõê
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.2, size * 0.16, 0, Math.PI * 2);
                    ctx.fill();
                    // ÏôºÏ™Ω ÏïÑÎûò Ïõê
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, size * 0.2, size * 0.16, 0, Math.PI * 2);
                    ctx.fill();
                    // Ïò§Î•∏Ï™Ω ÏïÑÎûò Ïõê
                    ctx.beginPath();
                    ctx.arc(size * 0.2, size * 0.2, size * 0.16, 0, Math.PI * 2);
                    ctx.fill();
                    // Ïó∞Í≤∞ÏÑ† (Îçî ÎëêÍªçÍ≥† Î∂ÄÎìúÎüΩÍ≤å)
                    ctx.strokeStyle = '#9b59b6';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.04);
                    ctx.lineTo(-size * 0.2, size * 0.04);
                    ctx.moveTo(0, -size * 0.04);
                    ctx.lineTo(size * 0.2, size * 0.04);
                    ctx.moveTo(-size * 0.2, size * 0.04);
                    ctx.lineTo(size * 0.2, size * 0.04);
                    ctx.stroke();
                    break;
                case 'judgment':
                    // ÏÑ†Í≥†: ÌòÑÎåÄÏ†ÅÏù∏ Ï∂©Í≤©Ìåå Î™®Ïñë (ÏõêÌòï ÌååÎèô, Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff4444';
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 3.5;
                    ctx.lineCap = 'round';
                    // Î∞îÍπ•Ï™Ω Ïõê
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                    // Ï§ëÍ∞Ñ Ïõê
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                    ctx.stroke();
                    // ÏïàÏ™Ω Ïõê
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    // Ï§ëÏïô ÌôîÏÇ¥Ìëú (Î∞ÄÏñ¥ÎÇ¥Îäî Î∞©Ìñ•, Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    const judgmentGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.35);
                    judgmentGradient.addColorStop(0, '#ff6666');
                    judgmentGradient.addColorStop(1, '#cc0000');
                    ctx.fillStyle = judgmentGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * 0.22, -size * 0.16);
                    ctx.lineTo(size * 0.16, -size * 0.12);
                    ctx.lineTo(size * 0.26, -size * 0.12);
                    ctx.lineTo(size * 0.26, -size * 0.22);
                    ctx.lineTo(size * 0.36, 0);
                    ctx.lineTo(size * 0.26, size * 0.22);
                    ctx.lineTo(size * 0.26, size * 0.12);
                    ctx.lineTo(size * 0.16, size * 0.12);
                    ctx.lineTo(size * 0.22, size * 0.16);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'boomerang':
                    // Î∂ÄÎß§Îûë: ÌòÑÎåÄÏ†ÅÏù∏ Î∂ÄÎ©îÎûë Î™®Ïñë (Í≥°ÏÑ† ÌôîÏÇ¥Ìëú, Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00aaff';
                    ctx.strokeStyle = '#00aaff';
                    ctx.lineWidth = 3.5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    // Î∂ÄÎ©îÎûë Î≥∏Ï≤¥ (Í≥°ÏÑ†, Îçî ÎëêÍªçÍ≤å)
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.32, -Math.PI * 0.3, Math.PI * 1.3);
                    ctx.stroke();
                    // ÌôîÏÇ¥Ìëú Î®∏Î¶¨ (ÎêòÎèåÏïÑÏò§Îäî Î∞©Ìñ•, Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
                    const boomerangGradient = ctx.createLinearGradient(size * 0.25, -size * 0.15, size * 0.4, -size * 0.15);
                    boomerangGradient.addColorStop(0, '#33ccff');
                    boomerangGradient.addColorStop(1, '#0088cc');
                    ctx.fillStyle = boomerangGradient;
                    ctx.beginPath();
                    ctx.moveTo(size * 0.26, -size * 0.16);
                    ctx.lineTo(size * 0.36, -size * 0.26);
                    ctx.lineTo(size * 0.32, -size * 0.22);
                    ctx.lineTo(size * 0.42, -size * 0.16);
                    ctx.lineTo(size * 0.32, -size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    // Î∞òÎåÄ Î∞©Ìñ• ÌôîÏÇ¥Ìëú (ÎèåÏïÑÏò§Îäî Î∞©Ìñ•)
                    const boomerangGradient2 = ctx.createLinearGradient(-size * 0.25, size * 0.15, -size * 0.4, size * 0.15);
                    boomerangGradient2.addColorStop(0, '#33ccff');
                    boomerangGradient2.addColorStop(1, '#0088cc');
                    ctx.fillStyle = boomerangGradient2;
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.26, size * 0.16);
                    ctx.lineTo(-size * 0.36, size * 0.26);
                    ctx.lineTo(-size * 0.32, size * 0.22);
                    ctx.lineTo(-size * 0.42, size * 0.16);
                    ctx.lineTo(-size * 0.32, size * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    break;
                default:
                    // Í∏∞Î≥∏: ÏÇ¨Í∞ÅÌòï
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(-size * 0.3, -size * 0.3, size * 0.6, size * 0.6);
            }
            
            ctx.restore();
        }

        // Ï¶ùÍ∞ï ÏïÑÏù¥ÏΩò Î™©Î°ù Í∑∏Î¶¨Í∏∞
        function drawAugmentIcons(character, x, y, align = 'left') {
            const iconSize = 32; // 2Î∞∞ Ï¶ùÍ∞Ä (16 -> 32)
            const spacing = 8; // Í∞ÑÍ≤©ÎèÑ 2Î∞∞ Ï¶ùÍ∞Ä
            const bgSize = iconSize + 4; // Î∞∞Í≤Ω ÌÅ¨Í∏∞
            
            // ÎßàÏö∞Ïä§ Ìò∏Î≤Ñ Í∞êÏßÄ
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseCanvasX = (mouse.x - rect.left) * scaleX;
            const mouseCanvasY = (mouse.y - rect.top) * scaleY;
            
            character.augmentations.forEach((aug, index) => {
                let iconX;
                if (align === 'right') {
                    iconX = x - (character.augmentations.length - index - 1) * (iconSize + spacing) - iconSize / 2;
                } else {
                    iconX = x + index * (iconSize + spacing) + iconSize / 2;
                }
                
                // ÎßàÏö∞Ïä§ Ìò∏Î≤Ñ Ï≤¥ÌÅ¨
                const iconLeft = iconX - bgSize / 2;
                const iconRight = iconX + bgSize / 2;
                const iconTop = y - bgSize / 2;
                const iconBottom = y + bgSize / 2;
                
                if (mouseCanvasX >= iconLeft && mouseCanvasX <= iconRight &&
                    mouseCanvasY >= iconTop && mouseCanvasY <= iconBottom) {
                    hoveredAugment = {
                        aug: aug,
                        x: iconX,
                        y: y
                    };
                }
                
                // Î∞∞Í≤Ω ÏÇ¨Í∞ÅÌòï (Ìò∏Î≤Ñ Ïãú Í∞ïÏ°∞)
                if (hoveredAugment && hoveredAugment.aug === aug) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                }
                ctx.fillRect(iconX - bgSize / 2, y - bgSize / 2, bgSize, bgSize);
                
                // ÏïÑÏù¥ÏΩò Í∑∏Î¶¨Í∏∞
                drawAugmentIcon(ctx, iconX, y, iconSize, aug.id);
            });
        }

        // ÌÉÑÌôòÏàò ÌëúÏãú (Ï≤¥Î†• ÏïÑÎûò - ÌïòÏñÄÏÉâ Ïõê)
        function drawAmmoCount(character, x, y, align = 'left') {
            const circleSize = 12; // Ï≤¥Î†•Î∞î(30px)Î≥¥Îã§ Îçî ÏûëÏùÄ Ïõê
            const spacing = 4;
            const radius = circleSize / 2;
            const centerY = y + radius; // ÏõêÏùò Ï§ëÏã¨ Y Ï¢åÌëú
            
            // Ï¥ù ÌÉÑÌôòÏàòÎßåÌÅº Ïõê Í∑∏Î¶¨Í∏∞ (ÏÇ¨Ïö©Ìïú ÌÉÑÌôòÏùÄ Î∞òÌà¨Î™Ö)
            for (let i = 0; i < character.maxAmmo; i++) {
                ctx.save();
                if (i < character.ammo) {
                    // ÎÇ®ÏùÄ ÌÉÑÌôò: Î∂àÌà¨Î™Ö ÌïòÏñÄÏÉâ + ÎÑ§Ïò® Ìö®Í≥º
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff'; // ÌååÏä§ÌÖî ÌôîÏù¥Ìä∏
                } else {
                    // ÏÇ¨Ïö©Ìïú ÌÉÑÌôò: Î∞òÌà¨Î™Ö
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                }
                
                let centerX;
                if (align === 'right') {
                    // Ïò§Î•∏Ï™Ω Ï†ïÎ†¨: Ïò§Î•∏Ï™ΩÎ∂ÄÌÑ∞ ÏôºÏ™ΩÏúºÎ°ú
                    centerX = x - (character.maxAmmo - i - 1) * (circleSize + spacing) - radius;
                } else {
                    // ÏôºÏ™Ω Ï†ïÎ†¨: ÏôºÏ™ΩÎ∂ÄÌÑ∞ Ïò§Î•∏Ï™ΩÏúºÎ°ú
                    centerX = x + i * (circleSize + spacing) + radius;
                }
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ÎßàÎ¶ÑÎ™® Í∑∏Î¶¨Í∏∞ Ìï®Ïàò
        function drawDiamond(x, y, size, color) {
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2); // ÏúÑ
            ctx.lineTo(x + size / 2, y); // Ïò§Î•∏Ï™Ω
            ctx.lineTo(x, y + size / 2); // ÏïÑÎûò
            ctx.lineTo(x - size / 2, y); // ÏôºÏ™Ω
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌëúÏãú (ÎßàÎ¶ÑÎ™® ÏïÑÎûò)
        function drawCountdown() {
            const countdownValue = gameState.countdown > 0 ? gameState.countdown : gameState.augmentCountdown;
            if (countdownValue <= 0) return;
            
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const y = 100; // ÎßàÎ¶ÑÎ™® ÏïÑÎûò
            
            // Î∞òÌà¨Î™Ö Î∞∞Í≤Ω
            const textWidth = ctx.measureText(countdownValue).width;
            const padding = 30;
            ctx.fillRect(
                canvas.width / 2 - textWidth / 2 - padding,
                y - 50,
                textWidth + padding * 2,
                100
            );
            
            // Ïà´Ïûê ÌëúÏãú (ÎÑ§Ïò® Ìö®Í≥º)
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffffff';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(countdownValue, canvas.width / 2, y);
            ctx.restore();
        }

        // ÏäπÎ¶¨ ÌëúÏãú ÎßàÎ¶ÑÎ™® Í∑∏Î¶¨Í∏∞ (ÌôîÎ©¥ ÏúÑÏ™Ω Í∞ÄÏö¥Îç∞)
        function drawWinIndicators() {
            const diamondSize = 20;
            const spacing = 5;
            const groupSpacing = 15; // Í∑∏Î£π ÏÇ¨Ïù¥ Í∞ÑÍ≤© (ÏñáÏùÄ ÏÑ† Ìè¨Ìï®)
            const diamondsPerGroup = 5;
            
            // Ï≤´ Î≤àÏß∏ Í∑∏Î£π ÎÑàÎπÑ Í≥ÑÏÇ∞
            const groupWidth = (diamondsPerGroup * diamondSize) + ((diamondsPerGroup - 1) * spacing);
            // Ï†ÑÏ≤¥ ÎÑàÎπÑ Í≥ÑÏÇ∞ (Îëê Í∑∏Î£π + Í∑∏Î£π ÏÇ¨Ïù¥ Í∞ÑÍ≤©)
            const totalWidth = (groupWidth * 2) + groupSpacing;
            const startX = (canvas.width - totalWidth) / 2;
            const y = 35; // ÏÇ¥Ïßù ÏïÑÎûòÎ°ú ÎÇ¥Î¶º

            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: ÌåÄ Í∏∞Ï§ÄÏúºÎ°ú ÏäπÎ¶¨ Ïàò Í≥ÑÏÇ∞
            // ÏôºÏ™ΩÏùÄ Ìï≠ÏÉÅ ÌååÎûÄÌåÄ, Ïò§Î•∏Ï™ΩÏùÄ Ìï≠ÏÉÅ Îπ®Í∞ÑÌåÄ
            let blueWins, redWins;
            if (gameState.isMultiplayer && myTeam) {
                if (myTeam === 'blue') {
                    blueWins = gameState.playerWins;
                    redWins = gameState.enemyWins;
                } else {
                    blueWins = gameState.enemyWins;
                    redWins = gameState.playerWins;
                }
            } else {
                // ÏÜîÎ°ú: ÌîåÎ†àÏù¥Ïñ¥=ÌååÎûÄ, Ï†Å=Îπ®Í∞ï
                blueWins = gameState.playerWins;
                redWins = gameState.enemyWins;
            }

            // ÏôºÏ™Ω Í∑∏Î£π: ÌååÎûÄÌåÄ ÏäπÎ¶¨ (ÌååÎûÄÏÉâ)
            for (let i = 0; i < diamondsPerGroup; i++) {
                let color;
                if (i < blueWins) {
                    // ÌååÎûÄÌåÄ ÏäπÎ¶¨: ÌååÎûÄÏÉâ
                    color = 'rgba(74, 158, 255, 0.8)';
                } else {
                    // ÏïÑÏßÅ ÏßÑÌñâÎêòÏßÄ ÏïäÏùÄ ÎùºÏö¥Îìú: Î∞òÌà¨Î™Ö ÌöåÏÉâ
                    color = 'rgba(255, 255, 255, 0.2)';
                }
                
                const x = startX + i * (diamondSize + spacing) + diamondSize / 2;
                drawDiamond(x, y, diamondSize, color);
            }
            
            // Ïò§Î•∏Ï™Ω Í∑∏Î£π: Îπ®Í∞ÑÌåÄ ÏäπÎ¶¨ (Îπ®Í∞ÑÏÉâ) - Ïò§Î•∏Ï™ΩÎ∂ÄÌÑ∞ Ï±ÑÏõåÏßê
            for (let i = 0; i < diamondsPerGroup; i++) {
                let color;
                // Ïò§Î•∏Ï™ΩÎ∂ÄÌÑ∞ Ï±ÑÏö∞Í∏∞ ÏúÑÌï¥ Ïó≠ÏàúÏúºÎ°ú Í≥ÑÏÇ∞
                if ((diamondsPerGroup - 1 - i) < redWins) {
                    // Îπ®Í∞ÑÌåÄ ÏäπÎ¶¨: Îπ®Í∞ÑÏÉâ
                    color = 'rgba(233, 69, 96, 0.8)';
                } else {
                    // ÏïÑÏßÅ ÏßÑÌñâÎêòÏßÄ ÏïäÏùÄ ÎùºÏö¥Îìú: Î∞òÌà¨Î™Ö ÌöåÏÉâ
                    color = 'rgba(255, 255, 255, 0.2)';
                }
                
                const x = startX + groupWidth + groupSpacing + i * (diamondSize + spacing) + diamondSize / 2;
                drawDiamond(x, y, diamondSize, color);
            }
            
            // Í∑∏Î£π ÏÇ¨Ïù¥ ÏñáÏùÄ ÏÑ† Í∑∏Î¶¨Í∏∞
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            const lineX = startX + groupWidth + groupSpacing / 2;
            ctx.beginPath();
            ctx.moveTo(lineX, y - diamondSize / 2 - 5);
            ctx.lineTo(lineX, y + diamondSize / 2 + 5);
            ctx.stroke();
            ctx.restore();
        }

        // Ïû¨Ïû•Ï†Ñ ÏßÑÌñâÎ•† Î∞î Í∑∏Î¶¨Í∏∞ (ÎèôÍ∑∏ÎûÄ Î∞îÎ°ú)
        function drawReloadBar(character, x, y) {
            if (!character.isReloading) return;
            
            const now = Date.now();
            const elapsed = now - character.reloadStartTime;
            const progress = Math.min(elapsed / character.reloadTime, 1); // 0~1 ÏÇ¨Ïù¥ Í∞í
            
            const radius = 8; // ÏõêÏùò Î∞òÏßÄÎ¶Ñ (20% Ï§ÑÏûÑ: 10 -> 8)
            const lineWidth = 4; // ÏÑ† ÎëêÍªò (30% ÎäòÎ¶º: 3 -> 4)
            
            ctx.save();
            // Î∞∞Í≤Ω Ïõê (ÌöåÏÉâ)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ÏßÑÌñâÎ•† Ïõê (ÌïòÏñÄÏÉâ + ÎÑ§Ïò® Ìö®Í≥º)
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffffff';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(x, y, radius, -Math.PI / 2, -Math.PI / 2 + (progress * Math.PI * 2));
            ctx.stroke();
            ctx.restore();
        }

        // Í∑∏Î¶¨Í∏∞ Ìï®Ïàò
        // Í≤åÏûÑ ÏãúÏûë Ìï®ÏàòÎì§
        // Î≥∏ Ï¶ùÍ∞ï Î™©Î°ù Í¥ÄÎ¶¨ (localStorage ÏÇ¨Ïö©)
        function getSeenAugments() {
            const seen = localStorage.getItem('seenAugments');
            return seen ? JSON.parse(seen) : [];
        }

        function markAugmentAsSeen(augmentId) {
            const seen = getSeenAugments();
            if (!seen.includes(augmentId)) {
                seen.push(augmentId);
                localStorage.setItem('seenAugments', JSON.stringify(seen));
            }
        }

        // Ï¶ùÍ∞ï ÏÑ†ÌÉù ÌöüÏàò Í¥ÄÎ¶¨ (localStorage ÏÇ¨Ïö©)
        function getAugmentSelectCounts() {
            const counts = localStorage.getItem('augmentSelectCounts');
            return counts ? JSON.parse(counts) : {};
        }

        function incrementAugmentSelectCount(augmentId) {
            const counts = getAugmentSelectCounts();
            counts[augmentId] = (counts[augmentId] || 0) + 1;
            localStorage.setItem('augmentSelectCounts', JSON.stringify(counts));
        }

        function getAugmentSelectCount(augmentId) {
            const counts = getAugmentSelectCounts();
            return counts[augmentId] || 0;
        }

        // ÎèÑÍ∞ê ÌôîÎ©¥ ÎÇ¥Ïö© Î°úÎìú
        function loadCollectionContent() {
            const content = document.getElementById('collectionContent');
            const seenAugments = getSeenAugments();
            
            if (content) {
            content.innerHTML = '';
            
            augmentations.forEach(aug => {
                const isSeen = seenAugments.includes(aug.id);
                const selectCount = getAugmentSelectCount(aug.id);
                const item = document.createElement('div');
                item.className = 'collection-item' + (isSeen ? '' : ' locked');
                item.innerHTML = `
                    ${selectCount > 0 ? `<span class="select-count">${selectCount}Ìöå ÏÑ†ÌÉù</span>` : ''}
                    <h4>${isSeen ? aug.name : '???'}</h4>
                    <p>${isSeen ? aug.description : '??? (ÏïÑÏßÅ Î∞úÍ≤¨ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§)'}</p>
                `;
                content.appendChild(item);
            });
            }
        }

        // ÏÉÅÏ†ê ÏÉÅÌíà Î™©Î°ù
        const shopItemsRaw = [
            { id: 'hitEffect_dot_gray', name: 'Ï†ê', description: 'ÌîºÍ≤© Ïãú ÌöåÏÉâ Ï†ê Ïù¥ÌéôÌä∏Í∞Ä ÌëúÏãúÎê©ÎãàÎã§', price: 40, rarity: 'common' },
            { id: 'hitEffect_triangle_gray', name: 'ÏÇºÍ∞ÅÌòï', description: 'ÌîºÍ≤© Ïãú ÌöåÏÉâ ÏÇºÍ∞ÅÌòï Ïù¥ÌéôÌä∏Í∞Ä ÌëúÏãúÎê©ÎãàÎã§', price: 40, rarity: 'common' },
            { id: 'hitEffect_square_gray', name: 'ÏÇ¨Í∞ÅÌòï', description: 'ÌîºÍ≤© Ïãú ÌöåÏÉâ ÏÇ¨Í∞ÅÌòï Ïù¥ÌéôÌä∏Í∞Ä ÌëúÏãúÎê©ÎãàÎã§', price: 40, rarity: 'common' },
            { id: 'hitEffect_firework_gray', name: 'Ìè≠Ï£Ω', description: 'ÌîºÍ≤© Ïãú ÌöåÏÉâ Ìè≠Ï£Ω Ïù¥ÌéôÌä∏Í∞Ä ÌëúÏãúÎê©ÎãàÎã§', price: 75, rarity: 'rare' }
        ];
        
        // Îì±Í∏âÎ≥Ñ Í∞ÄÍ≤© ÏÑ§Ï†ï (common: 40, rare: 75)
        const shopItems = shopItemsRaw.map(item => {
            if (item.rarity === 'common') {
                return { ...item, price: 40 };
            } else if (item.rarity === 'rare') {
                return { ...item, price: 75 };
            }
            return { ...item };
        });
        
        // Î≥¥Í¥ÄÏÜå (Íµ¨Îß§Ìïú ÏïÑÏù¥ÌÖú Ï†ÄÏû•)
        let storage = JSON.parse(localStorage.getItem('gameStorage') || '[]');
        
        // ÏÉÅÏ†ê ÏÉàÎ°úÍ≥†Ïπ® ÏãúÍ∞Ñ Í¥ÄÎ¶¨ (6ÏãúÍ∞ÑÎßàÎã§)
        const SHOP_REFRESH_INTERVAL = 6 * 60 * 60 * 1000; // 6ÏãúÍ∞Ñ (Î∞ÄÎ¶¨Ï¥à)
        
        function getShopRefreshTime() {
            const lastRefresh = localStorage.getItem('shopLastRefresh');
            if (!lastRefresh) {
                // Ï≤òÏùåÏù¥Î©¥ ÌòÑÏû¨ ÏãúÍ∞ÑÏúºÎ°ú ÏÑ§Ï†ïÌïòÍ≥† ÏÉÅÌíàÎèÑ Ï¥àÍ∏∞Ìôî
                const now = Date.now();
                localStorage.setItem('shopLastRefresh', now.toString());
                // ÏÉÅÌíàÏù¥ ÏóÜÏúºÎ©¥ Îπà Î∞∞Ïó¥ Ï†ÄÏû•
                if (!localStorage.getItem('shopCurrentItems')) {
                    localStorage.setItem('shopCurrentItems', JSON.stringify([]));
                }
                return now;
            }
            return parseInt(lastRefresh);
        }
        
        function shouldRefreshShop() {
            const lastRefresh = getShopRefreshTime();
            const now = Date.now();
            return (now - lastRefresh) >= SHOP_REFRESH_INTERVAL;
        }
        
        function refreshShopItems() {
            // Î™®Îì† ÏÉÅÌíàÏùÑ Î∞òÌôòÌïòÎêò, 3Í∞úÎäî Ìï†Ïù∏Îêú ÏÉÅÌíàÏúºÎ°ú ÌëúÏãú
            if (shopItems.length > 0) {
                const shuffled = [...shopItems].sort(() => Math.random() - 0.5);
                const discountedItems = shuffled.slice(0, Math.min(3, shopItems.length));
                
                // Ìï†Ïù∏Ïú® 20%~50% ÎûúÎç§ Ï†ÅÏö© (5% Îã®ÏúÑ)
                const discountRates = [0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50]; // 5% Îã®ÏúÑ Ìï†Ïù∏Ïú®
                const allItems = shopItems.map((item, index) => {
                    const isDiscounted = discountedItems.some(disc => disc.id === item.id);
                    // Ìï†Ïù∏Îêú ÏÉÅÌíàÏóê ÎåÄÌï¥ ÎûúÎç§ÌïòÍ≤å 5% Îã®ÏúÑ Ìï†Ïù∏Ïú® ÏÑ†ÌÉù
                    const discountRate = isDiscounted ? discountRates[Math.floor(Math.random() * discountRates.length)] : 0;
                    return {
                        ...item,
                        originalPrice: item.price,
                        discountRate: discountRate,
                        discountedPrice: Math.floor(item.price * (1 - discountRate))
                    };
                });
                
                localStorage.setItem('shopCurrentItems', JSON.stringify(allItems));
                localStorage.setItem('shopDiscountedItems', JSON.stringify(discountedItems.map(item => item.id)));
                localStorage.setItem('shopLastRefresh', Date.now().toString());
                return allItems;
        }
            return [];
        }
        
        function getCurrentShopItems() {
            // ÏÉàÎ°úÍ≥†Ïπ®Ïù¥ ÌïÑÏöîÌïúÏßÄ ÌôïÏù∏ÌïòÎêò, ÏãúÍ∞Ñ Í≥ÑÏÇ∞ÏùÄ Î≥ÑÎèÑÎ°ú Ï≤òÎ¶¨
            const shouldRefresh = shouldRefreshShop();
            if (shouldRefresh) {
                const refreshed = refreshShopItems();
                return refreshed;
            }
            const stored = localStorage.getItem('shopCurrentItems');
            if (stored) {
                const items = JSON.parse(stored);
                // shopItemsÏóê ÏûàÎäî Î™®Îì† ÏïÑÏù¥ÌÖúÏù¥ Ï†ÄÏû•Îêú ÏïÑÏù¥ÌÖúÏóê ÏûàÎäîÏßÄ ÌôïÏù∏
                const storedIds = items.map(item => item.id);
                const allShopItemIds = shopItems.map(item => item.id);
                const hasNewItems = allShopItemIds.some(id => !storedIds.includes(id));
                
                // Í∏∞Ï°¥ Ï†ÄÏû•Îêú ÏïÑÏù¥ÌÖúÏóê rarity ÏÜçÏÑ±Ïù¥ ÏóÜÍ±∞ÎÇò, shopItemsÏùò Îì±Í∏âÍ≥º Îã§Î•¥Í±∞ÎÇò, ÏÉàÎ°úÏö¥ ÏïÑÏù¥ÌÖúÏù¥ ÏûàÍ±∞ÎÇò, Í∞ÄÍ≤©Ïù¥ 0Ïù¥Í±∞ÎÇò Îã§Î•¥Î©¥ ÏÉàÎ°úÍ≥†Ïπ®
                const needsRefresh = hasNewItems || items.some(item => {
                    if (!item.rarity) return true;
                    const originalItem = shopItems.find(shopItem => shopItem.id === item.id);
                    if (originalItem && originalItem.rarity !== item.rarity) return true;
                    // Í∞ÄÍ≤©Ïù¥ 0Ïù¥Í±∞ÎÇò shopItemsÏùò Í∞ÄÍ≤©Í≥º Îã§Î•¥Î©¥ ÏÉàÎ°úÍ≥†Ïπ®
                    if (originalItem && (item.price === 0 || item.originalPrice === 0 || item.price !== originalItem.price)) return true;
                    return false;
                });
                if (needsRefresh) {
                    return refreshShopItems();
                }
                // Í∏∞Ï°¥ Ï†ÄÏû•Îêú ÏïÑÏù¥ÌÖúÏóê rarity ÏÜçÏÑ±Ïù¥ ÏóÜÏúºÎ©¥ Ï∂îÍ∞ÄÌïòÍ≥†, Í∞ÄÍ≤©ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
                return items.map(item => {
                    const originalItem = shopItems.find(shopItem => shopItem.id === item.id);
                    if (originalItem) {
                        if (!item.rarity) {
                            item.rarity = originalItem.rarity;
                        }
                        // Í∞ÄÍ≤©Ïù¥ 0Ïù¥Í±∞ÎÇò Îã§Î•¥Î©¥ ÏóÖÎç∞Ïù¥Ìä∏
                        if (item.price === 0 || item.price !== originalItem.price) {
                            item.price = originalItem.price;
                            item.originalPrice = originalItem.price;
                            // Ìï†Ïù∏Îêú Í∞ÄÍ≤©ÎèÑ Îã§Ïãú Í≥ÑÏÇ∞
                            if (item.discountRate > 0) {
                                item.discountedPrice = Math.floor(item.price * (1 - item.discountRate));
                            }
                        }
                    } else {
                        if (!item.rarity) {
                            item.rarity = 'common'; // Í∏∞Î≥∏Í∞í
                        }
                    }
                    return item;
                });
            }
            // Ï†ÄÏû•Îêú ÏÉÅÌíàÏù¥ ÏóÜÏúºÎ©¥ ÏÉàÎ°úÍ≥†Ïπ®
            return refreshShopItems();
        }
        
        function formatTimeUntilRefresh() {
            const lastRefresh = getShopRefreshTime();
            const now = Date.now();
            const elapsed = now - lastRefresh;
            let remaining = SHOP_REFRESH_INTERVAL - elapsed;
            
            // ÎßåÏïΩ Ïù¥ÎØ∏ ÏÉàÎ°úÍ≥†Ïπ® ÏãúÍ∞ÑÏù¥ ÏßÄÎÇ¨Îã§Î©¥ Îã§Ïùå ÏÉàÎ°úÍ≥†Ïπ®ÍπåÏßÄÏùò ÏãúÍ∞Ñ Í≥ÑÏÇ∞
            if (remaining <= 0) {
                // Ïù¥ÎØ∏ ÏßÄÎÇú ÏãúÍ∞ÑÏùÑ Ï£ºÍ∏∞Î°ú ÎÇòÎàà ÎÇòÎ®∏ÏßÄÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Îã§Ïùå Ï£ºÍ∏∞ÍπåÏßÄÏùò ÏãúÍ∞Ñ Í≥ÑÏÇ∞
                const elapsedInCycle = elapsed % SHOP_REFRESH_INTERVAL;
                remaining = SHOP_REFRESH_INTERVAL - elapsedInCycle;
            }
            
            // ÏùåÏàòÍ∞Ä ÎêòÏßÄ ÏïäÎèÑÎ°ù Î≥¥Ï†ï
            remaining = Math.max(0, remaining);
            
            const totalSeconds = Math.floor(remaining / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            // Îëê ÏûêÎ¶¨ Ïà´ÏûêÎ°ú Ìè¨Îß∑ÌåÖ
            const formattedHours = String(hours).padStart(2, '0');
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');
            
            return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
        }
        
        // ÏÉÅÏ†ê ÌôîÎ©¥Ïù¥ Ïó¥Î†§ÏûàÏùÑ Îïå Ïã§ÏãúÍ∞ÑÏúºÎ°ú ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
        let shopRefreshInterval = null;
        
        function startShopRefreshTimer() {
            // Í∏∞Ï°¥ ÌÉÄÏù¥Î®∏Í∞Ä ÏûàÏúºÎ©¥ Ï†úÍ±∞
            if (shopRefreshInterval) {
                clearInterval(shopRefreshInterval);
            }
            
            // 1Ï¥àÎßàÎã§ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
            shopRefreshInterval = setInterval(() => {
                const refreshTimeElement = document.getElementById('shopRefreshTime');
                if (refreshTimeElement) {
                    refreshTimeElement.textContent = formatTimeUntilRefresh();
                }
            }, 1000);
        }
        
        function stopShopRefreshTimer() {
            if (shopRefreshInterval) {
                clearInterval(shopRefreshInterval);
                shopRefreshInterval = null;
            }
        }
        
        // ÏÉÅÏ†ê ÌôîÎ©¥ Ïó¥Í∏∞ (ÎÇ¥Î∂Ä Ìï®Ïàò)
        function openShopModal() {
            const itemsContainer = document.getElementById('shopItems');
            const refreshTimeElement = document.getElementById('shopRefreshTime');
            
            // ÌòÑÏû¨ ÏÉÅÌíà Í∞ÄÏ†∏Ïò§Í∏∞ (Ïù¥ Ìï®ÏàòÍ∞Ä shopLastRefreshÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï† Ïàò ÏûàÏùå)
            const currentItems = getCurrentShopItems();
            
            // ÏÉàÎ°úÍ≥†Ïπ® ÏãúÍ∞Ñ ÌëúÏãú (ÏÉÅÌíà Î°úÎìú ÌõÑÏóê ÌëúÏãú)
            if (refreshTimeElement) {
                refreshTimeElement.textContent = formatTimeUntilRefresh();
            }
            
            // Ïã§ÏãúÍ∞Ñ ÌÉÄÏù¥Î®∏ ÏãúÏûë
            startShopRefreshTimer();
            
            // ÏÉÅÌíà ÌëúÏãú
            if (itemsContainer) {
                itemsContainer.innerHTML = '';
                if (currentItems.length === 0) {
                    itemsContainer.innerHTML = '<p style="color: #888; text-align: center; grid-column: 1 / -1;">ÏÉÅÌíàÏù¥ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.</p>';
                } else {
                    // Ìï†Ïù∏Îêú ÏÉÅÌíàÍ≥º ÏùºÎ∞ò ÏÉÅÌíà Î∂ÑÎ¶¨
                    const discountedItems = currentItems.filter(item => item.discountRate > 0);
                    const regularItems = currentItems.filter(item => item.discountRate === 0);
            
                    // Ìï†Ïù∏Îêú ÏÉÅÌíà ÏÑπÏÖò (3Í∞úÎßå ÌëúÏãú)
                    if (discountedItems.length > 0) {
                        const discountSection = document.createElement('div');
                        discountSection.style.cssText = 'grid-column: 1 / -1; margin-bottom: 30px;';
                        discountSection.innerHTML = '<h3 style="color: #ffc107; font-size: 24px; margin-bottom: 20px; text-align: center;">Ìï†Ïù∏ ÏÉÅÌíà</h3>';
                        itemsContainer.appendChild(discountSection);
                        
                        // Ï≤òÏùå 3Í∞úÎßå ÌëúÏãú
                        discountedItems.slice(0, 3).forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'shop-item';
                            // Îì±Í∏âÏóê Îî∞Î•∏ ÌÅ¥ÎûòÏä§ Ï∂îÍ∞Ä
                            if (item.rarity === 'common') {
                                itemDiv.classList.add('rarity-common');
                            } else if (item.rarity === 'rare') {
                                itemDiv.classList.add('rarity-rare');
                            } else if (item.rarity === 'epic') {
                                itemDiv.classList.add('rarity-epic');
                            }
                            
                            const isOwned = storage.includes(item.id);
                            if (isOwned) {
                                itemDiv.classList.add('owned');
                            }
                            
                            const displayPrice = item.discountedPrice || item.price;
                            const discountPercent = Math.round(item.discountRate * 100);
                            
                            // Îì±Í∏â ÏïÑÏù¥ÏΩò ÏÉùÏÑ±
                            let rarityIcon = '';
                            if (item.rarity === 'common') {
                                rarityIcon = '<div class="rarity-icon triangle common"></div>';
                            } else if (item.rarity === 'rare') {
                                rarityIcon = '<div class="rarity-icon square"></div>';
                            } else if (item.rarity === 'epic') {
                                rarityIcon = '<div class="rarity-icon pentagon"></div>';
                            }
                            
                            itemDiv.innerHTML = `
                                ${rarityIcon}
                                <div style="position: absolute; top: 10px; right: 10px; background: #e94560; color: white; padding: 5px 10px; border-radius: 5px; font-size: 14px; font-weight: bold; z-index: 10;">-${discountPercent}%</div>
                                <h4>${item.name}</h4>
                                <p>${item.description}</p>
                                <div class="shop-item-price" style="text-decoration: line-through; color: #888; font-size: 14px; margin-top: 10px; display: flex; align-items: center; justify-content: center; gap: 5px;">
                                    ${item.originalPrice}<div class="neon-diamond" style="width: 12px; height: 12px; border: 2px solid #888;"></div>
                                </div>
                                <div class="shop-item-price" style="color: #ffc107; font-size: 20px; font-weight: bold; margin-top: 5px; display: flex; align-items: center; justify-content: center; gap: 5px;">
                                    ${displayPrice}<div class="neon-diamond" style="width: 14px; height: 14px; border: 2px solid #ffc107;"></div>
                                </div>
                                ${isOwned ? '<p style="color: #4a9eff; margin-top: 10px;">Î≥¥Ïú† Ï§ë</p>' : ''}
                            `;
                            
                            if (!isOwned) {
                                itemDiv.onclick = () => buyShopItem(item, displayPrice);
                            }
                            
                            itemsContainer.appendChild(itemDiv);
                        });
                    }
                    
                    // ÏùºÎ∞ò ÏÉÅÌíà ÏÑπÏÖò
                    if (regularItems.length > 0) {
                        const regularSection = document.createElement('div');
                        regularSection.style.cssText = 'grid-column: 1 / -1; margin-top: 30px; margin-bottom: 20px;';
                        regularSection.innerHTML = '<h3 style="color: #ffffff; font-size: 24px; margin-bottom: 20px; text-align: center;">ÏùºÎ∞ò ÏÉÅÌíà</h3>';
                        itemsContainer.appendChild(regularSection);
                        
                        regularItems.forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'shop-item';
                            // Îì±Í∏âÏóê Îî∞Î•∏ ÌÅ¥ÎûòÏä§ Ï∂îÍ∞Ä
                            if (item.rarity === 'common') {
                                itemDiv.classList.add('rarity-common');
                            } else if (item.rarity === 'rare') {
                                itemDiv.classList.add('rarity-rare');
                            } else if (item.rarity === 'epic') {
                                itemDiv.classList.add('rarity-epic');
                            }
                            
                            const isOwned = storage.includes(item.id);
                            if (isOwned) {
                                itemDiv.classList.add('owned');
                            }
                            
                            const displayPrice = item.price;
                            
                            // Îì±Í∏â ÏïÑÏù¥ÏΩò ÏÉùÏÑ±
                            let rarityIcon = '';
                            if (item.rarity === 'common') {
                                rarityIcon = '<div class="rarity-icon triangle common"></div>';
                            } else if (item.rarity === 'rare') {
                                rarityIcon = '<div class="rarity-icon square"></div>';
                            } else if (item.rarity === 'epic') {
                                rarityIcon = '<div class="rarity-icon pentagon"></div>';
                            }
                            
                            itemDiv.innerHTML = `
                                ${rarityIcon}
                                <h4>${item.name}</h4>
                                <p>${item.description}</p>
                                <div class="shop-item-price" style="display: flex; align-items: center; justify-content: center; gap: 5px; margin-top: 10px;">
                                    ${displayPrice}<div class="neon-diamond" style="width: 14px; height: 14px; border: 2px solid #fff;"></div>
                                </div>
                                ${isOwned ? '<p style="color: #4a9eff; margin-top: 10px;">Î≥¥Ïú† Ï§ë</p>' : ''}
                            `;
                            
                            if (!isOwned) {
                                itemDiv.onclick = () => buyShopItem(item, displayPrice);
                            }
                            
                            itemsContainer.appendChild(itemDiv);
                        });
                    }
                }
            }
        }

        // ÏÉÅÏ†ê ÏïÑÏù¥ÌÖú Íµ¨Îß§
        function buyShopItem(item, displayPrice) {
            const price = displayPrice !== undefined ? displayPrice : (item.discountedPrice || item.price);
            if (gameKillCount < price) {
                alert('Ï†úÌôîÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§!');
                return;
            }
            
            if (storage.includes(item.id)) {
                alert('Ïù¥ÎØ∏ Î≥¥Ïú†Ìïú ÏïÑÏù¥ÌÖúÏûÖÎãàÎã§!');
                return;
            }
            
            // Íµ¨Îß§ ÌôïÏù∏
            if (confirm(`${item.name}ÏùÑ(Î•º) ${price} Ï†úÌôîÏóê Íµ¨Îß§ÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                gameKillCount -= price;
                updateKillCount(gameKillCount);
                storage.push(item.id);
                localStorage.setItem('gameStorage', JSON.stringify(storage));
                
                // ÏÉÅÏ†ê ÌôîÎ©¥ ÏÉàÎ°úÍ≥†Ïπ®
                openShopModal();
                alert('Íµ¨Îß§ ÏôÑÎ£å! Î≥¥Í¥ÄÏÜåÏóêÏÑú ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.');
            }
        }
        
        // ÏÑ†ÌÉùÎêú ÌîºÍ≤© Ïù¥ÌéôÌä∏ ÏïÑÏù¥ÌÖú Í¥ÄÎ¶¨
        let selectedHitEffectItem = localStorage.getItem('selectedHitEffectItem') || null;
        
        // Î≥¥Í¥ÄÏÜå ÌôîÎ©¥ Ïó¥Í∏∞ (ÎÇ¥Î∂Ä Ìï®Ïàò)
        function openStorageModal() {
            const itemsContainer = document.getElementById('storageItems');
            
            // ÏÑ†ÌÉùÎêú ÏïÑÏù¥ÌÖú Îã§Ïãú Î∂àÎü¨Ïò§Í∏∞
            selectedHitEffectItem = localStorage.getItem('selectedHitEffectItem') || null;
            
            // Î≥¥Í¥ÄÎêú ÏïÑÏù¥ÌÖú ÌëúÏãú
            if (itemsContainer) {
                itemsContainer.innerHTML = '';
                if (storage.length === 0) {
                    itemsContainer.innerHTML = '<p style="color: #888; text-align: center; grid-column: 1 / -1;">Î≥¥Í¥ÄÎêú ÏïÑÏù¥ÌÖúÏù¥ ÏóÜÏäµÎãàÎã§.</p>';
                } else {
                    // Îì±Í∏â ÏàúÏÑú Ï†ïÏùò (ÎÜíÏùÄ ÏàúÏÑúÎ∂ÄÌÑ∞)
                    const rarityOrder = { 'epic': 3, 'rare': 2, 'common': 1 };
                    
                    // ÏïÑÏù¥ÌÖúÏùÑ Îì±Í∏â ÏàúÏúºÎ°ú Ï†ïÎ†¨
                    const sortedItems = storage.map(itemId => {
                        const item = shopItems.find(i => i.id === itemId);
                        return item ? { id: itemId, item: item } : null;
                    }).filter(entry => entry !== null).sort((a, b) => {
                        const orderA = rarityOrder[a.item.rarity] || 0;
                        const orderB = rarityOrder[b.item.rarity] || 0;
                        return orderB - orderA; // ÎÜíÏùÄ Îì±Í∏âÎ∂ÄÌÑ∞
                    });
                    
                    sortedItems.forEach(({ item }) => {
                        if (item) {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'storage-item';
                            
                            // Îì±Í∏âÏóê Îî∞Î•∏ ÌÅ¥ÎûòÏä§ Ï∂îÍ∞Ä
                            if (item.rarity === 'common') {
                                itemDiv.classList.add('rarity-common');
                            } else if (item.rarity === 'rare') {
                                itemDiv.classList.add('rarity-rare');
                            } else if (item.rarity === 'epic') {
                                itemDiv.classList.add('rarity-epic');
                            }
                            
                            // ÏÑ†ÌÉùÎêú ÏïÑÏù¥ÌÖúÏù∏ÏßÄ ÌôïÏù∏
                            if (selectedHitEffectItem === item.id) {
                                itemDiv.classList.add('selected');
                            }
                            
                            // Îì±Í∏â ÏïÑÏù¥ÏΩò ÏÉùÏÑ±
                            let rarityIcon = '';
                            if (item.rarity === 'common') {
                                rarityIcon = '<div class="rarity-icon triangle common"></div>';
                            } else if (item.rarity === 'rare') {
                                rarityIcon = '<div class="rarity-icon square"></div>';
                            } else if (item.rarity === 'epic') {
                                rarityIcon = '<div class="rarity-icon pentagon"></div>';
                            }
                            
                            // Í∞ïÌôî Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
                            const levelKey = `hitEffect_level_${item.id}`;
                            let currentLevel = parseInt(localStorage.getItem(levelKey) || '0');
                            // Í∞ïÌôîÎäî ÏµúÎåÄ 2Îã®Í≥ÑÍπåÏßÄÎßå Í∞ÄÎä•ÌïòÎØÄÎ°ú Ï†úÌïú
                            if (currentLevel > 2) {
                                currentLevel = 2;
                                localStorage.setItem(levelKey, '2');
                            }
                            const isEnhanced = currentLevel > 0;
                            const isEnhancedPlus = currentLevel >= 2;
                            
                            // ÏÑ†ÌÉùÎêú Í∞ïÌôî Îã®Í≥Ñ Í∞ÄÏ†∏Ïò§Í∏∞
                            const selectedLevelKey = `selectedHitEffectLevel_${item.id}`;
                            let selectedLevel = parseInt(localStorage.getItem(selectedLevelKey) || '0');
                            // ÏÑ†ÌÉùÎêú Îã®Í≥ÑÍ∞Ä Í∞ïÌôîÌïú Îã®Í≥ÑÎ•º Ï¥àÍ≥ºÌïòÏßÄ ÏïäÎèÑÎ°ù Ï†úÌïú
                            if (selectedLevel > currentLevel) {
                                selectedLevel = 0;
                                localStorage.setItem(selectedLevelKey, '0');
                            }
                            
                            itemDiv.style.position = 'relative'; // ÏÉÅÎåÄ ÏúÑÏπò ÏÑ§Ï†ï
                            
                            itemDiv.innerHTML = `
                                ${rarityIcon}
                                <div class="selected-badge">ÏÑ†ÌÉùÎê®</div>
                                <h4>${item.name}${isEnhancedPlus ? '<span style="opacity: 0.7;"> (Í∞ïÌôî+)</span>' : isEnhanced ? '<span style="opacity: 0.7;"> (Í∞ïÌôî)</span>' : ''}</h4>
                                <p>${item.description}</p>
                                ${isEnhanced ? `<p style="color: #4a9eff; margin-top: 10px;">ÌîºÍ≤© Ïãú ÎûúÎç§ ÏÉâÏÉÅ Ïù¥ÌéôÌä∏</p>` : ''}
                                ${isEnhancedPlus ? `<p style="color: #ffc107; margin-top: 5px;">ÎÑ§Ïò® Ìö®Í≥º Ï†ÅÏö©</p>` : ''}
                                ${currentLevel < 2 ? `<button onclick="enhanceHitEffect('${item.id}', event)" style="
                                    position: absolute;
                                    bottom: 10px;
                                    right: 10px;
                                    padding: 8px 16px;
                                    background: #4a9eff;
                                    color: white;
                                    border: none;
                                    border-radius: 5px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    display: flex;
                                    align-items: center;
                                    gap: 5px;
                                ">${currentLevel === 0 ? 'Í∞ïÌôî' : 'Í∞ïÌôî+'} (20<div class="neon-diamond" style="width: 12px; height: 12px; border: 2px solid #fff; display: inline-block; margin-left: 2px;"></div>)</button>` : ''}
                                ${isEnhanced ? `<button onclick="cycleHitEffectLevel('${item.id}', event)" style="
                                    position: absolute;
                                    bottom: 10px;
                                    left: 10px;
                                    padding: 8px 12px;
                                    background: ${selectedLevel === 2 ? 'rgba(255, 193, 7, 0.3)' : 'rgba(74, 158, 255, 0.3)'};
                                    color: white;
                                    border: 1px solid ${selectedLevel === 2 ? '#ffc107' : '#4a9eff'};
                                    border-radius: 5px;
                                    cursor: pointer;
                                    font-size: 16px;
                                    font-weight: bold;
                                    min-width: 40px;
                                ">${selectedLevel}</button>` : ''}
                            `;
                            
                            // ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏: ÏÑ†ÌÉù/Ìï¥Ï†ú (Î≤ÑÌäº ÌÅ¥Î¶≠ ÏãúÏóêÎäî Ïù¥Î≤§Ìä∏ Ï†ÑÌåå Î∞©ÏßÄ)
                            itemDiv.addEventListener('click', (e) => {
                                // Î≤ÑÌäº ÌÅ¥Î¶≠Ïù¥Î©¥ ÏÑ†ÌÉù Ïù¥Î≤§Ìä∏ Ïã§Ìñâ Ïïà Ìï®
                                if (e.target.tagName === 'BUTTON') return;
                                
                                // Î™®Îì† ÏÑ†ÌÉù Ìï¥Ï†ú
                                document.querySelectorAll('.storage-item').forEach(el => {
                                    el.classList.remove('selected');
                                });
                                
                                // ÌòÑÏû¨ ÏïÑÏù¥ÌÖú ÏÑ†ÌÉù
                                if (selectedHitEffectItem === item.id) {
                                    // Ïù¥ÎØ∏ ÏÑ†ÌÉùÎêú ÏïÑÏù¥ÌÖúÏù¥Î©¥ Ìï¥Ï†ú
                                    selectedHitEffectItem = null;
                                    localStorage.removeItem('selectedHitEffectItem');
                                } else {
                                    // ÏÉàÎ°ú ÏÑ†ÌÉù
                                    selectedHitEffectItem = item.id;
                                    itemDiv.classList.add('selected');
                                    localStorage.setItem('selectedHitEffectItem', item.id);
                                }
                            });
                            
                            itemsContainer.appendChild(itemDiv);
                        }
                    });
                }
            }
        }
        
        // Ïù¥ÌéôÌä∏ Í∞ïÌôî Ìï®Ïàò
        function enhanceHitEffect(itemId, event) {
            event.stopPropagation(); // Ïù¥Î≤§Ìä∏ Ï†ÑÌåå Î∞©ÏßÄ
            
            const levelKey = `hitEffect_level_${itemId}`;
            let currentLevel = parseInt(localStorage.getItem(levelKey) || '0');
            // Í∞ïÌôîÎäî ÏµúÎåÄ 2Îã®Í≥ÑÍπåÏßÄÎßå Í∞ÄÎä•ÌïòÎØÄÎ°ú Ï†úÌïú
            if (currentLevel > 2) {
                currentLevel = 2;
                localStorage.setItem(levelKey, '2');
            }
            
            // Ïù¥ÎØ∏ ÏµúÎåÄ Í∞ïÌôîÎêòÏóàÏúºÎ©¥ Í∞ïÌôî Î∂àÍ∞Ä
            if (currentLevel >= 2) {
                alert('Ïù¥ÎØ∏ ÏµúÎåÄ Í∞ïÌôîÎêú ÏïÑÏù¥ÌÖúÏûÖÎãàÎã§!');
                return;
            }
            
            // Í∞ïÌôî ÎπÑÏö© ÌôïÏù∏
            const enhanceCost = 20;
            if (gameKillCount < enhanceCost) {
                alert('Ï†úÌôîÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§!');
                return;
            }
            
            // Ï†úÌôî Ï∞®Í∞ê
            gameKillCount -= enhanceCost;
            updateKillCount(gameKillCount);
            
            // Í∞ïÌôî (Î†àÎ≤® Ï¶ùÍ∞Ä)
            const newLevel = currentLevel + 1;
            localStorage.setItem(levelKey, newLevel.toString());
            
            // Í∞ïÌôî Îã®Í≥ÑÎèÑ ÏûêÎèôÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
            const selectedLevelKey = `selectedHitEffectLevel_${itemId}`;
            localStorage.setItem(selectedLevelKey, newLevel.toString());
            
            // Î≥¥Í¥ÄÏÜå ÌôîÎ©¥ ÏÉàÎ°úÍ≥†Ïπ®
            openStorageModal();
            
            if (newLevel === 1) {
                alert('Í∞ïÌôî ÏôÑÎ£å! Ïù¥Ï†ú ÌîºÍ≤© Ïãú ÎûúÎç§ ÏÉâÏÉÅ Ïù¥ÌéôÌä∏Í∞Ä ÌëúÏãúÎê©ÎãàÎã§.');
            } else if (newLevel === 2) {
                alert('Í∞ïÌôî+ ÏôÑÎ£å! Ïù¥Ï†ú ÌîºÍ≤© Ïãú ÎûúÎç§ ÏÉâÏÉÅ Ïù¥ÌéôÌä∏ÏôÄ ÎÑ§Ïò® Ìö®Í≥ºÍ∞Ä ÌëúÏãúÎê©ÎãàÎã§.');
            }
        }
        
        // Í∞ïÌôî Îã®Í≥Ñ ÏàúÌôò Ìï®Ïàò
        function cycleHitEffectLevel(itemId, event) {
            event.stopPropagation(); // Ïù¥Î≤§Ìä∏ Ï†ÑÌåå Î∞©ÏßÄ
            
            const levelKey = `hitEffect_level_${itemId}`;
            let currentLevel = parseInt(localStorage.getItem(levelKey) || '0');
            // Í∞ïÌôîÎäî ÏµúÎåÄ 2Îã®Í≥ÑÍπåÏßÄÎßå Í∞ÄÎä•ÌïòÎØÄÎ°ú Ï†úÌïú
            if (currentLevel > 2) {
                currentLevel = 2;
                localStorage.setItem(levelKey, '2');
            }
            const selectedLevelKey = `selectedHitEffectLevel_${itemId}`;
            let currentSelectedLevel = parseInt(localStorage.getItem(selectedLevelKey) || '0');
            
            // ÏÑ†ÌÉùÎêú Îã®Í≥ÑÍ∞Ä Í∞ïÌôîÌïú Îã®Í≥ÑÎ•º Ï¥àÍ≥ºÌïòÏßÄ ÏïäÎèÑÎ°ù Ï†úÌïú
            if (currentSelectedLevel > currentLevel) {
                currentSelectedLevel = 0;
                localStorage.setItem(selectedLevelKey, '0');
            }
            
            // Îã§Ïùå Îã®Í≥Ñ Í≥ÑÏÇ∞: 0Î∂ÄÌÑ∞ ÏãúÏûëÌï¥ÏÑú Í∞ïÌôîÌïú Îã®Í≥ÑÍπåÏßÄ 1Ïî© Ï¶ùÍ∞Ä, ÎÑòÏñ¥ÏÑúÎ©¥ 0ÏúºÎ°ú ÏàúÌôò
            let nextLevel = currentSelectedLevel + 1;
            if (nextLevel > currentLevel) {
                nextLevel = 0; // ÏûêÏã†Ïù¥ Í∞ïÌôîÌïú Îã®Í≥ÑÎ≥¥Îã§ ÎÑòÏñ¥ÏÑúÎ©¥ 0ÏúºÎ°ú ÎèåÏïÑÏò¥
            }
            
            // ÏÑ†ÌÉùÌïú Í∞ïÌôî Îã®Í≥Ñ Ï†ÄÏû•
            localStorage.setItem(selectedLevelKey, nextLevel.toString());
            
            // Î≥¥Í¥ÄÏÜå ÌôîÎ©¥ ÏÉàÎ°úÍ≥†Ïπ®
            openStorageModal();
        }


        // Î™®Îìú ÏÑ†ÌÉù Ï†ëÍ∏∞ Ìï®Ïàò
        function collapseModeSelection() {
            const modeSelection = document.getElementById('modeSelection');
            if (modeSelection.classList.contains('expanded')) {
                modeSelection.classList.remove('expanded');
                // Î©ÄÌã∞ ÌîåÎ†àÏù¥ ÏõêÎûò ÏúÑÏπòÎ°ú
                document.getElementById('multiPlayText').classList.remove('moved-down');
            }
        }

        function collapseMultiModeSelection() {
            const multiModeSelection = document.getElementById('multiModeSelection');
            if (multiModeSelection.classList.contains('expanded')) {
                multiModeSelection.classList.remove('expanded');
                // ÎèÑÍ∞êÎßå ÏõêÎûò ÏúÑÏπòÎ°ú
                document.getElementById('collectionText').classList.remove('moved-down');
            }
        }

        function showModeSelection() {
            const modeSelection = document.getElementById('modeSelection');
            const isExpanded = modeSelection.classList.contains('expanded');
            
            // Î©ÄÌã∞ÌîåÎ†àÏù¥ ÏÑ†ÌÉùÏù¥ ÌéºÏ≥êÏ†∏ ÏûàÏúºÎ©¥ Ï†ëÍ∏∞
            collapseMultiModeSelection();
            
            if (isExpanded) {
                // Ï†ëÍ∏∞: Î™®Îìú ÏÑ†ÌÉù ÌôîÎ©¥ Ïà®Í∏∞Í∏∞
                collapseModeSelection();
            } else {
                // ÌéºÏπòÍ∏∞: Î™®Îìú ÏÑ†ÌÉù ÌôîÎ©¥ ÌëúÏãú
                modeSelection.classList.add('expanded');
                // Î©ÄÌã∞ ÌîåÎ†àÏù¥Îßå ÎÇ¥Î¶¨Í∏∞
                document.getElementById('multiPlayText').classList.add('moved-down');
                // ÎÇòÎ®∏ÏßÄ Î©îÎâ¥Îäî ÏõêÎûò ÏúÑÏπò Ïú†ÏßÄ
                document.getElementById('collectionText').classList.remove('moved-down');
                document.getElementById('settingsText').classList.remove('moved-down');
                document.getElementById('storageText').classList.remove('moved-down');
            }
        }

        function showMultiModeSelection() {
            const multiModeSelection = document.getElementById('multiModeSelection');
            const isExpanded = multiModeSelection.classList.contains('expanded');
            
            // ÏÜîÎ°úÌîåÎ†àÏù¥ ÏÑ†ÌÉùÏù¥ ÌéºÏ≥êÏ†∏ ÏûàÏúºÎ©¥ Ï†ëÍ∏∞
            collapseModeSelection();
            
            if (isExpanded) {
                // Ï†ëÍ∏∞: Î©ÄÌã∞ Î™®Îìú ÏÑ†ÌÉù ÌôîÎ©¥ Ïà®Í∏∞Í∏∞
                collapseMultiModeSelection();
            } else {
                // ÌéºÏπòÍ∏∞: Î©ÄÌã∞ Î™®Îìú ÏÑ†ÌÉù ÌôîÎ©¥ ÌëúÏãú
                multiModeSelection.classList.add('expanded');
                // ÎèÑÍ∞êÎßå ÎÇ¥Î¶¨Í∏∞ (Î©ÄÌã∞ÌîåÎ†àÏù¥ÏôÄ ÎèÑÍ∞ê ÏÇ¨Ïù¥ Í∞ÑÍ≤©Îßå ÎÑìÌûàÍ∏∞)
                document.getElementById('collectionText').classList.add('moved-down');
            }
        }

        // ÎãâÎÑ§ÏûÑ Î≥ÄÏàò
        let playerNickname = localStorage.getItem('playerNickname') || null;
        let opponentNickname = null;
        
        // Î©ÄÌã∞ÌîåÎ†àÏù¥ Î≥ÄÏàò
        let multiplayerPeer = null;
        let multiplayerConnection = null;
        let currentRoomCode = null;
        let isHost = false;
        let myTeam = null; // 'blue' ÎòêÎäî 'red'
        let opponentTeam = null;
        let opponentReady = false; // ÏÉÅÎåÄÎ∞© Ïó∞Í≤∞ Î∞è ÌåÄ ÏÑ†ÌÉù ÏôÑÎ£å
        let gameStarted = false; // Í≤åÏûÑ ÏãúÏûë Ïó¨Î∂Ä
        
        // ÎãâÎÑ§ÏûÑ ÌôïÏù∏ (Ï≤òÏùå Ï†ëÏÜç ÏãúÏóêÎßå Î¨ºÏñ¥Î¥Ñ)
        function checkNickname() {
            if (!playerNickname || playerNickname.trim() === '') {
                document.getElementById('nicknameModal').style.display = 'block';
            } else {
                showNicknameDisplay();
            }
        }
        
        // ÎãâÎÑ§ÏûÑ Ï†ÄÏû•
        function saveNickname() {
            const input = document.getElementById('nicknameInput');
            const nickname = input.value.trim();
            
            if (nickname.length < 1) {
                input.style.borderColor = '#e94560';
                return;
            }
            
            playerNickname = nickname;
            localStorage.setItem('playerNickname', nickname);
            document.getElementById('nicknameModal').style.display = 'none';
            showNicknameDisplay();
        }
        
        // Ï†úÌôî Î≥ÄÏàò (Í≤åÏûÑ ÎÇ¥ Ï†úÌôî, localStorageÏóêÏÑú Î∂àÎü¨Ïò§Í∏∞)
        let gameKillCount = parseInt(localStorage.getItem('gameKillCount') || '0');
        
        // Ï†úÌôî ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        function updateKillCount(count) {
            gameKillCount = count;
            // localStorageÏóê Ï†ÄÏû•
            localStorage.setItem('gameKillCount', gameKillCount.toString());
            
            const killCountNumber = document.getElementById('killCountNumber');
            if (killCountNumber) {
                killCountNumber.textContent = gameKillCount;
            }
        }
        
        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï†úÌôî ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏ (Ï¶âÏãú Ïã§Ìñâ)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                updateKillCount(gameKillCount);
                // Î©îÏù∏ Î©îÎâ¥Í∞Ä ÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏúºÎ©¥ ÎãâÎÑ§ÏûÑ ÌëúÏãú
                const mainMenu = document.getElementById('mainMenu');
                if (mainMenu && mainMenu.classList.contains('active')) {
                    if (playerNickname) {
                        showNicknameDisplay();
                    }
                }
            });
        } else {
            // Ïù¥ÎØ∏ Î°úÎìúÎêú Í≤ΩÏö∞ Ï¶âÏãú Ïã§Ìñâ
            updateKillCount(gameKillCount);
            // Î©îÏù∏ Î©îÎâ¥Í∞Ä ÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏúºÎ©¥ ÎãâÎÑ§ÏûÑ ÌëúÏãú
            const mainMenu = document.getElementById('mainMenu');
            if (mainMenu && mainMenu.classList.contains('active')) {
                if (playerNickname) {
                    showNicknameDisplay();
                }
            }
        }
        
        // ÎãâÎÑ§ÏûÑ ÌëúÏãú
        function showNicknameDisplay() {
            const nicknameDisplay = document.getElementById('nicknameDisplay');
            const playerNicknameSpan = document.getElementById('playerNickname');
            
            if (playerNickname && nicknameDisplay && playerNicknameSpan) {
                playerNicknameSpan.textContent = playerNickname;
                nicknameDisplay.style.display = 'flex';
                
                // Ï†úÌôî ÌëúÏãúÎèÑ Ìï®Íªò ÏóÖÎç∞Ïù¥Ìä∏
                updateKillCount(gameKillCount);
            } else if (nicknameDisplay) {
                // ÎãâÎÑ§ÏûÑÏù¥ ÏóÜÏñ¥ÎèÑ Ï†úÌôîÎäî ÌëúÏãú
                nicknameDisplay.style.display = 'flex';
                updateKillCount(gameKillCount);
            }
            
            // Ï†úÌôî ÏïÑÏù¥ÏΩò Ìò∏Î≤Ñ Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï (ÎèôÏ†ÅÏúºÎ°ú ÌëúÏãúÎê† ÎïåÎ•º ÎåÄÎπÑ)
            setupKillCountHover();
        }
        
        // ÎãâÎÑ§ÏûÑ Ïà®Í∏∞Í∏∞
        function hideNicknameDisplay() {
            const nicknameDisplay = document.getElementById('nicknameDisplay');
            if (nicknameDisplay) {
                nicknameDisplay.style.display = 'none';
            }
        }
        
        // Ï†úÌôî ÏïÑÏù¥ÏΩò Ìò∏Î≤Ñ Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï
        function setupKillCountHover() {
            const killCountContainer = document.getElementById('killCountContainer');
            const killCountDisplay = document.getElementById('killCountDisplay');
            const killCountNumber = document.getElementById('killCountNumber');
            const killCountInfo = document.getElementById('killCountInfo');
            const nicknameDisplay = document.getElementById('nicknameDisplay');
            
            if (!killCountInfo) return;
            
            const showInfo = () => {
                if (killCountInfo) killCountInfo.style.display = 'block';
            };
            const hideInfo = () => {
                if (killCountInfo) killCountInfo.style.display = 'none';
            };
            
            if (killCountContainer) {
                killCountContainer.addEventListener('mouseenter', showInfo);
                killCountContainer.addEventListener('mouseleave', hideInfo);
            }
            if (killCountDisplay) {
                killCountDisplay.addEventListener('mouseenter', showInfo);
                killCountDisplay.addEventListener('mouseleave', hideInfo);
            }
            if (killCountNumber) {
                killCountNumber.addEventListener('mouseenter', showInfo);
                killCountNumber.addEventListener('mouseleave', hideInfo);
            }
            if (killCountInfo) {
                killCountInfo.addEventListener('mouseenter', showInfo);
                killCountInfo.addEventListener('mouseleave', hideInfo);
            }
        }
        
        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú ÎãâÎÑ§ÏûÑ ÌôïÏù∏
        document.addEventListener('DOMContentLoaded', () => {
            setupKillCountHover();
            setTimeout(() => {
                checkNickname();
                // Î©îÏù∏ Î©îÎâ¥Í∞Ä ÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏúºÎ©¥ ÎãâÎÑ§ÏûÑ ÌëúÏãú
                const mainMenu = document.getElementById('mainMenu');
                if (mainMenu && mainMenu.classList.contains('active')) {
                    if (playerNickname) {
                        showNicknameDisplay();
                    }
                }
            }, 100);
        });

        function generateRoomCode() {
            return Math.floor(10000 + Math.random() * 90000).toString();
        }

        function createRoom() {
            // Ïù¥Ï†Ñ Ïó∞Í≤∞Ïù¥ ÏûàÏúºÎ©¥ ÏôÑÏ†ÑÌûà Ï†ïÎ¶¨
            cleanupMultiplayerConnection();
            
            // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            myTeam = null;
            opponentTeam = null;
            opponentReady = false;
            opponentNickname = null;
            gameStarted = false;
            gameState.isMultiplayer = false;
            currentRoomCode = null;
            
            const modal = document.getElementById('roomModal');
            const title = document.getElementById('roomModalTitle');
            const roomCodeSection = document.getElementById('roomCodeSection');
            const joinInput = document.getElementById('roomJoinInput');
            const teamSelectUI = document.getElementById('teamSelectUI');
            const roomCodeElement = document.getElementById('roomCode');
            const waitingMessage = document.getElementById('waitingMessage');
            
            // Î∞© ÏΩîÎìú ÏÉùÏÑ±
            currentRoomCode = generateRoomCode();
            isHost = true; // Ìò∏Ïä§Ìä∏Î°ú ÏÑ§Ï†ï (initPeerConnection Ï†ÑÏóê ÏÑ§Ï†ï)
            
            // UI ÏÑ§Ï†ï
            title.textContent = 'Î∞© ÏÉùÏÑ±';
            roomCodeSection.style.display = 'block';
            joinInput.style.display = 'none';
            teamSelectUI.style.display = 'none';
            roomCodeElement.textContent = currentRoomCode;
            waitingMessage.textContent = 'ÏÉÅÎåÄÎ∞©ÏùÑ Í∏∞Îã§Î¶¨Îäî Ï§ë...';
            waitingMessage.style.color = '#4a9eff';
            
            modal.style.display = 'block';
            
            // Î©ÄÌã∞ Î©îÎâ¥ Ï†ëÍ∏∞
            collapseMultiModeSelection();
            
            // UI Ï¥àÍ∏∞Ìôî
            document.getElementById('startGameBtn').style.display = 'none';
            document.getElementById('guestWaitingMessage').style.display = 'none';
            updateTeamUI();
            
            // PeerJS Ïó∞Í≤∞ Ï¥àÍ∏∞Ìôî
            initPeerConnection(currentRoomCode);
        }

        function showJoinRoom() {
            // Ïù¥Ï†Ñ Ïó∞Í≤∞Ïù¥ ÏûàÏúºÎ©¥ ÏôÑÏ†ÑÌûà Ï†ïÎ¶¨
            cleanupMultiplayerConnection();
            
            // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            myTeam = null;
            opponentTeam = null;
            opponentReady = false;
            opponentNickname = null;
            gameStarted = false;
            gameState.isMultiplayer = false;
            isHost = false;
            currentRoomCode = null;
            
            const modal = document.getElementById('roomModal');
            const title = document.getElementById('roomModalTitle');
            const roomCodeSection = document.getElementById('roomCodeSection');
            const joinInput = document.getElementById('roomJoinInput');
            const teamSelectUI = document.getElementById('teamSelectUI');
            const joinCodeInput = document.getElementById('joinCodeInput');
            const errorMessage = document.getElementById('joinErrorMessage');
            
            isHost = false;
            
            // UI ÏÑ§Ï†ï
            title.textContent = 'Î∞© ÏûÖÏû•';
            roomCodeSection.style.display = 'none';
            joinInput.style.display = 'block';
            teamSelectUI.style.display = 'none';
            joinCodeInput.value = '';
            errorMessage.style.display = 'none';
            
            modal.style.display = 'block';
            
            // Î©ÄÌã∞ Î©îÎâ¥ Ï†ëÍ∏∞
            collapseMultiModeSelection();
            
            // UI Ï¥àÍ∏∞Ìôî
            document.getElementById('startGameBtn').style.display = 'none';
            document.getElementById('guestWaitingMessage').style.display = 'none';
            updateTeamUI();
            
            // ÏûÖÎ†• ÌïÑÎìúÏóê Ìè¨Ïª§Ïä§
            setTimeout(() => joinCodeInput.focus(), 100);
        }

        function joinRoom() {
            const joinCodeInput = document.getElementById('joinCodeInput');
            const errorMessage = document.getElementById('joinErrorMessage');
            const code = joinCodeInput.value.trim();
            
            if (code.length !== 5 || !/^\d+$/.test(code)) {
                errorMessage.textContent = '5ÏûêÎ¶¨ Ïà´ÏûêÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî';
                errorMessage.style.display = 'block';
                return;
            }
            
            currentRoomCode = code;
            errorMessage.style.display = 'none';
            
            // PeerJSÎ°ú Î∞©Ïóê Ïó∞Í≤∞ ÏãúÎèÑ
            connectToRoom(code);
        }

        function closeRoomModal(keepConnection = false) {
            const modal = document.getElementById('roomModal');
            modal.style.display = 'none';
            
            // UI Ï¥àÍ∏∞Ìôî
            document.getElementById('roomCodeSection').style.display = 'none';
            document.getElementById('roomJoinInput').style.display = 'none';
            document.getElementById('teamSelectUI').style.display = 'none';
            document.getElementById('startGameBtn').style.display = 'none';
            document.getElementById('guestWaitingMessage').style.display = 'none';
            document.getElementById('blueTeamPlayer').innerHTML = '';
            document.getElementById('redTeamPlayer').innerHTML = '';
            document.getElementById('joinCodeInput').value = '';
            document.getElementById('roomModalTitle').style.display = 'block';
            
            // keepConnectionÏù¥ falseÏùº ÎïåÎßå Ïó∞Í≤∞ Ï†ïÎ¶¨ (ÎÇòÍ∞ÄÍ∏∞ Î≤ÑÌäº ÎàÑÎ•º Îïå)
            if (!keepConnection) {
                // ÏÉÅÎåÄÎ∞©ÏóêÍ≤å ÎÇòÍ∞ÄÍ∏∞ ÏïåÎ¶º
                if (multiplayerConnection && multiplayerConnection.open) {
                    sendMultiplayerData({ type: 'leave' });
                }
                
                myTeam = null;
                opponentTeam = null;
                opponentReady = false;
                opponentNickname = null;
                if (multiplayerPeer) {
                    multiplayerPeer.destroy();
                    multiplayerPeer = null;
                }
                multiplayerConnection = null;
                currentRoomCode = null;
            }
        }

        // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïó∞Í≤∞ Ï†ïÎ¶¨ Ìï®Ïàò
        function cleanupMultiplayerConnection() {
            console.log('Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïó∞Í≤∞ Ï†ïÎ¶¨ ÏãúÏûë...');
            
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏûÑ Î£®ÌîÑ Ï†ïÏßÄ
            stopMultiplayerGameLoop();
            
            // ÏÉÅÎåÄÎ∞©ÏóêÍ≤å Ïó∞Í≤∞ Ï¢ÖÎ£å ÏïåÎ¶º (Ïó∞Í≤∞Ïù¥ Ïó¥Î†§ÏûàÏùÑ ÎïåÎßå)
            if (multiplayerConnection) {
                try {
                    if (multiplayerConnection.open) {
                        sendMultiplayerData({ type: 'leave' });
                        multiplayerConnection.close();
                    }
                } catch (e) {
                    console.log('Ïó∞Í≤∞ Ï¢ÖÎ£å ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®:', e);
                }
                // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†úÍ±∞
                try {
                    if (multiplayerConnection.removeAllListeners) {
                        multiplayerConnection.removeAllListeners();
                    }
                } catch (e) {
                    console.log('Ïó∞Í≤∞ Î¶¨Ïä§ÎÑà Ï†úÍ±∞ Ïã§Ìå®:', e);
                }
                multiplayerConnection = null;
            }
            
            if (multiplayerPeer) {
                try {
                    // PeerJSÏùò Î™®Îì† Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†úÍ±∞
                    if (multiplayerPeer.removeAllListeners) {
                        multiplayerPeer.removeAllListeners();
                    }
                    // Peer Ïù∏Ïä§ÌÑ¥Ïä§ ÏôÑÏ†ÑÌûà Ï†ïÎ¶¨
                    if (multiplayerPeer.destroy) {
                        multiplayerPeer.destroy();
                    }
                    // Peer Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÏôÑÏ†ÑÌûà Ï†ïÎ¶¨Îê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞
                    // destroy()Îäî ÎπÑÎèôÍ∏∞Ï†ÅÏúºÎ°ú ÏûëÎèôÌï† Ïàò ÏûàÏúºÎØÄÎ°ú ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ ÌõÑ null ÏÑ§Ï†ï
                } catch (e) {
                    console.log('Peer Ï¢ÖÎ£å Ïã§Ìå®:', e);
                }
                multiplayerPeer = null;
            }
            
            // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            gameState.isMultiplayer = false;
            gameState.obstacles = []; // Ïû•Ïï†Î¨º Ï¥àÍ∏∞Ìôî
            myTeam = null;
            opponentTeam = null;
            opponentReady = false;
            opponentNickname = null;
            currentRoomCode = null;
            isHost = false;
            gameStarted = false;
            
            console.log('Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïó∞Í≤∞ Ï†ïÎ¶¨ ÏôÑÎ£å');
        }
        
        function initPeerConnection(roomCode) {
            const waitingMessage = document.getElementById('waitingMessage');
            
            // Ïù¥Ï†Ñ Ïó∞Í≤∞Ïù¥ ÏûàÏúºÎ©¥ Ï†ïÎ¶¨ (isHostÎäî ÎÇòÏ§ëÏóê ÏÑ§Ï†ïÎêòÎØÄÎ°ú Ï†ÄÏû•)
            const wasHost = isHost;
            cleanupMultiplayerConnection();
            
            // PeerJSÍ∞Ä ÏôÑÏ†ÑÌûà Ï†ïÎ¶¨Îê† ÎïåÍπåÏßÄ ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ (ÌïÑÏöîÌïú Í≤ΩÏö∞)
            // ÌïòÏßÄÎßå ÏùºÎ∞òÏ†ÅÏúºÎ°ú cleanupMultiplayerConnection()Ïù¥ Ï¶âÏãú Ï≤òÎ¶¨ÎêòÎØÄÎ°ú Î∞îÎ°ú ÏßÑÌñâ
            
            // Ìò∏Ïä§Ìä∏Ïù∏ Í≤ΩÏö∞ isHost Î≥µÏõê
            if (wasHost) {
                isHost = true;
            }
            
            // PeerJS Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± (Î∞© ÏΩîÎìúÎ•º IDÎ°ú ÏÇ¨Ïö©)
            const peerId = 'revolver-duel-' + roomCode;
            
            try {
                multiplayerPeer = new Peer(peerId);
                
                multiplayerPeer.on('open', (id) => {
                    console.log('PeerJS Ïó∞Í≤∞Îê®, ID:', id);
                    waitingMessage.textContent = 'ÏÉÅÎåÄÎ∞©ÏùÑ Í∏∞Îã§Î¶¨Îäî Ï§ë...';
                });
                
                multiplayerPeer.on('connection', (conn) => {
                    console.log('ÏÉÅÎåÄÎ∞© Ïó∞Í≤∞Îê®!');
                    multiplayerConnection = conn;
                    
                    conn.on('open', () => {
                        // Î∞© ÏΩîÎìú ÏÑπÏÖò Ïà®Í∏∞Í≥† ÌåÄ ÏÑ†ÌÉù UI ÌëúÏãú
                        document.getElementById('roomCodeSection').style.display = 'none';
                        document.getElementById('teamSelectUI').style.display = 'block';
                        document.getElementById('roomModalTitle').style.display = 'none';
                        
                        // UI Ï¥àÍ∏∞Ìôî
                        updateTeamUI();
                        
                        // ÎÇ¥ ÎãâÎÑ§ÏûÑ Ï†ÑÏÜ°
                        sendMultiplayerData({
                            type: 'nickname',
                            nickname: playerNickname
                        });
                    });
                    
                    conn.on('data', (data) => {
                        handleMultiplayerData(data);
                    });
                    
                    conn.on('close', () => {
                        console.log('ÏÉÅÎåÄÎ∞© Ïó∞Í≤∞ ÎÅäÍπÄ');
                        // Í≤åÏûÑ Ï§ëÏùº ÎïåÎßå disconnect Ï≤òÎ¶¨
                        if (gameState.isMultiplayer && !gameState.isMenu) {
                            handleDisconnect();
                        }
                    });
                });
                
                multiplayerPeer.on('error', (err) => {
                    console.error('PeerJS ÏóêÎü¨:', err);
                    // Í∞ôÏùÄ IDÎ•º ÏÇ¨Ïö©ÌïòÎ†§Í≥† Ìï† Îïå Î∞úÏÉùÌïòÎäî ÏóêÎü¨ Ï≤òÎ¶¨
                    if (err.type === 'peer-unavailable' || err.type === 'unavailable-id') {
                        // Ïù¥Ï†Ñ Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÏïÑÏßÅ Ï†ïÎ¶¨ Ï§ëÏùº Ïàò ÏûàÏúºÎØÄÎ°ú Ïû†Ïãú ÌõÑ Ïû¨ÏãúÎèÑ
                        setTimeout(() => {
                            cleanupMultiplayerConnection();
                            // Ïû¨ÏãúÎèÑ
                            initPeerConnection(roomCode);
                        }, 1000);
                    } else {
                        waitingMessage.textContent = 'Ïó∞Í≤∞ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§';
                        waitingMessage.style.color = '#e94560';
                    }
                });
            } catch (e) {
                console.error('PeerJS Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', e);
                waitingMessage.textContent = 'PeerJS Î°úÎìú Ïã§Ìå®. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ® Ìï¥Ï£ºÏÑ∏Ïöî.';
                waitingMessage.style.color = '#e94560';
            }
        }

        function connectToRoom(roomCode) {
            const errorMessage = document.getElementById('joinErrorMessage');
            const joinInput = document.getElementById('roomJoinInput');
            
            // Ïù¥Ï†Ñ Ïó∞Í≤∞Ïù¥ ÏûàÏúºÎ©¥ Ï†ïÎ¶¨
            cleanupMultiplayerConnection();
            
            // Ìò∏Ïä§Ìä∏Ïùò Peer ID (Î∞© ÏΩîÎìú Í∏∞Î∞ò)
            const peerId = 'revolver-duel-' + roomCode;
            
            try {
                // ÏÉà Peer Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± (Í≥†Ïú† IDÎ°ú)
                const myId = 'revolver-duel-guest-' + Math.random().toString(36).substr(2, 9);
                multiplayerPeer = new Peer(myId);
                
                multiplayerPeer.on('open', () => {
                    console.log('PeerJS Ïó∞Í≤∞Îê®, Î∞©Ïóê Ï†ëÏÜç ÏãúÎèÑ...');
                    
                    // Ìò∏Ïä§Ìä∏Ïóê Ïó∞Í≤∞
                    multiplayerConnection = multiplayerPeer.connect(peerId);
                    
                    multiplayerConnection.on('open', () => {
                        console.log('Î∞©Ïóê Ïó∞Í≤∞Îê®!');
                        
                        // ÏΩîÎìú ÏûÖÎ†• UI Ïà®Í∏∞Í≥† ÌåÄ ÏÑ†ÌÉù UI ÌëúÏãú
                        document.getElementById('roomJoinInput').style.display = 'none';
                        document.getElementById('teamSelectUI').style.display = 'block';
                        document.getElementById('roomModalTitle').style.display = 'none';
                        
                        // UI Ï¥àÍ∏∞Ìôî
                        updateTeamUI();
                        
                        // ÎÇ¥ ÎãâÎÑ§ÏûÑ Ï†ÑÏÜ°
                        sendMultiplayerData({
                            type: 'nickname',
                            nickname: playerNickname
                        });
                    });
                    
                    multiplayerConnection.on('data', (data) => {
                        handleMultiplayerData(data);
                    });
                    
                    multiplayerConnection.on('close', () => {
                        console.log('Ïó∞Í≤∞ ÎÅäÍπÄ');
                        // Í≤åÏûÑ Ï§ëÏùº ÎïåÎßå disconnect Ï≤òÎ¶¨
                        if (gameState.isMultiplayer && !gameState.isMenu) {
                            handleDisconnect();
                        }
                    });
                    
                    multiplayerConnection.on('error', (err) => {
                        console.error('Ïó∞Í≤∞ ÏóêÎü¨:', err);
                        errorMessage.textContent = 'Î∞©ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§';
                        errorMessage.style.display = 'block';
                    });
                    
                    // Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ (5Ï¥à)
                    setTimeout(() => {
                        if (!multiplayerConnection || !multiplayerConnection.open) {
                            errorMessage.textContent = 'Î∞©ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§';
                            errorMessage.style.display = 'block';
                            if (multiplayerPeer) {
                                multiplayerPeer.destroy();
                                multiplayerPeer = null;
                            }
                        }
                    }, 5000);
                });
                
                multiplayerPeer.on('error', (err) => {
                    console.error('PeerJS ÏóêÎü¨:', err);
                    // Ïó∞Í≤∞ Ïò§Î•ò Ï≤òÎ¶¨
                    if (err.type === 'peer-unavailable' || err.type === 'unavailable-id') {
                        // Ïù¥Ï†Ñ Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÏïÑÏßÅ Ï†ïÎ¶¨ Ï§ëÏùº Ïàò ÏûàÏúºÎØÄÎ°ú Ïû†Ïãú ÌõÑ Ïû¨ÏãúÎèÑ
                        setTimeout(() => {
                            cleanupMultiplayerConnection();
                            // Ïû¨ÏãúÎèÑ
                            connectToRoom(roomCode);
                        }, 1000);
                    } else {
                        errorMessage.textContent = 'Ïó∞Í≤∞ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§';
                        errorMessage.style.display = 'block';
                    }
                });
            } catch (e) {
                console.error('PeerJS Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', e);
                errorMessage.textContent = 'PeerJS Î°úÎìú Ïã§Ìå®';
                errorMessage.style.display = 'block';
            }
        }

        function handleMultiplayerData(data) {
            if (!data || !data.type) return;
            
            switch (data.type) {
                case 'gameState':
                    // Í≤åÏûÑÏù¥ ÏãúÏûëÎêòÏßÄ ÏïäÏïòÏúºÎ©¥ Î¨¥Ïãú
                    if (!gameStarted) return;
                    
                    // ÏÉÅÎåÄÎ∞©Ïùò ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉúÎ•º Ïö∞Î¶¨Ïùò enemyÏóê Ï†ÅÏö©
                    if (data.player) {
                        enemy.x = data.player.x;
                        enemy.y = data.player.y;
                        enemy.angle = data.player.angle;
                        enemy.health = data.player.health;
                        enemy.displayHealth = data.player.displayHealth;
                        enemy.ammo = data.player.ammo;
                        enemy.maxAmmo = data.player.maxAmmo;
                        enemy.isReloading = data.player.isReloading;
                        enemy.reloadStartTime = data.player.reloadStartTime;
                        enemy.reloadTime = data.player.reloadTime;
                        enemy.isDodging = data.player.isDodging;
                        enemy.isInvincible = data.player.isInvincible;
                        enemy.isReviving = data.player.isReviving;
                        enemy.shieldReady = data.player.shieldReady;
                        enemy.reflectActive = data.player.reflectActive;
                        enemy.isFortified = data.player.isFortified;
                    }
                    
                    // Í≤åÏûÑ ÏÉÅÌÉú ÎèôÍ∏∞Ìôî (isPaused, countdown)
                    if (data.gameState) {
                        // Ìò∏Ïä§Ìä∏Ïùò isPaused ÏÉÅÌÉúÎ•º Îî∞Î¶Ñ
                        if (isHost === false) {
                            gameState.isPaused = data.gameState.isPaused;
                            gameState.countdown = data.gameState.countdown;
                        }
                    }
                    break;
                    
                case 'shoot':
                    // ÏÉÅÎåÄÎ∞©Ïù¥ Ï¥ùÏùÑ ÏêàÏùÑ Îïå
                    if (data.bullets) {
                        data.bullets.forEach(bulletData => {
                            const bullet = new Bullet(
                                bulletData.x,
                                bulletData.y,
                                bulletData.angle,
                                enemy,
                                false
                            );
                            bullet.damage = bulletData.damage || enemy.damage;
                            bullet.hasPoison = bulletData.hasPoison || false;
                            bullet.hasBouncy = bulletData.hasBouncy || false;
                            bullet.maxBounces = bulletData.maxBounces || 0;
                            enemy.bullets.push(bullet);
                        });
                    }
                    break;
                    
                case 'teamSelect':
                    // ÏÉÅÎåÄÎ∞© ÌåÄ ÏÑ†ÌÉù
                    opponentTeam = data.team;
                    console.log('ÏÉÅÎåÄÎ∞© ÌåÄ ÏÑ†ÌÉù ÏàòÏã†:', opponentTeam, 'ÎÇ¥ ÌåÄ:', myTeam, 'Ìò∏Ïä§Ìä∏:', isHost);
                    updateTeamUI();
                    // ÏñëÏ™Ω Î™®Îëê ÏÑ†ÌÉùÎêòÏóàÎäîÏßÄ Îã§Ïãú ÌïúÎ≤à ÌôïÏù∏ÌïòÏó¨ Î≤ÑÌäº ÌëúÏãú
                    if (isHost && myTeam && opponentTeam) {
                        const startGameBtn = document.getElementById('startGameBtn');
                        if (startGameBtn) {
                            startGameBtn.style.display = 'block';
                            console.log('‚úÖ ÏÉÅÎåÄÎ∞© ÌåÄ ÏÑ†ÌÉù ÏàòÏã† ÌõÑ ÏãúÏûë Î≤ÑÌäº ÌëúÏãúÎê®!');
                        }
                    }
                    break;
                    
                case 'nickname':
                    // ÏÉÅÎåÄÎ∞© ÎãâÎÑ§ÏûÑ ÏàòÏã†
                    opponentNickname = data.nickname;
                    opponentReady = true;
                    updateTeamUI();
                    break;
                
                case 'leave':
                    // ÏÉÅÎåÄÎ∞©Ïù¥ Î∞©ÏùÑ ÎÇòÍ∞ê (Î©îÏãúÏßÄ Î≥¥ÎÇ¥ÏßÄ ÏïäÍ≥† Ï†ïÎ¶¨)
                    console.log('ÏÉÅÎåÄÎ∞©Ïù¥ Î∞©ÏùÑ ÎÇòÍ∞îÏäµÎãàÎã§');
                    // Í≤åÏûÑ Ï§ëÏù¥ ÏïÑÎãàÎ©¥ ÏïåÎ¶º ÌëúÏãú
                    if (!gameStarted) {
                        alert('ÏÉÅÎåÄÎ∞©Ïù¥ ÎÇòÍ∞îÏäµÎãàÎã§');
                    }
                    // Ïó∞Í≤∞ ÏôÑÏ†ÑÌûà Ï†ïÎ¶¨
                    cleanupMultiplayerConnection();
                    closeRoomModal(true); // keepConnection=trueÎ°ú Ìï¥ÏÑú Îã§Ïãú leave Î©îÏãúÏßÄ Ïïà Î≥¥ÎÉÑ
                    currentRoomCode = null;
                    // UI Ï¥àÍ∏∞Ìôî
                    document.getElementById('roomCodeSection').style.display = 'none';
                    document.getElementById('roomJoinInput').style.display = 'none';
                    document.getElementById('teamSelectUI').style.display = 'none';
                    document.getElementById('startGameBtn').style.display = 'none';
                    document.getElementById('guestWaitingMessage').style.display = 'none';
                    break;
                    
                case 'gameEnd':
                    // ÏÉÅÎåÄÎ∞©Ïù¥ Í≤åÏûÑ Ï¢ÖÎ£å ÏïåÎ¶º (ÎèôÍ∏∞Ìôî)
                    console.log('ÏÉÅÎåÄÎ∞© Í≤åÏûÑ Ï¢ÖÎ£å:', data.winner);
                    // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏûÑ Î£®ÌîÑ Ï†ïÏßÄ
                    stopMultiplayerGameLoop();
                    break;
                    
                case 'startGame':
                    // Ìò∏Ïä§Ìä∏Í∞Ä Í≤åÏûÑ ÏãúÏûë
                    if (!isHost) {
                        closeRoomModal(true);
                        startMultiplayerGame();
                    }
                    break;
                    
                case 'roundEnd':
                    // ÎùºÏö¥Îìú Ï¢ÖÎ£å ÎèôÍ∏∞Ìôî - Í≤åÏä§Ìä∏Îßå Ï≤òÎ¶¨
                    if (!isHost && data.winner) {
                        if (data.winner === 'host') {
                            // Ìò∏Ïä§Ìä∏Í∞Ä Ïù¥ÍπÄ = ÎÇò(Í≤åÏä§Ìä∏)Í∞Ä Ïßê
                            handleRoundEndFromHost('enemy');
                        } else {
                            // Í≤åÏä§Ìä∏Í∞Ä Ïù¥ÍπÄ = ÎÇò(Í≤åÏä§Ìä∏)Í∞Ä Ïù¥ÍπÄ
                            handleRoundEndFromHost('player');
                        }
                    }
                    break;
                    
                case 'augmentSelected':
                    // ÏÉÅÎåÄÎ∞© Ï¶ùÍ∞ï ÏÑ†ÌÉù ÏôÑÎ£å
                    if (data.augment) {
                        const aug = augmentations.find(a => a.id === data.augment.id);
                        if (aug) {
                            aug.effect(enemy);
                            enemy.augmentations.push(aug);
                        }
                    }
                    // ÏÉÅÎåÄ ÏÑ†ÌÉù ÏôÑÎ£å - Îã§Ïùå ÎùºÏö¥ÎìúÎ°ú
                    gameState.showOpponentSelecting = false;
                    setTimeout(() => {
                        nextRound();
                    }, 500);
                    break;
                    
                case 'nextRound':
                    // Îã§Ïùå ÎùºÏö¥Îìú ÏãúÏûë
                    if (!isHost) {
                        nextRound();
                    }
                    break;
                    
            }
        }
        
        // Í≤åÏä§Ìä∏Ïö©: Ìò∏Ïä§Ìä∏Î°úÎ∂ÄÌÑ∞ ÎùºÏö¥Îìú Ï¢ÖÎ£å Î∞õÏùå
        function handleRoundEndFromHost(winner) {
            // Î™®Îì† Ïù¥ÌéôÌä∏ ÏßÄÏö∞Í∏∞
            if (player.hitEffectParticles) {
                player.hitEffectParticles = [];
            }
            if (enemy.hitEffectParticles) {
                enemy.hitEffectParticles = [];
            }
            gameState.isPaused = true;
            gameState.roundWins.push(winner);
            
            if (winner === 'player') {
                gameState.playerWins++;
            } else {
                gameState.enemyWins++;
            }
            
            // ÏäπÎ¶¨ Ï≤¥ÌÅ¨
            if (gameState.playerWins >= gameState.winsNeeded || gameState.enemyWins >= gameState.winsNeeded) {
                endGame(winner);
                return;
            }
            
            // Ï¶ùÍ∞ï ÏÑ†ÌÉù
            if (winner === 'player') {
                // ÎÇ¥Í∞Ä ÏäπÎ¶¨: ÏÉÅÎåÄÍ∞Ä Ï¶ùÍ∞ï ÏÑ†ÌÉù Ï§ë - 15Ï¥à Ïπ¥Ïö¥Ìä∏Îã§Ïö¥Îßå ÌëúÏãú
                gameState.showOpponentSelecting = true;
                gameState.augmentCountdown = 15;
                startOpponentWaitCountdown();
            } else {
                // ÎÇ¥Í∞Ä Ìå®Î∞∞: Ï¶ùÍ∞ï ÏÑ†ÌÉù
                showAugmentModal(player);
            }
        }
        
        // ÏÉÅÎåÄÎ∞© Ï¶ùÍ∞ï ÏÑ†ÌÉù ÎåÄÍ∏∞ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
        function startOpponentWaitCountdown() {
            const countdownInterval = setInterval(() => {
                gameState.augmentCountdown--;
                if (gameState.augmentCountdown <= 0 || !gameState.showOpponentSelecting) {
                    clearInterval(countdownInterval);
                    gameState.augmentCountdown = 0;
                }
            }, 1000);
        }
        
        // ÌåÄ ÏÑ†ÌÉù
        function selectTeam(team) {
            // ÏÉÅÎåÄÎ∞©Ïù¥ Ïù¥ÎØ∏ Í∑∏ ÌåÄÏùÑ ÏÑ†ÌÉùÌñàÏúºÎ©¥ ÏÑ†ÌÉù Î∂àÍ∞Ä
            if (opponentTeam === team) {
                return;
            }
            
            myTeam = team;
            
            // ÏÉÅÎåÄÎ∞©ÏóêÍ≤å ÌåÄ ÏÑ†ÌÉù ÏïåÎ¶º
            sendMultiplayerData({
                type: 'teamSelect',
                team: team
            });
            
            updateTeamUI();
        }
        
        // ÌåÄ UI ÏóÖÎç∞Ïù¥Ìä∏
        function updateTeamUI() {
            const blueTeamPlayer = document.getElementById('blueTeamPlayer');
            const redTeamPlayer = document.getElementById('redTeamPlayer');
            const blueTeamBox = document.getElementById('blueTeamBox');
            const redTeamBox = document.getElementById('redTeamBox');
            const teamSelectStatus = document.getElementById('teamSelectStatus');
            
            // ÏôïÍ¥Ä ÏïÑÏù¥ÏΩò (Ìò∏Ïä§Ìä∏ ÌëúÏãú) - ÎÖ∏ÎûÄÏÉâ
            
            // ÌååÎûÄÌåÄ ÌëúÏãú
            if (myTeam === 'blue') {
                const name = playerNickname || 'ÎÇò';
                blueTeamPlayer.innerHTML = name;
                blueTeamBox.style.boxShadow = '0 0 20px rgba(74, 158, 255, 0.5)';
            } else if (opponentTeam === 'blue') {
                const name = opponentNickname || 'ÏÉÅÎåÄÎ∞©';
                blueTeamPlayer.innerHTML = name;
                blueTeamBox.style.boxShadow = 'none';
            } else {
                blueTeamPlayer.innerHTML = '';
                blueTeamBox.style.boxShadow = 'none';
            }
            
            // Îπ®Í∞ÑÌåÄ ÌëúÏãú
            if (myTeam === 'red') {
                const name = playerNickname || 'ÎÇò';
                redTeamPlayer.innerHTML = name;
                redTeamBox.style.boxShadow = '0 0 20px rgba(233, 69, 96, 0.5)';
            } else if (opponentTeam === 'red') {
                const name = opponentNickname || 'ÏÉÅÎåÄÎ∞©';
                redTeamPlayer.innerHTML = name;
                redTeamBox.style.boxShadow = 'none';
            } else {
                redTeamPlayer.innerHTML = '';
                redTeamBox.style.boxShadow = 'none';
            }
            
            // ÏÉÅÌÉú Î©îÏãúÏßÄ
            if (myTeam && opponentTeam) {
                teamSelectStatus.textContent = 'ÏñëÏ™Ω Î™®Îëê ÌåÄ ÏÑ†ÌÉù ÏôÑÎ£å!';
                teamSelectStatus.style.color = '#00ff00';
            } else if (myTeam) {
                teamSelectStatus.textContent = 'ÏÉÅÎåÄÎ∞©Ïù¥ ÌåÄÏùÑ ÏÑ†ÌÉùÌïòÎäî Ï§ë...';
                teamSelectStatus.style.color = '#ffc107';
            } else {
                teamSelectStatus.textContent = 'ÌåÄÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî';
                teamSelectStatus.style.color = '#aaa';
            }
            
            // Ìò∏Ïä§Ìä∏: ÏñëÏ™Ω Î™®Îëê ÌåÄ ÏÑ†ÌÉù ÏôÑÎ£åÌïòÎ©¥ ÏãúÏûë Î≤ÑÌäº ÌëúÏãú
            const startGameBtn = document.getElementById('startGameBtn');
            if (startGameBtn) {
                // Ìò∏Ïä§Ìä∏Ïù¥Í≥† ÏñëÏ™Ω Î™®Îëê ÌåÄÏùÑ ÏÑ†ÌÉùÌñàÎäîÏßÄ ÌôïÏù∏
                const bothTeamsSelected = isHost && myTeam && opponentTeam;
                console.log('updateTeamUI Ìò∏Ï∂úÎê®:', { isHost, myTeam, opponentTeam, bothTeamsSelected });
                
                if (bothTeamsSelected) {
                    // ÏñëÏ™Ω Î™®Îëê ÌåÄ ÏÑ†ÌÉù ÏôÑÎ£å - ÏãúÏûë Î≤ÑÌäº ÌëúÏãú
                    startGameBtn.style.display = 'block';
                    console.log('‚úÖ ÏãúÏûë Î≤ÑÌäº ÌëúÏãúÎê®!');
                } else {
                    // Ï°∞Í±¥Ïù¥ ÎßûÏßÄ ÏïäÏúºÎ©¥ ÏãúÏûë Î≤ÑÌäº Ïà®Í∏∞Í∏∞
                    startGameBtn.style.display = 'none';
                    if (isHost) {
                        console.log('‚ùå ÏãúÏûë Î≤ÑÌäº Ïà®ÍπÄ - Ï°∞Í±¥ Î∂àÏùºÏπò:', {
                            'isHost': isHost,
                            'myTeam': myTeam,
                            'opponentTeam': opponentTeam,
                            'myTeam truthy': !!myTeam,
                            'opponentTeam truthy': !!opponentTeam
                        });
                    }
                }
            } else {
                console.error('startGameBtn ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§!');
            }
            
            // Í≤åÏä§Ìä∏: ÎåÄÍ∏∞ Î©îÏãúÏßÄ ÌëúÏãú
            if (!isHost && myTeam) {
                document.getElementById('guestWaitingMessage').style.display = 'block';
            } else {
                document.getElementById('guestWaitingMessage').style.display = 'none';
            }
        }
        
        // Í≤åÏûÑ ÏãúÏûë Ïã†Ìò∏ Ï†ÑÏÜ° (Ìò∏Ïä§Ìä∏Îßå)
        function sendStartGame() {
            if (!isHost || !myTeam) return;
            
            // ÏÉÅÎåÄÎ∞©ÏóêÍ≤å Í≤åÏûÑ ÏãúÏûë ÏïåÎ¶º
            sendMultiplayerData({ type: 'startGame' });
            
            // ÏûêÏã†ÎèÑ Í≤åÏûÑ ÏãúÏûë
            closeRoomModal(true);
            startMultiplayerGame();
        }
        
        // Ïó∞Í≤∞ ÎÅäÍπÄ ÌôïÏù∏
        function confirmDisconnect() {
            document.getElementById('disconnectModal').style.display = 'none';
            // Ïó∞Í≤∞ ÏôÑÏ†ÑÌûà Ï†ïÎ¶¨
            cleanupMultiplayerConnection();
            restartGame();
        }

        function handleDisconnect() {
            // Ïó∞Í≤∞ ÎÅäÍπÄ Ï≤òÎ¶¨
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏûÑ Î£®ÌîÑ Ï†ïÏßÄ
            stopMultiplayerGameLoop();
            
            // Ïó∞Í≤∞ ÏôÑÏ†ÑÌûà Ï†ïÎ¶¨
            cleanupMultiplayerConnection();
            
            gameState.isMultiplayer = false;
            gameStarted = false;
            
            // Í≤åÏûÑ Ï§ëÏù¥ÏóàÏúºÎ©¥ Î™®Îã¨ ÌëúÏãú
            if (!gameState.isMenu) {
                document.getElementById('disconnectModal').style.display = 'block';
            }
        }

        // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°
        function sendMultiplayerData(data) {
            if (multiplayerConnection && multiplayerConnection.open) {
                multiplayerConnection.send(data);
            }
        }

        // ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉú Ï†ÑÏÜ° (Í≤åÏûÑ Î£®ÌîÑÏóêÏÑú Ìò∏Ï∂ú)
        function sendPlayerState() {
            if (!gameState.isMultiplayer || !multiplayerConnection) return;
            
            const now = Date.now();
            // 30msÎßàÎã§ Ï†ÑÏÜ° (ÏïΩ 33fps)
            if (now - gameState.lastSyncTime < 30) return;
            gameState.lastSyncTime = now;
            
            sendMultiplayerData({
                type: 'gameState',
                player: {
                    x: player.x,
                    y: player.y,
                    angle: player.angle,
                    health: player.health,
                    displayHealth: player.displayHealth,
                    ammo: player.ammo,
                    maxAmmo: player.maxAmmo,
                    isReloading: player.isReloading,
                    reloadStartTime: player.reloadStartTime,
                    reloadTime: player.reloadTime,
                    isDodging: player.isDodging,
                    isInvincible: player.isInvincible,
                    isReviving: player.isReviving,
                    shieldReady: player.shieldReady,
                    reflectActive: player.reflectActive,
                    isFortified: player.isFortified
                },
                gameState: {
                    isPaused: gameState.isPaused,
                    countdown: gameState.countdown
                }
            });
        }

        // Ï¥ùÏïå Î∞úÏÇ¨ Ï†ÑÏÜ°
        function sendShootData(bullets) {
            if (!gameState.isMultiplayer) return;
            
            const bulletDataArray = bullets.map(b => ({
                x: b.x,
                y: b.y,
                angle: b.angle,
                damage: b.damage,
                hasPoison: b.hasPoison,
                hasBouncy: b.hasBouncy,
                maxBounces: b.maxBounces
            }));
            
            sendMultiplayerData({
                type: 'shoot',
                bullets: bulletDataArray
            });
        }

        // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïû•Ïï†Î¨º ÏÉùÏÑ± Ìï®Ïàò
        function generateMultiplayerObstacles() {
            gameState.obstacles = [];
            const minSize = 50; // ÏµúÏÜå ÌÅ¨Í∏∞
            const maxSize = 200; // ÏµúÎåÄ ÌÅ¨Í∏∞ (200px Ïù¥ÎÇ¥)
            const minDistance = 100; // Ïû•Ïï†Î¨º Í∞Ñ ÏµúÏÜå Í±∞Î¶¨
            const margin = 50; // Îßµ Í≤ΩÍ≥ÑÎ°úÎ∂ÄÌÑ∞Ïùò Ïó¨Î∞±
            
            for (let i = 0; i < 4; i++) {
                let attempts = 0;
                let valid = false;
                let obstacle = null;
                
                while (!valid && attempts < 100) {
                    attempts++;
                    const width = Math.random() * (maxSize - minSize) + minSize;
                    const height = Math.random() * (maxSize - minSize) + minSize;
                    const angle = Math.random() * Math.PI * 2; // ÎûúÎç§ ÌöåÏ†Ñ
                    
                    // ÌöåÏ†ÑÎêú ÏßÅÏÇ¨Í∞ÅÌòïÏùò Ïã§Ï†ú ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
                    const cos = Math.abs(Math.cos(angle));
                    const sin = Math.abs(Math.sin(angle));
                    const actualWidth = width * cos + height * sin;
                    const actualHeight = width * sin + height * cos;
                    
                    // ÎûúÎç§ ÏúÑÏπò (Îßµ Í≤ΩÍ≥Ñ ÎÇ¥, Ïó¨Î∞± Í≥†Î†§)
                    const x = Math.random() * (gameState.mapBounds.maxX - gameState.mapBounds.minX - actualWidth - margin * 2) + 
                              gameState.mapBounds.minX + actualWidth / 2 + margin;
                    const y = Math.random() * (gameState.mapBounds.maxY - gameState.mapBounds.minY - actualHeight - margin * 2) + 
                              gameState.mapBounds.minY + actualHeight / 2 + margin;
                    
                    // Îã§Î•∏ Ïû•Ïï†Î¨ºÍ≥ºÏùò Í±∞Î¶¨ ÌôïÏù∏
                    let tooClose = false;
                    for (let j = 0; j < gameState.obstacles.length; j++) {
                        const other = gameState.obstacles[j];
                        const dx = x - other.x;
                        const dy = y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minRequiredDistance = Math.max(actualWidth, actualHeight) / 2 + 
                                                   Math.max(other.width, other.height) / 2 + minDistance;
                        
                        if (distance < minRequiredDistance) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï†ÅÏùò Ï¥àÍ∏∞ ÏúÑÏπòÏôÄÏùò Í±∞Î¶¨ ÌôïÏù∏
                    const playerDist = Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2);
                    const enemyDist = Math.sqrt((x - enemy.x) ** 2 + (y - enemy.y) ** 2);
                    const minPlayerDistance = Math.max(actualWidth, actualHeight) / 2 + player.radius + 50;
                    
                    if (!tooClose && playerDist > minPlayerDistance && enemyDist > minPlayerDistance) {
                        obstacle = { x, y, width, height, angle };
                        valid = true;
                    }
                }
                
                if (obstacle) {
                    gameState.obstacles.push(obstacle);
                }
            }
            
            console.log('Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïû•Ïï†Î¨º ÏÉùÏÑ±:', gameState.obstacles.length, 'Í∞ú');
        }

        function startMultiplayerGame() {
            console.log('Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏûÑ ÏãúÏûë! Ìò∏Ïä§Ìä∏:', isHost, 'ÌåÄ:', myTeam);
            
            gameStarted = true;
            
            // Í≤åÏûÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            gameState.isMultiplayer = true;
            
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏûÑ Î£®ÌîÑ ÏãúÏûë (Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑúÎèÑ Ïã§Ìñâ)
            startMultiplayerGameLoop();
            gameState.isMenu = false;
            gameState.gameMode = 'classic'; // Î©ÄÌã∞ÌîåÎ†àÏù¥Îäî ÌÅ¥ÎûòÏãù Î™®Îìú
            gameState.round = 1;
            gameState.playerWins = 0;
            gameState.enemyWins = 0;
            gameState.roundWins = [];
            gameState.gameTime = 180;
            gameState.isGameOver = false;
            gameState.countdown = 3;
            gameState.isPaused = true;
            
            // Î©îÏù∏ Î©îÎâ¥ Ïà®Í∏∞Í∏∞
            showScreen('game'); // Í≤åÏûÑ ÌôîÎ©¥ÏúºÎ°ú Ï†ÑÌôò (Ïã§Ï†úÎ°úÎäî Î™®Îì† ÌôîÎ©¥ Ïà®ÍπÄ)
            
            // ÎãâÎÑ§ÏûÑ Ïà®Í∏∞Í∏∞
            hideNicknameDisplay();
            
            // Îßµ Í≤ΩÍ≥Ñ ÏÑ§Ï†ï
            gameState.mapBounds = {
                minX: 0,
                minY: 0,
                maxX: canvas.width,
                maxY: canvas.height
            };
            
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïû•Ïï†Î¨º ÏÉùÏÑ±
            generateMultiplayerObstacles();
            
            // ÌåÄÏóê Îî∞Î•∏ ÏÉâÏÉÅ Î∞è ÏúÑÏπò ÏÑ§Ï†ï
            const isBlueTeam = myTeam === 'blue';
            player.color = isBlueTeam ? '#4a9eff' : '#e94560';
            enemy.color = isBlueTeam ? '#e94560' : '#4a9eff';
            
            // ÌååÎûÄÌåÄÏùÄ ÏôºÏ™Ω, Îπ®Í∞ÑÌåÄÏùÄ Ïò§Î•∏Ï™Ω
            const leftX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            const rightX = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
            const centerY = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            
            player.x = isBlueTeam ? leftX : rightX;
            player.y = centerY;
            enemy.x = isBlueTeam ? rightX : leftX;
            enemy.y = centerY;
            
            // ÌîåÎ†àÏù¥Ïñ¥ Ï¥àÍ∏∞Ìôî
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.damage = 1;
            player.speed = 3;
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.reloadTime = 3000;
            player.baseReloadTime = 3000;
            player.shootCooldown = 1000;
            player.isReloading = false;
            player.isDodging = false;
            player.isReviving = false;
            player.isInvincible = false;
            player.hasRevived = 0;
            resetPlayerAugments(player);
            
            // Ï†Å(ÏÉÅÎåÄÎ∞©) Ï¥àÍ∏∞Ìôî
            enemy.health = 5;
            enemy.displayHealth = 5;
            enemy.maxHealth = 5;
            enemy.ammo = 6;
            enemy.maxAmmo = 6;
            enemy.bullets = [];
            enemy.augmentations = [];
            enemy.damage = 1;
            enemy.speed = 3;
            enemy.bulletSpeedMultiplier = 1;
            enemy.bulletSizeMultiplier = 1;
            enemy.reloadTime = 3000;
            enemy.baseReloadTime = 3000;
            enemy.shootCooldown = 1000;
            enemy.isReloading = false;
            enemy.isDodging = false;
            enemy.isReviving = false;
            enemy.isInvincible = false;
            enemy.hasRevived = 0;
            resetPlayerAugments(enemy);
            
            // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏãúÏûë
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.isPaused = false;
                }
            }, 1000);
        }
        
        // ÌîåÎ†àÏù¥Ïñ¥ Ï¶ùÍ∞ï ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî Ìó¨Ìçº Ìï®Ïàò
        function resetPlayerAugments(char) {
            char.hasCritical = false;
            char.hasDoubleShot = false;
            char.hasDodge = false;
            char.hasRevive = false;
            char.hasDeepWound = false;
            char.hasOneShotOneKill = false;
            char.hasPoisonBullet = false;
            char.hasReloadHeal = false;
            char.hasSurvivalInstinct = false;
            char.hasLastBullet = false;
            char.hasRecoveryContract = false;
            char.hasRecoveryContractUsed = false;
            char.hasFocusedFire = false;
            char.hasShotgun = false;
            char.hasRagged = false;
            char.hasGhost = false;
            char.hasFortify = false;
            char.isFortified = false;
            char.hasOverheat = false;
            char.hasGamble = false;
            char.hasWeaken = false;
            char.isWeakened = false;
            char.hasDamageBoost = false;
            char.hasLightning = false;
            char.isStunned = false;
            char.hasShield = false;
            char.shieldReady = false;
            char.hasRegeneration = false;
            char.hasEvasiveManeuver = false;
            char.hasCombatExperience = false;
            char.hasHallucination = false;
            char.hasTasteOfBlood = false;
            char.hasCannon = false;
            char.hasTimeBarrier = false;
            char.hasBouncyBullet = false;
            char.hasGamble2 = false;
            char.hasReflect = false;
            char.reflectActive = false;
            char.hasExplosiveBullet = false;
            char.hasReaper = false;
            char.isInvisible = false;
            char.invisibilityEndTime = 0;
            char.hasOvercharge = false;
            char.overchargeActive = false;
            char.overchargeCooldown = 0;
            char.overchargeEndTime = 0;
            char.hasVictor = false;
            char.hasTimeStop = false;
            char.timeStopActive = false;
            char.hasScatter = false;
            char.hasRocket = false;
            char.hasTrinity = false;
            char.hasJudgment = false;
            char.hasBoomerang = false;
            char.poisonEffects = [];
            char.damageNumbers = [];
        }

        // ÎûúÎç§ Î™®Îìú Ï†ïÏùò
        const randomModes = [
            {
                id: 'doubleAugment',
                name: '2XÎ™®Îìú',
                description: 'Ï¶ùÍ∞ïÏùÑ 2Í∞úÏî© ÏÑ†ÌÉùÌï©ÎãàÎã§'
            },
            {
                id: 'hp1',
                name: 'HP1Î™®Îìú',
                description: 'Ï¥àÍ∏∞ ÏµúÎåÄÏ≤¥Î†•Ïù¥ 1Ïù¥ Îê©ÎãàÎã§'
            },
            {
                id: 'movingWork',
                name: 'Î¨¥ÎπôÏõåÌÅ¨Î™®Îìú',
                description: 'Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥Í∞Ä 5Ï¥àÎßàÎã§ Î∞îÎÄåÎäî Î∞©Ìñ•ÏúºÎ°ú Ï¥àÎãπ 25pxÏî© Ïù¥ÎèôÌï©ÎãàÎã§'
            },
            {
                id: 'turtle',
                name: 'Í±∞Î∂ÅÏù¥Î™®Îìú',
                description: 'Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥Ïùò Ïù¥ÎèôÏÜçÎèÑÍ∞Ä 50% Í∞êÏÜåÌï©ÎãàÎã§'
            },
            {
                id: 'flame',
                name: 'Ïö©ÏïîÎ™®Îìú',
                description: 'Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥Í∞Ä 5Ï¥àÎßàÎã§ 0.5 Îç∞ÎØ∏ÏßÄÎ•º ÏûÖÏäµÎãàÎã§'
            },
            {
                id: 'noReload',
                name: 'Î¶¨Î°úÎìú!Î™®Îìú',
                description: 'Ïû¨Ïû•Ï†Ñ ÏãúÍ∞ÑÏù¥ 0.3Ï¥àÍ∞Ä Îê©ÎãàÎã§'
            },
            {
                id: 'melee',
                name: 'Í∑ºÏ†ëÏ†ÑÎ™®Îìú',
                description: 'Î™®Îì† Ï¥ùÏïåÏù¥ 500pxÍπåÏßÄÎßå Î∞úÏÇ¨Îê©ÎãàÎã§'
            },
            {
                id: 'smallMap',
                name: '-25%Î™®Îìú',
                description: 'Îßµ ÌÅ¨Í∏∞Í∞Ä 25% Ï§ÑÏñ¥Îì≠ÎãàÎã§'
            },
            {
                id: 'ice',
                name: 'ÎπôÌåêÎ™®Îìú',
                description: 'Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ïù¥ÎèôÎ∞©Ìñ•ÏúºÎ°ú ÎØ∏ÎÅÑÎü¨ÏßëÎãàÎã§'
            },
            {
                id: 'superAI',
                name: 'ÏäàÌçºAIÎ™®Îìú',
                description: 'AIÍ∞Ä Ï¶ùÍ∞ïÏùÑ ÎûúÎç§ÏúºÎ°ú 2Í∞ú ÏÑ†ÌÉùÌïòÍ≥† Í≤åÏûÑÏùÑ ÏãúÏûëÌï©ÎãàÎã§'
            }
        ];

        function startSoloGame(mode) {
            // Î™®Îìú ÏÑ†ÌÉù Ï†ëÍ∏∞
            collapseModeSelection();
            
            gameState.gameMode = mode || 'classic'; // 'classic' ÎòêÎäî 'random'
            
            // ÎûúÎç§ Î™®ÎìúÏù∏ Í≤ΩÏö∞ Ïä¨Î°ØÎ®∏Ïã† Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë (ÏãúÍ∞Ñ Î©àÏ∂îÍ∏∞)
            if (mode === 'random') {
                gameState.isPaused = true; // Ïä¨Î°ØÎ®∏Ïã† Ï§ë ÏãúÍ∞Ñ Î©àÏ∂îÍ∏∞
                gameState.isSlotMachine = true;
                gameState.slotMachineStartTime = Date.now();
                gameState.slotMachineCurrentIndex = 0;
                gameState.slotMachineSelectedMode = null;
                gameState.selectedRandomMode = null; // ÏïÑÏßÅ ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏùå
            } else {
                gameState.selectedRandomMode = null;
                gameState.isSlotMachine = false;
            }
            
            gameState.isMenu = false;
            showScreen('game'); // Í≤åÏûÑ ÌôîÎ©¥ÏúºÎ°ú Ï†ÑÌôò (Ïã§Ï†úÎ°úÎäî ÌôîÎ©¥ Ïà®ÍπÄ)
            
            // ÎãâÎÑ§ÏûÑ Ïà®Í∏∞Í∏∞
            hideNicknameDisplay();
            
            initGame();
        }

        // ÎûúÎç§ Î™®Îìú Ï†ÅÏö© Ìï®Ïàò
        function applyRandomMode(modeId) {
            switch(modeId) {
                case 'hp1':
                    // HP1Î™®Îìú: ÏµúÎåÄÏ≤¥Î†• 1Î°ú ÏãúÏûë
                    player.maxHealth = 1;
                    player.health = 1;
                    player.displayHealth = 1;
                    enemy.maxHealth = 1;
                    enemy.health = 1;
                    break;
                case 'turtle':
                    // Í±∞Î∂ÅÏù¥Î™®Îìú: Ïù¥ÎèôÏÜçÎèÑ 50% Í∞êÏÜå
                    player.speed *= 0.5;
                    enemy.speed *= 0.5;
                    break;
                case 'noReload':
                    // ÎÖ∏Î¶¨Î°úÎìúÎ™®Îìú: Ïû¨Ïû•Ï†Ñ ÏãúÍ∞Ñ 0.3Ï¥à
                    player.reloadTime = 300;
                    player.baseReloadTime = 300; // Reload! Î™®Îìú: Í∏∞Î≥∏ Ïû¨Ïû•Ï†Ñ ÏãúÍ∞Ñ 0.3Ï¥à
                    enemy.reloadTime = 300;
                    enemy.baseReloadTime = 300; // Reload! Î™®Îìú: Í∏∞Î≥∏ Ïû¨Ïû•Ï†Ñ ÏãúÍ∞Ñ 0.3Ï¥à
                    break;
                case 'smallMap':
                    // -25%Î™®Îìú: Îßµ ÌÅ¨Í∏∞ 25% Í∞êÏÜå
                    const mapScale = 0.75;
                    const mapWidth = canvas.width * mapScale;
                    const mapHeight = canvas.height * mapScale;
                    const mapOffsetX = (canvas.width - mapWidth) / 2;
                    const mapOffsetY = (canvas.height - mapHeight) / 2;
                    
                    gameState.mapBounds.minX = mapOffsetX;
                    gameState.mapBounds.minY = mapOffsetY;
                    gameState.mapBounds.maxX = mapOffsetX + mapWidth;
                    gameState.mapBounds.maxY = mapOffsetY + mapHeight;
                    
                    // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï†Å ÏúÑÏπòÎ•º Ï§ÑÏñ¥Îì† Îßµ ÏïàÏúºÎ°ú Ï°∞Ï†ï
                    player.x = Math.max(gameState.mapBounds.minX + player.radius, 
                                      Math.min(gameState.mapBounds.maxX - player.radius, player.x));
                    player.y = Math.max(gameState.mapBounds.minY + player.radius, 
                                      Math.min(gameState.mapBounds.maxY - player.radius, player.y));
                    enemy.x = Math.max(gameState.mapBounds.minX + enemy.radius, 
                                     Math.min(gameState.mapBounds.maxX - enemy.radius, enemy.x));
                    enemy.y = Math.max(gameState.mapBounds.minY + enemy.radius, 
                                     Math.min(gameState.mapBounds.maxY - enemy.radius, enemy.y));
                    break;
                case 'superAI':
                    // ÏäàÌçºAIÎ™®Îìú: AIÍ∞Ä Ï¶ùÍ∞ï 2Í∞ú ÎûúÎç§ ÏÑ†ÌÉù
                    const availableAugments = augmentations.filter(aug => aug.id !== 'dodge' && aug.id !== 'fortify' && aug.id !== 'timeStop');
                    const shuffled = [...availableAugments].sort(() => Math.random() - 0.5);
                    // 2Í∞ú ÏÑ†ÌÉù
                    for (let i = 0; i < 2 && i < shuffled.length; i++) {
                        const selectedAugment = shuffled[i];
                        selectedAugment.effect(enemy);
                        enemy.augmentations.push(selectedAugment);
                        incrementAugmentSelectCount(selectedAugment.id);
                    }
                    break;
            }
        }

        function initGame() {
            // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Ïû¨ÌôïÏù∏
            resizeCanvas();
            
            // Ï†úÌôîÎäî Í≤åÏûÑ ÏãúÏûë Ïãú Î¶¨ÏÖãÌïòÏßÄ ÏïäÏùå (localStorageÏóêÏÑú Ïú†ÏßÄ)
            
            // Îßµ Í≤ΩÍ≥Ñ Ï¥àÍ∏∞Ìôî (Ï†ÑÏ≤¥ Ï∫îÎ≤ÑÏä§)
            gameState.mapBounds.minX = 0;
            gameState.mapBounds.minY = 0;
            gameState.mapBounds.maxX = canvas.width;
            gameState.mapBounds.maxY = canvas.height;
            
            // Îßµ Í≤ΩÍ≥Ñ Ï¥àÍ∏∞Ìôî (Ï†ÑÏ≤¥ Ï∫îÎ≤ÑÏä§)
            gameState.mapBounds.minX = 0;
            gameState.mapBounds.minY = 0;
            gameState.mapBounds.maxX = canvas.width;
            gameState.mapBounds.maxY = canvas.height;
            
            // Í≤åÏûÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            gameState.round = 1;
            gameState.playerWins = 0;
            gameState.enemyWins = 0;
            gameState.gameTime = 180;
            gameState.isGameOver = false;
            gameState.isPaused = true;
            gameState.countdown = 3;
            gameState.roundWins = [];
            gameState.augmentCountdown = 0;
            gameState.showOpponentSelecting = false;

            // ÎûúÎç§ Î™®Îìú ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏ (Ïä¨Î°ØÎ®∏Ïã† Ï§ëÏù¥ ÏïÑÎãê ÎïåÎßå)
            if (!gameState.isSlotMachine) {
                const randomModeDisplay = document.getElementById('randomModeDisplay');
                const randomModeName = document.getElementById('randomModeName');
                const randomModeTooltip = document.getElementById('randomModeTooltip');
                
                if (gameState.selectedRandomMode) {
                    randomModeDisplay.style.display = 'block';
                    randomModeName.textContent = gameState.selectedRandomMode.name;
                    randomModeTooltip.textContent = gameState.selectedRandomMode.description;
                    
                } else {
                    randomModeDisplay.style.display = 'none';
                }
            }

            // ÌîåÎ†àÏù¥Ïñ¥ Ï¥àÍ∏∞Ìôî
            player.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.2;
            player.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
            player.health = 5;
            player.displayHealth = 5;
            player.maxHealth = 5;
            player.ammo = 6;
            player.maxAmmo = 6;
            player.bullets = [];
            player.augmentations = [];
            player.angle = 0;
            player.bulletSpeedMultiplier = 1;
            player.bulletSizeMultiplier = 1;
            player.speed = 3; // Í∏∞Î≥∏ ÏÜçÎèÑ ÏÑ§Ï†ï
            player.hasCritical = false;
            player.hasDoubleShot = false;
            player.hasDodge = false;
            player.hasRevive = false;
            player.hasRevived = false;
            player.hasDeepWound = false;
            player.hasOneShotOneKill = false;
            player.hasPoisonBullet = false;
            player.hasReloadHeal = false;
            player.hasSurvivalInstinct = false;
            player.hasLastBullet = false;
            player.hasRecoveryContract = false;
            player.hasRecoveryContractUsed = false;
            player.hasFocusedFire = false;
            player.hasShotgun = false;
            player.hasRagged = false;
            player.hasGhost = false;
            player.hasFortify = false;
            player.isFortified = false;
            player.fortifyStartTime = 0;
            player.lastPosition = { x: player.x, y: player.y };
            player.stationaryTime = 0;
            player.hasOverheat = false;
            player.overheatHitCount = 0;
            player.lastHitTime = 0;
            player.hasGamble = false;
            player.hasWeaken = false;
            player.isWeakened = false;
            player.weakenEndTime = 0;
            player.hasDamageBoost = false;
            player.hasLightning = false;
            player.isStunned = false;
            player.stunEndTime = 0;
            player.hasShield = false;
            player.shieldReady = false;
            player.shieldCooldown = 0;
            player.hasRegeneration = false;
            player.lastRegenTime = 0;
            player.hasEvasiveManeuver = false;
            player.hasCombatExperience = false;
            player.combatExperienceRounds = 0;
            player.hasHallucination = false;
            player.hasTasteOfBlood = false;
            player.hasCannon = false;
            player.hasTimeBarrier = false;
            player.timeBarrierRadius = 150;
            player.hasBouncyBullet = false;
            player.hasExplosiveBullet = false;
            player.hasReaper = false;
            player.isInvisible = false;
            player.invisibilityEndTime = 0;
            player.hasOvercharge = false;
            player.overchargeActive = false;
            player.overchargeCooldown = 0;
            player.overchargeEndTime = 0;
            player.hasVictor = false;
            player.hasReflect = false;
            player.reflectActive = false;
            player.reflectCooldown = 0;
            player.reflectEndTime = 0;
            player.hasTimeStop = false;
            player.timeStopCooldown = 0;
            player.timeStopActive = false;
            player.timeStopEndTime = 0;
            player.hasScatter = false;
            player.hasGamble2 = false;
            player.hasRocket = false;
            player.hasTrinity = false;
            player.hasJudgment = false;
            player.isJudgmentPushing = false;
            player.judgmentPushStartX = 0;
            player.judgmentPushStartY = 0;
            player.judgmentPushTargetX = 0;
            player.judgmentPushTargetY = 0;
            player.judgmentPushStartTime = 0;
            player.judgmentPushDuration = 0;
            player.hasBoomerang = false;
            player.isVulnerable = false;
            player.vulnerabilityUsed = false;
            player.poisonEffects = [];
            player.isDodging = false;
            player.isReviving = false;
            player.isInvincible = false;
            player.slowEndTime = 0;
            player.damageNumbers = [];
            player.damage = 1;
            player.speed = 3;
            player.reloadTime = 3000;
            player.baseReloadTime = 3000; // Í∏∞Î≥∏ Ïû¨Ïû•Ï†Ñ ÏãúÍ∞Ñ Ï†ÄÏû•
            player.isReloading = false;
            player.reloadStartTime = 0;
            player.shootCooldown = 1000;
            player.lastShot = 0;

            // enemy Ï¥àÍ∏∞Ìôî
                enemy.x = gameState.mapBounds.minX + (gameState.mapBounds.maxX - gameState.mapBounds.minX) * 0.8;
                enemy.y = gameState.mapBounds.minY + (gameState.mapBounds.maxY - gameState.mapBounds.minY) * 0.5;
                enemy.health = 5;
                enemy.displayHealth = 5;
                enemy.maxHealth = 5;
                enemy.ammo = 6;
                enemy.maxAmmo = 6;
                enemy.bullets = [];
                enemy.augmentations = [];
                enemy.angle = Math.PI;
                enemy.bulletSpeedMultiplier = 1;
                enemy.bulletSizeMultiplier = 1;
                enemy.hasCritical = false;
                enemy.hasDoubleShot = false;
                enemy.hasDodge = false;
                enemy.hasRevive = false;
                enemy.hasRevived = false;
                enemy.hasDeepWound = false;
                enemy.hasOneShotOneKill = false;
                enemy.hasPoisonBullet = false;
                enemy.hasReloadHeal = false;
                enemy.hasSurvivalInstinct = false;
                enemy.hasLastBullet = false;
                enemy.hasRecoveryContract = false;
                enemy.hasRecoveryContractUsed = false;
                enemy.hasFocusedFire = false;
            enemy.hasShotgun = false;
            enemy.hasRagged = false;
            enemy.hasGhost = false;
            enemy.hasFortify = false;
            enemy.isFortified = false;
            enemy.fortifyStartTime = 0;
            enemy.lastPosition = { x: enemy.x, y: enemy.y };
            enemy.stationaryTime = 0;
            enemy.hasOverheat = false;
            enemy.overheatHitCount = 0;
            enemy.lastHitTime = 0;
            enemy.hasGamble = false;
            enemy.hasWeaken = false;
            enemy.isWeakened = false;
            enemy.weakenEndTime = 0;
            enemy.hasDamageBoost = false;
            enemy.hasLightning = false;
            enemy.isStunned = false;
            enemy.stunEndTime = 0;
            enemy.hasShield = false;
            enemy.shieldReady = false;
            enemy.shieldCooldown = 0;
            enemy.hasRegeneration = false;
            enemy.lastRegenTime = 0;
            enemy.hasEvasiveManeuver = false;
            enemy.hasCombatExperience = false;
            enemy.combatExperienceRounds = 0;
            enemy.hasHallucination = false;
            enemy.hasTasteOfBlood = false;
            enemy.hasCannon = false;
            enemy.hasTimeBarrier = false;
            enemy.timeBarrierRadius = 150;
            enemy.hasBouncyBullet = false;
                enemy.isVulnerable = false;
                enemy.vulnerabilityUsed = false;
                enemy.poisonEffects = [];
                enemy.isDodging = false;
                enemy.isReviving = false;
                enemy.isInvincible = false;
                enemy.slowEndTime = 0;
                enemy.damageNumbers = [];
                enemy.usePrediction = false;
                enemy.lastPlayerX = 0;
                enemy.lastPlayerY = 0;
                enemy.playerVelocity = { x: 0, y: 0 };
                enemy.damage = 1;
                enemy.speed = 2.5; // Í∏∞Î≥∏ ÏÜçÎèÑ ÏÑ§Ï†ï
            enemy.reloadTime = 3000;
                enemy.baseReloadTime = 3000; // Í∏∞Î≥∏ Ïû¨Ïû•Ï†Ñ ÏãúÍ∞Ñ Ï†ÄÏû•
                enemy.isReloading = false;
                enemy.reloadStartTime = 0;
                enemy.shootCooldown = 1000;
                enemy.lastShot = 0;
                
                // Î™®ÎìúÎ≥Ñ Ï¥àÍ∏∞Ìôî (ÏÜçÎèÑ ÏÑ§Ï†ï ÌõÑÏóê Ï†ÅÏö©)
                if (gameState.selectedRandomMode) {
                    applyRandomMode(gameState.selectedRandomMode.id);
                }

            // Ï≤´ ÎùºÏö¥Îìú Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏãúÏûë (ÎûúÎç§ Î™®ÎìúÏù¥Í≥† Ïä¨Î°ØÎ®∏Ïã† Ï§ëÏù¥Î©¥ Ïä¨Î°ØÎ®∏Ïã†Ïù¥ ÎÅùÎÇú ÌõÑ ÏãúÏûë)
            if (gameState.gameMode !== 'random' || !gameState.isSlotMachine) {
                const initialCountdown = setInterval(() => {
                    gameState.countdown--;
                    if (gameState.countdown <= 0) {
                        clearInterval(initialCountdown);
                        gameState.isPaused = false;
                    }
                }, 1000);
            }
        }

        function draw() {
            // Î©îÎâ¥ ÌôîÎ©¥ ÌëúÏãú
            if (gameState.isMenu) {
                return; // Î©îÎâ¥Îäî HTMLÎ°ú ÌëúÏãúÎêòÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî Í∑∏Î¶¨ÏßÄ ÏïäÏùå
            }

            // Ïä¨Î°ØÎ®∏Ïã† Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ëÏùº ÎïåÎäî Ïä¨Î°ØÎ®∏Ïã†Îßå Í∑∏Î¶¨Í∏∞
            if (gameState.isSlotMachine) {
                ctx.fillStyle = '#0f0f1e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Ïä¨Î°ØÎ®∏Ïã† Ïï†ÎãàÎ©îÏù¥ÏÖò Í∑∏Î¶¨Í∏∞
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // ÌòÑÏû¨ ÌëúÏãúÌï† Î™®Îìú
                const currentMode = randomModes[gameState.slotMachineCurrentIndex];
                
                // Î™®Îìú Ïù¥Î¶Ñ ÌëúÏãú
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 64px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(currentMode.name, centerX, centerY);
                
                // Î™®Îìú ÏÑ§Î™Ö ÌëúÏãú
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '32px Arial';
                ctx.fillText(currentMode.description, centerX, centerY + 60);
                
                return; // Ïä¨Î°ØÎ®∏Ïã† Ï§ëÏóêÎäî ÎÇòÎ®∏ÏßÄ Í≤åÏûÑ ÏöîÏÜå Í∑∏Î¶¨ÏßÄ ÏïäÏùå
            }

            // Ìò∏Î≤ÑÎêú Ï¶ùÍ∞ï Ï¥àÍ∏∞Ìôî
            hoveredAugment = null;
            
            // ÌôîÎ©¥ ÌùîÎì§Î¶º Ï†ÅÏö©
            let shakeX = 0;
            let shakeY = 0;
            if (gameState.shake.duration > 0) {
                shakeX = (Math.random() - 0.5) * gameState.shake.intensity;
                shakeY = (Math.random() - 0.5) * gameState.shake.intensity;
                gameState.shake.duration = Math.max(0, gameState.shake.duration - 16); // ÏïΩ 60fps Í∏∞Ï§Ä
                gameState.shake.intensity *= 0.9; // Ï†êÏßÑÏ†ÅÏúºÎ°ú Í∞êÏÜå
            }

            // Î∞∞Í≤Ω ÌÅ¥Î¶¨Ïñ¥ (ÌùîÎì§Î¶º Ï†ÑÏóê Í∑∏Î¶¨Í∏∞)
            // Ïö©ÏïîÎ™®Îìú: Î∞∞Í≤ΩÏùÑ Î∂âÏùÄ Í≥ÑÏó¥Î°ú Î≥ÄÍ≤Ω
            // ÎπôÌåêÎ™®Îìú: Î∞∞Í≤ΩÏùÑ Ìë∏Î•∏ Í≥ÑÏó¥Î°ú Î≥ÄÍ≤Ω
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'flame') {
                ctx.fillStyle = '#2a0f0f'; // Ïñ¥ÎëêÏö¥ Î∂âÏùÄ Í≥ÑÏó¥
            } else if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'ice') {
                ctx.fillStyle = '#0f1e3a'; // Îçî ÌååÎûÄÏÉâ Ìë∏Î•∏ Í≥ÑÏó¥
            } else {
                ctx.fillStyle = '#0f0f1e';
            }
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ÌôîÎ©¥ ÌùîÎì§Î¶º Ï†ÅÏö©
            ctx.save();
            ctx.translate(shakeX, shakeY);

            // Í≤©Ïûê Í∑∏Î¶¨Í∏∞ (Îßµ Í≤ΩÍ≥Ñ ÎÇ¥Î∂ÄÎßå, Í≤ΩÍ≥ÑÏÑ† Ï†úÏô∏)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const startX = gameState.mapBounds.minX;
            const startY = gameState.mapBounds.minY;
            const endX = gameState.mapBounds.maxX;
            const endY = gameState.mapBounds.maxY;
            
            // Í≤©Ïûê ÏÑ†Ïù¥ Îßµ Í≤ΩÍ≥ÑÏÑ†Í≥º Í≤πÏπòÏßÄ ÏïäÎèÑÎ°ù Í≤ΩÍ≥ÑÏÑ†ÏùÑ Ï†úÏô∏ÌïòÍ≥† Í∑∏Î¶¨Í∏∞
            const gridStartX = Math.ceil(startX / 50) * 50; // Í≤ΩÍ≥ÑÏÑ† Îã§Ïùå Í≤©ÏûêÎ∂ÄÌÑ∞
            const gridStartY = Math.ceil(startY / 50) * 50;
            const gridEndX = Math.floor(endX / 50) * 50; // Í≤ΩÍ≥ÑÏÑ† Ï†ÑÍπåÏßÄ
            const gridEndY = Math.floor(endY / 50) * 50;
            
            for (let i = gridStartX; i <= gridEndX; i += 50) {
                if (i > startX && i < endX) { // Í≤ΩÍ≥ÑÏÑ† Ï†úÏô∏
                    ctx.beginPath();
                    ctx.moveTo(i, startY);
                    ctx.lineTo(i, endY);
                    ctx.stroke();
                }
            }
            for (let i = gridStartY; i <= gridEndY; i += 50) {
                if (i > startY && i < endY) { // Í≤ΩÍ≥ÑÏÑ† Ï†úÏô∏
                    ctx.beginPath();
                    ctx.moveTo(startX, i);
                    ctx.lineTo(endX, i);
                    ctx.stroke();
                }
            }

            // -25%Î™®Îìú: Ï§ÑÏñ¥Îì† ÏòÅÏó≠ÏùÑ Í≤ÄÏùÄÏÉâÏúºÎ°ú ÌëúÏãú (Í≤©Ïûê Í∑∏Î¶¨Í∏∞ ÌõÑ, Í≤©Ïûê ÏÑ†ÏùÑ ÎçÆÍ∏∞ ÏúÑÌï¥)
            // ÌùîÎì§Î¶ºÏúºÎ°ú Ïù∏Ìïú Ïó¨Ïú† Í≥µÍ∞Ñ Ï∂îÍ∞Ä (ÏµúÎåÄ ÌùîÎì§Î¶º Í∞ïÎèÑ Í≥†Î†§)
            const shakeMargin = 50; // ÌùîÎì§Î¶º Ïó¨Ïú† Í≥µÍ∞Ñ
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'smallMap') {
                ctx.fillStyle = '#000000'; // Í≤ÄÏùÄÏÉâ
                // ÏúÑÏ™Ω ÏòÅÏó≠ (Ïó¨Ïú† Í≥µÍ∞Ñ Ï∂îÍ∞Ä)
                ctx.fillRect(-shakeMargin, -shakeMargin, canvas.width + shakeMargin * 2, gameState.mapBounds.minY + shakeMargin);
                // ÏïÑÎûòÏ™Ω ÏòÅÏó≠ (Ïó¨Ïú† Í≥µÍ∞ÑÏùÄ ÏúÑÏ™ΩÎßå, ÏïÑÎûòÏ™ΩÏùÄ Ï†ïÌôïÌûà Í≤ΩÍ≥ÑÏóêÏÑú ÏãúÏûë)
                ctx.fillRect(-shakeMargin, gameState.mapBounds.maxY, canvas.width + shakeMargin * 2, canvas.height - gameState.mapBounds.maxY);
                // ÏôºÏ™Ω ÏòÅÏó≠ (Ïó¨Ïú† Í≥µÍ∞Ñ Ï∂îÍ∞Ä)
                ctx.fillRect(-shakeMargin, gameState.mapBounds.minY - shakeMargin, gameState.mapBounds.minX + shakeMargin, gameState.mapBounds.maxY - gameState.mapBounds.minY + shakeMargin * 2);
                // Ïò§Î•∏Ï™Ω ÏòÅÏó≠ (Ïó¨Ïú† Í≥µÍ∞ÑÏùÄ ÏôºÏ™ΩÎßå, Ïò§Î•∏Ï™ΩÏùÄ Ï†ïÌôïÌûà Í≤ΩÍ≥ÑÏóêÏÑú ÏãúÏûë)
                ctx.fillRect(gameState.mapBounds.maxX, gameState.mapBounds.minY - shakeMargin, canvas.width - gameState.mapBounds.maxX, gameState.mapBounds.maxY - gameState.mapBounds.minY + shakeMargin * 2);
            }

            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïû•Ïï†Î¨º Í∑∏Î¶¨Í∏∞
            if (gameState.isMultiplayer && gameState.obstacles && gameState.obstacles.length > 0) {
                ctx.save();
                gameState.obstacles.forEach(obstacle => {
                    ctx.save();
                    ctx.translate(obstacle.x, obstacle.y);
                    ctx.rotate(obstacle.angle);
                    
                    // Ïû•Ïï†Î¨º Í∑∏Î¶¨Í∏∞ (ÌöåÏÉâ, ÏïΩÍ∞Ñ Ìà¨Î™Ö)
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
                    ctx.strokeStyle = 'rgba(150, 150, 150, 0.9)';
                    ctx.lineWidth = 2;
                    
                    // ÏßÅÏÇ¨Í∞ÅÌòï Í∑∏Î¶¨Í∏∞
                    ctx.beginPath();
                    ctx.rect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                });
                ctx.restore();
            }

            // Ï¥ùÏïå Í∑∏Î¶¨Í∏∞
            // ÌîºÍ≤© Ïù¥ÌéôÌä∏ Í∑∏Î¶¨Í∏∞ (ÌîåÎ†àÏù¥Ïñ¥)
            if (player.hitEffectParticles && player.hitEffectParticles.length > 0) {
                ctx.save();
                player.hitEffectParticles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    ctx.globalAlpha = alpha * 0.8;
                    ctx.fillStyle = particle.color;
                    ctx.strokeStyle = particle.color;
                    // ÎÑ§Ïò® Ìö®Í≥º Ï†ÅÏö© (2Îã®Í≥Ñ Í∞ïÌôî Ïãú)
                    if (particle.hasNeon) {
                        // Î∞òÎîßÎ∂àÏù¥Ï≤òÎüº Í∞ïÌïú ÎÑ§Ïò® Ìö®Í≥º - Ïó¨Îü¨ Í≤πÏúºÎ°ú Í∑∏Î¶¨Í∏∞
                        const neonLayers = 5; // 5Í≤πÏúºÎ°ú Í∑∏Î¶¨Í∏∞
                        const baseBlur = 80 + (particle.size * 10); // ÌÅ¨Í∏∞Ïóê Îî∞Îùº Î∏îÎü¨ Í∞ïÎèÑ Ï°∞Ï†à
                        
                        for (let layer = 0; layer < neonLayers; layer++) {
                            const layerAlpha = (alpha * 0.8) / neonLayers;
                            const layerBlur = baseBlur * (1 - layer * 0.15); // Í∞Å Î†àÏù¥Ïñ¥ÎßàÎã§ Î∏îÎü¨ Í∞êÏÜå
                            const layerSize = particle.size * (1 + layer * 0.3); // Í∞Å Î†àÏù¥Ïñ¥ÎßàÎã§ ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä
                            
                            ctx.globalAlpha = layerAlpha;
                            ctx.shadowBlur = layerBlur;
                            ctx.shadowColor = particle.color;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;
                            
                            if (particle.type === 'dot') {
                                ctx.beginPath();
                                ctx.arc(particle.x, particle.y, layerSize, 0, Math.PI * 2);
                                ctx.fill();
                            } else if (particle.type === 'triangle') {
                                ctx.save();
                                ctx.translate(particle.x, particle.y);
                                ctx.rotate(particle.rotation || 0);
                                ctx.beginPath();
                                ctx.moveTo(0, -layerSize);
                                ctx.lineTo(-layerSize * 0.866, layerSize * 0.5);
                                ctx.lineTo(layerSize * 0.866, layerSize * 0.5);
                                ctx.closePath();
                                ctx.fill();
                                ctx.restore();
                            } else if (particle.type === 'square') {
                                ctx.save();
                                ctx.translate(particle.x, particle.y);
                                ctx.rotate(particle.rotation || 0);
                                ctx.fillRect(-layerSize, -layerSize, layerSize * 2, layerSize * 2);
                                ctx.restore();
                            } else if (particle.type === 'diamond') {
                                ctx.save();
                                ctx.translate(particle.x, particle.y);
                                ctx.rotate(Math.PI / 4);
                                ctx.fillRect(-layerSize, -layerSize, layerSize * 2, layerSize * 2);
                                ctx.restore();
                            } else if (particle.type === 'spark') {
                                ctx.save();
                                ctx.translate(particle.x, particle.y);
                                ctx.rotate(particle.angle);
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(particle.length, 0);
                                ctx.lineWidth = particle.size * (1 + layer * 0.2);
                                ctx.stroke();
                                ctx.restore();
                            }
                        }
                        // ÏõêÎûò ÌÅ¨Í∏∞Î°ú Ìïú Î≤à Îçî Í∑∏Î¶¨Í∏∞ (Î∞ùÏùÄ Ï§ëÏã¨)
                        ctx.globalAlpha = alpha * 1.2;
                        ctx.shadowBlur = baseBlur * 0.5;
                        ctx.shadowColor = particle.color;
                    } else {
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = particle.color;
                    }
                    
                    if (particle.type === 'dot') {
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (particle.type === 'triangle') {
                        // ÏÇºÍ∞ÅÌòï Í∑∏Î¶¨Í∏∞ (ÎûúÎç§ ÌöåÏ†Ñ)
                        ctx.save();
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.rotation || 0); // ÎûúÎç§ ÌöåÏ†Ñ Í∞ÅÎèÑ Ï†ÅÏö©
                        ctx.beginPath();
                        ctx.moveTo(0, -particle.size); // ÏúÑÏ™Ω Íº≠ÏßìÏ†ê
                        ctx.lineTo(-particle.size * 0.866, particle.size * 0.5); // ÏôºÏ™Ω ÏïÑÎûò
                        ctx.lineTo(particle.size * 0.866, particle.size * 0.5); // Ïò§Î•∏Ï™Ω ÏïÑÎûò
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    } else if (particle.type === 'square') {
                        // ÏÇ¨Í∞ÅÌòï Í∑∏Î¶¨Í∏∞ (ÎûúÎç§ ÌöåÏ†Ñ)
                        ctx.save();
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.rotation || 0); // ÎûúÎç§ ÌöåÏ†Ñ Í∞ÅÎèÑ Ï†ÅÏö©
                        ctx.fillRect(-particle.size, -particle.size, particle.size * 2, particle.size * 2);
                        ctx.restore();
                    } else if (particle.type === 'diamond') {
                        ctx.save();
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(Math.PI / 4);
                        ctx.fillRect(-particle.size, -particle.size, particle.size * 2, particle.size * 2);
                        ctx.restore();
                    } else if (particle.type === 'spark') {
                        ctx.save();
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.angle);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(particle.length, 0);
                        ctx.lineWidth = particle.size;
                        ctx.stroke();
                        ctx.restore();
                    } else if (particle.type === 'firework') {
                        // Ìè≠Ï£Ω Ïù¥ÌéôÌä∏: ÏßÅÏÇ¨Í∞ÅÌòï Í∑∏Î¶¨Í∏∞ (Ï§ëÏïô Î∂ÄÎ∂Ñ ÎπÑÏö∞Í≥† Í∞êÏÜç Ìö®Í≥º, ÌçºÏßÄÎäî ÏÜçÎèÑ +25%, ÌçºÏßÄÎäî Í±∞Î¶¨ +25%, ÎÑàÎπÑ -25%)
                        ctx.save();
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.angle);
                        
                        // Í∞êÏÜç Ìö®Í≥ºÎ•º Í≥†Î†§Ìïú progress Í≥ÑÏÇ∞
                        const lifeProgress = 1 - (particle.life / particle.maxLife);
                        const speedMultiplier = particle.speed || 1.0;
                        // Ï¥àÍ∏∞ÏóêÎäî Îπ†Î•¥Í≤å, ÎÇòÏ§ëÏóêÎäî ÎäêÎ¶¨Í≤å (Í∞êÏÜç Í≥°ÏÑ†)
                        const easedProgress = lifeProgress * speedMultiplier;
                        const progress = Math.min(1, easedProgress * 3 * 1.25); // ÌçºÏßÄÎäî ÏÜçÎèÑ 3Î∞∞ * 1.25 (25% Ï¶ùÍ∞Ä)
                        
                        const maxSize = (particle.size || 16.875) * 1.25 * 1.25 * 1.25; // ÌçºÏßÄÎäî Í±∞Î¶¨ Ï∂îÍ∞Ä 25% Ï¶ùÍ∞Ä
                        const currentSize = maxSize * progress; // Ï†êÏ†ê Í∏∏Ïñ¥ÏßÄÎ©¥ÏÑú ÌçºÏßê (Í∞êÏÜç Ìö®Í≥º Ï†ÅÏö©)
                        const rectWidth = currentSize * 0.225 * 1.25 * 0.8 * 0.85 * 0.75; // ÏßÅÏÇ¨Í∞ÅÌòï ÎÑàÎπÑ 25% Í∞êÏÜå
                        const startOffset = maxSize * 0.35 * 1.25; // Ï§ëÏïô Î∂ÄÎ∂Ñ ÎπÑÏö∞Í∏∞ Ï¶ùÍ∞Ä (0.2 -> 0.35)
                        // ÏßÅÏÇ¨Í∞ÅÌòï Í∑∏Î¶¨Í∏∞ (Ï§ëÏïôÏóêÏÑú Îçî Î©ÄÎ¶¨ Îñ®Ïñ¥ÏßÑ ÏúÑÏπòÏóêÏÑú ÏãúÏûë)
                        ctx.fillRect(startOffset, -rectWidth / 2, currentSize - startOffset, rectWidth);
                        ctx.restore();
                    } else if (particle.type === 'ring') {
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else if (particle.type === 'burst') {
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
            
            // Ìè≠Î∞ú Ïù¥ÌéôÌä∏ Í∑∏Î¶¨Í∏∞
            if (gameState.explosions && gameState.explosions.length > 0) {
                const now = Date.now();
                for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                    const explosion = gameState.explosions[i];
                    const elapsed = now - explosion.startTime;
                    const progress = Math.min(1, elapsed / explosion.duration);
                    
                    // Ìè≠Î∞ú Ïõê ÌÖåÎëêÎ¶¨ (Ï£ºÌô©ÏÉâ)
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, explosion.radius * progress, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Ìè≠Î∞ú Ï§ëÏã¨ (ÌéòÏù¥Îìú ÏïÑÏõÉ)
                    ctx.fillStyle = `rgba(255, 136, 0, ${1 - progress})`;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, explosion.radius * 0.3 * (1 - progress), 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (progress >= 1) {
                        gameState.explosions.splice(i, 1);
                    }
                }
                ctx.shadowBlur = 0;
            }
            
            player.bullets.forEach(bullet => bullet.draw());
            enemy.bullets.forEach(bullet => bullet.draw());

            // Íµ¨Î•¥Í∏∞ ÏûîÏÉÅ Í∑∏Î¶¨Í∏∞
            function drawDodgeTrail(character) {
                if (character.isDodging && character.dodgeTrail && character.dodgeTrail.length > 0) {
                    // ÏûîÏÉÅ Ìö®Í≥º (Í≥ºÍ±∞ ÏúÑÏπò Í∑∏Î¶¨Í∏∞)
                    character.dodgeTrail.forEach((trail, index) => {
                        const fadeAlpha = trail.alpha * (1 - index * 0.2); // Ï†êÏßÑÏ†ÅÏúºÎ°ú Ìà¨Î™Ö
                        ctx.globalAlpha = Math.max(0, fadeAlpha);
                        ctx.fillStyle = character.color;
                        ctx.beginPath();
                        ctx.arc(trail.x, trail.y, character.radius * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;
                }
            }
            
            // Í≥ºÏ∂©Ï†Ñ ÏûîÏÉÅ Í∑∏Î¶¨Í∏∞ (ÌååÎûÄÏÉâ)
            function drawOverchargeTrail(character) {
                if (character.overchargeActive && character.overchargeTrail && character.overchargeTrail.length > 0) {
                    character.overchargeTrail.forEach((trail, index) => {
                        const fadeAlpha = trail.alpha * (1 - index * 0.15); // Ï†êÏßÑÏ†ÅÏúºÎ°ú Ìà¨Î™Ö
                        ctx.globalAlpha = Math.max(0, fadeAlpha);
                        ctx.fillStyle = '#4a9eff'; // ÌååÎûÄÏÉâ
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#4a9eff';
                        ctx.beginPath();
                        ctx.arc(trail.x + shakeX, trail.y + shakeY, character.radius * 0.9, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;
                    ctx.shadowBlur = 0;
                }
            }

            // ÌÅ¥ÎûòÏãù Î™®Îìú ÎòêÎäî ÎûúÎç§ Î™®ÎìúÏóêÏÑú ÎÑ§Ïò® Ìö®Í≥º Ï∂îÍ∞Ä (Îßµ Í≤ΩÍ≥ÑÏóê ÏûòÎ¶¨ÏßÄ ÏïäÎèÑÎ°ù ÌùîÎì§Î¶º Î≥ÄÌôò Ï†ÑÏóê Í∑∏Î¶¨Í∏∞)
            const isClassicOrRandom = gameState.gameMode === 'classic' || gameState.gameMode === 'random';
            
            // ÎÑ§Ïò® Ìö®Í≥ºÎ•º Î®ºÏ†Ä Í∑∏Î¶¨Í∏∞ (Îßµ Í≤ΩÍ≥ÑÏóê ÏûòÎ¶¨ÏßÄ ÏïäÎèÑÎ°ù)
            if (isClassicOrRandom) {
                // Ï†Å ÎÑ§Ïò® Ìö®Í≥º
                if (enemy.x > -500 && enemy.y > -500) {
                    // ÏÇ¨Ïã† Ï¶ùÍ∞ï: Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑú Ï†ÅÏù¥ ÏùÄÏã† Ï§ëÏù¥Î©¥ ÌîåÎ†àÏù¥Ïñ¥ÏóêÍ≤åÎäî ÏïÑÏòà Î≥¥Ïù¥ÏßÄ ÏïäÏùå
                    if (gameState.isMultiplayer && enemy.isInvisible && Date.now() < enemy.invisibilityEndTime) {
                        // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑúÎäî ÏÉÅÎåÄÎ∞©Ïù¥ ÏùÄÏã† Ï§ëÏù¥Î©¥ ÏïÑÏòà Í∑∏Î¶¨ÏßÄ ÏïäÏùå
                    } else {
                        ctx.save();
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = enemy.color;
                        // ÏÇ¨Ïã† Ï¶ùÍ∞ï: Ïã±Í∏ÄÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑú Ï†ÅÏù¥ ÏùÄÏã† Ï§ëÏù¥Î©¥ 50% Ìà¨Î™Ö
                        if (enemy.isInvisible && Date.now() < enemy.invisibilityEndTime) {
                            ctx.globalAlpha = 0.5; // Ïã±Í∏ÄÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑúÎäî 50% Ìà¨Î™Ö
                        } else {
                            ctx.globalAlpha = 0.6; // ÎÑ§Ïò® Ìö®Í≥ºÎäî ÏïΩÍ∞Ñ Ìà¨Î™ÖÌïòÍ≤å
                        }
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                        ctx.fillStyle = enemy.color;
                        ctx.fill();
                        ctx.restore();
                    }
                }
                
                // ÌîåÎ†àÏù¥Ïñ¥ ÎÑ§Ïò® Ìö®Í≥º
                ctx.save();
                ctx.shadowBlur = 20;
                ctx.shadowColor = player.color;
                // ÏÇ¨Ïã† Ï¶ùÍ∞ï: ÏùÄÏã† Ï§ëÏù¥Î©¥ ÏÉÅÎåÄÎ∞©ÏóêÍ≤åÎäî Î≥¥Ïù¥ÏßÄ ÏïäÏùå (ÏûêÏã†ÏùÄ 50% Ìà¨Î™Ö)
                if (player.isInvisible && Date.now() < player.invisibilityEndTime) {
                    ctx.globalAlpha = 0.5; // ÏûêÏã†ÏùÄ 50% Ìà¨Î™Ö
                } else {
                    ctx.globalAlpha = 0.6; // ÎÑ§Ïò® Ìö®Í≥ºÎäî ÏïΩÍ∞Ñ Ìà¨Î™ÖÌïòÍ≤å
                }
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.restore();
            }

            // Ï†Å Í∑∏Î¶¨Í∏∞
            if (enemy.x > -500 && enemy.y > -500) {
                // ÏÇ¨Ïã† Ï¶ùÍ∞ï: Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑú Ï†ÅÏù¥ ÏùÄÏã† Ï§ëÏù¥Î©¥ ÌîåÎ†àÏù¥Ïñ¥ÏóêÍ≤åÎäî ÏïÑÏòà Î≥¥Ïù¥ÏßÄ ÏïäÏùå
                if (gameState.isMultiplayer && enemy.isInvisible && Date.now() < enemy.invisibilityEndTime) {
                    // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑúÎäî ÏÉÅÎåÄÎ∞©Ïù¥ ÏùÄÏã† Ï§ëÏù¥Î©¥ ÏïÑÏòà Í∑∏Î¶¨ÏßÄ ÏïäÏùå
                } else {
                    drawOverchargeTrail(enemy);
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y);
                    ctx.rotate(enemy.angle);
                    
                    // Í∏∞Î≥∏ alpha ÏÑ§Ï†ï
                    ctx.globalAlpha = 1.0;
                    
                    // Î¨¥Ï†Å ÏÉÅÌÉúÎ©¥ ÍπúÎπ°ÏûÑ Ìö®Í≥º
                    if (enemy.isInvincible) {
                        const blink = Math.floor(Date.now() / 100) % 2;
                        if (blink) {
                            ctx.globalAlpha = 0.5;
                        }
                    } else if (enemy.isInvisible && Date.now() < enemy.invisibilityEndTime) {
                        // ÏÇ¨Ïã† Ï¶ùÍ∞ï: Ïã±Í∏ÄÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑú Ï†ÅÏù¥ ÏùÄÏã† Ï§ëÏù¥Î©¥ 50% Ìà¨Î™Ö
                        ctx.globalAlpha = 0.5;
                    }
                
                // Íµ¨Î•¥Í∏∞ ÏûîÏÉÅ Í∑∏Î¶¨Í∏∞
                if (enemy.dodgeTrail && enemy.dodgeTrail.length > 0) {
                    enemy.dodgeTrail.forEach((trail, index) => {
                        ctx.save();
                        ctx.globalAlpha = trail.alpha * (index / enemy.dodgeTrail.length);
                        ctx.translate(trail.x - enemy.x, trail.y - enemy.y);
                        ctx.beginPath();
                        ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                        ctx.fillStyle = enemy.color;
                        ctx.fill();
                        ctx.restore();
                    });
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
                ctx.fillStyle = enemy.color;
                ctx.fill();
                
                // Î∞©Ïñ¥Îßâ: ÏßÑÌïú ÌååÎûÄÏÉâ ÌÖåÎëêÎ¶¨
                if (enemy.hasShield && enemy.shieldReady) {
                    ctx.strokeStyle = '#0066ff'; // ÏßÑÌïú ÌååÎûÄÏÉâ
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                // Î∞òÏÇ¨ Î≥¥Ìò∏Îßâ: ÌïòÏñÄÏÉâ ÌÖåÎëêÎ¶¨
                if (enemy.reflectActive) {
                    ctx.strokeStyle = '#ffffff'; // ÌïòÏñÄÏÉâ
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                
                // Î¶¨Î≥ºÎ≤Ñ Í∑∏Î¶¨Í∏∞ (ÎÑ§Ïò® Ìö®Í≥º Ï∂îÍ∞Ä)
                ctx.save();
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#333333';
                ctx.fillStyle = '#333'; // ÌååÏä§ÌÖî Í∑∏Î†àÏù¥
                ctx.fillRect(enemy.radius - 7.5, -4.5, 22.5, 9); // 1.5Î∞∞ Ï¶ùÍ∞Ä
                ctx.restore();
                
                    ctx.globalAlpha = 1.0; // Î≥µÏõê
                    ctx.restore();
                    
                    // Ï†Å Ï≤¥Î†•Í≥º ÌÉÑÌôòÏàòÎäî UI ÏòÅÏó≠ÏóêÏÑú ÌëúÏãúÎê®
                    
                    // Ï†Å Ïû¨Ïû•Ï†Ñ Î∞î ÌëúÏãú (Ï†Å Î∞îÎ°ú Ïò§Î•∏Ï™Ω ÏúÑ) - Ï†Å ÏúÑÏπòÏóê ÌùîÎì§Î¶º Ï†ÅÏö©
                    if (enemy.isReloading) {
                        drawReloadBar(enemy, enemy.x + 40 + shakeX, enemy.y - 40 + shakeY);
                    }
                }
            }
            
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: Ï∫êÎ¶≠ÌÑ∞ ÏúÑÏóê ÎãâÎÑ§ÏûÑ ÌëúÏãú
            if (gameState.isMultiplayer) {
                ctx.save();
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = 0.6;
                
                // ÌîåÎ†àÏù¥Ïñ¥ ÎãâÎÑ§ÏûÑ
                ctx.fillStyle = player.color;
                ctx.fillText(playerNickname || 'ÎÇò', player.x + shakeX, player.y - player.radius - 10 + shakeY);
                
                // ÏÉÅÎåÄÎ∞© ÎãâÎÑ§ÏûÑ (ÏùÄÏã† Ï§ëÏù¥Î©¥ ÌëúÏãúÌïòÏßÄ ÏïäÏùå)
                if (enemy.x > -500 && enemy.y > -500) {
                    // ÏÇ¨Ïã† Ï¶ùÍ∞ï: Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑú Ï†ÅÏù¥ ÏùÄÏã† Ï§ëÏù¥Î©¥ ÎãâÎÑ§ÏûÑÎèÑ ÌëúÏãúÌïòÏßÄ ÏïäÏùå
                    if (!(enemy.isInvisible && Date.now() < enemy.invisibilityEndTime)) {
                        ctx.fillStyle = enemy.color;
                        ctx.fillText(opponentNickname || 'ÏÉÅÎåÄ', enemy.x + shakeX, enemy.y - enemy.radius - 10 + shakeY);
                    }
                }
                
                ctx.restore();
            }

            // ÏãúÍ∞ÑÏû•Îßâ Í∑∏Î¶¨Í∏∞ (ÌîåÎ†àÏù¥Ïñ¥)
            if (player.hasTimeBarrier) {
                ctx.save();
                ctx.globalAlpha = 0.2; // Ìà¨Î™ÖÎèÑÍ∞Ä Í∞ïÌïú Ï¥àÎ°ùÏÉâ
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x + shakeX, player.y + shakeY, player.timeBarrierRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // ÏãúÍ∞ÑÏû•Îßâ Í∑∏Î¶¨Í∏∞ (Ï†Å) - ÏùÄÏã† Ï§ëÏù¥Î©¥ ÌëúÏãúÌïòÏßÄ ÏïäÏùå
            if (enemy.hasTimeBarrier && enemy.x > -500 && enemy.y > -500) {
                // ÏÇ¨Ïã† Ï¶ùÍ∞ï: Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ÏóêÏÑú Ï†ÅÏù¥ ÏùÄÏã† Ï§ëÏù¥Î©¥ ÏãúÍ∞ÑÏû•ÎßâÎèÑ ÌëúÏãúÌïòÏßÄ ÏïäÏùå
                if (!(gameState.isMultiplayer && enemy.isInvisible && Date.now() < enemy.invisibilityEndTime)) {
                    ctx.save();
                    ctx.globalAlpha = 0.2; // Ìà¨Î™ÖÎèÑÍ∞Ä Í∞ïÌïú Ï¥àÎ°ùÏÉâ
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x + shakeX, enemy.y + shakeY, enemy.timeBarrierRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // ÌîåÎ†àÏù¥Ïñ¥ Í∑∏Î¶¨Í∏∞
            drawDodgeTrail(player);
            drawOverchargeTrail(player);
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            
            // Î¨¥Ï†Å ÏÉÅÌÉúÏùº Îïå Î∞òÌà¨Î™Ö
            ctx.globalAlpha = 1.0; // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
            if (player.isInvincible || player.isReviving) {
                ctx.globalAlpha = 0.5;
            } else if (player.hasGhost) {
                // Ïú†Î†π Ï¶ùÍ∞ï: ÏÇ¥Ïßù ÌùêÎ†§ÏßÄÍ≤å
                ctx.globalAlpha = 0.7;
            } else if (player.isInvisible && Date.now() < player.invisibilityEndTime) {
                // ÏÇ¨Ïã† Ï¶ùÍ∞ï: ÏùÄÏã† Ï§ëÏù¥Î©¥ 50% Ìà¨Î™Ö
                ctx.globalAlpha = 0.5;
            }
            
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
            ctx.fill();
            // Í±∞Ï†êÌôïÎ≥¥: ÌïòÏñÄÏÉâ ÌÖåÎëêÎ¶¨
            if (player.hasFortify && player.isFortified) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // Î∞©Ïñ¥Îßâ: ÏßÑÌïú ÌååÎûÄÏÉâ ÌÖåÎëêÎ¶¨
            if (player.hasShield && player.shieldReady) {
                ctx.strokeStyle = '#0066ff'; // ÏßÑÌïú ÌååÎûÄÏÉâ
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            // Î∞òÏÇ¨ Î≥¥Ìò∏Îßâ: ÌïòÏñÄÏÉâ ÌÖåÎëêÎ¶¨
            if (player.reflectActive) {
                ctx.strokeStyle = '#ffffff'; // ÌïòÏñÄÏÉâ
                ctx.lineWidth = 4;
                ctx.stroke();
            }
            // Î¶¨Î≥ºÎ≤Ñ Í∑∏Î¶¨Í∏∞ (ÎÑ§Ïò® Ìö®Í≥º Ï∂îÍ∞Ä)
            ctx.save();
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#333333';
            ctx.fillStyle = '#333'; // ÌååÏä§ÌÖî Í∑∏Î†àÏù¥
            ctx.fillRect(player.radius - 7.5, -4.5, 22.5, 9); // 1.5Î∞∞ Ï¶ùÍ∞Ä
            ctx.restore();
            ctx.globalAlpha = 1.0;
            ctx.restore();

            // ÌôîÎ©¥ ÌùîÎì§Î¶º Ìö®Í≥º Ï¢ÖÎ£å
            ctx.restore();
            
            // Îç∞ÎØ∏ÏßÄ Ïà´Ïûê Í∑∏Î¶¨Í∏∞ (ÌùîÎì§Î¶º ÏòÅÌñ• Î∞õÏùå)
            ctx.save();
            ctx.translate(shakeX, shakeY);
            drawDamageNumbers(player);
                drawDamageNumbers(enemy);
            
            // Î¨¥ÎπôÏõåÌÅ¨ Î™®Îìú: ÌôîÎ©¥ Ï§ëÏïôÏóê Î∞©Ìñ• ÌôîÏÇ¥Ìëú ÏïÑÏù¥ÏΩò ÌëúÏãú (ÌùîÎì§Î¶º ÏòÅÌñ• Î∞õÏùå)
            if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'movingWork' && gameState.movingWorkDirection !== undefined) {
                const centerX = canvas.width / 2;
                let centerY = canvas.height / 2;
                
                // Ï¶ùÍ∞ïÏù¥ 5Í∞úÎ•º ÎÑòÏúºÎ©¥ ÏïÑÎûòÎ°ú ÎÇ¥Î¶º
                const totalAugments = (player.augmentations ? player.augmentations.length : 0) + (enemy.augmentations ? enemy.augmentations.length : 0);
                if (totalAugments > 5) {
                    centerY = canvas.height / 2 + 100; // ÏïÑÎûòÎ°ú 100px Ïù¥Îèô
                }
                
                // ÌôîÏÇ¥Ìëú Î∞©Ìñ•Ïóê Îî∞Î•∏ Ïú†ÎãàÏΩîÎìú ÌôîÏÇ¥Ìëú
                const angle = gameState.movingWorkDirection;
                let arrowChar;
                // 0 (Ïö∞), œÄ/2 (ÏïÑÎûò), œÄ (Ï¢å), 3œÄ/2 (ÏúÑ)
                if (Math.abs(angle - 0) < 0.1) {
                    arrowChar = '‚Üí'; // Ïö∞
                } else if (Math.abs(angle - Math.PI / 2) < 0.1) {
                    arrowChar = '‚Üì'; // ÏïÑÎûò
                } else if (Math.abs(angle - Math.PI) < 0.1) {
                    arrowChar = '‚Üê'; // Ï¢å
                } else if (Math.abs(angle - 3 * Math.PI / 2) < 0.1) {
                    arrowChar = '‚Üë'; // ÏúÑ
                } else {
                    arrowChar = '‚Üí'; // Í∏∞Î≥∏Í∞í
                }
                
                // ÎëêÍ∫ºÏö¥ ÌôîÏÇ¥Ìëú ÏïÑÏù¥ÏΩò ÌëúÏãú (ÌïòÏñÄÏÉâ Îã®ÏÉâ)
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // ÌïòÏñÄÏÉâ Îã®ÏÉâ, Ï°∞Í∏à Îçî Ìà¨Î™ÖÌïòÍ≤å
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillText(arrowChar, centerX, centerY);
            }
            
            ctx.restore();

            // UI ÏöîÏÜåÎì§ (ÌùîÎì§Î¶ºÏùò ÏòÅÌñ•ÏùÑ Î∞õÏßÄ ÏïäÏùå)
            // ÏäπÎ¶¨ ÌëúÏãú ÎßàÎ¶ÑÎ™® (ÌôîÎ©¥ ÏúÑÏ™Ω Í∞ÄÏö¥Îç∞)
            drawWinIndicators();
            
            // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌëúÏãú (ÎßàÎ¶ÑÎ™® ÏïÑÎûò)
            if (gameState.countdown > 0 || gameState.augmentCountdown > 0) {
                drawCountdown();
            }
            
            // ÏÉÅÎåÄ ÏÑ†ÌÉù Ï§ë Î©îÏãúÏßÄ ÌëúÏãú
            if (gameState.showOpponentSelecting) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const text = 'ÏÉÅÎåÄÍ∞Ä ÏÑ†ÌÉùÏ§ëÏûÖÎãàÎã§';
                const textWidth = ctx.measureText(text).width;
                const padding = 40;
                const y = canvas.height / 2;
                
                // Î∞∞Í≤Ω ÏÇ¨Í∞ÅÌòï
                ctx.fillRect(
                    canvas.width / 2 - textWidth / 2 - padding,
                    y - 40,
                    textWidth + padding * 2,
                    80
                );
                
                // ÌÖçÏä§Ìä∏
                ctx.fillStyle = '#ffffff';
                ctx.fillText(text, canvas.width / 2, y);
                ctx.restore();
            }
            
            // ÏãúÍ∞Ñ Ï†ïÏßÄ ÌùëÎ∞± Ìö®Í≥º: ÌîåÎ†àÏù¥Ïñ¥ÏôÄ ÌîåÎ†àÏù¥Ïñ¥Ïùò Ï¥ùÏïå Ï†úÏô∏ÌïòÍ≥† ÌùëÎ∞± Ï≤òÎ¶¨
            if (player.timeStopActive) {
                // ÌòÑÏû¨ canvas Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ ÌîåÎ†àÏù¥Ïñ¥ Ï¥ùÏïå ÏòÅÏó≠ Ï†ÄÏû• (Ïª¨Îü¨ Ïú†ÏßÄ)
                const playerColorRegions = [];
                const playerRadius = player.radius + 5; // ÏïΩÍ∞ÑÏùò Ïó¨Ïú†
                for (let y = Math.max(0, Math.floor(player.y - playerRadius)); y < Math.min(canvas.height, Math.floor(player.y + playerRadius)); y++) {
                    for (let x = Math.max(0, Math.floor(player.x - playerRadius)); x < Math.min(canvas.width, Math.floor(player.x + playerRadius)); x++) {
                        const dx = x - player.x;
                        const dy = y - player.y;
                        if (dx * dx + dy * dy <= playerRadius * playerRadius) {
                            const idx = (y * canvas.width + x) * 4;
                            playerColorRegions.push({
                                x, y,
                                r: data[idx],
                                g: data[idx + 1],
                                b: data[idx + 2],
                                a: data[idx + 3]
                            });
                        }
                    }
                }
                
                // ÌîåÎ†àÏù¥Ïñ¥ Ï¥ùÏïå ÏòÅÏó≠ Ï†ÄÏû•
                player.bullets.forEach(bullet => {
                    const bulletRadius = bullet.radius + 5;
                    for (let y = Math.max(0, Math.floor(bullet.y - bulletRadius)); y < Math.min(canvas.height, Math.floor(bullet.y + bulletRadius)); y++) {
                        for (let x = Math.max(0, Math.floor(bullet.x - bulletRadius)); x < Math.min(canvas.width, Math.floor(bullet.x + bulletRadius)); x++) {
                            const dx = x - bullet.x;
                            const dy = y - bullet.y;
                            if (dx * dx + dy * dy <= bulletRadius * bulletRadius) {
                                const idx = (y * canvas.width + x) * 4;
                                playerColorRegions.push({
                                    x, y,
                                    r: data[idx],
                                    g: data[idx + 1],
                                    b: data[idx + 2],
                                    a: data[idx + 3]
                                });
                            }
                        }
                    }
                });
                
                // Ï†ÑÏ≤¥Î•º ÌùëÎ∞±ÏúºÎ°ú Î≥ÄÌôò
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray;     // R
                    data[i + 1] = gray; // G
                    data[i + 2] = gray; // B
                }
                
                // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ ÌîåÎ†àÏù¥Ïñ¥ Ï¥ùÏïå ÏòÅÏó≠ ÏõêÎûò Ïª¨Îü¨Î°ú Î≥µÏõê
                playerColorRegions.forEach(region => {
                    const idx = (region.y * canvas.width + region.x) * 4;
                    data[idx] = region.r;
                    data[idx + 1] = region.g;
                    data[idx + 2] = region.b;
                    data[idx + 3] = region.a;
                });
                
                // Î≥ÄÌôòÎêú Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Îã§Ïãú Í∑∏Î¶¨Í∏∞
                ctx.putImageData(imageData, 0, 0);
            }

            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: ÌåÄ Í∏∞Ï§ÄÏúºÎ°ú UI ÌëúÏãú (ÌååÎûÄÌåÄ ÏôºÏ™Ω, Îπ®Í∞ÑÌåÄ Ïò§Î•∏Ï™Ω)
            // ÏÜîÎ°ú: ÌîåÎ†àÏù¥Ïñ¥ ÏôºÏ™Ω, Ï†Å Ïò§Î•∏Ï™Ω
            let leftChar, rightChar;
            if (gameState.isMultiplayer && myTeam) {
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: ÌååÎûÄÌåÄÏù¥ ÏôºÏ™Ω, Îπ®Í∞ÑÌåÄÏù¥ Ïò§Î•∏Ï™Ω
                if (myTeam === 'blue') {
                    leftChar = player;
                    rightChar = enemy;
                } else {
                    leftChar = enemy;
                    rightChar = player;
                }
            } else {
                // ÏÜîÎ°ú: ÌîåÎ†àÏù¥Ïñ¥ ÏôºÏ™Ω, Ï†Å Ïò§Î•∏Ï™Ω
                leftChar = player;
                rightChar = enemy;
            }
            
            // ÏôºÏ™Ω UI (ÌååÎûÄÌåÄ / ÌîåÎ†àÏù¥Ïñ¥)
            const leftHealthY = 20;
            drawHealthHearts(leftChar, 20, leftHealthY, leftChar === player);
            const leftAmmoY = leftHealthY + 40;
            drawAmmoCount(leftChar, 20, leftAmmoY, 'left');
            drawAugmentIcons(leftChar, 20, leftAmmoY + 50, 'left');
            
            // Ïò§Î•∏Ï™Ω UI (Îπ®Í∞ÑÌåÄ / Ï†Å)
            {
                const fixedBarWidth = 150;
                const rightHealthX = canvas.width - fixedBarWidth - 20;
                const rightHealthY = 20;
                drawHealthHearts(rightChar, rightHealthX, rightHealthY, rightChar === player);
                const rightAmmoY = rightHealthY + 40;
                drawAmmoCount(rightChar, rightHealthX + fixedBarWidth, rightAmmoY, 'right');
                drawAugmentIcons(rightChar, rightHealthX + fixedBarWidth, rightAmmoY + 50, 'right');
            }
            
            // ÌîåÎ†àÏù¥Ïñ¥ Ïû¨Ïû•Ï†Ñ Î∞î ÌëúÏãú (ÌîåÎ†àÏù¥Ïñ¥ Î∞îÎ°ú ÏòÜ) - ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπòÏóê ÌùîÎì§Î¶º Ï†ÅÏö©
            if (player.isReloading) {
                drawReloadBar(player, player.x - 40 + shakeX, player.y - 40 + shakeY);
            }
            // Ï¶ùÍ∞ï Ìà¥ÌåÅ ÌëúÏãú
            if (hoveredAugment) {
                drawAugmentTooltip(hoveredAugment.aug, hoveredAugment.x, hoveredAugment.y);
            }
            
        }
        
        // Ï¶ùÍ∞ï Ìà¥ÌåÅ Í∑∏Î¶¨Í∏∞
        function drawAugmentTooltip(aug, x, y) {
            ctx.save();
            
            const padding = 12;
            const lineHeight = 24;
            const fontSize = 18;
            ctx.font = `bold ${fontSize}px Arial`;
            
            // ÌÖçÏä§Ìä∏ ÌÅ¨Í∏∞ Ï∏°Ï†ï
            const titleWidth = ctx.measureText(aug.name).width;
            ctx.font = `${fontSize - 2}px Arial`;
            const descWidth = ctx.measureText(aug.description).width;
            const tooltipWidth = Math.max(titleWidth, descWidth) + padding * 2;
            const tooltipHeight = lineHeight * 2 + padding * 2;
            
            // Ìà¥ÌåÅ ÏúÑÏπò (ÏïÑÏù¥ÏΩò ÏúÑÏ™Ω ÎòêÎäî ÏïÑÎûòÏ™Ω)
            let tooltipX = x;
            let tooltipY = y - 50 - tooltipHeight; // ÏïÑÏù¥ÏΩò ÏúÑÏ™Ω
            
            // ÌôîÎ©¥ Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
            if (tooltipY < 0) {
                tooltipY = y + 50; // ÏïÑÏù¥ÏΩò ÏïÑÎûòÏ™Ω
            }
            if (tooltipX + tooltipWidth / 2 > canvas.width) {
                tooltipX = canvas.width - tooltipWidth / 2;
            }
            if (tooltipX - tooltipWidth / 2 < 0) {
                tooltipX = tooltipWidth / 2;
            }
            
            // Î∞∞Í≤Ω
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.strokeStyle = '#ffc107';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffc107';
            ctx.lineWidth = 2;
            drawRoundedRect(
                tooltipX - tooltipWidth / 2,
                tooltipY,
                tooltipWidth,
                tooltipHeight,
                8
            );
            ctx.fill();
            ctx.stroke();
            
            // Ï†úÎ™© (ÎÑ§Ïò® Ìö®Í≥º)
            ctx.fillStyle = '#ffc107';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#ffc107';
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(aug.name, tooltipX, tooltipY + padding);
            
            // ÏÑ§Î™Ö
            ctx.fillStyle = '#ffffff';
            ctx.font = `${fontSize - 2}px Arial`;
            ctx.fillText(aug.description, tooltipX, tooltipY + padding + lineHeight);
            
            ctx.restore();
        }

        // UI ÏóÖÎç∞Ïù¥Ìä∏ (Ï≤¥Î†• Ïï†ÎãàÎ©îÏù¥ÏÖò Î∞è Îç∞ÎØ∏ÏßÄ Ïà´Ïûê)
        function updateUI() {
            // ÌîåÎ†àÏù¥Ïñ¥ Ï≤¥Î†• Ïï†ÎãàÎ©îÏù¥ÏÖò
            if (player.displayHealth !== player.health) {
                const diff = player.health - player.displayHealth;
                const speed = 0.15; // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÜçÎèÑ
                player.displayHealth += diff * speed;
                // Í±∞Ïùò Í∞ôÏïÑÏßÄÎ©¥ Î∞îÎ°ú ÎßûÏ∂§
                if (Math.abs(diff) < 0.01) {
                    player.displayHealth = player.health;
                }
            }
            
            // Ï†Å Ï≤¥Î†• Ïï†ÎãàÎ©îÏù¥ÏÖò
            if (enemy.displayHealth !== enemy.health) {
                const diff = enemy.health - enemy.displayHealth;
                const speed = 0.15; // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÜçÎèÑ
                enemy.displayHealth += diff * speed;
                // Í±∞Ïùò Í∞ôÏïÑÏßÄÎ©¥ Î∞îÎ°ú ÎßûÏ∂§
                if (Math.abs(diff) < 0.01) {
                    enemy.displayHealth = enemy.health;
                }
            }
            
            // Îç∞ÎØ∏ÏßÄ Ïà´Ïûê ÏóÖÎç∞Ïù¥Ìä∏
            updateDamageNumbers(player);
            updateDamageNumbers(enemy);
            
            // ÎèÖ Ìö®Í≥º Ï≤òÎ¶¨
            updatePoisonEffects(player);
                updatePoisonEffects(enemy);
        }
        
        // ÎèÖ Ìö®Í≥º ÏóÖÎç∞Ïù¥Ìä∏
        function updatePoisonEffects(character) {
            const now = Date.now();
            for (let i = character.poisonEffects.length - 1; i >= 0; i--) {
                const poison = character.poisonEffects[i];
                const elapsed = now - poison.startTime;
                
                // 2Ï¥àÍ∞Ä ÏßÄÎÇòÍ±∞ÎÇò ÏµúÎåÄ ÌûàÌä∏ ÌöüÏàòÏóê ÎèÑÎã¨ÌïòÎ©¥ Ï†úÍ±∞
                if (elapsed >= poison.duration || (poison.hitCount >= poison.maxHits)) {
                    character.poisonEffects.splice(i, 1);
                    continue;
                }
                
                // 1Ï¥àÎßàÎã§ 0.2 Îç∞ÎØ∏ÏßÄ (ÏµúÎåÄ 2Î≤à, Ï†ïÌôî Ï¶ùÍ∞ïÏù¥ ÏûàÏúºÎ©¥ Î¨¥Ïãú)
                // Í∏∞Ï°¥ ÎèÖ Ìö®Í≥º Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ hitCountÍ∞Ä ÏóÜÏúºÎ©¥ Ï¥àÍ∏∞Ìôî
                if (!poison.hasOwnProperty('hitCount')) {
                    poison.hitCount = 0;
                    poison.maxHits = 3;
                }
                if (now - poison.lastDamageTime >= 1000 && (poison.hitCount || 0) < (poison.maxHits || 3)) {
                    // Í≤åÏûÑÏù¥ ÏùºÏãúÏ†ïÏßÄÎêú ÏÉÅÌÉúÎ©¥ Îç∞ÎØ∏ÏßÄ Î¨¥Ïãú (Ï¶ùÍ∞ï ÏÑ†ÌÉù ÏãúÍ∞Ñ ÎèôÏïà)
                    if (gameState.isPaused) {
                        continue;
                    }
                    // Ïú†Î†π Ï¶ùÍ∞ï: ÌôïÎ•† Ï§ëÏ≤© (25% * count)
                    const ghostCount = poison.target.ghostCount || 1;
                    if (poison.target.hasGhost && Math.random() < (0.25 * ghostCount)) {
                        // "Î¨¥Ïãú" ÌÖçÏä§Ìä∏ ÌëúÏãú
                        poison.target.damageNumbers.push({
                            x: poison.target.x,
                            y: poison.target.y,
                            damage: 0,
                            isCritical: false,
                            isGhost: true, // Ïú†Î†π Î¨¥Ïãú Ïó¨Î∂Ä
                            startTime: now,
                            duration: 1000,
                            offsetY: 0
                        });
                        poison.lastDamageTime = now; // Îã§Ïùå Îç∞ÎØ∏ÏßÄ ÌÉÄÏù¥Î®∏ Î¶¨ÏÖã
                        continue; // Îç∞ÎØ∏ÏßÄ Ï†ÅÏö©ÌïòÏßÄ ÏïäÏùå
                    }
                    
                    let poisonDamage = poison.damagePerSecond;
                    // Í±∞Ï†êÌôïÎ≥¥: Îç∞ÎØ∏ÏßÄ *0.5
                    if (poison.target.hasFortify && poison.target.isFortified) {
                        poisonDamage *= 0.5;
                    }
                    // ÏÜåÏàòÏ†ê 3ÏûêÎ¶¨ Ïù¥ÏÉÅÏù¥Î©¥ 2ÏûêÎ¶¨Î°ú Î∞òÏò¨Î¶º
                    poisonDamage = roundToMaxTwoDecimals(poisonDamage);
                    
                    poison.target.health -= poisonDamage;
                    poison.target.health = roundToMaxTwoDecimals(poison.target.health);
                    poison.lastDamageTime = now;
                    poison.hitCount = (poison.hitCount || 0) + 1; // ÌûàÌä∏ ÌöüÏàò Ï¶ùÍ∞Ä
                    
                    // ÎèÖ Îç∞ÎØ∏ÏßÄ Ïà´Ïûê ÌëúÏãú (Ïñ¥ÎëêÏö¥ Ï¥àÎ°ùÏÉâ)
                    poison.target.damageNumbers.push({
                        x: poison.target.x,
                        y: poison.target.y,
                        damage: poisonDamage,
                        isCritical: false,
                        isPoison: true, // ÎèÖ Îç∞ÎØ∏ÏßÄ Ïó¨Î∂Ä
                        startTime: now,
                        duration: 1000,
                        offsetY: 0
                    });
                    
                    // Ï≤¥Î†•Ïù¥ 0 Ïù¥ÌïòÍ∞Ä ÎêòÎ©¥ Ï≤òÎ¶¨
                    if (poison.target.health <= 0) {
                        poison.target.health = 0;
                        // Î∂ÄÌôú Ï≤¥ÌÅ¨ (ÌöüÏàò Ï§ëÏ≤©)
                        const reviveCount = poison.target.reviveCount || 1;
                        const hasRevivedCount = (typeof poison.target.hasRevived === 'number' ? poison.target.hasRevived : (poison.target.hasRevived ? 1 : 0));
                        if (poison.target.hasRevive && hasRevivedCount < reviveCount && !poison.target.isReviving) {
                            poison.target.hasRevived = hasRevivedCount + 1;
                            poison.target.isReviving = true;
                            poison.target.reviveTime = now + 1000;
                        } else {
                            endRound(poison.target === player ? 'enemy' : 'player');
                        }
                    }
                }
            }
        }
        
        // Îç∞ÎØ∏ÏßÄ Ïà´Ïûê ÏóÖÎç∞Ïù¥Ìä∏
        function updateDamageNumbers(character) {
            const now = Date.now();
            for (let i = character.damageNumbers.length - 1; i >= 0; i--) {
                const damageNum = character.damageNumbers[i];
                const elapsed = now - damageNum.startTime;
                
                // ÏãúÍ∞ÑÏù¥ ÏßÄÎÇòÎ©¥ Ï†úÍ±∞
                if (elapsed >= damageNum.duration) {
                    character.damageNumbers.splice(i, 1);
                    continue;
                }
                
                // ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò
                const progress = elapsed / damageNum.duration;
                damageNum.offsetY = -30 * progress; // ÏúÑÎ°ú 30px Ïù¥Îèô
            }
        }
        
        // Îç∞ÎØ∏ÏßÄ Ïà´Ïûê Í∑∏Î¶¨Í∏∞
        function drawDamageNumbers(character) {
            const now = Date.now();
            character.damageNumbers.forEach(damageNum => {
                const elapsed = now - damageNum.startTime;
                const progress = elapsed / damageNum.duration;
                
                // ÌéòÏù¥ÎìúÏïÑÏõÉ Ìö®Í≥º
                const alpha = 1 - progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // ÏÉâÏÉÅ Í≤∞Ï†ï: ÌöåÎ≥µÏù¥Î©¥ Îπ®Í∞ÑÏÉâ, Î∞©Ïñ¥Îßâ Î¨¥ÏãúÎ©¥ ÏßÑÌïú ÌååÎûÄÏÉâ, Ïú†Î†π Î¨¥ÏãúÎ©¥ ÌöåÏÉâ, Í∏∞Ï†àÏù¥Î©¥ ÎÖ∏ÎûÄÏÉâ, ÎèÖ Îç∞ÎØ∏ÏßÄÎ©¥ Ïñ¥ÎëêÏö¥ Ï¥àÎ°ùÏÉâ, ÌÅ¨Î¶¨Ìã∞Ïª¨Ïù¥Î©¥ Ïñ¥ÎëêÏö¥ ÎÖ∏ÎûÄÏÉâ, ÏïÑÎãàÎ©¥ ÌïòÏñÄÏÉâ
                let shadowColor = '#ffffff';
                if (damageNum.isHeal) {
                    ctx.fillStyle = '#ff0000'; // Îπ®Í∞ÑÏÉâ
                    shadowColor = '#ff0000';
                } else if (damageNum.isShield) {
                    ctx.fillStyle = '#0066ff'; // ÏßÑÌïú ÌååÎûÄÏÉâ
                    shadowColor = '#0066ff';
                } else if (damageNum.isGhost) {
                    ctx.fillStyle = '#888888'; // ÌöåÏÉâ
                    shadowColor = '#888888';
                } else if (damageNum.isStunned) {
                    ctx.fillStyle = '#ffffff'; // ÌïòÏñÄÏÉâ
                    shadowColor = '#ffffff';
                } else if (damageNum.isPoison) {
                    ctx.fillStyle = '#006600'; // Ïñ¥ÎëêÏö¥ Ï¥àÎ°ùÏÉâ
                    shadowColor = '#006600';
                } else if (damageNum.isCritical) {
                    ctx.fillStyle = '#CCAA00'; // Ïñ¥ÎëêÏö¥ ÎÖ∏ÎûÄÏÉâ
                    shadowColor = '#CCAA00';
                } else if (damageNum.isFlame) {
                    ctx.fillStyle = '#ff6600'; // Ï£ºÌô©/Îπ®Í∞ï Í≥ÑÏó¥
                    shadowColor = '#ff6600';
                } else {
                    ctx.fillStyle = '#ffffff'; // ÌïòÏñÄÏÉâ
                    shadowColor = '#ffffff';
                }
                ctx.shadowBlur = 10;
                ctx.shadowColor = shadowColor;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Ï∫êÎ¶≠ÌÑ∞ ÏúÑÏπò Í∏∞Ï§ÄÏúºÎ°ú Îç∞ÎØ∏ÏßÄ Ïà´Ïûê ÎòêÎäî ÌäπÏàò ÌÖçÏä§Ìä∏ ÌëúÏãú
                let displayText;
                if (damageNum.isShield || damageNum.isGhost) {
                    displayText = 'Î¨¥Ïãú';
                } else if (damageNum.isStunned) {
                    displayText = 'Í∏∞Ï†à';
                } else {
                    // ÏÜåÏàòÏ†ê 3ÏûêÎ¶¨ Ïù¥ÏÉÅÏù¥Î©¥ 2ÏûêÎ¶¨Î°ú Î∞òÏò¨Î¶º, 1~2ÏûêÎ¶¨Îäî Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
                    let value = damageNum.damage;
                    // ÏÜåÏàòÏ†ê ÏûêÎ¶¨Ïàò ÌôïÏù∏ (Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôòÌï¥ÏÑú ÌôïÏù∏)
                    const strValue = value.toString();
                    const decimalIndex = strValue.indexOf('.');
                    if (decimalIndex !== -1) {
                        const decimalPart = strValue.substring(decimalIndex + 1);
                        if (decimalPart.length > 2) {
                            // 3ÏûêÎ¶¨ Ïù¥ÏÉÅÏù¥Î©¥ 2ÏûêÎ¶¨Î°ú Î∞òÏò¨Î¶º
                            value = Math.round(value * 100) / 100;
                        }
                    }
                    // Î∂àÌïÑÏöîÌïú ÏÜåÏàòÏ†ê Ï†úÍ±∞ (Ï†ïÏàòÎ©¥ ÏÜåÏàòÏ†ê Ï†úÍ±∞)
                    if (value % 1 === 0) {
                        displayText = value.toString();
                    } else {
                        // ÏÜåÏàòÏ†ê ÏûêÎ¶¨ÏàòÏóê ÎßûÍ≤å ÌëúÏãú
                        const strValue2 = value.toString();
                        const decimalIndex2 = strValue2.indexOf('.');
                        if (decimalIndex2 !== -1) {
                            const decimalPart2 = strValue2.substring(decimalIndex2 + 1);
                            displayText = value.toFixed(Math.min(decimalPart2.length, 2));
                        } else {
                            displayText = value.toString();
                        }
                    }
                }
                ctx.fillText(
                    displayText,
                    damageNum.x,
                    damageNum.y + damageNum.offsetY
                );
                
                ctx.restore();
            });
        }

        // Í≤åÏûÑ Î£®ÌîÑ
        let lastTime = 0;
        let gameLoopInterval = null; // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥Ïö© Ïù∏ÌÑ∞Î≤å
        
        function gameLoop(currentTime) {
            // Ïä¨Î°ØÎ®∏Ïã† Ïï†ÎãàÎ©îÏù¥ÏÖò Ï≤òÎ¶¨
            if (gameState.isSlotMachine) {
                const elapsed = Date.now() - gameState.slotMachineStartTime;
                const slotSpeed = 80; // 80msÎßàÎã§ Î™®Îìú Î≥ÄÍ≤Ω (Îπ†Î•∏ ÏàúÌôò)
                const spinningDuration = 1200; // 1.2Ï¥à ÎèôÏïà Ïä¨Î°ØÎ®∏Ïã† Ïï†ÎãàÎ©îÏù¥ÏÖò
                const displayDuration = 2000; // ÏÑ†ÌÉùÎêú Î™®Îìú ÌëúÏãú ÏãúÍ∞Ñ 2Ï¥à
                
                // Î™®Îìú ÏàúÌôò
                if (elapsed < spinningDuration) {
                    const newIndex = Math.floor(elapsed / slotSpeed) % randomModes.length;
                    gameState.slotMachineCurrentIndex = newIndex;
                } else if (elapsed < spinningDuration + displayDuration) {
                    // ÏÑ†ÌÉùÎêú Î™®ÎìúÏóêÏÑú Î©àÏ∂§ (ÏÑ§Î™Ö ÏùΩÏùÑ Ïàò ÏûàÍ≤å)
                    if (!gameState.slotMachineSelectedMode) {
                        // ÎûúÎç§ Î™®Îìú ÏÑ†ÌÉù
                        const randomIndex = Math.floor(Math.random() * randomModes.length);
                        gameState.selectedRandomMode = randomModes[randomIndex];
                        gameState.slotMachineSelectedMode = gameState.selectedRandomMode;
                        gameState.slotMachineCurrentIndex = randomIndex; // ÏÑ†ÌÉùÎêú Î™®ÎìúÎ°ú Í≥†Ï†ï
                        
                        // ÎûúÎç§ Î™®Îìú ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
                        const randomModeDisplay = document.getElementById('randomModeDisplay');
                        const randomModeName = document.getElementById('randomModeName');
                        const randomModeTooltip = document.getElementById('randomModeTooltip');
                        
                        randomModeDisplay.style.display = 'block';
                        randomModeName.textContent = gameState.selectedRandomMode.name;
                        randomModeTooltip.textContent = gameState.selectedRandomMode.description;
                        
                        // ÎûúÎç§ Î™®Îìú Ï†ÅÏö© (ÏÜçÎèÑ Ï¥àÍ∏∞Ìôî ÌõÑ Ï†ÅÏö©)
                        player.speed = 3;
                        enemy.speed = 2.5;
                        player.reloadTime = 3000;
                        player.baseReloadTime = 3000; // Í∏∞Î≥∏ Ïû¨Ïû•Ï†Ñ ÏãúÍ∞Ñ Ï†ÄÏû•
                        enemy.reloadTime = 3000;
                        enemy.baseReloadTime = 3000; // Í∏∞Î≥∏ Ïû¨Ïû•Ï†Ñ ÏãúÍ∞Ñ Ï†ÄÏû•
                        applyRandomMode(gameState.selectedRandomMode.id);
                    }
                } else {
                    // ÌëúÏãú ÏãúÍ∞Ñ Ï¢ÖÎ£å, Ïä¨Î°ØÎ®∏Ïã† Ï¢ÖÎ£å ÌõÑ 3Ï¥à Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏãúÏûë
                    gameState.isSlotMachine = false;
                    gameState.countdown = 3; // 3Ï¥à Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏãúÏûë
                    gameState.isPaused = true; // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Ï§ëÏù¥ÎØÄÎ°ú Î©àÏ∂§
                    
                    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Ï≤òÎ¶¨
                    const countdownInterval = setInterval(() => {
                        gameState.countdown--;
                        if (gameState.countdown <= 0) {
                            clearInterval(countdownInterval);
                            gameState.isPaused = false; // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Ï¢ÖÎ£å ÌõÑ Í≤åÏûÑ ÏãúÏûë
                        }
                    }, 1000);
                }
            }
            
            // Î©îÎâ¥ ÌôîÎ©¥Ïù¥ ÏïÑÎãê ÎïåÎßå Í≤åÏûÑ Î°úÏßÅ Ïã§Ìñâ (Ïä¨Î°ØÎ®∏Ïã† Ï§ëÏù¥ ÏïÑÎãê Îïå)
            if (!gameState.isMenu && !gameState.isPaused && !gameState.isGameOver && !gameState.isSlotMachine) {
                let rawDeltaTime = currentTime - lastTime;
                // deltaTimeÏùÑ ÏµúÎåÄ 100msÎ°ú Ï†úÌïú (ÌîÑÎ†àÏûÑ ÎìúÎ°≠Ïù¥ÎÇò ÌÉ≠ ÎπÑÌôúÏÑ±Ìôî Ïãú Í≥ºÎèÑÌïú Ïù¥Îèô Î∞©ÏßÄ)
                const deltaTime = Math.min(rawDeltaTime, 100);
                lastTime = currentTime;

                // ÌÉÄÏù¥Î®∏ Í∞êÏÜå (Ï¥àÎãπ 1Ïî©) - ÏõêÎ≥∏ deltaTime ÏÇ¨Ïö©
                if (rawDeltaTime >= 1000) {
                    gameState.gameTime--;
                    lastTime = currentTime;

                    // ÏãúÍ∞Ñ Ï¥àÍ≥º
                    if (gameState.gameTime <= 0) {
                        if (player.health > enemy.health) {
                            endRound('player');
                        } else if (enemy.health > player.health) {
                            endRound('enemy');
                        } else {
                            // Î¨¥ÏäπÎ∂Ä - Ï≤¥Î†•Ïù¥ Îçî ÎßéÏùÄ Ï™ΩÏù¥ ÏäπÎ¶¨
                            endRound(player.health >= enemy.health ? 'player' : 'enemy');
                        }
                    }
                }

                // Ïö©ÏïîÎ™®Îìú: 5Ï¥àÎßàÎã§ 0.5 Îç∞ÎØ∏ÏßÄ
                const now = Date.now();
                if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'flame') {
                    if (!gameState.flameLastDamage) {
                        gameState.flameLastDamage = now;
                    }
                    
                    if (now - gameState.flameLastDamage >= 5000) {
                        // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï†Å Î™®Îëê Îç∞ÎØ∏ÏßÄ
                        if (player.health > 0) {
                            player.health = Math.max(0, player.health - 0.5);
                            // Ïö©Ïïî Îç∞ÎØ∏ÏßÄ ÌëúÏãú (Ï£ºÌô©/Îπ®Í∞ï ÏÉâÏÉÅ)
                            player.damageNumbers.push({
                                damage: 0.5,
                                x: player.x,
                                y: player.y - player.radius - 20,
                                alpha: 1,
                                isFlame: true,
                                startTime: now,
                                duration: 1000
                            });
                        }
                        if (enemy.health > 0) {
                            enemy.health = Math.max(0, enemy.health - 0.5);
                            enemy.damageNumbers.push({
                                damage: 0.5,
                                x: enemy.x,
                                y: enemy.y - enemy.radius - 20,
                                alpha: 1,
                                isFlame: true,
                                startTime: now,
                                duration: 1000
                            });
                        }
                        gameState.flameLastDamage = now;
                        
                        // ÌôîÏóº Îç∞ÎØ∏ÏßÄÎ°ú Ï≤¥Î†•Ïù¥ 0 Ïù¥ÌïòÍ∞Ä ÎêòÎ©¥ ÎùºÏö¥Îìú Ìå®Î∞∞ Ï≤òÎ¶¨
                        if (player.health <= 0 && !player.isReviving) {
                            // Î∂ÄÌôú Ï≤¥ÌÅ¨ (ÌöüÏàò Ï§ëÏ≤©)
                            const reviveCount = player.reviveCount || 1;
                            const hasRevivedCount = (typeof player.hasRevived === 'number' ? player.hasRevived : (player.hasRevived ? 1 : 0));
                            if (player.hasRevive && hasRevivedCount < reviveCount) {
                                player.hasRevived = hasRevivedCount + 1;
                                player.isReviving = true;
                                player.reviveTime = now + 1000;
                            } else {
                                endRound('enemy');
                            }
                        }
                        if (enemy.health <= 0 && !enemy.isReviving) {
                            // Î∂ÄÌôú Ï≤¥ÌÅ¨ (ÌöüÏàò Ï§ëÏ≤©)
                            const reviveCount = enemy.reviveCount || 1;
                            const hasRevivedCount = (typeof enemy.hasRevived === 'number' ? enemy.hasRevived : (enemy.hasRevived ? 1 : 0));
                            if (enemy.hasRevive && hasRevivedCount < reviveCount) {
                                enemy.hasRevived = hasRevivedCount + 1;
                                enemy.isReviving = true;
                                enemy.reviveTime = now + 1000;
                            } else {
                                endRound('player');
                            }
                        }
                    }
                }


                updatePlayer(deltaTime);
                
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®ÎìúÍ∞Ä ÏïÑÎãê ÎïåÎßå AI ÏóÖÎç∞Ïù¥Ìä∏
                if (!gameState.isMultiplayer) {
                    updateEnemy(deltaTime);
                }
                
                updateBullets(enemy, deltaTime);
                updateBullets(player, deltaTime);
                
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®ÎìúÏùº Îïå ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉú Ï†ÑÏÜ°
                if (gameState.isMultiplayer) {
                    sendPlayerState();
                }
            }

            draw();
            
            // Î©îÎâ¥ ÌôîÎ©¥Ïù¥ ÏïÑÎãê ÎïåÎßå UI ÏóÖÎç∞Ïù¥Ìä∏
            if (!gameState.isMenu) {
            updateUI();
            }

            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®ÎìúÍ∞Ä ÏïÑÎãê ÎïåÎßå requestAnimationFrame ÏÇ¨Ïö©
            if (!gameState.isMultiplayer) {
            requestAnimationFrame(gameLoop);
            }
        }
        
        // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥Ïö© Í≤åÏûÑ Î°úÏßÅ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò (Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑúÎèÑ Ïã§Ìñâ)
        function multiplayerGameUpdate() {
            const currentTime = performance.now();
            if (!lastTime) lastTime = currentTime;
            
            // Ïä¨Î°ØÎ®∏Ïã† Ïï†ÎãàÎ©îÏù¥ÏÖò Ï≤òÎ¶¨
            if (gameState.isSlotMachine) {
                const elapsed = Date.now() - gameState.slotMachineStartTime;
                const slotSpeed = 80;
                const spinningDuration = 1200;
                const displayDuration = 2000;
                
                if (elapsed < spinningDuration) {
                    const newIndex = Math.floor(elapsed / slotSpeed) % randomModes.length;
                    gameState.slotMachineCurrentIndex = newIndex;
                } else if (elapsed < spinningDuration + displayDuration) {
                    if (!gameState.slotMachineSelectedMode) {
                        const randomIndex = Math.floor(Math.random() * randomModes.length);
                        gameState.selectedRandomMode = randomModes[randomIndex];
                        gameState.slotMachineSelectedMode = gameState.selectedRandomMode;
                        gameState.slotMachineCurrentIndex = randomIndex;
                        
                        const randomModeDisplay = document.getElementById('randomModeDisplay');
                        const randomModeName = document.getElementById('randomModeName');
                        const randomModeTooltip = document.getElementById('randomModeTooltip');
                        
                        randomModeDisplay.style.display = 'block';
                        randomModeName.textContent = gameState.selectedRandomMode.name;
                        randomModeTooltip.textContent = gameState.selectedRandomMode.description;
                        
                        player.speed = 3;
                        enemy.speed = 2.5;
                        player.reloadTime = 3000;
                        player.baseReloadTime = 3000;
                        enemy.reloadTime = 3000;
                        enemy.baseReloadTime = 3000;
                        applyRandomMode(gameState.selectedRandomMode.id);
                    }
                } else {
                    gameState.isSlotMachine = false;
                    gameState.countdown = 3;
                    gameState.isPaused = true;
                    
                    const countdownInterval = setInterval(() => {
                        gameState.countdown--;
                        if (gameState.countdown <= 0) {
                            clearInterval(countdownInterval);
                            gameState.isPaused = false;
                        }
                    }, 1000);
                }
            }
            
            // Î©îÎâ¥ ÌôîÎ©¥Ïù¥ ÏïÑÎãê ÎïåÎßå Í≤åÏûÑ Î°úÏßÅ Ïã§Ìñâ
            if (!gameState.isMenu && !gameState.isPaused && !gameState.isGameOver && !gameState.isSlotMachine) {
                let rawDeltaTime = currentTime - lastTime;
                const deltaTime = Math.min(rawDeltaTime, 100);
                lastTime = currentTime;

                // ÌÉÄÏù¥Î®∏ Í∞êÏÜå
                if (rawDeltaTime >= 1000) {
                    gameState.gameTime--;
                    lastTime = currentTime;

                    if (gameState.gameTime <= 0) {
                        if (player.health > enemy.health) {
                            endRound('player');
                        } else if (enemy.health > player.health) {
                            endRound('enemy');
                        } else {
                            endRound(player.health >= enemy.health ? 'player' : 'enemy');
                        }
                    }
                }

                // Ïö©ÏïîÎ™®Îìú Ï≤òÎ¶¨
                const now = Date.now();
                if (gameState.selectedRandomMode && gameState.selectedRandomMode.id === 'flame') {
                    if (!gameState.flameLastDamage) {
                        gameState.flameLastDamage = now;
                    }
                    
                    if (now - gameState.flameLastDamage >= 5000) {
                        if (player.health > 0) {
                            player.health = Math.max(0, player.health - 0.5);
                            player.damageNumbers.push({
                                damage: 0.5,
                                x: player.x,
                                y: player.y - player.radius - 20,
                                alpha: 1,
                                isFlame: true,
                                startTime: now,
                                duration: 1000
                            });
                        }
                        if (enemy.health > 0) {
                            enemy.health = Math.max(0, enemy.health - 0.5);
                            enemy.damageNumbers.push({
                                damage: 0.5,
                                x: enemy.x,
                                y: enemy.y - enemy.radius - 20,
                                alpha: 1,
                                isFlame: true,
                                startTime: now,
                                duration: 1000
                            });
                        }
                        gameState.flameLastDamage = now;
                        
                        if (player.health <= 0 && !player.isReviving) {
                            const reviveCount = player.reviveCount || 1;
                            const hasRevivedCount = (typeof player.hasRevived === 'number' ? player.hasRevived : (player.hasRevived ? 1 : 0));
                            if (player.hasRevive && hasRevivedCount < reviveCount) {
                                player.hasRevived = hasRevivedCount + 1;
                                player.isReviving = true;
                                player.reviveTime = now + 1000;
                            } else {
                                endRound('enemy');
                            }
                        }
                        if (enemy.health <= 0 && !enemy.isReviving) {
                            const reviveCount = enemy.reviveCount || 1;
                            const hasRevivedCount = (typeof enemy.hasRevived === 'number' ? enemy.hasRevived : (enemy.hasRevived ? 1 : 0));
                            if (enemy.hasRevive && hasRevivedCount < reviveCount) {
                                enemy.hasRevived = hasRevivedCount + 1;
                                enemy.isReviving = true;
                                enemy.reviveTime = now + 1000;
                            } else {
                                endRound('player');
                            }
                        }
                    }
                }


                updatePlayer(deltaTime);
                
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®ÎìúÍ∞Ä ÏïÑÎãê ÎïåÎßå AI ÏóÖÎç∞Ïù¥Ìä∏
                if (!gameState.isMultiplayer) {
                    updateEnemy(deltaTime);
                }
                
                updateBullets(enemy, deltaTime);
                updateBullets(player, deltaTime);
                
                // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®ÎìúÏùº Îïå ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉú Ï†ÑÏÜ°
                if (gameState.isMultiplayer) {
                    sendPlayerState();
                }
            }
        }
        
        // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®Îìú ÏãúÏûë/Ï¢ÖÎ£å Ïãú Í≤åÏûÑ Î£®ÌîÑ Ï†ÑÌôò
        function startMultiplayerGameLoop() {
            if (gameLoopInterval) return; // Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏù¥Î©¥ Î¨¥Ïãú
            
            // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®ÎìúÏóêÏÑúÎäî setIntervalÎ°ú Í≤åÏûÑ Î°úÏßÅ ÏóÖÎç∞Ïù¥Ìä∏
            gameLoopInterval = setInterval(() => {
                multiplayerGameUpdate();
            }, 16); // ÏïΩ 60fps
            
            // Î†åÎçîÎßÅÏùÄ requestAnimationFrameÏúºÎ°ú Í≥ÑÏÜç
            function renderLoop() {
                if (!gameState.isMultiplayer) {
                    // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®ÎìúÍ∞Ä ÎÅùÎÇòÎ©¥ Ïù∏ÌÑ∞Î≤å Ï†ïÎ¶¨
                    if (gameLoopInterval) {
                        clearInterval(gameLoopInterval);
                        gameLoopInterval = null;
                    }
                    return;
                }
                
                draw();
                if (!gameState.isMenu) {
                    updateUI();
                }
                requestAnimationFrame(renderLoop);
            }
            renderLoop();
        }
        
        function stopMultiplayerGameLoop() {
            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
                gameLoopInterval = null;
            }
        }

        // Í≤åÏûÑ ÏãúÏûë (Î©îÎâ¥ÏóêÏÑú ÏãúÏûë)
        gameLoop(0);
    </script>
</body>
</html>
